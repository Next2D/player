/*!
 * licenses: MIT Licenses.
 * version: 1.0.0
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2020-2021 Toshiyuki Ienaga.
 */
"next2d"in window||function(t){"use strict";let e=0,i=0;const s={$PREFIX:"__next2d__"};s.$MAX_VALUE=t.Number.MAX_VALUE,s.$MIN_VALUE=t.Number.MIN_VALUE,s.$HIGH_SAMPLES=4,s.$MEDIUM_SAMPLES=2,s.$LOW_SAMPLES=0,s.$LOAD_START="loadstart",s.$PROGRESS="progress",s.$LOADEND="loadend",s.$TOUCH_START="touchstart",s.$TOUCH_MOVE="touchmove",s.$TOUCH_END="touchend",s.$MOUSE_DOWN="mousedown",s.$MOUSE_MOVE="mousemove",s.$MOUSE_UP="mouseup",s.$MOUSE_WHEEL="wheel",s.$DOUBLE_CLICK="dblclick",s.$MOUSE_LEAVE="mouseleave",s.$KEY_DOWN="keydown",s.$KEY_UP="keyup",s.$SCROLL="scroll",s.$P_TAG=t.document.createElement("p"),s.$COLOR_ARRAY_IDENTITY=new Float32Array([1,1,1,1,0,0,0,0]),s.$COLOR_MATRIX_FILTER=new Uint8Array([1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0]),s.$window=t,s.$document=t.document,s.$navigator=t.navigator,s.$userAgent=t.navigator.userAgent,s.$location=t.location,s.$isNaN=t.isNaN,s.$min=Math.min,s.$max=Math.max,s.$sin=Math.sin,s.$cos=Math.cos,s.$tan=Math.tan,s.$sqrt=Math.sqrt,s.$pow=Math.pow,s.$abs=Math.abs,s.$sign=Math.sign,s.$ceil=Math.ceil,s.$atan2=Math.atan2,s.$floor=Math.floor,s.$round=Math.round,s.$SQRT2=Math.SQRT2,s.$PI=Math.PI,s.$Deg2Rad=s.$PI/180,s.$Rad2Deg=180/s.$PI,s.$Array=t.Array,s.$Map=t.Map,s.$parseFloat=t.parseFloat,s.$setTimeout=t.setTimeout,s.$encodeURIComponent=t.encodeURIComponent,s.$Infinity=t.Infinity,s.$WebGLTexture=t.WebGLTexture,s.$clearTimeout=t.clearTimeout,s.$setTimeout=t.setTimeout,s.$audioContext=null,s.$CanvasRenderingContext2D=t.CanvasRenderingContext2D,s.$requestAnimationFrame=t.requestAnimationFrame,s.$cancelAnimationFrame=t.cancelAnimationFrame,s.$performance=t.performance,s.$Float32Array=t.Float32Array,s.$Int16Array=t.Int16Array,s.$variables=new Map,s.$isUpdated=!1,s.$event=null,s.$dropTarget=null,s.$dragRules={lock:!1,position:{x:0,y:0},bounds:null},s.$rgbToLinearTable=new s.$Float32Array(256),s.$rgbIdentityTable=new s.$Float32Array(256);for(let t=0;t<256;++t)s.$rgbToLinearTable[t]=s.$pow(t/255,2.23333333),s.$rgbIdentityTable[t]=t/255;s.$devicePixelRatio=s.$min(2,t.devicePixelRatio),s.$MATRIX_ARRAY_IDENTITY=new Float32Array([1,0,0,1,0,0]),s.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0=new Float32Array([s.$devicePixelRatio,0,0,s.$devicePixelRatio,0,0]),s.$bounds=[],s.$arrays=[],s.$audios=[],s.$maps=[],s.$preObjects=[],s.$matrices=[],s.$colors=[],s.$float32Array4=[],s.$float32Array6=[],s.$float32Array8=[],s.$float32Array9=[],s.$isAndroid=s.$userAgent.indexOf("Android")>-1,s.isiOS=s.$userAgent.indexOf("iPhone")>-1||s.$userAgent.indexOf("iPod")>-1,s.$isTouch=s.$isAndroid||s.isiOS,s.$isChrome=s.$userAgent.indexOf("Chrome")>-1,s.$isFireFox=s.$userAgent.indexOf("Firefox")>-1,s.$isSafari=s.$userAgent.indexOf("Safari")>-1,s.$isEdge=s.$userAgent.indexOf("Edge")>-1,s.$isMac=s.$userAgent.indexOf("Mac")>-1,s.$isWindows=!1===s.$isMac;const r=t.document.createElement("canvas");r.width=1,r.height=1,s.$hitContext=r.getContext("2d"),s.$hitContext.globalAlpha=0,s.$hitContext.imageSmoothingEnabled=!1;const n=t.document.createElement("canvas");n.width=1,n.height=1,s.$textContext=n.getContext("2d"),s.$hitContext.globalAlpha=0,s.$hitContext.imageSmoothingEnabled=!1,s.$DIV=null,s.$isArray=function(t){return s.$Array.isArray(t)},s.$getArray=function(...t){const e=s.$arrays.pop()||[];return t.length&&e.push.apply(e,t),e},s.$poolArray=function(t){t.length&&(t.length=0),s.$arrays.push(t)},s.$clamp=function(t,e,i,r){const n=+t;return s.$isNaN(n)&&null!==r?r:s.$min(s.$max(e,s.$isNaN(n)?0:n),i)},s.$multiplicationColor=function(t,e){return s.$getFloat32Array8(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7])},s.$multiplicationMatrix=function(t,e){return s.$getFloat32Array6(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5])},s.$getBoundsObject=function(t=0,e=0,i=0,r=0){const n=s.$bounds.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return n.xMin=t,n.xMax=e,n.yMin=i,n.yMax=r,n},s.$poolBoundsObject=function(t){s.$bounds.push(t)},s.$poolMap=function(t){t.size&&t.clear(),s.$maps.push(t)},s.$getMap=function(){return s.$maps.pop()||new s.$Map},s.$getFloat32Array4=function(t=0,e=0,i=0,r=0){const n=s.$float32Array4.pop()||new s.$window.Float32Array(4);return n[0]=t,n[1]=e,n[2]=i,n[3]=r,n},s.$poolFloat32Array4=function(t){s.$float32Array4.push(t)},s.$getFloat32Array6=function(t=0,e=0,i=0,r=0,n=0,a=0){const o=s.$float32Array6.pop()||new s.$window.Float32Array(6);return o[0]=t,o[1]=e,o[2]=i,o[3]=r,o[4]=n,o[5]=a,o},s.$poolFloat32Array6=function(t){s.$float32Array6.push(t)},s.$getFloat32Array8=function(t=1,e=1,i=1,r=1,n=0,a=0,o=0,h=0){const l=s.$float32Array8.pop()||new s.$window.Float32Array(8);return l[0]=t,l[1]=e,l[2]=i,l[3]=r,l[4]=n,l[5]=a,l[6]=o,l[7]=h,l},s.$poolFloat32Array8=function(t){s.$float32Array8.push(t)},s.$getFloat32Array9=function(t=0,e=0,i=0,r=0,n=0,a=0,o=0,h=0,l=0){const $=s.$float32Array9.pop()||new s.$window.Float32Array(9);return $[0]=t,$[1]=e,$[2]=i,$[3]=r,$[4]=n,$[5]=a,$[6]=o,$[7]=h,$[8]=l,$},s.$poolFloat32Array9=function(t){s.$float32Array9.push(t)},s.$currentPlayer=function(){return t.next2d._$player},s.$currentMousePoint=function(){const t=s.$currentPlayer();let e=s.$window.pageXOffset,i=s.$window.pageYOffset;const r=s.$document.getElementById(t.contentElementId);if(r){const t=r.getBoundingClientRect();e+=t.left,i+=t.top}let n=0,a=0;switch(!0){case s.$isTouch:const t=s.$event.changedTouches[0];n=t.pageX,a=t.pageY;break;default:n=s.$event.pageX,a=s.$event.pageY}const o=(n-e)/t._$scale|0,h=(a-i)/t._$scale|0;return new f(o,h)},s.$boundsMatrix=function(t,e){const i=t.xMax*e[0]+t.yMax*e[2]+e[4],r=t.xMax*e[0]+t.yMin*e[2]+e[4],n=t.xMin*e[0]+t.yMax*e[2]+e[4],a=t.xMin*e[0]+t.yMin*e[2]+e[4],o=t.xMax*e[1]+t.yMax*e[3]+e[5],h=t.xMax*e[1]+t.yMin*e[3]+e[5],l=t.xMin*e[1]+t.yMax*e[3]+e[5],$=t.xMin*e[1]+t.yMin*e[3]+e[5],_=s.$min(s.$MAX_VALUE,i,r,n,a),c=s.$max(-s.$MAX_VALUE,i,r,n,a),u=s.$min(s.$MAX_VALUE,o,h,l,$),d=s.$max(-s.$MAX_VALUE,o,h,l,$);return s.$getBoundsObject(_,c,u,d)},s.$upperPowerOfTwo=function(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t},s.$getMatrix=function(t=1,e=0,i=0,r=1,n=0,a=0){if(!s.$matrices.length)return new p(t,e,i,r,n,a);const o=s.$matrices.pop();return o._$matrix=s.$getFloat32Array6(t,e,i,r,n,a),o},s.$poolMatrix=function(t){s.$poolFloat32Array6(t._$matrix),t._$matrix=null,s.$matrices.push(t)},s.$toBoolean=function(t=!1){switch(typeof t){case"boolean":return t;case"function":return!0;case"object":case"string":case"number":return!!t;default:return!1}},s.$getColorTransform=function(t=1,e=1,i=1,r=1,n=0,a=0,o=0,h=0){if(!s.$colors.length)return new g(t,e,i,r,n,a,o,h);const l=s.$colors.pop();return l._$colorTransform=s.$getFloat32Array8(t,e,i,r,n,a,o,h),l},s.$poolColorTransform=function(t){s.$poolFloat32Array8(t._$colorTransform),t._$colorTransform=null,s.$colors.push(t)},s.$toColorInt=function(t){return"number"==typeof t?t:this.$colorStringToInt(t)},s.$colorStringToInt=function(t){s.$hitContext.fillStyle=t;const e=s.$hitContext.fillStyle.substr(1);return s.$hitContext.fillStyle="rgba(0, 0, 0, 1)",0|`0x${e}`},s.$intToR=function(t,e,i){return(t>>16)*(i?e:1)/255},s.$intToG=function(t,e,i){return(t>>8&255)*(i?e:1)/255},s.$intToB=function(t,e,i){return(255&t)*(i?e:1)/255},s.$uintToRGBA=function(t){return{A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}},s.$intToRGBA=function(t,e=1){return{R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}},s.$generateColorTransform=function(t,e){return{R:s.$max(0,s.$min(t.R*e[0]+e[4],255)),G:s.$max(0,s.$min(t.G*e[1]+e[5],255)),B:s.$max(0,s.$min(t.B*e[2]+e[6],255)),A:s.$max(0,s.$min(255*t.A*e[3]+e[7],255))/255}},s.$cacheStore=function(){return s.$currentPlayer()._$cacheStore},s.$inverseMatrix=function(t){const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],r=t[1]*t[6]-t[0]*t[7];return s.$getFloat32Array9(t[4]*e,-t[1]*e,0,-t[3]*e,t[0]*e,0,i*e,r*e,1)},s.$decodeAudioFailed=function(){const t=this._$character?this._$character.buffer:this._$buffer;console.log(t);let e=0;for(;e=t.indexOf(255,e),-1!==e&&224!=(224&t[e+1]);)++e;e>-1&&s.$audioContext.decodeAudioData(t.buffer.subarray(e),s.$decodeAudioSuccess.bind(this))},s.$decodeAudioSuccess=function(t){this._$character?(this._$character.buffer=null,this._$character.audioBuffer=t):(this._$buffer=null,this._$audioBuffer=t)},s.$decodeAudioData=function(t){const e=t._$character?t._$character.buffer:t._$buffer;e&&s.$audioContext.decodeAudioData(e.buffer,s.$decodeAudioSuccess.bind(t),s.$decodeAudioFailed.bind(t))},s.$loadAudioData=function(){if(s.$audioContext||(s.$audioContext=new s.$window.AudioContext,s.$audioContext.resume()),s.$audioContext){const t=s.$audios.length;for(let e=0;e<t;++e){const t=s.$audios[e];if(t._$character&&t._$character.audioBuffer)return;if(t._$audioBuffer)return;s.$decodeAudioData(t)}s.$audios.length=0}},s.$resizeTimerId=0,s.$resize=function(){(0,s.$clearTimeout)(s.$resizeTimerId);const t=s.$setTimeout;s.$resizeTimerId=t(s.$resizeExecute,300)},s.$resizeExecute=function(){const t=s.$currentPlayer();2===t._$loadStatus&&t._$resize()},s.$window.addEventListener("resize",s.$resize),s.$resetContext=function(t){const e=t._$contextStyle;switch(e._$fillStyle.constructor){case It:case Pt:e._$fillStyle=s.$getFloat32Array4(1,1,1,1);break;default:e._$fillStyle[0]=1,e._$fillStyle[1]=1,e._$fillStyle[2]=1,e._$fillStyle[3]=1}switch(e._$strokeStyle.constructor){case It:case Pt:e._$strokeStyle=s.$getFloat32Array4(1,1,1,1);break;default:e._$strokeStyle[0]=1,e._$strokeStyle[1]=1,e._$strokeStyle[2]=1,e._$strokeStyle[3]=1}t._$style=e,t._$globalAlpha=1,t._$globalCompositeOperation=S.NORMAL,t._$imageSmoothingEnabled=!1},s.$getPreObject=function(){return s.$preObjects.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,currentAttachment:null,currentMaskBuffer:null,currentMaskBounds:null,cacheCurrentBounds:null,blendMode:null,filters:null,layerWidth:null,layerHeight:null}},s.$poolPreObject=function(t){t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.currentAttachment=null,t.currentMaskBuffer=null,t.currentMaskBounds=null,t.cacheCurrentBounds=null,t.blendMode=null,t.filters=null,t.layerWidth=null,t.layerHeight=null,s.$preObjects.push(t)},s.$cross=function(t,e,i,s){return t*s-i*e},s.$linearGradientXY=function(t){const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],r=-819.2*t[0]+819.2*t[2]+t[4],n=-819.2*t[1]-819.2*t[3]+t[5],a=819.2*t[1]-819.2*t[3]+t[5];let o=r-e,h=-819.2*t[1]+819.2*t[3]+t[5]-n;const l=s.$sqrt(o*o+h*h);l?(o/=l,h/=l):(o=0,h=0);const $=(i-e)*o+(a-n)*h;return s.$getArray(e+$*o,n+$*h,i,a)},s.$ajax=function(t=null){t||(t={method:"GET"}),"method"in t||(t.method="GET");let e=null;switch(t.method.toUpperCase()){case dt.GET:if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():e[1]+"&"+t.data.toString(),t.url=e.join("?")}break;case dt.PUT:case dt.POST:e=t.data?t.data.toString():null}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),t.withCredentials&&(i.withCredentials=!0),t.event){const e=Object.keys(t.event),r=e.length;for(let s=0;s<r;++s){const r=e[s];i.addEventListener(r,t.event[r])}s.$poolArray(e)}if(t.format===_t.ARRAY_BUFFER&&(i.responseType=_t.ARRAY_BUFFER),t.headers){const e=t.headers,r=Object.keys(e),n=r.length;for(let t=0;t<n;++t){const s=r[t];i.setRequestHeader(s,e[s])}s.$poolArray(r)}i.send(e)},s.$headerToArray=function(t){const e=s.$getArray();if(t){const i=t.trim().split("\n"),s=i.length;for(let t=0;t<s;++t){const s=i[t].split(":");e.push({name:s[0],value:s[1].trim()})}}return e},s.$getClass=function(t){const e=t.split(".");let i=s.$window;for(let t=0;t<e.length;++t){const s=e[t];if(!(s in i))return null;i=i[s]}return i},s.$packages=function(t){t.display={BitmapData:A,BitmapDataChannel:M,BlendMode:S,CapsStyle:C,DisplayObject:b,DisplayObjectContainer:v,FrameLabel:R,GradientType:w,Graphics:O,InteractiveObject:T,InterpolationMethod:L,JointStyle:I,Loader:P,LoaderInfo:D,MovieClip:E,Shape:N,SimpleButton:U,SpreadMethod:k,Sprite:y,Stage:G},t.events={Event:a,EventDispatcher:o,EventPhase:h,FocusEvent:l,HTTPStatusEvent:$,IOErrorEvent:_,MouseEvent:c,ProgressEvent:u,VideoEvent:d},t.filters={BevelFilter:z,BitmapFilterQuality:j,BitmapFilterType:H,BlurFilter:W,ColorMatrixFilter:q,ConvolutionFilter:K,DisplacementMapFilter:Q,DisplacementMapFilterMode:V,DropShadowFilter:J,GlowFilter:Z,GradientBevelFilter:tt,GradientGlowFilter:et},t.geom={ColorTransform:g,Matrix:p,Point:f,Rectangle:m,Transform:x},t.media={Sound:ot,SoundMixer:ht,SoundTransform:lt,Video:$t},t.net={URLLoaderDataFormat:_t,URLRequest:ct,URLRequestHeader:ut,URLRequestMethod:dt},t.text={TextField:rt,TextFieldAutoSize:st,TextFieldType:nt,TextFormat:at,TextFormatAlign:it},t.ui={Easing:gt,Job:pt,Tween:ft}};class a{constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=e,this._$cancelable=i,this._$target=null,this._$currentTarget=null,this._$eventPhase=h.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1,this._$preventDefault=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get SCROLL(){return"scroll"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}get eventPhase(){return this._$eventPhase}get listener(){return this._$listener}get target(){return this._$target?this._$target:this._$currentTarget}get type(){return this._$type}formatToString(){let t=`[${arguments[0]}`;for(let e=1;e<arguments.length;++e){const i=arguments[e];t+=` ${i}=`;const s=this[i];t+="string"==typeof s?`"${s}"`:`${s}`}return`${t}]`}isDefaultPrevented(){return!!s.$event&&s.$event.defaultPrevented}preventDefault(){this._$preventDefault=!0}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}class o{constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,r=0){let n,o,h=!1;switch(t=`${t}`){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":o=s.$currentPlayer(),o.broadcastEvents.size&&o.broadcastEvents.has(t)||o.broadcastEvents.set(t,s.$getArray()),n=o.broadcastEvents.get(t),h=!0;break;default:this._$events||(this._$events=s.$getMap()),this._$events.size&&this._$events.has(t)||this._$events.set(t,s.$getArray()),n=this._$events.get(t)}let l=n.length;for(let t=0;t<l;++t){const s=n[t];i===s.useCapture&&(s.target===this&&s.listener===e&&(l=t))}n[l]={listener:e,priority:r,useCapture:i,target:this},h?o.broadcastEvents.set(t,n):(n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,n))}dispatchEvent(t){switch(t.type){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:s.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t.type)){const e=i.broadcastEvents.get(t.type),r=e.length;for(let i=0;i<r;++i){const r=e[i];if(r.target===this){t._$eventPhase=h.AT_TARGET,t._$currentTarget=r.target;try{t._$listener=r.listener,r.listener.call(s.$window,t)}catch(t){return!1}}}return!0}}break;default:{let e=s.$getArray();this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type).slice(0));const i=s.$getArray();if(this instanceof b){let e=this._$parent;for(;e;)e.hasEventListener(t.type)&&(i[i.length]=e._$events.get(t.type)),e=e._$parent}if(t._$target=this,e.length||i.length){if(t._$eventPhase=h.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const r=i[e];for(let e=0;e<r.length;++e){const i=r[e];if(i.useCapture){t._$currentTarget=i.target;try{t._$listener=i.listener,i.listener.call(s.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}switch(t._$eventPhase=h.AT_TARGET,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:const i=e.length;for(let r=0;r<i;++r){const i=e[r];if(!i.useCapture){t._$currentTarget=i.target;try{t._$listener=i.listener,i.listener.call(s.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}}switch(t._$eventPhase=h.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const r=i[e];for(let e=0;e<r.length;++e){const i=r[e];if(!i.useCapture){t._$currentTarget=i.target;try{t._$listener=i.listener,i.listener.call(s.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return s.$poolArray(e),s.$poolArray(i),!0}s.$poolArray(e),s.$poolArray(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":const e=this.stage,i=e?e._$player:s.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t)){const e=i.broadcastEvents.get(t);for(let t=0;t<e.length;t++)if(e[t].target===this)return!0}return!1;default:return this._$events&&this._$events.size&&this._$events.has(t)}}removeEventListener(t,e,i=!1){if(t=`${t}`,!this.hasEventListener(t))return;let r,n,o=!1;switch(t){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":o=!0,n=s.$currentPlayer(),n&&(r=n.broadcastEvents.get(t));break;default:r=this._$events.get(t)}const h=r.length;for(let t=0;t<h;++t){const s=r[t];if(i===s.useCapture&&s.listener===e){r.splice(t,1);break}}r.length?o?n.broadcastEvents.set(t,r):(r.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,r)):o?n.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(s.$poolMap(this._$events),this._$events=null))}willTrigger(t){if(this.hasEventListener(t))return!0;let e=this._$parent;for(;e;){if(e.hasEventListener(t))return!0;e=e._$parent}return!1}}class h{constructor(){}static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class l extends a{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class $ extends a{constructor(t,e=!1,i=!1,s=0){super(t,e,i),this._$status=0|s,this._$responseHeaders=[],this._$responseURL=""}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","bytes_loaded","bytes_total")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}set responseHeaders(t){return this._$responseHeaders=t}get responseURL(){return this._$responseURL}set responseURL(t){this._$responseURL=t}}class _ extends a{constructor(t,e=!0,i=!1,s=""){super(t,e,i),this._$text=s}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}}class c extends a{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:function(t,e){return e in t?t[e]:s.$event&&e in s.$event?s.$event[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class u extends a{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","bytes_loaded","bytes_total")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class d extends a{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","bytes_loaded","bytes_total")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class g{constructor(t=1,e=1,i=1,r=1,n=0,a=0,o=0,h=0){this._$colorTransform=s.$getFloat32Array8(t,e,i,r,n,a,o,h)}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=s.$clamp(t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=s.$clamp(0|t,-255,255)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=s.$clamp(t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=s.$clamp(0|t,-255,255)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=s.$clamp(t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=s.$clamp(0|t,-255,255)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=s.$clamp(t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=s.$clamp(0|t,-255,255)}concat(t){const e=s.$multiplicationColor(this._$colorTransform,t._$colorTransform);this._$colorTransform[0]=e[0],this._$colorTransform[1]=e[1],this._$colorTransform[2]=e[2],this._$colorTransform[3]=e[3],this._$colorTransform[4]=e[4],this._$colorTransform[5]=e[5],this._$colorTransform[6]=e[6],this._$colorTransform[7]=e[7],s.$poolFloat32Array8(e)}_$clone(){return s.$getColorTransform(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class p{constructor(t=1,e=0,i=0,r=1,n=0,a=0){this._$matrix=s.$getFloat32Array6(t,e,i,r,n,a)}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=+t}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=+t}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=+t}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=+t}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=+t}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=+t}_$clone(){return this.clone()}clone(){return s.$getMatrix(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let s=e[0]*i[0],r=0,n=0,a=e[3]*i[3],o=e[4]*i[0]+i[4],h=e[5]*i[3]+i[5];switch(!0){case 0!==e[1]:case 0!==e[2]:case 0!==i[1]:case 0!==i[2]:s+=e[1]*i[2],a+=e[2]*i[1],r+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],o+=e[5]*i[2],h+=e[4]*i[1]}this._$matrix[0]=s,this._$matrix[1]=r,this._$matrix[2]=n,this._$matrix[3]=a,this._$matrix[4]=o,this._$matrix[5]=h}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,s=0,r=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(s,r)}createGradientBox(t,e,i=0,s=0,r=0){this.createBox(t/1638.4,e/1638.4,i,s+t/2,r+e/2)}deltaTransformPoint(t){return new f(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){let t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],s=this._$matrix[3],r=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/s,this.tx=-this.a*r,this.ty=-this.d*n;else{const a=t*s-e*i;if(0===a)this.identity();else{const o=1/a;this.a=s*o,this.b=-e*o,this.c=-i*o,this.d=t*o,this.tx=-(this.a*r+this.c*n),this.ty=-(this.b*r+this.d*n)}}}rotate(t){const e=this._$matrix[0],i=this._$matrix[1],r=this._$matrix[2],n=this._$matrix[3],a=this._$matrix[4],o=this._$matrix[5];this._$matrix[0]=e*s.$cos(t)-i*s.$sin(t),this._$matrix[1]=e*s.$sin(t)+i*s.$cos(t),this._$matrix[2]=r*s.$cos(t)-n*s.$sin(t),this._$matrix[3]=r*s.$sin(t)+n*s.$cos(t),this._$matrix[4]=a*s.$cos(t)-o*s.$sin(t),this._$matrix[5]=a*s.$sin(t)+o*s.$cos(t)}scale(t,e){this._$matrix[0]*=t,this._$matrix[2]*=t,this._$matrix[4]*=t,this._$matrix[1]*=e,this._$matrix[3]*=e,this._$matrix[5]*=e}setTo(t,e,i,s,r,n){this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}transformPoint(t){return new f(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class f{constructor(t=0,e=0){this._$x=+t,this._$y=+e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return s.$sqrt(s.$pow(this.x,2)+s.$pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=+t}get y(){return this._$y}set y(t){this._$y=+t}add(t){return new f(this.x+t.x,this.y+t.y)}clone(){return new f(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return s.$sqrt(s.$pow(t._$x-e._$x,2)+s.$pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new f(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new f(t*s.$cos(e),t*s.$sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new f(this.x-t.x,this.y-t.y)}}class m{constructor(t=0,e=0,i=0,s=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,s)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new f(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=+t}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new f(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new f(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=+t}get x(){return this._$x}set x(t){this._$x=+t}get y(){return this._$y}set y(t){this._$y=+t}clone(){return new m(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=s.$max(this.x,t.x),i=s.$max(this.y,t.y),r=s.$min(this.right,t.right)-e,n=s.$min(this.bottom,t.bottom)-i;return r>0&&n>0?new m(e,i,r,n):new m(0,0,0,0)}intersects(t){const e=s.$max(this.x,t.x),i=s.$max(this.y,t.y),r=s.$min(this.right,t.right),n=s.$min(this.bottom,t.bottom);return r-e>0&&n-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new m(s.$min(this.x,t.x),s.$min(this.y,t.y),s.$max(this.right-t.left,t.right-this.left),s.$max(this.bottom-t.top,t.bottom-this.top))}}class x{constructor(t){if(!(t instanceof b))throw new Error("Transform params is DisplayObject only.");this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.colorTransform,i=new g;return i._$colorTransform=s.$getFloat32Array8(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),i}return this._$transform(),this._$colorTransform._$clone()}set colorTransform(t){t instanceof g&&this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=s.$multiplicationColor(e._$transform._$rawColorTransform(),t),e=e._$parent;return s.$getColorTransform(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.matrix;return s.$getMatrix(e[0],e[1],e[2],e[3],e[4],e[5])}return this._$transform(),this._$matrix._$clone()}set matrix(t){t instanceof p&&this._$transform(t._$matrix,null)}concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=s.$multiplicationMatrix(e._$transform._$rawMatrix(),t),e=e._$parent;return s.$getMatrix(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){const t=new m(0,0,0,0);if(!this._$displayObject)return t;const e=this._$displayObject._$getBounds(null);return t._$x=e.xMin,t._$y=e.yMin,t._$width=+s.$abs(e.xMax-e.xMin),t._$height=+s.$abs(e.yMax-e.yMin),s.$poolBoundsObject(e),t}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject._$getPlaceObject();return t?t.matrix:s.$MATRIX_ARRAY_IDENTITY}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject._$getPlaceObject();return t?t.colorTransform:s.$COLOR_ARRAY_IDENTITY}_$transform(t=null,e=null,i=null,s=""){const r=this._$displayObject._$getPlaceObject();this._$setMatrix(t,r),this._$setColorTransform(e,r),this._$setFilters(i,r),this._$setBlendMode(s,r)}_$setMatrix(t=null,e=null){t&&(this._$displayObject._$doChanged(),s.$isUpdated=!0),this._$matrix||(this._$matrix=s.$getMatrix(1,0,0,1,0,0),!t&&e&&(t=e.matrix));const i=this._$matrix._$matrix;t&&(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5])}_$setColorTransform(t=null,e=null){t&&(this._$displayObject._$doChanged(),s.$isUpdated=!0),this._$colorTransform||(this._$colorTransform=s.$getColorTransform(1,1,1,1,0,0,0,0),!t&&e&&(t=e.colorTransform));const i=this._$colorTransform._$colorTransform;t&&(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7])}_$setFilters(t=null,e=null){if(s.$isArray(t))return this._$filters&&s.$poolArray(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void(s.$isUpdated=!0);if(!this._$filters)if(e){if(e.filters)this._$filters=e.filters.slice(0);else if(e.surfaceFilterList){const t=s.$getArray(),i=e.surfaceFilterList.length;for(let s=0;s<i;++s){const i=e.surfaceFilterList[s],r=next2d.filters[i.class];t.push(new(r.bind.apply(r,i.params)))}e.filters=t,this._$filters=t.slice(0)}}else this._$filters=s.$getArray()}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void(s.$isUpdated=!0);this._$blendMode||(this._$blendMode=e?e.blendMode:S.NORMAL)}}class b extends o{constructor(){super(),this._$id=0,this._$instanceId=e++,this._$dictionaryId=0,this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$buffer=null,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=null,this._$startFrame=1,this._$endFrame=0,this._$transform=new x(this),this._$variables=null,this._$placeObject=null}static toString(){return"[class DisplayObject]"}static get namespace(){return"next2d.display.DisplayObject"}toString(){return"[object DisplayObject]"}get namespace(){return"next2d.display.DisplayObject"}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=s.$clamp(t,0,1,0);const e=this._$transform.colorTransform;e._$colorTransform[3]=t,e._$colorTransform[7]=0,this._$transform.colorTransform=e,s.$poolColorTransform(e)}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,this._$blendMode;const e=this._$getPlaceObject();return e?(this._$blendMode=e.blendMode,this._$blendMode):(t._$transform(),this._$blendMode=t._$blendMode,this._$blendMode)}set blendMode(t){this._$transform._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters)return this._$filters;const t=this._$transform;if(t._$filters)return this._$filters=t._$filters.slice(0),this._$filters;const e=this._$getPlaceObject();if(e){if(!e.filters){const t=[];if(e.surfaceFilterList){const i=e.surfaceFilterList.length;for(let s=0;s<i;++s){const i=e.surfaceFilterList[s],r=next2d.filters[i.class];t.push(new(r.bind.apply(r,i.params)))}}e.filters=t}return this._$filters||(this._$filters=e.filters),e.filters.slice(0)}return t._$transform(),this._$filters=t._$filters,this._$filters.slice(0)}set filters(t){this._$transform._$transform(null,null,t,null),this._$filters=t}get height(){const t=s.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=s.$abs(t.yMax-t.yMin);switch(s.$poolBoundsObject(t),e){case 0:case s.$Infinity:case-s.$Infinity:return 0;default:return e}}set height(t){if(t>-1){const e=this.rotation?s.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=s.$abs(e.yMax-e.yMin);switch(s.$poolBoundsObject(e),i){case 0:case s.$Infinity:case-s.$Infinity:this.scaleY=0;break;default:this.scaleY=t/i}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(this._$mask._$isMask=!1,this._$mask=null),t instanceof b&&(t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return s.$event?this.globalToLocal(s.$currentMousePoint()).x:0}get mouseY(){return s.$event?this.globalToLocal(s.$currentMousePoint()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren(),i=t.length;for(let s=0;s<i;++s){const i=t[s];i._$name&&e._$names.set(i.name,i)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){const t=this._$transform._$rawMatrix();return s.$atan2(t[1],t[0])*s.$Rad2Deg}set rotation(t){t%=360;const e=this._$transform,i=e.matrix,r=s.$sqrt(i.a*i.a+i.b*i.b),n=s.$sqrt(i.c*i.c+i.d*i.d);if(0===t)i.a=r,i.b=0,i.c=0,i.d=n;else{let e=s.$atan2(i.b,i.a),a=s.$atan2(-i.c,i.d);const o=t*s.$Deg2Rad;a=a+o-e,e=o,i.b=r*s.$sin(e),1===i.b||-1===i.b?i.a=0:i.a=r*s.$cos(e),i.c=-n*s.$sin(a),1===i.c||-1===i.c?i.d=0:i.d=n*s.$cos(a)}e.matrix=i,s.$poolMatrix(i)}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid=null,t instanceof m&&(this._$scale9Grid=t)}get scaleX(){const t=this._$transform._$rawMatrix();let e=s.$sqrt(t[0]*t[0]+t[1]*t[1]);return 0>t.a&&(e*=-1),e}set scaleX(t){const e=this._$transform,i=e.matrix;switch(!0){case s.$isNaN(i.b):case 0===i.b:i.a=t;break;default:const e=s.$atan2(i.b,i.a);i.b=t*s.$sin(e),1===i.b||-1===i.b?i.a=0:i.a=t*s.$cos(e)}e.matrix=i,s.$poolMatrix(i)}get scaleY(){const t=this._$transform._$rawMatrix();let e=s.$sqrt(t[2]*t[2]+t[3]*t[3]);return 0>t.d&&(e*=-1),e}set scaleY(t){const e=this._$transform,i=e.matrix;switch(!0){case s.$isNaN(i.c):case 0===i.c:i.d=t;break;default:const e=s.$atan2(-i.c,i.d);i.c=-t*s.$sin(e),1===i.c||-1===i.c?i.d=0:i.d=t*s.$cos(e)}e.matrix=i,s.$poolMatrix(i)}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t instanceof G?t:t._$stage:null}get transform(){return this._$transform}set transform(t){t instanceof x&&(this._$transform=t)}get visible(){return this._$visible}set visible(t){this._$visible!==t&&(this._$doChanged(),s.$isUpdated=!0,this._$visible=t)}get width(){const t=s.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=s.$abs(t.xMax-t.xMin);switch(s.$poolBoundsObject(t),!0){case 0===e:case e===s.$Infinity:case e===-s.$Infinity:return 0;default:return e}}set width(t){if(t>-1){const e=this.rotation?s.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=s.$abs(e.xMax-e.xMin);switch(s.$poolBoundsObject(e),!0){case 0===i:case i===s.$Infinity:case i===-s.$Infinity:this.scaleX=0;break;default:this.scaleX=t/i}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform,i=this._$transform.matrix;i.tx=t,e.matrix=i,s.$poolMatrix(i)}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform,i=e.matrix;i.ty=t,e.matrix=i,s.$poolMatrix(i)}getBounds(t=null){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix(),r=s.$boundsMatrix(e,i._$matrix);s.$poolMatrix(i),s.$poolBoundsObject(e);const n=s.$getBoundsObject(r.xMin,r.xMax,r.yMin,r.yMax);s.$poolBoundsObject(r),t||(t=this);const a=t._$transform.concatenatedMatrix();a.invert();const o=s.$boundsMatrix(n,a._$matrix),h=o.xMin,l=o.yMin,$=o.xMax,_=o.yMax;return s.$poolBoundsObject(n),s.$poolBoundsObject(o),s.$poolMatrix(a),new m(h,l,s.$abs($-h),s.$abs(_-l))}globalToLocal(t){const e=this._$transform.concatenatedMatrix();e.invert();const i=new f(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return s.$poolMatrix(e),i}hitTestObject(t){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix(),r=s.$boundsMatrix(e,i._$matrix);s.$poolMatrix(i),s.$poolBoundsObject(e);const n=t._$getBounds(null),a=t._$transform.concatenatedMatrix(),o=s.$boundsMatrix(n,a._$matrix);s.$poolMatrix(a),s.$poolBoundsObject(n);const h=s.$max(r.xMin,o.xMin),l=s.$max(r.yMin,o.yMin),$=s.$min(r.xMax,o.xMax),_=s.$min(r.yMax,o.yMax);return s.$poolBoundsObject(r),s.$poolBoundsObject(o),$-h>=0&&_-l>=0}hitTestPoint(t,e,i=!1){if(i){let i=s.$MATRIX_ARRAY_IDENTITY,r=this._$parent;for(;r;)i=s.$multiplicationMatrix(r._$transform._$rawMatrix(),i),r=r._$parent;s.$hitContext.setTransform(1,0,0,1,0,0),s.$hitContext.beginPath();const n=this._$hit(s.$hitContext,i,{x:t,y:e},!0);return s.$poolFloat32Array6(i),n}const r=this._$getBounds(null),n=s.$boundsMatrix(r,this._$transform._$rawMatrix()),a=n.xMin,o=n.yMin,h=n.xMax-n.xMin,l=n.yMax-n.yMin,$=this._$parent?this._$parent.globalToLocal(new f(t,e)):new f(t,e);return s.$poolBoundsObject(n),s.$poolBoundsObject(r),new m(a,o,h,l).containsPoint($)}localToGlobal(t){const e=this._$transform.concatenatedMatrix(),i=new f(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return s.$poolMatrix(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=s.$getMap()),s.$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(s.$poolMap(this._$variables),this._$variables=null))}getGlobalVariable(t){return s.$variables.has(t)?s.$variables.get(t):null}setGlobalVariable(t,e){s.$variables.set(t,e)}hasGlobalVariable(t){return s.$variables.has(t)}deleteGlobalVariable(t){s.$variables.has(t)&&s.$variables.delete(t)}clearGlobalVariable(){return s.$variables.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(null===t)return null;const e=this._$parent;if(!e)return null;const i=e._$placeMap;if(!i||!i.length)return null;const s=i[e._$currentFrame||1];if(!s)return null;this._$placeObject=e._$placeObjects[s[t]]}return this._$placeObject}_$build(t,e){const i=e._$loaderInfo;return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;let t=this._$parent;t&&t._$updateState()}_$doChanged(){this._$isNext=!0,this._$updated=!0;let t=this._$parent;t&&t._$doChanged()}_$getLayerBounds(t=null){const e=this._$getBounds(t);if(!t)return e;const i=this._$filters||this.filters,r=i.length;if(!r)return e;let n=new m(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);s.$poolBoundsObject(e);for(let t=0;t<r;++t)n=i[t]._$generateFilterRect(n,null,null,!0);const a=n._$x,o=n._$x+n._$width,h=n._$y,l=n._$y+n._$height;return s.$getBoundsObject(a,o,h,l)}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger(a.ADDED)&&this.dispatchEvent(new a(a.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger(a.ADDED_TO_STAGE)&&this.dispatchEvent(new a(a.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e,i,r,n=null,a=!1,o=0,h=0){if(this._$isUpdated())return!0;if(a)for(let t=0;t<n.length;++t)if(n[t]._$isUpdated())return!0;const l=s.$cacheStore().get([this._$instanceId,"f"]);switch(!0){case null===l:case l.filterState!==a:case l.layerWidth!==s.$ceil(t):case l.layerHeight!==s.$ceil(e):case l.matrix!==i[0]+"_"+i[1]+"_"+i[2]+"_"+i[3]+"_"+o+"_"+h:case l.colorTransform!==r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3]+"_"+r[4]+"_"+r[5]+"_"+r[6]+"_"+r[7]:return!0}return!1}_$getFilterTexture(t,e,i,r,n,a,o){const h=t.frameBuffer.currentAttachment,l=t.frameBuffer.createCacheAttachment(i.width,i.height);t._$bind(l),s.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;let $=null;for(let i=0;i<e.length;++i)$=e[i]._$applyFilter(t,r);let _=t._$offsetX,c=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,$._$offsetX=_,$._$offsetY=c,$.matrix=r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3]+"_0_0",$.colorTransform=n[0]+"_"+n[1]+"_"+n[2]+"_"+n[3]+"_"+n[4]+"_"+n[5]+"_"+n[6]+"_"+n[7],$.filterState=!0,$.layerWidth=i.width,$.layerHeight=i.height,t._$bind(h),t.frameBuffer.releaseAttachment(l,!1),$}_$preDraw(t,e,i){const r=this._$transform._$rawMatrix(),n=s.$multiplicationMatrix(e,r);if(!n[0]&&!n[1]||!n[2]&&!n[3])return!1;const a=s.$getPreObject();a.matrix=n;const o=this._$filters||this.filters,h=this._$blendMode||this.blendMode;if(o.length>0||h!==S.NORMAL){const e=this._$getBounds(null),l=s.$boundsMatrix(e,n),$=+l.xMax,_=+l.xMin,c=+l.yMax,u=+l.yMin;s.$poolBoundsObject(e),s.$poolBoundsObject(l);const d=s.$abs($-_),g=s.$abs(c-u);if(0>=d||0>=g)return!1;if(0>_+d||0>u+g)return!1;const p=t.frameBuffer.currentAttachment;if(_>p.width||u>p.height)return!1;a.basePosition.x=r[4],a.basePosition.y=r[5];let f=this._$getLayerBounds(null);const m=s.$boundsMatrix(f,n);let x=s.$abs(m.xMax-m.xMin),b=s.$abs(m.yMax-m.yMin);s.$poolBoundsObject(m),x===d&&b===g&&(s.$poolBoundsObject(f),f=null);let T=n[4]-s.$floor(_),v=n[5]-s.$floor(u),y=null;if(f){const t=s.$getFloat32Array6(n[0],n[1],n[2],n[3],0,0);y=s.$boundsMatrix(f,t),s.$poolBoundsObject(f),s.$poolFloat32Array6(t),T+=-s.$floor(y.xMin)-T,v+=-s.$floor(y.yMin)-v}let E=s.$floor(_),A=s.$floor(u),M=_,S=u;if(y&&(E-=-s.$floor(y.xMin)-(n[4]-E),A-=-s.$floor(y.yMin)-(n[5]-A),M-=-y.xMin-(n[4]-M),S-=-y.yMin-(n[5]-S),s.$poolBoundsObject(y)),a.position.dx=E>0?E:0,a.position.dy=A>0?A:0,x+M>p.texture.width&&(x-=x-p.texture.width+M),b+S>p.texture.height&&(b-=b-p.texture.height+S),0>E&&(T+=E,x+=M),0>A&&(v+=A,b+=S),0>=x||0>=b||!x||!b)return s.$poolPreObject(a),!1;t._$startLayer(s.$getBoundsObject(M,0,S,0)),a.canApply=this._$canApply(o);let C=this._$isFilterUpdated(x,b,n,i,o,a.canApply,a.basePosition.x,a.basePosition.y);const R=t._$cacheCurrentBuffer;t._$cacheCurrentBuffer=null;const w=t._$cacheCurrentBounds,O=s.$getBoundsObject(w.x,w.w,w.y,w.h);C&&(this._$buffer=t.frameBuffer.createCacheAttachment(s.$ceil(x),s.$ceil(b),!1),t._$bind(this._$buffer)),a.isFilter=!0,a.isUpdated=C,a.color=s.$getFloat32Array8(),a.baseMatrix=n,a.baseColor=i,a.currentAttachment=p,a.currentMaskBuffer=R,a.currentMaskBounds=O,a.filters=o,a.blendMode=h,a.layerWidth=x,a.layerHeight=b,a.matrix=s.$getFloat32Array6(n[0],n[1],n[2],n[3],T,v)}return a}_$postDraw(t,e,i,r){const n=[this._$instanceId,"f"];let a=null;if(this._$buffer){a=t.frameBuffer.getTextureFromCurrentAttachment();const e=s.$cacheStore().get(n);e&&(s.$cacheStore().set(n,null),t.frameBuffer.releaseTexture(e))}else a=s.$cacheStore().get(n);r.canApply||(a._$offsetX=0,a._$offsetY=0);let o=a._$offsetX,h=a._$offsetY;if(r.isUpdated&&r.canApply){let i=s.$cacheStore().get(n);i&&(s.$cacheStore().set(n,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,t.frameBuffer.releaseTexture(i),i=null);const l=r.filters.length;if(l){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<l;++i)a=r.filters[i]._$applyFilter(t,e);o=t._$offsetX,h=t._$offsetY,t._$offsetX=0,t._$offsetY=0,a._$offsetX=o,a._$offsetY=h}}if(r.isUpdated){a.filterState=r.canApply;const t=r.baseMatrix;a.matrix=t[0]+"_"+t[1]+"_"+t[2]+"_"+t[3]+"_"+r.basePosition.x+"_"+r.basePosition.y;const e=r.baseColor;a.colorTransform=e[0]+"_"+e[1]+"_"+e[2]+"_"+e[3]+"_"+e[4]+"_"+e[5]+"_"+e[6]+"_"+e[7],a.layerWidth=r.layerWidth,a.layerHeight=r.layerHeight}s.$cacheStore().set(n,a),s.$poolArray(n),t._$bind(r.currentAttachment);const l=a.width,$=a.height;s.$resetContext(t),t.setTransform(1,0,0,1,0,0),t._$globalAlpha=s.$clamp(i[3]+i[7]/255,0,1),t._$globalCompositeOperation=r.blendMode,t.drawImage(a,-o+r.position.dx,-h+r.position.dy,l,$,i),t._$endLayer(),this._$buffer&&(t.frameBuffer.releaseAttachment(this._$buffer,!1),this._$buffer=null),t._$cacheCurrentBuffer=r.currentMaskBuffer,t._$cacheCurrentBounds.x=r.currentMaskBounds.xMin,t._$cacheCurrentBounds.y=r.currentMaskBounds.yMin,t._$cacheCurrentBounds.w=r.currentMaskBounds.xMax,t._$cacheCurrentBounds.h=r.currentMaskBounds.yMax,s.$poolFloat32Array8(r.color),s.$poolFloat32Array6(r.matrix),s.$poolFloat32Array6(r.baseMatrix),s.$poolBoundsObject(r.currentMaskBounds),s.$poolPreObject(r)}_$shouldClip(t){if(this instanceof rt)return!(!this.textWidth||!this.textHeight);const e=this._$getBounds(t),i=s.$abs(e.xMax-e.xMin),r=s.$abs(e.yMax-e.yMin);return s.$poolBoundsObject(e),!(!i||!r)}_$startClip(t,e){let i=null;return!(!t._$cacheCurrentBuffer&&(i=t._$startClip(this,e),!i))&&(t._$enterClip(),t._$beginClipDef(),this instanceof v&&(t._$mask._$containerClip=!0),this._$clip(t,i||e),this._$updated=!1,t._$mask._$containerClip&&(t._$mask._$containerClip=!1,t._$drawContainerClip()),t._$endClipDef(),i)}}class T extends b{constructor(){super(),this._$mouseEnabled=!0,this._$isFocus=!1,this._$isComposing=!1}static toString(){return"[class InteractiveObject]"}static get namespace(){return"next2d.display.InteractiveObject"}toString(){return"[object InteractiveObject]"}get namespace(){return"next2d.display.InteractiveObject"}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=t}}class v extends T{constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=s.$getArray(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=s.$getMap(),new Proxy(this,{get:function(t,e){return t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]}})}static toString(){return"[class DisplayObjectContainer]"}static get namespace(){return"next2d.display.DisplayObjectContainer"}toString(){return"[object DisplayObjectContainer]"}get namespace(){return"next2d.display.DisplayObjectContainer"}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){if(!(t instanceof b))throw new TypeError("TypeError: addChild: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));return this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){if(!(t instanceof b))throw new TypeError("TypeError: addChildAt: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),s=i.length;if(0>e||e>s)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(s&&s>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(!(t instanceof b))throw new TypeError("TypeError: contains: not DisplayObject.");if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren(),i=e.length;for(let s=0;s<i;++s){const i=e[s];if(i._$instanceId===t._$instanceId)return!0;if(i instanceof v&&i.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren(),i=e.length;if(0>t||t>i)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren(),i=e.length;for(let s=0;s<i;++s){const i=e[s];if(i.name===t)return i}return null}getChildIndex(t){if(!(t instanceof b))throw new TypeError("TypeError: getChildIndex: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError(`ArgumentError: getChildIndex: index error: ${e}`);const e=this._$getChildren().indexOf(t);if(-1===e)throw new ArgumentError("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(!(t instanceof b))throw new TypeError("TypeError: removeChild: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError(`ArgumentError: removeChild: index error: ${index}`);return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const i=this._$getChildren(),r=i.length;if(r){t=s.$clamp(t,0,2147483646,0)-1,e=s.$clamp(e,1,134217727,134217727);for(let n=s.$min(e,r-1);n>t;--n)this._$remove(i[n])}}setChildIndex(t,e){if(!(t instanceof b))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this.getChildIndex(t);if(i===e)return;const s=this._$getChildren();s.splice(i,1),s.splice(e,0,t)}swapChildren(t,e){if(!(t instanceof b&&e instanceof b))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this._$getChildren(),s=this.getChildIndex(t),r=this.getChildIndex(e);i[s]=e,i[r]=t}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=s.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==s.$MATRIX_ARRAY_IDENTITY&&(e=s.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),r=this._$needsChildren?this._$getChildren():this._$children,n=r.length;if(!n&&!i){const i=s.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&s.$poolFloat32Array6(e),i}const a=s.$MAX_VALUE;let o=a,h=-a,l=a,$=-a;if(i){const t=s.$boundsMatrix(this._$graphics._$getBounds(),e);o=t.xMin,h=t.xMax,l=t.yMin,$=t.yMax,s.$poolBoundsObject(t)}for(let t=0;t<n;++t){const i=r[t]._$getBounds(e);o=s.$min(o,i.xMin),h=s.$max(h,i.xMax),l=s.$min(l,i.yMin),$=s.$max($,i.yMax),s.$poolBoundsObject(i)}return t&&e!==t&&s.$poolFloat32Array6(e),s.$getBoundsObject(o,h,l,$)}_$getLayerBounds(t=null){let e=s.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==s.$MATRIX_ARRAY_IDENTITY&&(e=s.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),r=this._$needsChildren?this._$getChildren():this._$children,n=r.length;if(!n&&!i){const i=s.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&s.$poolFloat32Array6(e),i}const a=s.$MAX_VALUE;let o=a,h=-a,l=a,$=-a;if(i){const t=s.$boundsMatrix(this._$graphics._$getBounds(),e);o=+t.xMin,h=+t.xMax,l=+t.yMin,$=+t.yMax,s.$poolBoundsObject(t)}for(let t=0;t<n;++t){const i=r[t]._$getLayerBounds(e);o=s.$min(o,i.xMin),h=s.$max(h,i.xMax),l=s.$min(l,i.yMin),$=s.$max($,i.yMax),s.$poolBoundsObject(i)}if(t&&e!==t&&s.$poolFloat32Array6(e),!t)return s.$getBoundsObject(o,h,l,$);const _=this._$filters||this.filters,c=_.length;if(!c)return s.$getBoundsObject(o,h,l,$);let u=new m(o,l,h-o,$-l);for(let t=0;t<c;++t)u=_[t]._$generateFilterRect(u,null,null,!0);return o=u._$x,h=u._$x+u._$width,l=u._$y,$=u._$y+u._$height,s.$getBoundsObject(o,h,l,$)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=this._$currentFrame||1;if(!this._$controller)return this._$children;let e=this._$controller[t];const i=this._$children.length;if(!i){if(e){const t=e.length;for(let i=0;i<t;++i){const t=this._$createInstance(e[i]);t._$placeId=i,this._$children.push(t),t._$name&&this._$names.set(t._$name,t)}}return this._$children}const r=s.$getMap(),n=s.$getMap();let o=0;const h=s.$getArray();for(let s=0;s<i;++s){const i=this._$children[s],l=i._$parent;if(l&&l._$instanceId===this._$instanceId)if(i._$startFrame<=t&&i._$endFrame>t){if(i._$filters=null,i._$blendMode=null,null===i._$id){h.push(i),i._$name&&this._$names.set(i._$name,i);continue}const t=e[o];if(i._$id===t){i._$placeId=o,h.push(i),i._$name&&this._$names.set(i._$name,i),n.has(t)&&n.delete(t),r.set(t,!0),o++;continue}n.set(i._$id,i)}else i.willTrigger(a.REMOVED)&&i.dispatchEvent(new a(a.REMOVED,!0)),i.willTrigger(a.REMOVED_FROM_STAGE)&&i.dispatchEvent(new a(a.REMOVED_FROM_STAGE,!0)),i._$added=!1,i._$addedStage=!1,i._$active=!1,i._$updated=!0,i._$filters=null,i._$blendMode=null,i._$isNext=!0,i instanceof v&&(i._$executeRemovedFromStage(),i._$removeParentAndStage())}if(e)for(let t=0;t<e.length;++t){const i=e[t];if(r.has(i))continue;const s=n.has(i)?n.get(i):this._$createInstance(i);s._$placeId=t,h.push(s),s._$name&&this._$names.set(s._$name,s)}s.$poolMap(r),s.$poolMap(n),s.$poolArray(this._$children),this._$children=null,this._$children=h}return this._$children}_$clearChildren(){this._$doChanged(),s.$isUpdated=!0,this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$stage=this._$stage,t._$parent=this,t._$root=this.constructor===G?t:this._$root,t instanceof v&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger(a.ADDED)&&t.dispatchEvent(new a(a.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(t.willTrigger(a.ADDED_TO_STAGE)&&t.dispatchEvent(new a(a.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof v&&t._$executeAddedToStage()),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e._$root=this._$root,e._$stage=this._$stage,e instanceof v&&(e._$setParentAndStage(),e._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage||(e.willTrigger(a.ADDED_TO_STAGE)&&e.dispatchEvent(new a(a.ADDED_TO_STAGE)),e._$addedStage=!0),e instanceof v&&e._$executeAddedToStage())}}_$remove(t,e=!0){t._$transform._$transform();const i=this._$needsChildren?this._$getChildren():this._$children,s=this.getChildIndex(t);return i.splice(s,1),this._$names.delete(t.name),e&&(t.willTrigger(a.REMOVED)&&t.dispatchEvent(new a(a.REMOVED,!0)),null!==this._$stage&&(t.willTrigger(a.REMOVED_FROM_STAGE)&&t.dispatchEvent(new a(a.REMOVED_FROM_STAGE)),t instanceof v&&t._$executeRemovedFromStage()),t instanceof v&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,this._$doChanged()),t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0),e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage&&(e.willTrigger(a.REMOVED_FROM_STAGE)&&e.dispatchEvent(new a(a.REMOVED_FROM_STAGE)),e._$addedStage=!1),e instanceof v&&e._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e instanceof v&&e._$removeParentAndStage(),e._$stage=null,e._$root=null,e._$addedStage=!1}if(this._$sounds)for(let[t,e]of this._$sounds)for(let t=0;t<e.length;++t){e[t].stop()}}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,this._$isNext}_$clip(t,e){let i=e;const r=this._$transform._$rawMatrix();r!==s.$MATRIX_ARRAY_IDENTITY&&(i=s.$multiplicationMatrix(e,r)),this._$graphics&&this._$graphics._$getBounds()&&this._$graphics._$clip(t,i);const n=this._$getChildren(),a=n.length;for(let e=0;e<a;++e){const s=n[e];s._$isMask||(s._$clip(t,i),s._$updated=!1)}i!==e&&s.$poolFloat32Array6(i)}_$draw(t,e,i){if(!this._$visible)return;let r=i;const n=this._$transform._$rawColorTransform();n!==s.$COLOR_ARRAY_IDENTITY&&(r=s.$multiplicationColor(i,n));if(!s.$clamp(r[3]+r[7]/255,0,1,0))return;const a=this._$needsChildren?this._$getChildren():this._$children,o=a.length;if(!(o||this._$graphics&&this._$graphics._$canDraw))return;const h=this._$preDraw(t,e,i);if(!h)return;if(h.isFilter&&!h.isUpdated)return void this._$postDraw(t,e,r,h);let l=h.matrix;const $=h.isFilter?h.color:r;this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$draw(t,l,$);let _=!0,c=null;const u=s.$getArray(),d=s.$getArray(),g=s.$getArray(),p=s.$getArray(),f=t._$isLayer,m=this._$isUpdated();for(let e=0;e<o;++e){const i=a[e];if(m&&(i._$placeObject=null),i._$isMask)continue;const r=i._$blendMode||i.blendMode;if((r===S.ALPHA||r===S.ERASE)&&!f)continue;if(c&&(i._$placeId>c||i._$clipDepth>0)&&(t.restore(),_&&(t._$leaveClip(),u.length&&(s.$poolFloat32Array6(l),l=u.pop())),c=g.length?g.pop():null,_=p.pop()),!_)continue;if(i._$clipDepth>0){if(t.save(),c&&g.push(c),p.push(_),c=i._$clipDepth,_=i._$shouldClip(l),_){const e=i._$startClip(t,l);if(!1===e){_=!1;continue}e&&(u.push(l),l=e)}continue}const n=i._$mask;if(n){let e;if(n._$updated=!1,this===n._$parent)e=l;else{e=s.$MATRIX_ARRAY_IDENTITY;let i=n._$parent;for(;i;)e=s.$multiplicationMatrix(i._$transform._$rawMatrix(),e),i=i._$parent;const r=this.stage._$player,a=r._$scale*r._$ratio/20,o=s.$getFloat32Array6(a,0,0,a,0,0);if(e=s.$multiplicationMatrix(o,e),t._$isLayer){const i=t._$getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t._$cacheCurrentBuffer&&(e[4]-=t._$cacheCurrentBounds.x,e[5]-=t._$cacheCurrentBounds.y)}if(!n._$shouldClip(e))continue;let i=n._$startClip(t,e);if(t.save(),!1===i){t.restore();continue}if(i){if(d.push(l),this!==n._$parent){const e=this._$transform._$rawMatrix();i[0]=s.$abs(l[0])*s.$sign(e[0]),i[1]=s.$abs(l[1])*s.$sign(e[1]),i[2]=s.$abs(l[2])*s.$sign(e[2]),i[3]=s.$abs(l[3])*s.$sign(e[3]),i[4]=l[4]-t._$cacheCurrentBounds.x,i[5]=l[5]-t._$cacheCurrentBounds.y}l=i}}i._$draw(t,l,$),i._$updated=!1,n&&(t.restore(),t._$leaveClip(),d.length&&(s.$poolFloat32Array6(l),l=d.pop()))}if(c&&(t.restore(),p.pop()&&t._$leaveClip()),s.$poolArray(u),s.$poolArray(d),s.$poolArray(g),s.$poolArray(p),h.isFilter)return this._$postDraw(t,e,r,h);s.$poolFloat32Array6(l),s.$poolPreObject(h)}_$mouseHit(t,e,i,r=!0){let n=e;const a=this._$transform._$rawMatrix();a!==s.$MATRIX_ARRAY_IDENTITY&&(n=s.$multiplicationMatrix(e,a));const o=this._$getChildren(),h=s.$getArray(),l=s.$getArray(),$=s.$getMap();let _=o.length,c=null,u=null;for(let t=0;t<_;++t){const e=o[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?(u=h.length,c=e._$clipDepth,h.push(e)):(c&&e._$placeId>c&&(u=null,c=null),null!==u&&$.set(e._$instanceId,u),l.push(e)))}const d=s.$min(this._$mouseChildren,r);let g=!1;const p=this._$root===this;_=l.length;for(let e=0;e<_;++e){const e=l.pop();if(e._$isMask)continue;if(p&&!(e instanceof T))continue;if($.has(e._$instanceId)){if(!h[$.get(e._$instanceId)]._$hit(t,n,i,!0))continue}const r=e._$mask;if(r)if(this===r._$parent){if(!r._$hit(t,n,i,!0))continue}else{let e=s.$MATRIX_ARRAY_IDENTITY,n=r._$parent;for(;n;)e=s.$multiplicationMatrix(n._$transform._$rawMatrix(),e),n=n._$parent;if(!r._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,n,i,d)||e._$hitArea&&e._$hitArea._$mouseHit(t,n,i,d)){if(e._$root===e)return!0;if(!d)return!0;if(g=!0,e instanceof T){if(!e._$mouseEnabled&&!e._$hitObject)continue;if(!s.$isTouch&&!i.pointer)switch(!0){case e instanceof rt:e._$type===nt.DYNAMIC&&(i.pointer="text");break;case e instanceof U:case e.buttonMode&&e.useHandCursor:i.pointer="pointer"}return i.hit||(i.hit=!e._$mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}return s.$poolArray(h),s.$poolArray(l),s.$poolMap($),!g&&this._$graphics&&(g=this._$graphics._$hit(t,n,i)),n!==e&&s.$poolFloat32Array6(n),g}_$hit(t,e,i,r=!1){let n=e;const a=this._$transform._$rawMatrix();a!==s.$MATRIX_ARRAY_IDENTITY&&(n=s.$multiplicationMatrix(e,a));const o=this._$getChildren();for(let e=o.length-1;e>-1;--e){const s=o[e];if(!s._$isMask&&s._$hit(t,n,i,r))return!0}let h=!1;return this._$graphics&&(h=this._$graphics._$hit(t,n,i)),n!==e&&s.$poolFloat32Array6(n),h}_$createInstance(t){const e=this._$dictionary[t],i=this._$loaderInfo,r=i._$data.characters[e.characterId];if(!r.class){const t=i._$data.symbols;let n=r.symbol;e.characterId in t&&(n=t[r._$characterId]),r.class=s.$getClass(n)}const n=new r.class;return n._$build(e,this),n._$id=t,n}_$nextFrame(){let t=!1;const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,this._$isNext}_$outCheck(t,e){let i=s.$MATRIX_ARRAY_IDENTITY,r=this._$parent;for(;r;)i=s.$multiplicationMatrix(r._$transform._$rawMatrix(),i),r=r._$parent;return s.$hitContext.setTransform(1,0,0,1,0,0),s.$hitContext.beginPath(),this._$mouseHit(s.$hitContext,i,{x:t,y:e})}}class y extends v{constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=t}get dropTarget(){return s.$dropTarget}get graphics(){return this._$graphics||(this._$graphics=new O,this._$graphics._$displayObject=this),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=null,t instanceof y&&(this._$hitArea=t,t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new lt),this._$soundTransform}set soundTransform(t){t instanceof lt&&(this._$soundTransform=t)}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=t}startDrag(t=!1,e=null){let i=0,r=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,r=this.y-t.y}s.$dropTarget=this,s.$dragRules.lock=t,s.$dragRules.position.x=i,s.$dragRules.position.y=r,s.$dragRules.bounds=e}stopDrag(){s.$dropTarget=null,s.$dragRules.lock=!1,s.$dragRules.position.x=0,s.$dragRules.position.y=0,s.$dragRules.bounds=null}_$build(t,e){const i=super._$build(t,e);return this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(s.$currentMousePoint()):this.globalToLocal(s.$currentMousePoint())}}class E extends y{constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=s.$getMap(),this._$frameCache=s.$getMap(),this._$labels=null,this._$sounds=s.$getMap(),this._$channels=s.$getMap(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1,this._$enabled=!0}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)?this._$labels.get(t):null}get currentLabels(){return this._$labels?s.$Array.from(this._$labels):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=s.$getMap()),t instanceof R&&this._$labels.set(t.frame,t)}addFrameScript(){const t=arguments.length;for(let e=0;e<t;e+=2){let t=arguments[e];s.$isNaN(0|t)&&(t=this._$getFrameForLabel(t));const i=arguments[e+1];if(i&&t&&this._$totalFrames>=t&&this._$addAction(t,i),t===this._$currentFrame){const t=s.$currentPlayer();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push.apply(t._$actions,e),t._$actionOffset=0}}}}_$getFrameForLabel(t){for(let[e,i]of this._$labels)if(i.name===t)return 0|e;return 0}_$addAction(t,e){(t|=0)&&(this._$actions.has(t)||this._$actions.set(t,s.$getArray()),this._$actions.get(t).push(e))}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e.willTrigger(a.FRAME_LABEL)&&e.dispatchEvent(new a(a.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=s.$currentPlayer();if(t){-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}}_$goToFrame(t){if(s.$isNaN(+t)&&(t=this._$getFrameForLabel(t)),t<1&&(t=1),t>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const e=s.$currentPlayer();switch(!0){case t!==this._$currentFrame:{this._$wait=!1;const i=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",t),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=t,this._$clearChildren(),e._$actionOffset=e._$actions.length;const s=e._$actionOffset?e._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),e._$actionOffset&&e._$actionOffset!==e._$actions.length){const t=e._$actions.splice(0,e._$actionOffset);e._$actions.push.apply(e._$actions,t),e._$actionOffset=0}if(!this._$actionProcess&&(s>-1||!e._$actionOffset))for(;e._$actions.length&&e._$actions.length!==s;){const t=e._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const i=t._$currentFrame;if(!t._$actions.has(i))continue;const s=t._$actions.get(i),r=s.length;for(let e=0;e<r;++e)try{s[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=i,this._$clearChildren())}break;case!this._$actionProcess&&e._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=e._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const s=e._$actions.get(i),r=s.length;for(let t=0;t<r;++t)try{s[t].apply(e)}catch(t){e.stop()}}}}this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!e._$sounds.has(this._$instanceId)&&e._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$draw(t,e,i){super._$draw(t,e,i);const r=s.$currentPlayer();this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!r._$sounds.has(this._$instanceId)&&r._$sounds.set(this._$instanceId,this)}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:t=!0,this._$canAction=!0,this._$canSound=!0,++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1),this._$clearChildren()}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$setAction(),this._$isNext=t,this._$isNext}_$build(t,e){const i=super._$build(t,e);for(let t=0;t<i.sounds.length;++t){const e=i.sounds[t],r=s.$getArray();for(let t=0;t<e.sound.length;++t){const i=new ot;i._$build(e.sound[t],this),r.push(i)}this._$sounds.set(e.frame,r)}for(let t=0;t<i.actions.length;++t){const e=i.actions[t];e.script||(e.script=Function(e.action)),this._$addAction(e.frame,e.script)}for(let t=0;t<i.labels.length;++t){const e=i.labels[t];this.addFrameLabel(new R(e.name,e.frame))}return this._$totalFrames=i.totalFrame||1,i}_$soundPlay(){const t=this._$sounds.get(this._$currentFrame);if(!t)return;const e=t.length;if(e){let i=this._$soundTransform,s=this._$parent;for(;s;)s._$soundTransform&&(i=s._$soundTransform),s=s._$parent;for(let s=0;s<e;++s){const e=t[s];i&&(e.loop=i.loop,e.volume=i.volume),e.play()}}this._$canSound=!1}}class A{constructor(t=0,i=0,r=!0,n=4294967295){this._$width=0|t,this._$height=0|i,this._$transparent=r,this._$color=this._$toRGBA(s.$clamp(n,0,4294967295,4294967295)),this._$instanceId=e++}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get height(){return this._$height}get transparent(){return this._$transparent}get width(){return this._$width}get _$texture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=s.$currentPlayer(),r=i._$cacheStore,n=r.generateKeys(this._$instanceId);let a=r.get(n);if(!a){const o=i._$context;if(this._$buffer)a=o.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0),this._$buffer=null;else{const i=o.frameBuffer.currentAttachment,r=o.frameBuffer.createCacheAttachment(t,e,!1);o._$bind(r),s.$resetContext(o),o.fillStyle=[this._$color.R/255,this._$color.G/255,this._$color.B/255,this._$color.A/255],o.setTransform(1,0,0,1,0,0),o.beginPath(),o.fillRect(0,0,t,e),a=o.frameBuffer.getTextureFromCurrentAttachment(),i?o._$bind(i):o.frameBuffer.unbind(),o.frameBuffer.releaseAttachment(r,!1)}r.set(n,a)}return s.$poolArray(n),a._$bitmapData||(a._$bitmapData=this),a}set _$texture(t){this._$setPixelQueue=null,this._$setPixelCount=0,this._$linePixelsCache=null,this._$linePixelsCacheY=null;const e=s.$currentPlayer(),i=e._$cacheStore,r=i.generateKeys(this._$instanceId),n=i.get(r);n&&(n._$bitmapData&&delete n._$bitmapData,e._$context.frameBuffer.releaseTexture(n),i.set(r,null)),this._$buffer&&(this._$buffer=null),i.set(r,t),s.$poolArray(r),t._$bitmapData||(t._$bitmapData=this)}draw(t,e=null,i=null,r=S.NORMAL,n=null,a=!1){const o=this._$width,h=this._$height;if(!o||!h)return;const l=s.$currentPlayer()._$context,$=l.frameBuffer.currentAttachment,_=l.frameBuffer.createCacheAttachment(o,h,!1);if(l._$bind(_),s.$resetContext(l),l.setTransform(1,0,0,1,0,0),n){const t=n.x,e=n.y,i=n.width,s=n.height;l.save(),l._$enterClip(),l._$beginClipDef(),l.setTransform(1,0,0,1,0,0),l.beginPath(),l.moveTo(t,e),l.lineTo(t+i,e),l.lineTo(t+i,e+s),l.lineTo(t,e+s),l.lineTo(t,e),l.clip(!0),l._$endClipDef()}let c=e?e._$matrix:s.$MATRIX_ARRAY_IDENTITY,u=i?i._$colorTransform:s.$COLOR_ARRAY_IDENTITY;switch(!0){case t instanceof b:const i=t._$transform.matrix;i.invert(),e&&(c=s.$multiplicationMatrix(c,i._$matrix)),t._$draw(l,c,u),s.$poolMatrix(i);break;case t instanceof A:new Bitmap(t,PixelSnapping.AUTO,a)._$draw(l,c,u)}n&&(l.restore(),l._$leaveClip());const d=l.frameBuffer.getTextureFromCurrentAttachment(),g=l.frameBuffer.createTextureAttachmentFrom(this._$texture);l._$bind(g),l.frameBuffer.releaseAttachment(_,!1),s.$resetContext(l),l.setTransform(1,0,0,1,0,0),l._$imageSmoothingEnabled=a,l._$globalCompositeOperation=r,l.drawImage(d,0,0,o,h),$?l._$bind($):l.frameBuffer.unbind(),l.frameBuffer.releaseTexture(d),l.frameBuffer.releaseAttachment(g,!1)}load(t){}_$toRGBA(t){return this._$transparent?s.$uintToRGBA(t):s.$intToRGBA(t)}_$getPixels(t,e,i,r,n="ARGB",a=null){switch(n){case"ARGB":case"RGBA":case"BGRA":break;default:throw new Error(`Unsupported byteOrder: ${n}`)}t=Math.max(t,0),e=Math.max(e,0);const o=s.$min(i,this.width-t),h=s.$min(r,this.height-e);if(o<=0||h<=0)return new Uint8Array(0);const l=a?a(o*h*4):new Uint8Array(o*h*4),$=s.$currentPlayer()._$context;if(!$)return l;const _=$._$shaderList._$bitmapData.getPixels[n].instance;$._$shaderList.bitmapShaderVariants.setGetPixelsUniform(_.uniform,o/this.width,-h/this.height,t/this.width,1-e/this.height);const c=$.frameBuffer.currentAttachment,u=$.frameBuffer.createCacheAttachment(o,h,!1);$._$bind(u),$._$frameBufferManager._$textureManager.bind0(this._$texture,!1),$.blend.disable(),_._$drawImage(),$.blend.enable();const d=$._$gl;return d.readPixels(0,0,o,h,d.RGBA,d.UNSIGNED_BYTE,l),c?$._$bind(c):$.frameBuffer.unbind(),$.frameBuffer.releaseAttachment(u),l}toImage(){const{width:t,height:e}=this,i=new Image;if(t||e){const r=s.$cacheStore().getCanvas();r.width=t,r.height=e;const n=new ImageData(t,e);n.data.set(this._$getPixels(0,0,t,e,"RGBA"));const a=r.getContext("2d");a.putImageData(n,0,0),i.width=t,i.height=e,i.src=a.canvas.toDataURL(),s.$cacheStore().destroy(a)}return i}toUint8Array(){return this._$buffer?this._$buffer:this._$getPixels(0,0,this.width,this.height,"RGBA")}}class M{constructor(){}static toString(){return"[class BitmapDataChannel]"}static get namespace(){return"next2d.display.BitmapDataChannel"}toString(){return"[object BitmapDataChannel]"}get namespace(){return"next2d.display.BitmapDataChannel"}static get ALPHA(){return 8}static get BLUE(){return 4}static get GREEN(){return 2}static get RED(){return 1}}class S{constructor(){}static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}}class C{constructor(){}static toString(){return"[class CapsStyle]"}static get namespace(){return"next2d.display.CapsStyle"}toString(){return"[object CapsStyle]"}get namespace(){return"next2d.display.CapsStyle"}static get NONE(){return"none"}static get ROUND(){return"round"}static get SQUARE(){return"square"}}class R extends o{constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class w{constructor(){}static toString(){return"[class GradientType]"}static get namespace(){return"next2d.display.GradientType"}toString(){return"[object GradientType]"}get namespace(){return"next2d.display.GradientType"}static get LINEAR(){return"linear"}static get RADIAL(){return"radial"}}class O{constructor(t=null){this._$displayObject=t,this.clear()}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}beginBitmapFill(t,e=null,i=!0,r=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=s.$getArray()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$margePath(s.$getArray(O.BEGIN_PATH)),this._$fillType=O.BITMAP_FILL,this._$fillBitmap=new F(t,e,i,r),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=s.$getArray()),t=s.$clamp(s.$toColorInt(t),0,16777215,0),e=s.$clamp(e,0,1,1),this._$maxAlpha=s.$max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$margePath(s.$getArray(O.BEGIN_PATH));const i=s.$intToRGBA(t,e);return this._$fillType=O.FILL_STYLE,this._$fillStyleR=i.R,this._$fillStyleG=i.G,this._$fillStyleB=i.B,this._$fillStyleA=i.A,this}beginGradientFill(t,e,i,r,n=null,a=k.PAD,o=L.RGB,h=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=s.$getArray());const l=i.length;for(let t=0;t<l;++t)this._$maxAlpha=s.$max(this._$maxAlpha,i[t]);return this._$doFill=!0,this._$canDraw=!0,this._$margePath(s.$getArray(O.BEGIN_PATH)),this._$fillType=O.GRADIENT_FILL,this._$fillGradient=new B(t,e,i,r,n,a,o,h),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=0,this._$caps=C.NONE,this._$joints=I.ROUND,this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=s.$MAX_VALUE,this._$xMax=-s.$MAX_VALUE,this._$yMin=s.$MAX_VALUE,this._$yMax=-s.$MAX_VALUE,this._$recode&&(s.$poolArray(this._$recode),this._$recode=null),this._$fills&&(s.$poolArray(this._$fills),this._$fills=null),this._$lines&&(s.$poolArray(this._$lines),this._$lines=null),this._$restart(),this}clone(){const t=new O;this._$fillGradient&&(t._$fillGradient=this._$fillGradient.clone()),this._$fillBitmap&&(t._$fillBitmap=this._$fillBitmap.clone()),t._$doFill=this._$doFill,t._$fillType=this._$fillType,t._$fillStyleR=this._$fillStyleR,t._$fillStyleG=this._$fillStyleG,t._$fillStyleB=this._$fillStyleB,t._$fillStyleA=this._$fillStyleA,this._$lineGradient&&(t._$lineGradient=this._$lineGradient.clone()),t._$doLine=this._$doLine,t._$lineType=this._$lineType,t._$caps=this._$caps,t._$joints=this._$caps,t._$miterLimit=this._$miterLimit,t._$lineWidth=this._$lineWidth,t._$lineStyleR=this._$lineStyleR,t._$lineStyleG=this._$lineStyleG,t._$lineStyleB=this._$lineStyleB,t._$lineStyleA=this._$lineStyleA,t._$xMin=this._$xMin,t._$xMax=this._$xMax,t._$yMin=this._$yMin,t._$yMax=this._$yMax,t._$maxAlpha=this._$maxAlpha,t._$pointerX=this._$pointerX,t._$pointerY=this._$pointerY,t._$canDraw=this._$canDraw,this._$fills.length&&(t._$fills=this._$fills.slice(0)),this._$lines.length&&(t._$lines=this._$lines.slice(0)),this._$recode.length&&(t._$recode=this._$recode.slice(0))}cubicCurveTo(t,e,i,r,n,a){return n=+n||0,a=+a||0,this._$pointerX===n&&this._$pointerY===a||(t=+t||0,e=+e||0,i=+i||0,r=+r||0,this._$setBounds(t,e),this._$setBounds(i,r),this._$setBounds(n,a),this._$margePath(s.$getArray(O.CUBIC,t,e,i,r,n,a)),this._$pointerX=n,this._$pointerY=a,this._$restart()),this}curveTo(t,e,i,r){return i=+i||0,r=+r||0,this._$pointerX===i&&this._$pointerY===r||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,r),this._$margePath(s.$getArray(O.CURVE_TO,t,e,i,r)),this._$pointerX=i,this._$pointerY=r,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(s.$getArray(O.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,i,r){const n=(i=+i||0)/2,a=(r=+r||0)/2,o=(t=+t||0)+n,h=(e=+e||0)+a,l=t+i,$=e+r,_=4/3*(s.$SQRT2-1),c=_*n,u=_*a;return this.moveTo(o,e).cubicCurveTo(o+c,e,l,h-u,l,h).cubicCurveTo(l,h+u,o+c,$,o,$).cubicCurveTo(o-c,$,t,h+u,t,h).cubicCurveTo(t,h-u,o-c,e,o,e)}drawRect(t,e,i,s){const r=(t=+t||0)+(i=+i||0),n=(e=+e||0)+(s=+s||0);return this.moveTo(t,e).lineTo(t,n).lineTo(r,n).lineTo(r,e).lineTo(t,e)}drawRoundRect(t,e,i,r,n,a=NaN){t=+t||0,e=+e||0,i=+i||0,r=+r||0;const o=(n=+n||0)/2,h=(a=+a||n)/2,l=4/3*(s.$SQRT2-1),$=l*o,_=l*h,c=t+o,u=t+i,d=u-o,g=e+h,p=e+r,f=p-h;return this.moveTo(c,e).lineTo(d,e).cubicCurveTo(d+$,e,u,g-_,u,g).lineTo(u,f).cubicCurveTo(u,f+_,d+$,p,d,p).lineTo(c,p).cubicCurveTo(c-$,p,t,f+_,t,f).lineTo(t,g).cubicCurveTo(t,g-_,c-$,e,c,e)}endFill(){if(this._$doFill)switch(this._$recode||(this._$recode=s.$getArray()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(O.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push.apply(this._$recode,this._$fills),s.$poolArray(this._$fills),this._$fills=null,this._$fillType){case O.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,O.END_FILL);break;case O.GRADIENT_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillGradient.toArray());break;case O.BITMAP_FILL:this._$recode.push(this._$fillType);const t=this._$fillBitmap.toArray();for(let e=0;e<t.length;++e)this._$recode.push(t[e])}return this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine)switch(this._$recode||(this._$recode=s.$getArray()),this._$recode.push.apply(this._$recode,this._$lines),s.$poolArray(this._$lines),this._$lines=null,this._$lineType){case O.STROKE_STYLE:this._$recode.push(this._$lineType,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,O.END_STROKE);break;case O.GRADIENT_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$lineGradient.toArray())}return this._$lineType=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps=C.NONE,this._$joints=I.ROUND,this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineGradientStyle(t,e,i,r,n=null,a=k.PAD,o=L.RGB,h=0){if(!this._$doLine)return this;this._$lines||(this._$lines=s.$getArray());const l=i.length;for(let t=0;t<l;++t)this._$maxAlpha=s.$max(this._$maxAlpha,i[t]);return this._$margePath(s.$getArray(O.BEGIN_PATH)),this._$lineType=O.GRADIENT_STROKE,this._$lineGradient=new B(t,e,i,r,n,a,o,h),this}lineStyle(t=1,e=0,i=1,r=C.ROUND,n=I.ROUND,a=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=s.$getArray()),e=s.$clamp(s.$toColorInt(e),0,16777215,0),i=s.$clamp(i,0,1,1),this._$maxAlpha=s.$max(this._$maxAlpha,i),this._$doLine=!0,this._$canDraw=!0,this._$margePath(s.$getArray(O.BEGIN_PATH));const o=s.$intToRGBA(e,i);return this._$lineType=O.STROKE_STYLE,this._$lineStyleR=o.R,this._$lineStyleG=o.G,this._$lineStyleB=o.B,this._$lineStyleA=o.A,this._$lineWidth=t,this._$caps=`${r}`,this._$joints=`${n}`,this._$joints===I.MITER&&(this._$miterLimit=a),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(s.$getArray(O.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){return t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e),this._$margePath(s.$getArray(O.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,e){const i=this._$getBounds(),r=s.$boundsMatrix(i,e);let n=s.$ceil(s.$abs(r.xMax-r.xMin)),a=s.$ceil(s.$abs(r.yMax-r.yMin));switch(s.$poolBoundsObject(i),s.$poolBoundsObject(r),!0){case 0===n:case 0===a:case n===-s.$Infinity:case a===-s.$Infinity:case n===s.$Infinity:case a===s.$Infinity:return}s.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$doDraw(t,s.$COLOR_ARRAY_IDENTITY,!0)}_$draw(t,e,i,r=S.NORMAL,n=null){if(!this._$maxAlpha)return;const a=s.$clamp(i[3]+i[7]/255,0,1),o=this._$displayObject;let h=null!==o._$scale9Grid,l=null;h&&(l=o._$transform._$rawMatrix(),h=h&&s.$abs(l[1])<.001&&s.$abs(l[2])<1e-4);const $=this._$getBounds(),_=s.$boundsMatrix($,e),c=_.xMax,u=_.xMin,d=_.yMax,g=_.yMin;s.$poolBoundsObject(_);let p=s.$ceil(s.$abs(c-u)),f=s.$ceil(s.$abs(d-g));switch(!0){case 0===p:case 0===f:case p===-s.$Infinity:case f===-s.$Infinity:case p===s.$Infinity:case f===s.$Infinity:return}if(0>u+p||0>g+f){if(!(n&&n.length&&o._$canApply(n)))return;{let t=Math.sqrt(e[0]*e[0]+e[1]*e[1]),i=Math.sqrt(e[2]*e[2]+e[3]*e[3]),s=new m(0,0,p,f);for(let e=0;e<n.length;++e)s=n[e]._$generateFilterRect(s,t,i);if(0>s.x+s.width||0>s.y+s.height)return}}const x=t.frameBuffer.currentAttachment;if(u>x.width||g>x.height)return;const b=t._$textureScale(p,f);b<1&&(p*=b,f*=b);const T=s.$sqrt(e[0]*e[0]+e[1]*e[1]),v=s.$sqrt(e[2]*e[2]+e[3]*e[3]),y=s.$cacheStore().generateKeys(o._$instanceId,[T,v],i);let E=s.$cacheStore().get(y);if(!E){const r=t.frameBuffer.createCacheAttachment(p,f,!0);if(t._$bind(r),s.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4]-u,e[5]-g),h){const i=s.$currentPlayer(),r=i._$scale*i._$ratio,n=s.$getFloat32Array6(r,0,0,r,0,0),a=s.$multiplicationMatrix(n,l);s.$poolFloat32Array6(n);const h=o._$parent._$transform._$calculateConcatenatedMatrix()._$matrix,_=s.$getFloat32Array6(h[0],h[1],h[2],h[3],h[4]*r-u,h[5]*r-g),c=s.$multiplicationMatrix(_,a),d=c[4]-(e[4]-u),p=c[5]-(e[5]-g);s.$poolFloat32Array6(c);const f=s.$boundsMatrix($,a),m=+f.xMax,x=+f.xMin,b=+f.yMax,T=+f.yMin,v=s.$ceil(s.$abs(m-x)),y=s.$ceil(s.$abs(b-T));s.$poolBoundsObject(f),t.grid.enable(x,T,v,y,$,o._$scale9Grid,a[0],a[1],a[2],a[3],a[4],a[5],_[0],_[1],_[2],_[3],_[4]-d,_[5]-p),s.$poolFloat32Array6(a),s.$poolFloat32Array6(_)}i[3]=1,this._$doDraw(t,i,!1),h&&t.grid.disable(),E=t.frameBuffer.getTextureFromCurrentAttachment(),s.$cacheStore().set(y,E),t.frameBuffer.releaseAttachment(r,!1),t._$bind(x)}let A=!1,M=0,C=0;if(n&&n.length){const r=o._$canApply(n);if(r){A=!0;const a=[o._$instanceId,"f"];let h=s.$cacheStore().get(a);const l=o._$isFilterUpdated(p,f,e,i,n,r);h&&!l||(h&&(s.$cacheStore().set(a,null),h.layerWidth=0,h.layerHeight=0,h._$offsetX=0,h._$offsetY=0,h.matrix=null,h.colorTransform=null,t.frameBuffer.releaseTexture(h),h=null),E=o._$getFilterTexture(t,n,E,e,i),s.$cacheStore().set(a,E)),h&&(E=h),s.$poolArray(a),M=E._$offsetX,C=E._$offsetY}}s.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=r,t.setTransform(1,0,0,1,0,0),A?t.drawImage(E,u-M,g-C,E.width,E.height,i):t.drawImage(E,u,g,p,f,i),s.$poolArray(y),l&&s.$poolMatrix(l),s.$poolBoundsObject($)}_$doDraw(t,e,i=!1){s.$resetContext(t),t.beginPath(),this._$runCommand(t,e,i),i&&t.clip()}_$hit(t,e,i,s=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,s,i)}_$getBounds(t=null){const e=this._$displayObject;return e&&e._$bounds?s.$getBoundsObject(e._$bounds.xMin,e._$bounds.xMax,e._$bounds.yMin,e._$bounds.yMax):s.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){this._$displayObject&&!this._$displayObject._$isUpdated()&&(this._$displayObject._$doChanged(),s.$isUpdated=!0,s.$cacheStore().removeCache(this._$displayObject._$instanceId))}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t,e){this._$xMin=s.$min(this._$xMin,t),this._$xMax=s.$max(this._$xMax,t),this._$yMin=s.$min(this._$yMin,e),this._$yMax=s.$max(this._$yMax,e)}_$setLineBounds(t,e){this._$xMin=s.$min(this._$xMin,s.$min(t,this._$pointerX)),this._$xMax=s.$max(this._$xMax,s.$max(t,this._$pointerX)),this._$yMin=s.$min(this._$yMin,s.$min(e,this._$pointerY)),this._$yMax=s.$max(this._$yMax,s.$max(e,this._$pointerY));const i=this._$lineWidth/2,r=.5*s.$PI,n=s.$atan2(e-this._$pointerY,t-this._$pointerX),a=s.$atan2(this._$pointerY-e,this._$pointerX-t),o=n+r,h=n-r,l=a+r,$=a-r;let _=t+i,c=-i+t,u=this._$pointerX+i,d=-i+this._$pointerX,g=e+i,p=-i+e,f=this._$pointerY+i,m=-i+this._$pointerY;s.$abs(o)%r!=0&&(_=t+s.$cos(o)*i),s.$abs(h)%r!=0&&(c=t+s.$cos(h)*i),s.$abs(l)%r!=0&&(u=this._$pointerX+s.$cos(l)*i),s.$abs($)%r!=0&&(d=this._$pointerX+s.$cos($)*i),o&&s.$abs(o)%s.$PI!=0&&(g=e+s.$sin(o)*i),h&&s.$abs(h)%s.$PI!=0&&(p=e+s.$sin(h)*i),l&&s.$abs(l)%s.$PI!=0&&(f=this._$pointerY+s.$sin(l)*i),$&&s.$abs($)%s.$PI!=0&&(m=this._$pointerY+s.$sin($)*i),this._$xMin=s.$min(this._$xMin,s.$min(_,s.$min(c,s.$min(u,d)))),this._$xMax=s.$max(this._$xMax,s.$max(_,s.$max(c,s.$max(u,d)))),this._$yMin=s.$min(this._$yMin,s.$min(g,s.$min(p,s.$min(f,m)))),this._$yMax=s.$max(this._$yMax,s.$max(g,s.$max(p,s.$max(f,m))));let x=0,b=0,T=0,v=0,y=0,E=0,A=0,M=0;switch(this._$caps){case C.ROUND:s.$abs(n)%r!=0&&(x=t+s.$cos(n)*i),n&&s.$abs(n)%s.$PI!=0&&(b=e+s.$sin(n)*i),s.$abs(a)%r!=0&&(T=this._$pointerX+s.$cos(a)*i),a&&s.$abs(a)%s.$PI!=0&&(v=this._$pointerY+s.$sin(a)*i),this._$xMin=s.$min(this._$xMin,s.$min(x,T)),this._$xMax=s.$max(this._$xMax,s.$max(x,T)),this._$yMin=s.$min(this._$yMin,s.$min(b,v)),this._$yMax=s.$max(this._$yMax,s.$max(b,v));break;case C.SQUARE:if(s.$abs(n)%r!=0){const t=s.$cos(n)*i;x=_+t,T=c+t}if(s.$abs(a)%r!=0){const t=s.$cos(a)*i;y=u+t,A=d+t}if(n&&s.$abs(n)%s.$PI!=0){const t=s.$sin(n)*i;b=g+t,v=p+t}if(a&&s.$abs(a)%s.$PI!=0){const t=s.$sin(a)*i;E=f+t,M=m+t}this._$xMin=s.$min(this._$xMin,s.$min(x,s.$min(T,s.$min(y,A)))),this._$xMax=s.$max(this._$xMax,s.$max(x,s.$max(T,s.$max(y,A)))),this._$yMin=s.$min(this._$yMin,s.$min(b,s.$min(v,s.$min(E,M)))),this._$yMax=s.$max(this._$yMax,s.$max(b,s.$max(v,s.$max(E,M))))}}_$margePath(t){this._$doFill&&this._$fills.push.apply(this._$fills,t),this._$doLine&&this._$lines.push.apply(this._$lines,t),s.$poolArray(t)}_$runCommand(t,e=null,i=!1,r=null){if(this._$doFill&&this.endFill(),this._$doLine&&this.endLine(),!this._$recode)return!1;const n=this._$recode,a=n.length;for(let o=0;o<a;)switch(n[o++]){case O.BEGIN_PATH:t.beginPath();break;case O.MOVE_TO:t.moveTo(n[o++],n[o++]);break;case O.LINE_TO:t.lineTo(n[o++],n[o++]);break;case O.CURVE_TO:t.quadraticCurveTo(n[o++],n[o++],n[o++],n[o++]);break;case O.FILL_STYLE:if(i||r){o+=4;continue}const a=t._$contextStyle;a._$fillStyle[0]=1!==e[0]||0!==e[4]?s.$max(0,s.$min(n[o++]*e[0]+e[4],255))/255:n[o++]/255,a._$fillStyle[1]=1!==e[1]||0!==e[5]?s.$max(0,s.$min(n[o++]*e[1]+e[5],255))/255:n[o++]/255,a._$fillStyle[2]=1!==e[2]||0!==e[6]?s.$max(0,s.$min(n[o++]*e[2]+e[6],255))/255:n[o++]/255,a._$fillStyle[3]=1!==e[3]||0!==e[7]?s.$max(0,s.$min(n[o++]*e[3]+e[7],255))/255:n[o++]/255,t._$style=a;break;case O.END_FILL:if(r){if(t.isPointInPath(r.x,r.y))return!0;continue}i||t.fill();break;case O.STROKE_STYLE:if(i||r){o+=8;continue}t.lineWidth=n[o++],t.lineCap=n[o++],t.lineJoin=n[o++],t.miterLimit=n[o++];const h=t._$contextStyle;h._$strokeStyle[0]=1!==e[0]||0!==e[4]?s.$max(0,s.$min(n[o++]*e[0]+e[4],255))/255:n[o++]/255,h._$strokeStyle[1]=1!==e[1]||0!==e[5]?s.$max(0,s.$min(n[o++]*e[1]+e[5],255))/255:n[o++]/255,h._$strokeStyle[2]=1!==e[2]||0!==e[6]?s.$max(0,s.$min(n[o++]*e[2]+e[6],255))/255:n[o++]/255,h._$strokeStyle[3]=1!==e[3]||0!==e[7]?s.$max(0,s.$min(n[o++]*e[3]+e[7],255))/255:n[o++]/255,t._$style=h;break;case O.END_STROKE:if(r){if(t.isPointInStroke(r.x,r.y))return!0;continue}i||t.stroke();break;case O.CLOSE_PATH:t.closePath();break;case O.CUBIC:t.bezierCurveTo(n[o++],n[o++],n[o++],n[o++],n[o++],n[o++]);break;case O.ARC:const l=n[o++],$=n[o++],_=n[o++];t.moveTo(l+_,$),t.arc(l,$,_,0,2*s.$PI);break;case O.GRADIENT_FILL:{if(r){if(t.isPointInPath(r.x,r.y))return!0;o+=6;continue}if(i){o+=6;continue}const a=n[o++],h=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++];let u=null;if(a===w.LINEAR){const e=s.$linearGradientXY(l);u=t.createLinearGradient(e[0],e[1],e[2],e[3],_,$)}else t.save(),t.transform(l[0],l[1],l[2],l[3],l[4],l[5]),u=t.createRadialGradient(0,0,0,0,0,819.2,_,$,c);const d=h.length;for(let t=0;t<d;++t){const i=h[t];u.addColorStop(i.ratio,s.$getFloat32Array4(0|s.$max(0,s.$min(i.R*e[0]+e[4],255)),0|s.$max(0,s.$min(i.G*e[1]+e[5],255)),0|s.$max(0,s.$min(i.B*e[2]+e[6],255)),0|s.$max(0,s.$min(i.A*e[3]+e[7],255))))}t.fillStyle=u,t.fill(),a===w.RADIAL&&t.restore()}break;case O.GRADIENT_STROKE:{if(r){if(t.isPointInStroke(r.x,r.y))return!0;o+=12;continue}if(i){o+=12;continue}const a=n[o++],h=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++],u=n[o++],d=n[o++],g=n[o++],p=n[o++];let f=null;if(_===w.LINEAR){const e=s.$linearGradientXY(u);f=t.createLinearGradient(e[0],e[1],e[2],e[3],g,d)}else t.save(),t.transform(u[0],u[1],u[2],u[3],u[4],u[5]),f=t.createRadialGradient(0,0,0,0,0,819.2,g,d,p);const m=c.length;for(let t=0;t<m;++t){const i=c[t];f.addColorStop(i.ratio,s.$getFloat32Array4(0|s.$max(0,s.$min(i.R*e[0]+e[4],255)),0|s.$max(0,s.$min(i.G*e[1]+e[5],255)),0|s.$max(0,s.$min(i.B*e[2]+e[6],255)),0|s.$max(0,s.$min(i.A*e[3]+e[7],255))))}t.strokeStyle=f,t.lineWidth=a,t.lineCap=h,t.lineJoin=l,t.miterLimit=$,t.stroke(),_===w.RADIAL&&t.restore()}break;case O.BITMAP_FILL:{if(r){if(t.isPointInPath(r.x,r.y))return!0;o+=6;continue}if(i){o+=6;continue}t.save();const s=t.frameBuffer.createTextureFromPixels(n[o++],n[o++],n[o++]),a=n[o++],h=n[o++],l=n[o++];t.fillStyle=t.createPattern(s,h,e),t.transform(a[0],a[1],a[2],a[3],a[4],a[5]),t._$imageSmoothingEnabled=l,t.fill(),t.restore(),t._$imageSmoothingEnabled=!1,t.frameBuffer.releaseTexture(s)}}return!1}}class F{constructor(t,e=null,i=!1,s=!1){this._$bitmapData=null,this._$matrix=null,this._$repeat=!1,this._$smooth=!1,this.bitmapData=t,this.matrix=e,this.repeat=i,this.smooth=s}get bitmapData(){return this._$bitmapData}set bitmapData(t){this._$bitmapData=null,t instanceof A&&(this._$bitmapData=t)}get matrix(){return this._$matrix}set matrix(t){this._$matrix=null,t instanceof p&&(this._$matrix=t)}get repeat(){return this._$repeat}set repeat(t){this._$repeat=t}get smooth(){return this._$smooth}set smooth(t){this._$smooth=t}clone(){return new F(this._$bitmapData,this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){const t=this._$bitmapData._$buffer?this._$bitmapData._$buffer:this._$bitmapData.toUint8Array(),e=this._$matrix?this._$matrix._$matrix:s.$MATRIX_ARRAY_IDENTITY;return s.$getArray(this._$bitmapData.width,this._$bitmapData.height,t,e,this._$repeat?"repeat":"no-repeat",this._$smooth)}}class B{constructor(t,e,i,s,r=null,n=k.PAD,a=L.RGB,o=0){this._$type=`${t}`,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$matrix=null,this._$spreadMethod=k.PAD,this._$interpolationMethod=L.RGB,this._$focalPointRatio=0|o,this._$colorStops=null,this.colors=e,this.alphas=i,this.ratios=s,this.matrix=r,this.spreadMethod=n,this.interpolationMethod=a}get alphas(){return this._$alphas}set alphas(t){if(this._$alphas=null,s.$isArray(t)){this._$alphas=s.$getArray();const e=t.length;for(let i=0;i<e;++i)this._$alphas[i]=s.$clamp(t[i],0,1,0)}}get colors(){return this._$colors}set colors(t){if(this._$colors=null,s.$isArray(t)){this._$colors=s.$getArray();const e=t.length;for(let i=0;i<e;++i)this._$colors[i]=s.$clamp(s.$toColorInt(t[i]),0,16777215,16777215)}}get colorStops(){if(!this._$colorStops){this._$colorStops=s.$getArray();const t=s.$min(s.$min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=s.$intToRGBA(this._$colors[e],this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:t.R,G:t.G,B:t.B,A:t.A}}}return this._$colorStops}get focalPointRatio(){return this._$focalPointRatio}set focalPointRatio(t){this._$focalPointRatio=t}get interpolationMethod(){return this._$interpolationMethod}set interpolationMethod(t){this._$interpolationMethod=L.LINEAR_RGB===t?t:L.RGB}get matrix(){return this._$matrix}set matrix(t){this._$matrix=t instanceof p?t:null}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios=null,s.$isArray(t)){this._$ratios=s.$getArray();const e=t.length;for(let i=0;i<e;++i)this._$ratios[i]=s.$clamp(t[i],0,255,0)}}get spreadMethod(){return this._$spreadMethod}set spreadMethod(t){switch(t){case k.REFLECT:case k.REPEAT:this._$spreadMethod=t;break;default:this._$spreadMethod=k.PAD}}get type(){return this._$type}set type(t){this._$type=w.RADIAL===t?t:w.LINEAR}clone(){return new B(this._$type,this.colors.slice(0),this.alphas.slice(0),this.ratios.slice(0),this._$matrix?this._$matrix.clone():null,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}toArray(){const t=this._$matrix?this._$matrix._$matrix:s.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0;return s.$getArray(this._$type,this.colorStops,t,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class L{constructor(){}static toString(){return"[class InterpolationMethod]"}static get namespace(){return"next2d.display.InterpolationMethod"}toString(){return"[object InterpolationMethod]"}get namespace(){return"next2d.display.InterpolationMethod"}static get LINEAR_RGB(){return"linearRGB"}static get RGB(){return"rgb"}}class I{constructor(){}static toString(){return"[class JointStyle]"}static get namespace(){return"next2d.display.JointStyle"}toString(){return"[object JointStyle]"}get namespace(){return"next2d.display.JointStyle"}static get BEVEL(){return"bevel"}static get MITER(){return"miter"}static get ROUND(){return"round"}}class P extends v{constructor(){super(),this._$loaderInfo=new D}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo._$content}get contentLoaderInfo(){return this._$loaderInfo}load(t){if(!(t&&t instanceof ct))return;const e=this.contentLoaderInfo;switch(t.responseDataFormat){case _t.JSON:case _t.ARRAY_BUFFER:break;default:return void(e.willTrigger(_.IO_ERROR)&&e.dispatchEvent(new _(_.IO_ERROR,!1,!1,"data format is json or arrayBuffer only.")))}e._$url=t.url,e._$format=t.responseDataFormat,s.$ajax({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(a.OPEN)&&e.dispatchEvent(new a(a.OPEN)),e.willTrigger(u.PROGRESS)&&e.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(u.PROGRESS)&&e.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(u.PROGRESS)&&e.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total));const i=s.$getArray(),r=s.$headerToArray(t.target.getAllResponseHeaders());let n="";const a=r.length;for(let t=0;t<a;++t){const e=r[t];"content-type"===e.name&&(n=e.value),i.push(new ut(e.name,e.value))}if(e.willTrigger($.HTTP_STATUS)){const s=new $($.HTTP_STATUS,!1,!1,t.target.status);s.responseURL=t.target.responseURL,s.responseHeaders=i,e.dispatchEvent(s)}if(199<t.target.status&&400>t.target.status)switch(e.format){case _t.JSON:e._$data=JSON.parse(t.target.responseText);const i=e._$data.characters[0];e._$content=new E,e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:i.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const r=s.$currentPlayer();r._$loaders.push(e),1===r._$loadStatus&&(r._$loadStatus=2)}else e.willTrigger(_.IO_ERROR)&&e.dispatchEvent(new _(_.IO_ERROR,!1,!1,t.target.statusText))}.bind(this)}})}}class D extends o{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format=_t.STRING}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get content(){return this._$content}get url(){return this._$url}get format(){return this._$format}set format(t){this._$format=t}}class N extends b{constructor(){super(),this._$graphics=null,this._$bounds=null}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new O(this)),this._$graphics}_$build(t,e){const i=super._$build(t,e),r=this.graphics;if(i.recodes)r._$recode=i.recodes.slice(0);else{const t=s.$abs(i.bounds.xMax-i.bounds.xMin),e=s.$abs(i.bounds.yMax-i.bounds.yMin),n=new A(t,e,!0,0);i._$buffer||(i._$buffer=new Uint8Array(i.buffer),s.$poolArray(i.buffer),i.buffer=null),n._$buffer=i._$buffer,r.beginBitmapFill(n,null,!1).drawRect(0,0,t,e).endFill()}return r._$maxAlpha=1,r._$canDraw=!0,r._$xMin=i.bounds.xMin,r._$xMax=i.bounds.xMax,r._$yMin=i.bounds.yMin,r._$yMax=i.bounds.yMax,i}_$getBounds(t=null){if(!this._$graphics)return s.$getBoundsObject(0,0,0,0);const e=this._$graphics._$getBounds(t);if(!e)return s.$poolBoundsObject(e),s.$getBoundsObject(0,0,0,0);if(t){const i=s.$multiplicationMatrix(t,this._$transform._$rawMatrix()),r=s.$boundsMatrix(e,i);return s.$poolBoundsObject(e),r}const i=s.$getBoundsObject(e.xMin,e.xMax,e.yMin,e.yMax);return s.$poolBoundsObject(e),i}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let r=i;const n=this._$transform._$rawColorTransform();n!==s.$COLOR_ARRAY_IDENTITY&&(r=s.$multiplicationColor(i,n));if(!s.$clamp(r[3]+r[7]/255,0,1,0))return void(r!==i&&s.$poolFloat32Array8(r));let a=e;const o=this._$transform._$rawMatrix();o!==s.$MATRIX_ARRAY_IDENTITY&&(a=s.$multiplicationMatrix(e,o));const h=this._$filters||this.filters,l=this._$blendMode||this.blendMode;this._$graphics._$draw(t,a,r,l,h),r!==i&&s.$poolFloat32Array8(r),a!==e&&s.$poolFloat32Array6(a)}_$clip(t,e){let i=e;const r=this._$transform._$rawMatrix();r!==s.$MATRIX_ARRAY_IDENTITY&&(i=s.$multiplicationMatrix(e,r)),this._$graphics._$clip(t,i),i!==e&&s.$poolFloat32Array6(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,r){let n=!1;if(this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$getBounds()){let a=e;const o=this._$transform._$rawMatrix();o!==s.$MATRIX_ARRAY_IDENTITY&&(a=s.$multiplicationMatrix(e,o)),n=this._$graphics._$hit(t,a,i,r),a!==e&&s.$poolFloat32Array6(a)}return n}}class U extends T{constructor(){super()}}class k{constructor(){}static toString(){return"[class SpreadMethod]"}static get namespace(){return"next2d.display.SpreadMethod"}toString(){return"[object SpreadMethod]"}get namespace(){return"next2d.display.SpreadMethod"}static get PAD(){return"pad"}static get REFLECT(){return"reflect"}static get REPEAT(){return"repeat"}}class G extends v{constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=s.$toColorInt(t);const e=this._$player;if(e){const t=s.$uintToRGBA(this._$color);e._$context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=s.$clamp(t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get stageHeight(){return this._$player?this._$player._$height/this._$player._$scale/this._$player._$ratio:0}get stageWidth(){return this._$player?this._$player._$width/this._$player._$scale/this._$player._$ratio:0}invalidate(){this._$invalidate=!0}}class X{constructor(){}static toString(){return"[class StageQuality]"}static get namespace(){return"next2d.display.StageQuality"}toString(){return"[object StageQuality]"}get namespace(){return"next2d.display.StageQuality"}static get HIGH(){return"high"}static get LOW(){return"low"}static get MEDIUM(){return"medium"}}class Y{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0}}class H{constructor(){}static toString(){return"[class BitmapFilterType]"}static get namespace(){return"next2d.filters.BitmapFilterType"}toString(){return"[object BitmapFilterType]"}get namespace(){return"next2d.filters.BitmapFilterType"}static get FULL(){return"full"}static get INNER(){return"inner"}static get OUTER(){return"outer"}}class j{constructor(){}static toString(){return"[class BitmapFilterQuality]"}static get namespace(){return"next2d.filters.BitmapFilterQuality"}toString(){return"[object BitmapFilterQuality]"}get namespace(){return"next2d.filters.BitmapFilterQuality"}static get LOW(){return 1}static get MEDIUM(){return 2}static get HIGH(){return 3}}class V{constructor(){}static toString(){return"[class DisplacementMapFilterMode]"}static get namespace(){return"next2d.filters.DisplacementMapFilterMode"}toString(){return"[object DisplacementMapFilterMode]"}get namespace(){return"next2d.filters.DisplacementMapFilterMode"}static get CLAMP(){return"clamp"}static get COLOR(){return"color"}static get IGNORE(){return"ignore"}static get WRAP(){return"wrap"}}class W extends Y{constructor(t=4,e=4,i=1){super(),this._$blurX=t,this._$blurY=e,this._$quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=s.$clamp(+t,0,255,0))!==this._$blurX&&this._$doChanged(!0),this._$blurX=t}get blurY(){return this._$blurY}set blurY(t){(t=s.$clamp(+t,0,255,0))!==this._$blurY&&this._$doChanged(!0),this._$blurY=t}get quality(){return this._$quality}set quality(t){(t=s.$clamp(0|t,0,15,j.LOW))!==this._$quality&&this._$doChanged(!0),this._$quality=t}clone(){return new W(this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=null,i=null){const r=t.clone();if(!this._$quality)return r;const n=W.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,o=0>=this._$blurY?1:this._$blurY*n;switch(!0){case"number"==typeof e:case"number"==typeof i:a*=e,o*=i;break;default:a=s.$round(a),o=s.$round(o)}return r.x-=a,r.width+=2*a,r.y-=o,r.height+=2*o,r}_$isSame(t){return this._$quality===t._$quality&&(this._$blurX===t._$blurX&&this._$blurY===t._$blurY)}_$canApply(){return!(!this._$quality||!this._$blurX&&!this._$blurY)}_$applyFilter(t,e,i=!0){this._$doChanged(!1);const r=t.frameBuffer.currentAttachment,n=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return i?n:t.frameBuffer.createTextureFromCurrentAttachment();const a=s.$sqrt(e[0]*e[0]+e[1]*e[1]),o=s.$sqrt(e[2]*e[2]+e[3]*e[3]),h=new m(0,0,n.width,n.height),l=this._$generateFilterRect(h,a,o),$=0|s.$ceil(l.width),_=0|s.$ceil(l.height),c=s.$ceil(s.$abs(l.x)+.5*s.$abs($-l.width)),u=s.$ceil(s.$abs(l.y)+.5*s.$abs(_-l.height));t._$offsetX=+(c+t._$offsetX),t._$offsetY=+(u+t._$offsetY);const d=this._$blurX*a,g=this._$blurY*o;let p=1,f=1;d>128?p=.0625:d>64?p=.125:d>32?p=.25:d>16&&(p=.5),g>128?f=.0625:g>64?f=.125:g>32?f=.25:g>16&&(f=.5);const x=d*p,b=g*f;let T=s.$ceil($*p),v=s.$ceil(_*f);const y=t.frameBuffer.createTextureAttachment(T,v),E=[y,t.frameBuffer.createTextureAttachment(T,v)];let A=0;t._$bind(y),s.$resetContext(t),t.setTransform(p,0,0,f,0,0),t.drawImage(n,c,u,n.width,n.height),t.blend.toOneZero();let M=t.frameBuffer.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){A=(A+1)%2;const e=E[A];t._$bind(e),t._$applyBlurFilter(M,!0,x),M=t.frameBuffer.getTextureFromCurrentAttachment()}if(this._$blurY>0){A=(A+1)%2;const e=E[A];t._$bind(e),t._$applyBlurFilter(M,!1,b),M=t.frameBuffer.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==p||1!==f){const e=t.frameBuffer.createTextureAttachment($,_);t._$bind(e),s.$resetContext(t),t.imageSmoothingEnabled=!0,t.setTransform(1/p,0,0,1/f,0,0),t.drawImage(M,0,0,T,v),M=t.frameBuffer.getTextureFromCurrentAttachment(),s.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.frameBuffer.releaseAttachment(E[0],!0),t.frameBuffer.releaseAttachment(E[1],!0),i?t.frameBuffer.releaseAttachment(r,!0):t.frameBuffer.releaseAttachment(e,!1)}else t.frameBuffer.releaseAttachment(E[(A+1)%2],!0),i?t.frameBuffer.releaseAttachment(r,!0):t.frameBuffer.releaseAttachment(E[A],!1);return M}}class z extends Y{constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,o=4,h=1,l=1,$="inner",_=!1){super(),this._$blurFilter=new W(a,o,l),this._$distance=t,this._$angle=e,this._$highlightColor=i,this._$highlightAlpha=s,this._$shadowColor=r,this._$shadowAlpha=n,this._$strength=h,this._$type=$,this._$knockout=_}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=+t)!==this._$distance&&this._$doChanged(!0),this._$distance=t}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=s.$clamp(+t,0,1,0))!==this._$highlightAlpha&&this._$doChanged(!0),this._$highlightAlpha=t}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t|=0)>16777215&&(t%=16777216),(t=s.$toColorInt(t))!==this._$highlightColor&&this._$doChanged(!0),this._$highlightColor=t}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=s.$clamp(+t,0,1,0))!==this._$shadowAlpha&&this._$doChanged(!0),this._$shadowAlpha=t}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t|=0)>16777215&&(t%=16777216),(t=s.$toColorInt(t))!==this._$shadowColor&&this._$doChanged(!0),this._$shadowColor=t}get strength(){return this._$strength}set strength(t){(t=s.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case H.OUTER:case H.INNER:this._$type=t;break;default:this._$type=H.FULL}}clone(){return new z(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=+this.angle*s.$PI/180,a=s.$cos(n)*this.distance,o=s.$sin(n)*this.distance;let h=0|s.$abs(a),l=0|s.$abs(o);return 0>a&&h++,0>o&&l++,0===h&&0>o&&(h=1),0===l&&0>a&&(l=1),r.x-=h,r.width+=2*h,r.y-=l,r.height+=2*l,r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$highlightColor===t._$highlightColor&&(this._$highlightAlpha===t._$highlightAlpha&&(this._$shadowColor===t._$shadowColor&&(this._$shadowAlpha===t._$shadowAlpha&&(this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))))))}_$canApply(){return!(!this._$strength||!this._$distance)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=i.width,a=i.height,o=t._$offsetX,h=t._$offsetY,l=s.$sqrt(e[0]*e[0]+e[1]*e[1]),$=s.$sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*s.$Deg2Rad,c=+s.$cos(_)*this._$distance*l,u=+s.$sin(_)*this._$distance*$;let d=t.frameBuffer.createTextureAttachment(n,a);t._$bind(d),s.$resetContext(t),t.drawImage(r,0,0,n,a),t.globalCompositeOperation=S.ERASE,t.drawImage(r,2*c,2*u,n,a);const g=this._$blurFilter._$applyFilter(t,e,!1),p=g.width,f=g.height,m=s.$ceil(p+2*s.$abs(c)),x=s.$ceil(f+2*s.$abs(u)),b=this._$type===H.INNER,T=b?n:m,v=b?a:x,y=s.$abs(c),E=s.$abs(u),A=(p-n)/2,M=(f-a)/2;let C,R,w,O;return b?(C=0,R=0,w=-A-c,O=-M-u):(C=y+A,R=E+M,w=y-c,O=E-u),t._$bind(i),t._$applyBitmapFilter(g,T,v,n,a,C,R,p,f,w,O,!1,this._$type,this._$knockout,this._$strength,this.blurX,this.blurY,null,null,null,s.$intToR(this._$highlightColor,this._$highlightAlpha,!0),s.$intToG(this._$highlightColor,this._$highlightAlpha,!0),s.$intToB(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,s.$intToR(this._$shadowColor,this._$shadowAlpha,!0),s.$intToG(this._$shadowColor,this._$shadowAlpha,!0),s.$intToB(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=o+C,t._$offsetY=h+R,t.frameBuffer.releaseTexture(g),t.frameBuffer.getTextureFromCurrentAttachment()}}class q extends Y{constructor(t=null){super(),this._$matrix=t||[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this._$doApply=!1}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(!s.$isArray(t)||20!==t.length)return;this._$matrix=t,this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i)if(t[i]!==s.$COLOR_MATRIX_FILTER[i]){this._$doApply=!0;break}}clone(){return new q(this._$matrix)}_$generateFilterRect(t,e=null,i=null){return t}_$isSame(t){const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$doApply}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment(),n=r.width,a=r.height,o=t.frameBuffer.createTextureAttachment(n,a);return t._$bind(o),s.$resetContext(t),t._$applyColorMatrixFilter(r,this._$matrix),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class K extends Y{constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,o=0,h=0){super(),this._$matrixX=t,this._$matrixY=e,this._$matrix=i,this._$divisor=s,this._$bias=r,this._$preserveAlpha=n,this._$clamp=a,this._$color=o,this._$alpha=h}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=s.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get bias(){return this._$bias}set bias(t){(t=+t)!==this._$bias&&this._$doChanged(!0),this._$bias=t}get clamp(){return this._$clamp}set clamp(t){t!==this._$clamp&&this._$doChanged(!0),this._$clamp=t}get color(){return this._$color}set color(t){(t|=0)>16777215&&(t%=16777216),(t=s.$toColorInt(t))!==this._$color&&this._$doChanged(!0),this._$color=t}get divisor(){return this._$divisor}set divisor(t){(t=+t)!==this._$divisor&&this._$doChanged(!0),this._$divisor=t}get matrix(){return this._$matrix}set matrix(t){this._$doChanged(!0),this._$matrix&&s.$poolArray(this._$matrix),this._$matrix=s.$getArray(),s.$isArray(t)&&(this._$matrix=t.slice(0))}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|s.$clamp(0|t,0,15,0))!==this._$matrixX&&this._$doChanged(!0),this._$matrixX=t}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|s.$clamp(0|t,0,15,0))!==this._$matrixY&&this._$doChanged(!0),this._$matrixY=t}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){t!==this._$preserveAlpha&&this._$doChanged(!0),this._$preserveAlpha=t}clone(){return new K(this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t,e=null,i=null){return t}_$isSame(t){if(this._$matrixX!==t._$matrixX)return!1;if(this._$matrixY!==t._$matrixY)return!1;if(this._$divisor!==t._$divisor)return!1;if(this._$bias!==t._$bias)return!1;if(this._$preserveAlpha!==t._$preserveAlpha)return!1;if(this._$clamp!==t._$clamp)return!1;if(this._$color!==t._$color)return!1;if(this._$alpha!==t._$alpha)return!1;const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();return this._$canApply()?(t._$applyConvolutionFilter(r,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,s.$intToR(this._$color,this._$alpha,!1),s.$intToG(this._$color,this._$alpha,!1),s.$intToB(this._$color,this._$alpha,!1),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()):r}}class Q extends Y{constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",o=0,h=0){super(),this._$mapBitmap=t,this._$mapPoint=e,this._$componentX=i,this._$componentY=s,this._$scaleX=r,this._$scaleY=n,this._$mode=a,this._$color=o,this._$alpha=h}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=s.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get color(){return this._$color}set color(t){(t|=0)>16777215&&(t%=16777216),(t=s.$toColorInt(t))!==this._$color&&this._$doChanged(!0),this._$color=t}get componentX(){return this._$componentX}set componentX(t){switch((t|=0)!==this._$componentX&&this._$doChanged(!0),this._$componentX=0,t){case M.ALPHA:case M.BLUE:case M.GREEN:case M.RED:this._$componentX=t}}get componentY(){return this._$componentY}set componentY(t){switch((t|=0)!==this._$componentY&&this._$doChanged(!0),this._$componentX=0,t){case M.ALPHA:case M.BLUE:case M.GREEN:case M.RED:this._$componentY=t}}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&this._$doChanged(!0),this._$mapBitmap=null,t instanceof A&&(this._$mapBitmap=t)}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&this._$doChanged(!0),this._$mapPoint=null,t instanceof f&&(this._$mapPoint=t)}get mode(){return this._$mode}set mode(t){switch((t+="")!==this._$mode&&this._$doChanged(!0),this._$mode=V.WRAP,t){case V.CLAMP:case V.COLOR:case V.IGNORE:this._$mode=t}}get scaleX(){return this._$scaleX}set scaleX(t){(t=s.$clamp(+t,-65535,65535,0))!==this._$scaleX&&this._$doChanged(!0),this._$scaleX=t}get scaleY(){return this._$scaleY}set scaleY(t){(t=s.$clamp(+t,-65535,65535,0))!==this._$scaleY&&this._$doChanged(!0),this._$scaleY=t}clone(){return new Q(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t,e=null,i=null){return t}_$isSame(t){return this._$mapBitmap===t._$mapBitmap&&(this._$mapPoint.x===t._$mapPoint.x&&(this._$mapPoint.y===t._$mapPoint.y&&(this._$componentX===t._$componentX&&(this._$componentY===t._$componentY&&(this._$scaleX===t._$scaleX&&(this._$scaleY===t._$scaleY&&(this._$mode===t._$mode&&(this._$color===t._$color&&this._$alpha===t._$alpha))))))))}_$canApply(){return!(null===this._$mapBitmap||!this._$componentX&&!this._$componentY||!this._$scaleX&&!this._$scaleY)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=s.$sqrt(e[0]*e[0]+e[1]*e[1]),a=s.$sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(r,this._$mapBitmap._$texture,r.width/n,r.height/a,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,s.$intToR(this._$color,this._$alpha,!0),s.$intToG(this._$color,this._$alpha,!0),s.$intToB(this._$color,this._$alpha,!0),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class J extends Y{constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,o=1,h=!1,l=!1,$=!1){super(),this._$blurFilter=new W(r,n,o),this._$distance=t,this._$angle=e,this._$color=i,this._$alpha=s,this._$strength=a,this._$inner=h,this._$knockout=l,this._$hideObject=$}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=s.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t|=0)>16777215&&(t%=16777216),this._$color=s.$toColorInt(t)}get distance(){return this._$distance}set distance(t){(t=+t)!==this._$distance&&this._$doChanged(!0),this._$distance=t}get hideObject(){return this._$hideObject}set hideObject(t){t!==this._$hideObject&&this._$doChanged(!0),this._$hideObject=t}get inner(){return this._$inner}set inner(t){t!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=s.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new J(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=+this._$angle*s.$Deg2Rad,a=+s.$cos(n)*this._$distance,o=+s.$sin(n)*this._$distance;let h=0,l=0,$=0,_=0;switch(a<0){case!0:h=0|s.$floor(a),$=0|-s.$round(a/2);break;default:h=0|s.$round(a/2),$=a/2|0}switch(o<0){case!0:l=0|s.$floor(o),_=0|-s.$round(o/2);break;default:l=0|s.$round(o/2),_=o/2|0}return r.x+=h,r.width+=$,r.y+=l,r.height+=_,r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&(this._$hideObject===t._$hideObject&&this._$blurFilter._$isSame(t._$blurFilter))))))))}_$canApply(){return!(!this._$alpha||!this._$strength)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,$=h.height,_=t._$offsetX,c=t._$offsetY,u=_-a,d=c-o,g=+this._$angle*s.$Deg2Rad,p=+s.$cos(g)*this._$distance*s.$devicePixelRatio,f=+s.$sin(g)*this._$distance*s.$devicePixelRatio,m=this._$inner?r:l+s.$max(0,s.$abs(p)-u),x=this._$inner?n:$+s.$max(0,s.$abs(f)-d),b=s.$ceil(m),T=s.$ceil(x),v=(b-m)/2,y=(T-x)/2;let E,A,M,S,C,R;return this._$inner?(E=0,A=0,M=p-_,S=f-c):(E=s.$max(0,u-p)+v,A=s.$max(0,d-f)+y,M=(p>0?s.$max(0,p-u):0)+v,S=(f>0?s.$max(0,f-d):0)+y),this._$inner?(C=H.INNER,R=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(C=H.FULL,R=!0):(C=H.OUTER,R=this._$knockout),t._$bind(i),t._$applyBitmapFilter(h,b,T,r,n,E,A,l,$,M,S,!0,C,R,this._$strength,this.blurX,this.blurY,null,null,null,s.$intToR(this._$color,this._$alpha,!0),s.$intToG(this._$color,this._$alpha,!0),s.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+E,t._$offsetY=o+A,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class Z extends Y{constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,o=!1){super(),this._$blurFilter=new W(i,s,n),this._$color=t,this._$alpha=e,this._$strength=r,this._$inner=a,this._$knockout=o}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=s.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t|=0)>16777215&&(t%=16777216),this._$color=s.$toColorInt(t)}get inner(){return this._$inner}set inner(t){t!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=s.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new Z(this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){const s=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$isSame(t){return this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))}_$canApply(){return!(!this._$alpha||!this._$strength)&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,$=h.height,_=t._$offsetX,c=t._$offsetY,u=this._$inner?r:l,d=this._$inner?n:$;let g,p,f,m;this._$inner?(g=0,p=0,f=-_,m=-c):(g=_-a,p=c-o,f=0,m=0);const x=this._$inner?H.INNER:H.OUTER;return t._$bind(i),t._$applyBitmapFilter(h,u,d,r,n,g,p,l,$,f,m,!0,x,this._$knockout,this._$strength,this.blurX,this.blurY,null,null,null,s.$intToR(this._$color,this._$alpha,!0),s.$intToG(this._$color,this._$alpha,!0),s.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=o+p,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class tt extends Y{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new W(n,a,h),this._$distance=t,this._$angle=e,this._$colors=i,this._$alphas=s,this._$ratios=r,this._$strength=o,this._$type=l,this._$knockout=$}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,s.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=s.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,s.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-s.$abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=s.$toColorInt(s.$abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=+t)!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,s.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=s.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=s.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case H.OUTER:case H.INNER:this._$type=t;break;default:this._$type=H.FULL}}clone(){return new tt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r);const n=+this.angle*s.$PI/180,a=s.$cos(n)*this._$distance,o=s.$sin(n)*this._$distance;let h=0|s.$abs(a),l=0|s.$abs(o);return 0>a&&h++,0>o&&l++,0===h&&0>o&&(h=1),0===l&&0>a&&(l=1),r.x-=h,r.width+=2*h,r.y-=l,r.height+=2*l,r}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$canApply(){return!!(0!==this._$strength&&0!==this._$distance&&this._$alphas&&this._$ratios&&this._$colors)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=i.width,a=i.height,o=t._$offsetX,h=t._$offsetY,l=s.$sqrt(e[0]*e[0]+e[1]*e[1]),$=s.$sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*s.$Deg2Rad,c=+s.$cos(_)*this._$distance*l,u=+s.$sin(_)*this._$distance*$;let d=t.frameBuffer.createTextureAttachment(n,a);t._$bind(d),s.$resetContext(t),t.drawImage(r,0,0,n,a),t.globalCompositeOperation=S.ERASE,t.drawImage(r,2*c,2*u,n,a);const g=this._$blurFilter._$applyFilter(t,e,!1),p=g.width,f=g.height,m=s.$ceil(p+2*s.$abs(c)),x=s.$ceil(f+2*s.$abs(u)),b=this._$type===H.INNER,T=b?n:m,v=b?a:x,y=s.$abs(c),E=s.$abs(u),A=(p-n)/2,M=(f-a)/2;let C,R,w,O;return b?(C=0,R=0,w=-A-c,O=-M-u):(C=y+A,R=E+M,w=y-c,O=E-u),t._$bind(i),t._$applyBitmapFilter(g,T,v,n,a,C,R,p,f,w,O,!1,this._$type,this._$knockout,this._$strength,this.blurX,this.blurY,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=o+C,t._$offsetY=h+R,t.frameBuffer.releaseTexture(g),t.frameBuffer.getTextureFromCurrentAttachment()}}class et extends Y{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new W(n,a,h),this._$distance=t,this._$angle=e,this._$colors=i,this._$alphas=s,this._$ratios=r,this._$strength=o,this._$type=l,this._$knockout=$}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,s.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=s.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,s.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-s.$abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=s.$toColorInt(s.$abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=+t)!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,s.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=s.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=s.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case H.OUTER:case H.INNER:this._$type=t;break;default:this._$type=H.FULL}}clone(){return new et(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=+this.angle*s.$PI/180,a=+s.$cos(n)*this.distance,o=+s.$sin(n)*this.distance;let h=0,l=0,$=0,_=0;switch(a<0){case!0:h=0|s.$floor(a),$=0|-s.$round(a/2);break;default:h=0|s.$round(a/2),$=a/2|0}switch(o<0){case!0:l=0|s.$floor(o),_=0|-s.$round(o/2);break;default:l=0|s.$round(o/2),_=o/2|0}return r.x+=h,r.width+=$,r.y+=l,r.height+=_,r}_$canApply(){return!!(0!==this._$strength&&this._$alphas&&this._$ratios&&this._$colors)}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,$=h.height,_=t._$offsetX,c=t._$offsetY,u=_-a,d=c-o,g=s.$sqrt(e[0]*e[0]+e[1]*e[1]),p=s.$sqrt(e[2]*e[2]+e[3]*e[3]),f=+this._$angle*s.$Deg2Rad,m=+s.$cos(f)*this._$distance*g,x=+s.$sin(f)*this._$distance*p,b=this.type===H.INNER,T=b?r:l+s.$max(0,s.$abs(m)-u),v=b?n:$+s.$max(0,s.$abs(x)-d),y=s.$ceil(T),E=s.$ceil(v),A=(y-T)/2,M=(E-v)/2;let S,C,R,w;return b?(S=0,C=0,R=m-_,w=x-c):(S=s.$max(0,u-m)+A,C=s.$max(0,d-x)+M,R=(m>0?s.$max(0,m-u):0)+A,w=(x>0?s.$max(0,x-d):0)+M),t._$bind(i),t._$applyBitmapFilter(h,y,E,r,n,S,C,l,$,R,w,!0,this.type,this.knockout,this._$strength,this.blurX,this.blurY,this.ratios,this.colors,this.alphas,0,0,0,0,0,0,0,0),t._$offsetX=a+S,t._$offsetY=o+C,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class it{constructor(){}static toString(){return"[class TextFormatAlign]"}static get namespace(){return"next2d.text.TextFormatAlign"}toString(){return"[object TextFormatAlign]"}get namespace(){return"next2d.text.TextFormatAlign"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get RIGHT(){return"right"}}class st{constructor(){}static toString(){return"[class TextFieldAutoSize]"}static get namespace(){return"next2d.text.TextFieldAutoSize"}toString(){return"[object TextFieldAutoSize]"}get namespace(){return"next2d.text.TextFieldAutoSize"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get NONE(){return"none"}static get RIGHT(){return"right"}}class rt extends T{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$selectable=!0,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0,this._$textColor=null;const t=new at;t._$setDefault(this),this._$defaultTextFormat=t,this._$decisionTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict=null,this._$isHTML=!1,this._$textData=null,this._$renew=!0,this._$textHeight=null,this._$textWidth=null,this._$widthTable=null,this._$textarea=null,this._$autoSize=st.NONE,this._$textAppending=!1,this._$heightTable=null,this._$textFormatTable=[],this._$textAreaActive=!1,this._$totalWidth=null,this._$objectTable=null,this._$imageData=null,this._$type=nt.STATIC,this._$textHeightTable=null,this._$actTotalWidth=null}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}static get TEXT(){return"text"}static get BREAK(){return"break"}static get WRAP(){return"wrap"}static get IMAGE(){return"image"}get autoSize(){return this._$autoSize}set autoSize(t){switch(t){case st.CENTER:case st.LEFT:case st.RIGHT:this._$autoSize=t;break;default:this._$autoSize=st.NONE}this._$reload()}get background(){return this._$background}set background(t){this._$background=t,this._$reset()}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){this._$backgroundColor=0|t,this._$reset()}get border(){return this._$border}set border(t){this._$border=t,this._$reset()}get borderColor(){return this._$borderColor}set borderColor(t){this._$borderColor=0|t,this._$reset()}get defaultTextFormat(){return this._$defaultTextFormat}set defaultTextFormat(t){t instanceof at&&(t._$merge(this._$defaultTextFormat),t._$textField=this,this._$defaultTextFormat=t)}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=t,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable=[],this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1,this._$getTextData();const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=2*this._$textHeightTable[t-1],s=0;for(;t>s&&(i+=this._$textHeightTable[s],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){this._$multiline=t,this._$reset()}get numLines(){return null===this._$textData&&this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=t}get scrollH(){return this._$scrollH}set scrollH(t){t=s.$clamp(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger(a.SCROLL)&&this.dispatchEvent(new a(a.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){t=s.$clamp(0|t,1,this.maxScrollV),this._$scrollV!==t&&(this._$scrollV=t,this._$reset(),this.willTrigger(a.SCROLL)&&this.dispatchEvent(new a(a.SCROLL,!0)))}get selectable(){return this._$selectable}set selectable(t){this._$selectable=t}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData(),i=0|e.length;for(let s=1;s<i;++s){const i=e[s];switch(i.mode){case rt.TEXT:t+=i.text;break;case rt.BREAK:t+="\r"}}return!this._$isHTML&&this._$initText&&(t+="\r"),this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$cacheText="",this._$isHTML=!1,this._$textAppending||(this._$textFormatTable=[]),this._$reload())}get textColor(){return this._$defaultTextFormat.color}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();let t=0|this._$decisionTextFormat._$leading;const e=this._$textHeightTable.length;1===e&&(this._$textHeight+=t);for(let t=0;t<e;++t)this._$textHeight+=this._$textHeightTable[t]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=s.$max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap=t}get width(){return super.width}set width(t){const e=this._$getBounds(null),i=s.$abs(e.xMin);this._$originBounds.xMax=t+i,this._$originBounds.xMin=i,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}get height(){return super.height}set height(t){const e=this._$getBounds(null),i=s.$abs(e.yMin);this._$originBounds.yMax=t+i,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin/20}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this._$textAppending=!0,this.text=e+`${t}`,this._$textAppending=!1}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),s=e>-1?e:i.length;let r=!1,n=new at,a=t>-1?t:0;for(;a<s;++a){if(i[a].mode===rt.BREAK)continue;const t=i[a].textFormat;r?(n._$align=n._$align!==t._$align?null:t._$align,n._$blockIndent=n._$blockIndent!==t._$blockIndent?null:t._$blockIndent,n._$bold=n._$bold!==t._$bold?null:t._$bold,n._$color=n._$color!==t._$color?null:t._$color,n._$font=n._$font!==t._$font?null:t._$font,n._$indent=n._$indent!==t._$indent?null:t._$indent,n._$italic=n._$italic!==t._$italic?null:t._$italic,n._$leading=n._$leading!==t._$leading?null:t._$leading,n._$leftMargin=n._$leftMargin!==t._$leftMargin?null:t._$leftMargin,n._$letterSpacing=n._$letterSpacing!==t._$letterSpacing?null:t._$letterSpacing,n._$rightMargin=n._$rightMargin!==t._$rightMargin?null:t._$rightMargin,n._$size=n._$size!==t._$size?null:t._$size,n._$underline=n._$underline!==t._$underline?null:t._$underline):(r=!0,n=t._$clone())}return n}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const s=this.text;t>=s.length?e>=s.length&&e>=t&&(this.text=s+`${i}`):this.text=s.substr(0,t)+`${i}`+s.substr(e,s.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const s=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:{const e=s.length;for(let i=0;i<e;++i)this._$textFormatTable[i]=t._$clone()}break;case e>-1&&-1===i:{let i=e+1,r=s[i];r.mode===rt.WRAP&&(r=s[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let r=0;for(let n=e;n<i;++n){const e=s[n];e&&(e.mode!==rt.WRAP&&e.mode!==rt.BREAK?this._$textFormatTable[n+r]=t._$clone():(++i,--r))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(null===this._$textData){this._$textData=[],this._$imageData=[],this._$heightTable=[],this._$textHeightTable=[],this._$objectTable=[],this._$widthTable=[];let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),s.$P_TAG.innerHTML!==e&&(s.$P_TAG.textContent="",s.$P_TAG.insertAdjacentHTML("afterbegin",e)),this._$totalWidth=0,this._$actTotalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=0,this._$widthTable[0]=0;let r=this._$decisionTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(r),r=t}const n={mode:rt.BREAK,x:0,yIndex:0,textFormat:r._$clone()};this._$objectTable[0]=n,this._$textData[0]=n,this._$parseTag(s.$P_TAG,r._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")],i=e.length;for(let s=0;s<i;++s){this._$totalWidth=0,this._$actTotalWidth=0;let i=this.defaultTextFormat;const r=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[r]=0,this._$textHeightTable[r]=0,this._$widthTable[r]=0,r&&(this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(i),i=t}const n={mode:rt.BREAK,x:0,yIndex:r,textFormat:i._$clone()};i=this.defaultTextFormat,this._$objectTable[r]=n,this._$textData[this._$textData.length]=n;const a=e[s];a&&(t=this._$parseText(a,i,t))}}}return this._$textData}_$parseTag(t,e,i){const r=t.childNodes,n=r.length;for(let t=0;t<n;++t){let n=e._$clone();const a=r[t];if(3!==a.nodeType)switch(a.nodeName){case"P":{if(a.hasAttribute("align")&&(n._$align=a.getAttribute("align").toLowerCase()),this._$parseTag(a,n,i),!this._$multiline)break;const t=this._$getImageOffsetX();this._$totalWidth=t,this._$actTotalWidth=t;const e=this._$heightTable.length;if(this._$heightTable[e]=0,this._$textHeightTable[e]=0,this._$widthTable[e]=0,e&&(this._$heightTable[e]=this._$heightTable[e-1],this._$textHeightTable[e]=this._$textHeightTable[e-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(n),n=t}const s={mode:rt.BREAK,x:0,yIndex:e,textFormat:n};this._$objectTable[e]=s,this._$textData[this._$textData.length]=s}break;case"B":n._$bold=!0,this._$parseTag(a,n,i);break;case"I":n._$italic=!0,this._$parseTag(a,n,i);break;case"U":n._$underline=!0,this._$parseTag(a,n,i);break;case"FONT":a.hasAttribute("face")&&(n._$font=a.getAttribute("face")),a.hasAttribute("size")&&(n._$size=0|a.getAttribute("size")),a.hasAttribute("color")&&(n._$color=s.$toColorInt(a.getAttribute("color"))),a.hasAttribute("letterSpacing")&&(n.letterSpacing=0|a.getAttribute("letterSpacing")),this._$parseTag(a,n,i);break;case"TEXTFORMAT":a.hasAttribute("blockindent")&&(n._$blockIndent=0|a.getAttribute("blockindent")),a.hasAttribute("indent")&&(n._$indent=0|a.getAttribute("indent")),a.hasAttribute("leading")&&(n._$leading=0|a.getAttribute("leading")),a.hasAttribute("leftmargin")&&(n._$leftMargin=0|a.getAttribute("leftmargin")),a.hasAttribute("rightmargin")&&(n._$rightMargin=0|a.getAttribute("rightmargin")),this._$parseTag(a,n,i);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0;const e=this._$getImageOffsetX();this._$totalWidth=e,this._$actTotalWidth=e,n._$indent=0;const i={mode:rt.BREAK,x:0,yIndex:t,textFormat:n};this._$objectTable[t]=i,this._$textData[this._$textData.length]=i}break;case"IMG":{const t=a.getAttribute("src")||"",e=a.getAttribute("width")||0,i=a.getAttribute("height")||0,r=a.getAttribute("vspace")||0,o=a.getAttribute("hspace")||0;let h=0;for(let t=0;t<this._$textHeightTable.length;t++)h+=this._$textHeightTable[t];const l={mode:rt.IMAGE,src:t,loaded:!1,x:0,y:h,width:e,height:i,hspace:o,vspace:r,textFormat:n};if(this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],e=t.y+t.height+2*t.vspace;l.y=s.$max(h,e)}this._$textData[this._$textData.length]=l,this._$imageData[this._$imageData.length]=l,this._$loadImage(l)}break;default:this._$parseTag(a,n,i)}else i=this._$parseText(a.nodeValue,n)}}_$parseText(t,e,i){let r=this._$heightTable.length-1|0,n=e._$clone(),a=s.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0;const o=s.$currentPlayer();if(o){const t=o._$scale*o._$ratio;a=s.$getFloat32Array6(t,0,0,t,0,0)}const h=s.$multiplicationMatrix(this._$transform.concatenatedMatrix()._$matrix,a),l=(this._$originBounds.xMax-this._$originBounds.xMin)*(h[0]/h[3]);s.$poolFloat32Array6(a),s.$poolFloat32Array6(h);const $=l-n._$widthMargin()-4;for(let a=0;a<t.length;++a){if(n=e._$clone(),this._$textData.length+i in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+i]._$clone();t._$merge(n),n=t}const o={mode:rt.TEXT,text:t[a],x:0,width:0,fontScale:0,yIndex:r,textFormat:n};let h=null;this._$multiline&&(h="\n"===o.text||"\r"===o.text||"\n\r"===o.text);let l=r?n._$leading:0,_=0,c=0,u=0,d=0,g=null;if(s.$textContext.font=n._$generateFontStyle(),c=s.$textContext.measureText(o.text).width+n._$letterSpacing,_=c,u=this._$getTextHeight(n),d=u+l,o.height=u,h||this._$wordWrap&&this._$actTotalWidth+_>$){this._$widthTable[++r]=0,o.yIndex=r,this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1];const t=this._$getImageOffsetX();this._$totalWidth=t,this._$actTotalWidth=t,n=n._$clone(),n._$indent=0;g={mode:h?rt.BREAK:rt.WRAP,x:0,yIndex:r,textFormat:n},this._$objectTable[r]=g,h||--i;let e=o.text,a=0,$=!0;const _=/[0-9a-zA-Z?!;:.,]/g;for(;e.match(_);){++a;const t=this._$textData[this._$textData.length-a];if(t.mode!==rt.TEXT){$=!1;break}e=t.text}if(a>1&&this._$textData[this._$textData.length-a+1].text.match(/[0-9a-zA-Z]/g)&&--a,a>0&&$){const t=this._$textData.length-a;this._$textData.splice(t,0,g);let e=1,i=this._$textData[t-e];for(this._$widthTable[r-1]=0,this._$heightTable[r-1]=0,this._$textHeightTable[r-1]=0;i.mode===rt.TEXT;)u=this._$getTextHeight(i.textFormat),d=u+l,this._$widthTable[r-1]+=i.width,this._$heightTable[r-1]=s.$max(this._$heightTable[r-1],u),this._$textHeightTable[r-1]=s.$max(this._$textHeightTable[r-1],d),++e,i=this._$textData[t-e];for(e=1;this._$textData.length>t+e;)i=this._$textData[t+e],++e,u=this._$getTextHeight(i.textFormat),d=u+l,this._$heightTable[r]=s.$max(this._$heightTable[r],u),this._$textHeightTable[r]=s.$max(this._$textHeightTable[r],d),i.x=this._$totalWidth,i.yIndex=r,this._$totalWidth+=i.width,this._$actTotalWidth+=i.width}else this._$textData[this._$textData.length]=g}h||(o.width=c,o.x=this._$totalWidth,this._$totalWidth=this._$totalWidth+c,this._$actTotalWidth+=_,this._$widthTable[r]=s.$max(this._$widthTable[r],this._$actTotalWidth),this._$heightTable[r]=s.$max(this._$heightTable[r],u),this._$textHeightTable[r]=s.$max(this._$textHeightTable[r],d),this._$textData[this._$textData.length]=o)}return i}_$getTextHeight(t){if(!s.$DIV){const t=s.$document.createElement("div");t.innerHTML="a",t.style.position="absolute",t.style.top="-9999px",t.style.left="-9999px",t.style.padding="0",t.style.margin="0",t.style.padding="0",t.style.border="0",t.style.outline="0",t.style.verticalAlign="bottom",t.style.lineHeight="100%",s.$DIV=t,s.$document.body.appendChild(s.$DIV)}const e=s.$DIV.style;return e.fontSize=`${t._$size}px`,e.fontFamily=t._$font,e.fontWeight=t._$bold?"bold":"normal",s.$DIV.clientHeight}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],s=i.height+2*i.vspace;if(i.y<=t&&t<i.y+s)return i.width+2*i.hspace}return 0}_$reset(){this._$renew=!0,this._$textData=null,this._$imageData=null,this._$textHeight=null,this._$textWidth=null,this._$heightTable=null,this._$textHeightTable=null,this._$widthTable=null,this._$objectTable=null,this._$totalWidth=null,this._$actTotalWidth=null,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),s.$isUpdated=!0,s.$cacheStore().removeCache(this._$instanceId)}_$reload(){this._$reset(),this._$getTextData(),this._$resize()}_$resize(){if(this._$autoSize!==st.NONE){const t=this._$defaultTextFormat,e=this.textWidth+2+t._$leftMargin+t._$rightMargin;if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case st.LEFT:case st.CENTER:this._$bounds.xMax=e+this._$bounds.xMin;break;case st.RIGHT:this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],r=t.textFormat,n=r._$blockIndent+r._$leftMargin>0?r._$blockIndent+r._$leftMargin:0;switch(!0){case!1===this._$wordWrap&&i>e:return s.$max(0,n);case r._$align===it.CENTER:case this._$autoSize===st.CENTER:return s.$max(0,e/2-n-r._$rightMargin-i/2);case r._$align===it.RIGHT:case this._$autoSize===st.RIGHT:return s.$max(0,e-n-i-r._$rightMargin);default:return s.$max(0,n+2)}}_$getBounds(t=null){if(t){const e=s.$multiplicationMatrix(t,this._$correctMatrix(this._$transform._$rawMatrix()));return s.$boundsMatrix(this._$bounds,e)}return s.$boundsMatrix(this._$bounds,this._$correctMatrix(s.$MATRIX_ARRAY_IDENTITY))}_$correctMatrix(t){switch(this._$autoSize){case st.CENTER:{const e=this.textWidth+4,i=(this._$originBounds.xMax-this._$originBounds.xMin)/2-e/2;return s.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}case st.RIGHT:{const e=this.textWidth+4,i=this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin);return s.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}default:return t}}_$build(t,e){const i=super._$build(t,e),s=this.defaultTextFormat;switch(s.font=i.font,s.size=i.size,s.align=i.align,s.color=i.color,s.leading=i.leading,s.letterSpacing=i.letterSpacing,s.leftMargin=i.leftMargin,s.rightMargin=i.rightMargin,i.fontType){case 1:s.bold=!0;break;case 2:s.italic=!0;break;case 3:s.bold=!0,s.italic=!0}this._$type=i.inputType,this._$multiline=i.multiline,this._$wordWrap=i.wordWrap,this._$border=i.border,this._$bounds=i.bounds,this._$originBounds=i.bounds,this.text=i.text}_$clip(t,e){const i=this._$getBounds(),r=i.xMax,n=i.xMin,a=i.yMax,o=i.yMin;s.$poolBoundsObject(i);let h=s.$ceil(s.$abs(r-n)),l=s.$ceil(s.$abs(a-o));if(!h||!l)return;let $=e;const _=this._$transform._$rawMatrix();_!==s.$MATRIX_ARRAY_IDENTITY&&($=s.$multiplicationMatrix(e,_)),s.$resetContext(t),t.setTransform($[0],$[1],$[2],$[3],$[4],$[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(h,0),t.lineTo(h,l),t.lineTo(0,l),t.lineTo(0,0),t.clip(!0),$!==e&&s.$poolFloat32Array6($)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let r=i;const n=this._$transform._$rawColorTransform();n!==s.$COLOR_ARRAY_IDENTITY&&(r=s.$multiplicationColor(i,n));const a=s.$clamp(r[3]+r[7]/255,0,1);if(!a)return;let o=e;const h=this._$transform._$rawMatrix();h!==s.$MATRIX_ARRAY_IDENTITY&&(o=s.$multiplicationMatrix(e,h));const l=this._$getBounds(null),$=s.$boundsMatrix(l,o),_=+$.xMax,c=+$.xMin,u=+$.yMax,d=+$.yMin;s.$poolBoundsObject($),s.$poolBoundsObject(l);const g=s.$ceil(s.$abs(_-c)),p=s.$ceil(s.$abs(u-d));if(!g||!p)return;if(0>c+g||0>d+p)return;const f=t.frameBuffer.currentAttachment;if(c>f.width||d>f.height)return;const m=+s.$sqrt(o[0]*o[0]+o[1]*o[1]),x=+s.$sqrt(o[2]*o[2]+o[3]*o[3]),b=s.$getArray();b[0]=m,b[1]=x;const T=s.$cacheStore(),v=T.generateKeys(this._$instanceId,b,r);let y=T.get(v);if(y&&(this._$renew||this._$isUpdated())&&(T.set(v,null),T.destroy(y),y=null),!y){this._$renew=!1,r[3]=1;const i=T.getCanvas();i.width=g,i.height=p;const n=i.getContext("2d");if(this._$background||this._$border){if(n.beginPath(),n.setTransform(1,0,0,1,0,0),n.rotate(s.$atan2(e[1],e[0])),n.moveTo(0,0),n.lineTo(g,0),n.lineTo(g,p),n.lineTo(0,p),n.lineTo(0,0),this._$background){const t=s.$generateColorTransform(s.$intToRGBA(this._$backgroundColor),r);n.fillStyle=`rgba(${t.R},${t.G},${t.B},${t.A})`,n.fill()}if(this._$border){const t=s.$generateColorTransform(s.$intToRGBA(this._$borderColor),r);n.lineWidth=1,n.strokeStyle=`rgba(${t.R},${t.G},${t.B},${t.A})`,n.stroke()}}n.save(),n.beginPath(),n.setTransform(1,0,0,1,0,0),n.rotate(s.$atan2(e[1],e[0])),n.moveTo(2,2),n.lineTo(g-2,2),n.lineTo(g-2,p-2),n.lineTo(2,p-2),n.lineTo(2,2),n.clip(),n.beginPath(),n.setTransform(e[0],e[1],e[2],e[3],0,0),this._$doDraw(n,e,r,!1,g/e[0]),n.restore(),y=t.frameBuffer.createTextureFromCanvas(n.canvas),T.set(v,y),T.destroy(n)}s.$poolArray(v),s.$poolArray(b);let E=!1,A=0,M=0;const S=this._$filters||this.filters;if(S&&S.length){const r=this._$canApply(S);if(r){E=!0;const n=[this._$instanceId,"f"];let a=s.$cacheStore().get(n);const o=this._$isFilterUpdated(g,p,e,i,S,r);a&&!o||(a&&(s.$cacheStore().set(n,null),a.layerWidth=0,a.layerHeight=0,a._$offsetX=0,a._$offsetY=0,a.matrix=null,a.colorTransform=null,t.frameBuffer.releaseTexture(a),a=null),y=this._$getFilterTexture(t,S,y,e,i),s.$cacheStore().set(n,y)),a&&(y=a),s.$poolArray(n),A=y._$offsetX,M=y._$offsetY}}s.$resetContext(t),t._$globalAlpha=a,t._$globalCompositeOperation=this._$blendMode||this.blendMode,t.setTransform(1,0,0,1,0,0),E?t.drawImage(y,c-A,d-M,y.width,y.height,r):t.drawImage(y,c,d,g,p,r)}_$doDraw(t,e,i,r,n){const a=this._$getTextData(),o=r?0:this.width,h=r?0:this.height;let l=0,$=0,_=0;const c=a.length;for(let u=0;u<c;++u){let c=a[u];if(0===c.width)continue;const d=l+c.x;if(!r&&this._$autoSize===st.NONE&&($>h||d>o))continue;let g=c.textFormat;if(!r){const e=s.$generateColorTransform(s.$intToRGBA(c.textFormat._$color),i);t.fillStyle=`rgba(${e.R},${e.G},${e.B},${e.A})`}const p=0|c.yIndex;switch(c.mode){case rt.BREAK:case rt.WRAP:if(_++,this.scrollV>_)continue;if($+=this._$textHeightTable[p],$+=2*e[3],l=this._$getAlignOffset(this._$objectTable[p],n),g._$underline){const r=c.textFormat._$size/12,n=s.$generateColorTransform(s.$intToRGBA(g._$color),i);t.lineWidth=s.$max(1,1/s.$min(e[0],e[3])),t.strokeStyle=`rgba(${n.R},${n.G},${n.B},${n.A})`,t.beginPath(),t.moveTo(l,$-r),t.lineTo(l+this._$widthTable[p],$-r),t.stroke()}break;case rt.TEXT:if(this.scrollV>_)continue;t.beginPath(),t.textBaseline="top",t.font=g._$generateFontStyle(),t.fillText(c.text,d,$-this._$heightTable[0]);break;case rt.IMAGE:if(!c.loaded)continue;t.beginPath(),t.drawImage(c.image,c.x,c.y,c.width,c.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,r=!1){let n=e;const a=this._$transform._$rawMatrix();a!==s.$MATRIX_ARRAY_IDENTITY&&(n=s.$multiplicationMatrix(e,a));const o=this._$getBounds(null),h=s.$boundsMatrix(o,n),l=+h.xMax,$=+h.xMin,_=+h.yMax,c=+h.yMin;s.$poolBoundsObject(h),s.$poolBoundsObject(o);const u=s.$ceil(s.$abs(l-$)),d=s.$ceil(s.$abs(_-c));return t.setTransform(1,0,0,1,$,c),t.beginPath(),t.moveTo(0,0),t.lineTo(u,0),t.lineTo(u,d),t.lineTo(0,d),t.lineTo(0,0),n!==e&&s.$poolFloat32Array6(n),t.isPointInPath(i.x,i.y)}}class nt{constructor(){}static toString(){return"[class TextFieldType]"}static get namespace(){return"next2d.text.TextFieldType"}toString(){return"[object TextFieldType]"}get namespace(){return"next2d.text.TextFieldType"}static get DYNAMIC(){return"dynamic"}static get STATIC(){return"static"}}class at{constructor(t=null,e=null,i=null,s=null,r=null,n=null,a=null,o=null,h=null,l=null,$=null,_=null){this._$font=t,this._$size=e,this._$color=i,this._$bold=s,this._$italic=r,this._$underline=n,this._$align=a,this._$leftMargin=o,this._$rightMargin=h,this._$indent=l,this._$leading=$,this._$blockIndent=_,this._$letterSpacing=0,this._$textField=null}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){switch(this._$align=null,t){case it.CENTER:case it.RIGHT:case it.LEFT:this._$align=t}this._$textField&&(this._$textField._$renew=!0)}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t,this._$textField&&(this._$textField._$renew=!0)}get bold(){return this._$bold}set bold(t){this._$bold=t,this._$textField&&(this._$textField._$renew=!0)}get color(){return this._$color}set color(t){this._$color=s.$clamp(t,0,4294967295,0),this._$textField&&(this._$textField._$renew=!0)}get font(){return this._$font}set font(t){this._$font=t,this._$textField&&(this._$textField._$renew=!0)}get indent(){return this._$indent}set indent(t){this._$indent=t,this._$textField&&(this._$textField._$renew=!0)}get italic(){return this._$italic}set italic(t){this._$italic=t,this._$textField&&(this._$textField._$renew=!0)}get leading(){return this._$leading}set leading(t){this._$leading=t,this._$textField&&(this._$textField._$renew=!0)}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t,this._$textField&&(this._$textField._$renew=!0)}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t,this._$textField&&(this._$textField._$renew=!0)}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t,this._$textField&&(this._$textField._$renew=!0)}get size(){return this._$size}set size(t){this._$size=t,this._$textField&&(this._$textField._$renew=!0)}get underline(){return this._$underline}set underline(t){this._$underline=t,this._$textField&&(this._$textField._$renew=!0)}_$clone(){const t=new at(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t._$textField=this._$textField,t}_$setDefault(t=null){this._$align=it.LEFT,this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="sans-serif",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1,this._$textField=t}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t.color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){return this._$indent+this._$leftMargin+this._$rightMargin}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','system-ui','sans-serif'`}}class ot extends o{constructor(t=null){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$buffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=s.$getArray(),this._$volume=1,this._$loop=!1}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=s.$min(ht.volume,s.$clamp(t,0,1,1));const e=this._$sources.length;if(e&&s.$audioContext)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume}}clone(){const t=new ot;return t.volume=this.volume,t.loop=this.loop,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){s.$ajax({format:_t.ARRAY_BUFFER,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(a.OPEN)&&this.dispatchEvent(new a(a.OPEN)),this.willTrigger(u.PROGRESS)&&this.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(u.PROGRESS)&&this.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(u.PROGRESS)&&this.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total)),199<t.target.status&&400>t.target.status?(this._$buffer=new Uint8Array(t.target.response),s.$audioContext?s.$decodeAudioData(this):s.$audios.push(this),s.$currentPlayer()._$loaders.push(this)):this.willTrigger(_.IO_ERROR)&&this.dispatchEvent(new _(_.IO_ERROR,!1,!1,t.target.statusText,t.target.status))}.bind(this)}})}play(t=0,e=!1){const i=this._$character?this._$character.audioBuffer:this._$audioBuffer;switch(!0){case null===s.$audioContext:case null===i:const r=function(t,e=0,i=!1){if(null!==(this._$character?this._$character.audioBuffer:this._$audioBuffer)&&null!==s.$audioContext){const r=(s.$performance.now()-t)/1e3;return void this._$createBufferSource(e,i,r)}(0,s.$requestAnimationFrame)(r)}.bind(this,s.$performance.now(),t,e);(0,s.$requestAnimationFrame)(r);break;default:this._$createBufferSource(t,e)}}stop(){const t=this._$sources.length;if(t){if(s.$audioContext){const e=s.$currentPlayer();for(let i=0;i<t;++i){const t=this._$sources[i];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect(),e._$sources.splice(e._$sources.indexOf(t),1)}}this._$sources.length=0}}_$build(t,e){this._$character=e._$loaderInfo._$data.characters[t.characterId],this._$character.init||(this._$character.init=!0,this._$character.buffer=new Uint8Array(this._$character.buffer),s.$audioContext?s.$decodeAudioData(this):s.$audios.push(this)),this._$loop=t.loop,this._$volume=s.$min(ht.volume,t.volume)}_$createBufferSource(t=0,e=!1,i=0){const r=s.$audioContext.createBufferSource();r._$startTime=t,r.onended=this._$endEventHandler.bind(this),r.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,r._$gainNode=s.$audioContext.createGain(),r._$gainNode.connect(s.$audioContext.destination);const n=s.$min(ht.volume,this._$volume);r._$gainNode.gain.value=n,r._$volume=n,r.connect(r._$gainNode),r.start(0|t,i);s.$currentPlayer()._$sources.push(r),this._$sources.push(r)}_$endEventHandler(t){const e=t.target;this._$sources.splice(this._$sources.indexOf(e),1);const i=s.$currentPlayer();i._$sources.splice(i._$sources.indexOf(e),1),this._$loop?this._$createBufferSource():(s.$audioContext&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),this.willTrigger(a.SOUND_COMPLETE)&&this.dispatchEvent(new a(a.SOUND_COMPLETE)))}}class ht{constructor(){}static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static _$volume=1;static get volume(){return ht._$volume}static set volume(t){ht._$volume=s.$clamp(t,0,1,1);const e=s.$currentPlayer()._$sources;for(let t=0;t<e.length;++t){const i=e[t];i._$gainNode.gain.value=s.$min(ht._$volume,i._$volume)}const i=s.$currentPlayer()._$videos;for(let t=0;t<i.length;++t){const e=i[t];e._$video.volume=s.$min(e.volume,ht._$volume)}}static stopAll(){const t=s.$currentPlayer()._$sounds;for(let e=0;e<t.length;++e)t[e].stop();const e=s.$currentPlayer()._$videos;for(let t=0;t<e.length;++t)e[t].pause()}}class lt{constructor(t=1,e=!1){this._$volume=t,this._$loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=t}}class $t extends b{constructor(t=320,e=240){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=s.$getBoundsObject(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$stop=!0,this._$wait=!1,this._$volume=1}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video?(this._$video.removeEventListener("canplaythrough",this._$start),this._$video.addEventListener("canplaythrough",this._$start)):this._$initializeVideo(),this._$video.src=t,this._$video.load()}get videoHeight(){return this._$bounds.yMax}get videoWidth(){return this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=s.$min(ht.volume,s.$clamp(t,0,1,1)),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$texture&&s.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$video&&this._$video.pause(),this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause();(0,s.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(s.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),this.dispatchEvent(new d(d.PAUSE),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=s.$currentPlayer();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){if(this._$video&&this._$stop){this._$stop=!1,this._$video.volume=s.$min(this._$volume,ht.volume),this._$video.play();const t=s.$requestAnimationFrame;this._$timerId=t(this._$update),this.dispatchEvent(new d(d.PLAY),!1,!1,this._$bytesLoaded,this._$bytesTotal);const e=s.$currentPlayer();-1===e._$videos.indexOf(this)&&e._$videos.push(this)}}seek(t){this._$video&&(this._$video.currentTime=t,this.dispatchEvent(new d(d.SEEK),!1,!1,this._$bytesLoaded,this._$bytesTotal))}_$initializeVideo(){this._$video=s.$document.createElement("video"),this._$update=function(){const t=s.$currentPlayer();if(!this._$stage){this._$video.pause();return(0,s.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(t._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),void t._$videos.splice(t._$videos.indexOf(this),1)}t._$draw(0),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this._$texture=t._$context.frameBuffer.createTextureFromVideo(this._$video,this._$smoothing,this._$texture),this.dispatchEvent(new d(d.PROGRESS),!1,!1,this._$bytesLoaded,this._$bytesTotal),this._$doChanged());const e=s.$requestAnimationFrame;this._$timerId=e(this._$update)}.bind(this),this._$sound=function(){const t=s.$isTouch?s.$TOUCH_END:s.$MOUSE_UP;s.$currentPlayer()._$canvas.removeEventListener(t,this._$sound),this._$video.muted=!1}.bind(this),this._$video.muted=!0,this._$video.autoplay=!1,this._$video.crossOrigin="anonymous",this._$video.type="video/mp4",s.$isTouch&&this._$video.setAttribute("playsinline",""),this._$start=function(){if(this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration,s.$audioContext)this._$video.muted=!1;else{const t=s.$isTouch?s.$TOUCH_END:s.$MOUSE_UP;s.$currentPlayer()._$canvas.addEventListener(t,this._$sound)}if(this._$autoPlay){const t=s.$currentPlayer();-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$wait=!0,this._$doChanged()}}.bind(this),this._$video.addEventListener("canplaythrough",this._$start),this._$video.addEventListener("ended",function(){if(this._$loop)return void(this._$video.currentTime=0);this.dispatchEvent(new d(d.PLAY_END),!1,!1,this._$bytesLoaded,this._$bytesTotal);(0,s.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1}.bind(this))}_$build(t,e){const i=super._$build(t,e);this._$loop=i.loop,this._$autoPlay=i.autoPlay,this._$bounds=i.bounds,this._$video||this._$initializeVideo(),this._$video.src=URL.createObjectURL(new Blob([new Uint8Array(i.buffer)],{type:"video/mp4"})),this._$video.volume=s.$min(i.volume,ht.volume),this._$video.load()}_$clip(t,e){let i=this._$bounds.xMax,r=this._$bounds.yMax;if(!i||!r)return;let n=e;const a=this._$transform._$rawMatrix();a!==s.$MATRIX_ARRAY_IDENTITY&&(n=s.$multiplicationMatrix(e,a)),s.$resetContext(t),t.setTransform(n[0],n[1],n[2],n[3],n[4],n[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,r),t.lineTo(0,r),t.lineTo(0,0),t.clip(!0),n!==e&&s.$poolFloat32Array6(n)}_$draw(t,e,i){if(!this._$visible)return;if(this._$wait){this._$stop=!1,this._$video.play(),this.dispatchEvent(new d(d.PLAY_START),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=s.$requestAnimationFrame;this._$timerId=t(this._$update),this._$wait=!1}if(!this._$texture)return;let r=i;const n=this._$transform._$rawColorTransform();n!==s.$COLOR_ARRAY_IDENTITY&&(r=s.$multiplicationColor(i,n));const a=s.$clamp(r[3]+r[7]/255,0,1,0);if(!a)return void(r!==i&&s.$poolFloat32Array8(r));let o=e;const h=this._$transform._$rawMatrix();h!==s.$MATRIX_ARRAY_IDENTITY&&(o=s.$multiplicationMatrix(e,h));const l=s.$boundsMatrix(this._$bounds,o),$=+l.xMax,_=+l.xMin,c=+l.yMax,u=+l.yMin;s.$poolBoundsObject(l);let g=s.$ceil(s.$abs($-_)),p=s.$ceil(s.$abs(c-u));if(!g||!p)return;let f=this._$texture,m=0,x=0;const b=this._$filters||this.filters;if(b&&b.length){const r=this._$canApply(b);if(r){const n=[this._$instanceId,"f"];let a=s.$cacheStore().get(n);const o=this._$isFilterUpdated(g,p,e,i,b,r);a&&!o||(a&&(s.$cacheStore().set(n,null),a.layerWidth=0,a.layerHeight=0,a._$offsetX=0,a._$offsetY=0,a.matrix=null,a.colorTransform=null,t.frameBuffer.releaseTexture(a),a=null),f=this._$getFilterTexture(t,b,this._$texture,e,i),s.$cacheStore().set(n,f)),a&&(f=a),s.$poolArray(n),m=f._$offsetX,x=f._$offsetY}}s.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=this._$blendMode||this.blendMode,t.setTransform(o[0],o[1],o[2],o[3],o[4],o[5]),t.drawImage(f,-m,-x,f.width,f.height,r)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,r){let n=e;const a=this._$transform._$rawMatrix();a!==s.$MATRIX_ARRAY_IDENTITY&&(n=s.$multiplicationMatrix(e,a));const o=this._$getBounds(null),h=s.$boundsMatrix(o,n),l=+h.xMax,$=+h.xMin,_=+h.yMax,c=+h.yMin;s.$poolBoundsObject(h),s.$poolBoundsObject(o);const u=s.$ceil(s.$abs(l-$)),d=s.$ceil(s.$abs(_-c));return t.setTransform(1,0,0,1,$,c),t.beginPath(),t.moveTo(0,0),t.lineTo(u,0),t.lineTo(u,d),t.lineTo(0,d),t.lineTo(0,0),n!==e&&s.$poolFloat32Array6(n),t.isPointInPath(i.x,i.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();i!==s.$MATRIX_ARRAY_IDENTITY&&(e=s.$multiplicationMatrix(t,i));const r=s.$boundsMatrix(this._$bounds,e);return e!==t&&s.$poolFloat32Array6(e),r}return s.$getBoundsObject(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}}class _t{constructor(){}static toString(){return"[class URLLoaderDataFormat]"}static get namespace(){return"next2d.net.URLLoaderDataFormat"}toString(){return"[object URLLoaderDataFormat]"}get namespace(){return"next2d.net.URLLoaderDataFormat"}static get ARRAY_BUFFER(){return"arraybuffer"}static get JSON(){return"json"}static get STRING(){return"string"}static get VARIABLES(){return"variables"}}class ct{constructor(t=""){this._$url=t,this._$contentType="application/json",this._$data=null,this._$method=dt.GET,this._$requestHeaders=s.$getArray(),this._$userAgent=s.$navigator.userAgent,this._$responseDataFormat=_t.JSON,this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){this._$method=t}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){this._$requestHeaders=t}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=s.$currentPlayer();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get userAgent(){return this._$userAgent}get responseDataFormat(){return this._$responseDataFormat}get withCredentials(){return this._$withCredentials}get headers(){const t={"Content-Type":`${this._$contentType}`},e=this._$requestHeaders.length;for(let i=0;i<e;++i){const e=this._$requestHeaders[i];e instanceof ut&&(t[e.name]=e.value)}return t}}class ut{constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}set name(t){this._$name=`${t}`}get value(){return this._$value}set value(t){this._$value=`${t}`}}class dt{constructor(){}static toString(){return"[class URLRequestMethod]"}static get namespace(){return"next2d.net.URLRequestMethod"}toString(){return"[object URLRequestMethod]"}get namespace(){return"next2d.net.URLRequestMethod"}static get DELETE(){return"DELETE"}static get GET(){return"GET"}static get HEAD(){return"HEAD"}static get OPTIONS(){return"OPTIONS"}static get POST(){return"POST"}static get PUT(){return"PUT"}}class gt{constructor(){}static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,s){return t/s*i+e}static inQuad(t,e,i,s){return(t/s)**2*i+e}static outQuad(t,e,i,s){return-(t/=s)*(t-2)*i+e}static inOutQuad(t,e,i,s){return(t/=s/2)<1?t**2*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,s){return(t/=s)**3*i+e}static outCubic(t,e,i,s){return(((t/=s)-1)**3+1)*i+e}static inOutCubic(t,e,i,s){return(t/=s/2)<1?t**3*i/2+e:((t-=2)**3+2)*i/2+e}static inQuart(t,e,i,s){return(t/=s)**4*i+e}static outQuart(t,e,i,s){return(((t/=s)-1)**4-1)*-i+e}static inOutQuart(t,e,i,s){return(t/=s/2)<1?t**4*i/2+e:((t-=2)**4-2)*-i/2+e}static inQuint(t,e,i,s){return(t/=s)**5*i+e}static outQuint(t,e,i,s){return(((t/=s)-1)**5+1)*i+e}static inOutQuint(t,e,i,s){return(t/=s/2)<1?t**5*i/2+e:((t-=2)**5+2)*i/2+e}static inSine(t,e,i,s){return-i*Math.cos(t/s*(Math.PI/2))+i+e}static outSine(t,e,i,s){return i*Math.sin(t/s*(Math.PI/2))+e}static inOutSine(t,e,i,s){return-i/2*(Math.cos(Math.PI*t/s)-1)+e}static inExpo(t,e,i,s){return i*Math.pow(2,10*(t/s-1))+e}static outExpo(t,e,i,s){return i*(1-Math.pow(2,-10*t/s))+e}static inOutExpo(t,e,i,s){return(t/=s/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*(t-=1)))+e}static inCirc(t,e,i,s){return(1-Math.sqrt(1-(t/=s)**2))*i+e}static outCirc(t,e,i,s){return Math.sqrt(1-((t/=s)-1)**2)*i+e}static inOutCirc(t,e,i,s){return(t/=s/2)<1?(1-Math.sqrt(1-t*t))*i/2+e:(Math.sqrt(1-(t-=2)**2)+1)*i/2+e}static inBack(t,e,i,s){return(2.70158*(t/=s)**3-1.70158*t*t)*i+e}static outBack(t,e,i,s){return(1+2.70158*Math.pow((t/=s)-1,3)+1.70158*Math.pow(t-1,2))*i+e}static inOutBack(t,e,i,s){let r=1.70158;return(t/=s/2)<1?t**2*((1+(r*=1.525))*t-r)*i/2+e:((t-=2)**2*((1+(r*=1.525))*t+r)+2)*i/2+e}static inElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:-Math.pow(2,(t*=10)-10)*Math.sin((t-10.75)*(2*Math.PI/3))*i+e}static outElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:(Math.pow(2,-10*t)*Math.sin((10*t-.75)*(2*Math.PI/3))+1)*i+e}static inOutElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:t<.5?-Math.pow(2,(t*=20)-10)*Math.sin((t-11.125)*(2*Math.PI/4.5))/2*i+e:(Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2+1)*i+e}static outBounce(t,e,i,s){return(t/=s)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,s){return i-gt.outBounce(s-t,0,i,s)+e}static inOutBounce(t,e,i,s){return t<s/2?gt.inBounce(2*t,e,i/2,s):gt.outBounce(2*t-s,e+i/2,i/2,s)}}class pt extends o{constructor(t,e=null,i=null,s=0,r=1,n=null){super(),this._$target=t,this._$delay=s,this._$duration=r,this._$ease=n||gt.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$to=i,this._$update=null}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$stopFlag=!1,this._$startTime=s.$performance.now(),this._$update=this.update.bind(this),this._$names=this.entries(this._$from),this.addEventListener(a.ENTER_FRAME,this._$update)}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],s=i[1];s&&"object"==typeof s&&(i[1]=this.entries(s))}return e}start(){if(this._$delay){(0,s.$setTimeout)(function(){this.initialize()}.bind(this),1e3*this._$delay)}else this.initialize()}stop(){this._$stopFlag=!0,this.removeEventListener(a.ENTER_FRAME,this._$update),this.hasEventListener(a.STOP)&&this.dispatchEvent(new a(a.STOP))}update(){this._$stopFlag?this.removeEventListener(a.ENTER_FRAME,this._$update):(this._$currentTime=.001*(s.$performance.now()-this._$startTime),this.updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener(a.UPDATE)&&this.dispatchEvent(new a(a.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener(a.ENTER_FRAME,this._$update),this.hasEventListener(a.COMPLETE)&&this.dispatchEvent(new a(a.COMPLETE))))}updateProperty(t,e,i,s){for(let r=0;r<s.length;++r){const n=s[r],a=n[0],o=n[1];if(o&&"object"==typeof o){this.updateProperty(t[a],e[a],i[a],o);continue}const h=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,h,i[a]-h,this._$duration):t[a]=i[a]}}}class ft{constructor(){}static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,s=0,r=1,n=null){return new pt(t,e,i,s,r,n)}}class mt{constructor(){this._$pool=s.$getArray(),this._$store=s.$getMap(),this._$lifeCount=2,this._$delayLifeCheck=this.lifeCheck.bind(this);(0,s.$setTimeout)(this._$delayLifeCheck,5e3)}reset(){for(const[t,e]of this._$store){for(const[t,i]of e)this.destroy(i);s.$poolMap(e)}this._$store.clear()}destroy(t){if(t)switch(t.constructor){case s.$WebGLTexture:const e=s.$currentPlayer(),i=t._$bitmapData;i&&(i._$buffer=i._$getPixels(0,0,i.width,i.height,"RGBA"),delete t._$bitmapData),e._$context&&e._$context.frameBuffer.releaseTexture(t);break;case s.$CanvasRenderingContext2D:const r=t.canvas,n=r.width,a=r.height;t.clearRect(0,0,n+1,a+1),r.width=r.height=1,this._$pool.push(r)}}getCanvas(){return this._$pool.pop()||s.$document.createElement("canvas")}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const[t,i]of e)this.destroy(i);s.$poolMap(e),this._$store.delete(t)}}generateLifeKey(t,e){return`${t}:${e}`}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){const t=this._$store.get(e);if(t.has(i)){const e=`life_${i}`;return 1===t.has(e)&&t.set(e,this._$lifeCount),t.get(i)}}return null}set(t,e){const i=`${t[0]}`,r=`${t[1]}`;this._$store.has(i)||this._$store.set(i,s.$getMap());this.generateLifeKey(i,r);const n=this._$store.get(i);if(!e)return n.delete(r),n.delete(`life_${r}`),void(n.size||(s.$poolMap(n),this._$store.delete(i)));{const t=n.get(r);t&&t!==e&&console.log("TODO delete cache")}n.set(r,e),n.set(`life_${r}`,this._$lifeCount)}generateShapeKeys(t,e,i=null){let r="";switch(!0){case 1!==e[0]:case 0!==e[1]:case 0!==e[2]:case 1!==e[3]:r=`${e[0]}_${e[1]}_${e[2]}_${e[3]}`}i&&(r+=this.colorToString(i));const n=s.$getArray();return n[0]=`${t}`,n[1]=r?this.generateHash(r):"_0",n}generateKeys(t,e=null,i=null){let r="";e&&(r+=`${e[0]}_${e[1]}`),i&&(r+=this.colorToString(i));const n=s.$getArray();return n[1]=r?this.generateHash(r):"_0",n[0]=`${t}`,n}colorToString(t=null){switch(!0){case 1!==t[0]:case 1!==t[1]:case 1!==t[2]:case 0!==t[4]:case 0!==t[5]:case 0!==t[6]:case 0!==t[7]:return`_${t[0]}_${t[1]}_${t[2]}_${t[4]}_${t[5]}_${t[6]}_${t[7]}`;default:return""}}generateHash(t){let e=0;const i=t.length;for(let s=0;s<i;s++){e=(e<<5)-e+t.charCodeAt(s),e|=0}return`_${e}`}lifeCheck(){for(const[t,e]of this._$store){for(const[t,i]of e){const s=`life_${t}`,r=e.get(s)-1;r?e.set(s,r):(this.destroy(i),e.delete(t),e.delete(`life_${t}`))}e.size||(s.$poolMap(e),this._$store.delete(t))}(0,s.$setTimeout)(this._$delayLifeCheck,5e3)}}class xt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBitmapShader(){return this._$collection.has("b")||this._$collection.set("b",new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),Bt.TEMPLATE(this._$keyword,0,0,!1))),this._$collection.get("b")}setBitmapUniform(t){}setGetPixelsUniform(t,e,i,s,r){const n=t.highp;n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n[12]=e,n[13]=0,n[14]=0,n[16]=0,n[17]=i,n[18]=0,n[3]=s,n[7]=r,n[11]=1}setSetPixelsUniform(t,e,i,s,r,n,a,o,h){const l=t.highp;l[0]=e,l[1]=0,l[2]=0,l[4]=0,l[5]=i,l[6]=0,l[8]=s,l[9]=r,l[10]=1,l[12]=n,l[13]=0,l[14]=0,l[16]=0,l[17]=a,l[18]=0,l[3]=o,l[7]=h,l[11]=1}setColorTransformUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4]/255,i[5]=e[5]/255,i[6]=e[6]/255,i[7]=e[7]/255}setManipulatePixelsUniform(t,e,i,s,r,n){const a=t.highp;a[0]=e[0],a[1]=e[1],a[2]=e[2],a[4]=e[3],a[5]=e[4],a[6]=e[5],a[8]=e[6],a[9]=e[7],a[10]=e[8],r?(a[12]=s[0],a[13]=s[1],a[14]=s[2],a[16]=s[3],a[17]=s[4],a[18]=s[5],a[20]=s[6],a[21]=s[7],a[22]=s[8],a[24]=n[0],a[25]=n[1],a[26]=n[2],a[3]=n[3],a[7]=n[4],a[11]=n[5],a[15]=n[6],a[19]=n[7],a[23]=n[8]):i&&(a[12]=s[0],a[13]=s[1],a[14]=s[2],a[16]=s[3],a[17]=s[4],a[18]=s[5],a[3]=s[6],a[7]=s[7],a[11]=s[8])}setCopyChannelUniform(t,e,i){const s=t.textures;s[0]=0,s[1]=1;const r=t.mediump;r[0]=1&e,r[1]=e>>1&1,r[2]=e>>2&1,r[3]=e>>3&1,r[4]=1&i,r[5]=i>>1&1,r[6]=i>>2&1,r[7]=i>>3&1}setCopyPixelsUniform(t,e){if(e){const e=t.textures;e[0]=0,e[1]=1}}setFillRectUniform(t,e,i,s,r){const n=t.mediump;n[0]=e,n[1]=i,n[2]=s,n[3]=r}setGetColorBoundsRectUniform(t,e,i,s,r,n){const a=t.highp;a[0]=1,a[1]=0,a[2]=0,a[4]=0,a[5]=1,a[6]=0,a[8]=0,a[9]=0,a[10]=1,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[16]=e[3],a[17]=e[4],a[18]=e[5],a[3]=e[6],a[7]=e[7],a[11]=e[8];const o=t.mediump;o[0]=i[0],o[1]=i[1],o[2]=s;const h=t.integer;h[0]=r[0],h[1]=r[1],h[2]=r[2],h[3]=r[3],h[4]=n[0],h[5]=n[1],h[6]=n[2],h[7]=n[3]}setMergeUniform(t,e,i,s,r){const n=t.textures;n[0]=0,n[1]=1;const a=t.mediump;a[0]=e,a[1]=i,a[2]=s,a[3]=r}setNoiseUniform(t,e,i,s,r,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=s,u[3]=r,u[4]=n,u[5]=a,u[6]=o,u[7]=h,u[8]=l,u[9]=$,u[10]=_,u[11]=c}setPaletteMapUniform(t){const e=t.textures;e[0]=0,e[1]=2}setPixelDissolveUniform(t,e,i,s,r){const n=t.mediump;n[0]=e,n[1]=i,n[2]=s,n[3]=r}setFlushSetPixelQueueUniform(t){const e=t.highp;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=-1,e[5]=0,e[6]=0,e[7]=1,e[8]=1}setThresholdUniform(t,e,i,s,r,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=s,u[3]=r,u[4]=n,u[5]=a,u[6]=o,u[7]=h;const d=t.integer;d[0]=l,d[1]=$,d[2]=_,d[3]=c}}class bt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getNormalBlendShader(t){const e="n"+(t?"y":"n");return this._$collection.has(e)||this._$collection.set(e,new Kt(this._$gl,this._$context,Mt.BLEND(this._$keyword),Bt.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getClipShader(){return this._$collection.has("c")||this._$collection.set("c",new Kt(this._$gl,this._$context,Mt.BLEND_CLIP(this._$keyword),Bt.TEMPLATE(this._$keyword,!1))),this._$collection.get("c")}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;return this._$collection.has(i)||this._$collection.set(i,new Kt(this._$gl,this._$context,Mt.BLEND(this._$keyword),class{static TEMPLATE(t,e,i){let s;switch(e){case S.SUBTRACT:s=this.FUNCTION_SUBTRACT();break;case S.MULTIPLY:s=this.FUNCTION_MULTIPLY();break;case S.LIGHTEN:s=this.FUNCTION_LIGHTEN();break;case S.DARKEN:s=this.FUNCTION_DARKEN();break;case S.OVERLAY:s=this.FUNCTION_OVERLAY();break;case S.HARDLIGHT:s=this.FUNCTION_HARDLIGHT();break;case S.DIFFERENCE:s=this.FUNCTION_DIFFERENCE();break;case S.INVERT:s=this.FUNCTION_INVERT();break;default:s=this.FUNCTION_NORMAL()}const r=i?"uniform vec4 u_mediump[2];":"",n=i?wt.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${r}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${s}\n\nvoid main() {\n    vec4 dst = ${t.texture2D()}(u_textures[0], v_coord);\n    vec4 src = ${t.texture2D()}(u_textures[1], v_coord);\n    ${n}\n    ${t.fragColor()} = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}.TEMPLATE(this._$keyword,t,e))),this._$collection.get(i)}setNormalBlendUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,p){const f=t.highp;if(f[0]=e,f[1]=i,f[2]=s,f[3]=r,f[4]=n[0],f[5]=n[1],f[6]=n[2],f[8]=n[3],f[9]=n[4],f[10]=n[5],f[12]=n[6],f[13]=n[7],f[14]=n[8],f[7]=a,f[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=p}}setClipUniform(t,e,i,s,r,n,a,o){const h=t.highp;h[0]=e,h[1]=i,h[2]=s,h[3]=r,h[4]=n[0],h[5]=n[1],h[6]=n[2],h[8]=n[3],h[9]=n[4],h[10]=n[5],h[12]=n[6],h[13]=n[7],h[14]=n[8],h[7]=a,h[11]=o}setBlendUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,p){const f=t.textures;f[0]=0,f[1]=1;const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=p}}}class Tt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBlurFilterShader(t){const e=`b${t}`;return this._$collection.has(e)||this._$collection.set(e,new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e){const i=e.toFixed(1);return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${i}; i += 1.0) {\n        color += ${t.texture2D()}(u_texture, v_coord + offset * i);\n        color += ${t.texture2D()}(u_texture, v_coord - offset * i);\n    }\n    color += ${t.texture2D()}(u_texture, v_coord + offset * ${i}) * fraction;\n    color += ${t.texture2D()}(u_texture, v_coord - offset * ${i}) * fraction;\n    color /= samples;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getBitmapFilterShader(t,e,i,r,n,a,o){const h=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${r}${n?"y":"n"}${a?"y":"n"}`;if(!this._$collection.has(h)){let l=1;t&&l++,o&&l++;let $=(t?4:0)+(e?4:0)+(a?1:0);o||($+=i?4:8),$=s.$ceil($/4),this._$collection.set(h,new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,r,n,a,o,h,l){let $=0;const _=s?this.STATEMENT_BASE_TEXTURE_TRANSFORM(t,$++):"",c=r?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(t,$++):this.STATEMENT_BLUR_TEXTURE(t),u=a===H.INNER,d=$;let g,p,f=4*$;switch(l?g=n?this.STATEMENT_GLOW(t,!1,s,h,l,d,f):this.STATEMENT_BEVEL(t,s,r,h,l,d,f):n?(f+=4,g=this.STATEMENT_GLOW(t,u,s,h,l,d,f)):(f+=8,g=this.STATEMENT_BEVEL(t,s,r,h,l,d,f)),a){case H.OUTER:p=o?"blur - blur * base.a":"base + blur - blur * base.a";break;case H.FULL:p=o?"blur":"base - base * blur.a + blur";break;case H.INNER:default:p="blur"}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[${e}];\nuniform vec4 u_mediump[${i}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${wt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${_}\n    ${c}\n    ${g}\n    ${t.fragColor()} = ${p};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t,e){return`\n    vec2 base_scale  = u_mediump[${e}].xy;\n    vec2 base_offset = u_mediump[${e}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), ${t.texture2D()}(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(t){return`\n    vec4 blur = ${t.texture2D()}(u_textures[0], v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t,e){return`\n    vec2 blur_scale  = u_mediump[${e}].xy;\n    vec2 blur_offset = u_mediump[${e}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,s,r,n,a){return`\n    ${e?"blur.a = 1.0 - blur.a;":""}\n    ${s?this.STATEMENT_GLOW_STRENGTH(a):""}\n    ${r?this.STATEMENT_GLOW_GRADIENT_COLOR(t,i):this.STATEMENT_GLOW_SOLID_COLOR(n)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${s.$floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,s,r,n,a){return`\n    ${i?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t):this.STATEMENT_BLUR_TEXTURE_2(t)}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${s?this.STATEMENT_BEVEL_STRENGTH(a):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${r?this.STATEMENT_BEVEL_GRADIENT_COLOR(t,e):this.STATEMENT_BEVEL_SOLID_COLOR(n)}\n`}static STATEMENT_BLUR_TEXTURE_2(t){return`\n    vec4 blur2 = ${t.texture2D()}(u_textures[0], 1.0 - v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t){return`\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], pq), isInside(pq));\n`}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${s.$floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}.TEMPLATE(this._$keyword,l,$,t,e,i,r,n,a,o)))}return this._$collection.get(h)}getColorMatrixFilterShader(){return this._$collection.has("m")||this._$collection.set("m",new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),class{static TEMPLATE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword))),this._$collection.get("m")}getConvolutionFilterShader(t,e,i,r){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${r?"y":"n"}`;if(!this._$collection.has(n)){const a=(r?1:2)+s.$ceil(t*e/4);this._$collection.set(n,new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r,n,a){const o=s.$floor(.5*i),h=s.$floor(.5*r),l=i*r;let $="";const _=a?1:2;for(let t=0;t<l;t++){$+=`\n    result += getWeightedColor(${t}, u_mediump[${_+s.$floor(t/4)}][${t%4}]);\n`}const c=n?`result.a = ${t.texture2D()}(u_texture, v_coord).a;`:"",u=a?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${wt.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${i};\n    int i_mod_x = i - ${i} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${o}, ${h} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = ${t.texture2D()}(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${u}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${$}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${c}\n\n    result.rgb *= result.a;\n    ${t.fragColor()} = result;\n}\n\n`}}.TEMPLATE(this._$keyword,a,t,e,i,r)))}return this._$collection.get(n)}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(!this._$collection.has(s)){const r=i===V.COLOR?3:2;this._$collection.set(s,new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,r){let n,a,o;switch(i){case M.RED:n="map_color.r";break;case M.GREEN:n="map_color.g";break;case M.BLUE:n="map_color.b";break;case M.ALPHA:n="map_color.a";break;default:n="0.5"}switch(s){case M.RED:a="map_color.r";break;case M.GREEN:a="map_color.g";break;case M.BLUE:a="map_color.b";break;case M.ALPHA:a="map_color.a";break;default:a="0.5"}switch(r){case V.CLAMP:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], uv);\n`;break;case V.IGNORE:o=`\n    vec4 source_color =${t.texture2D()}(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n`;break;case V.COLOR:o=`\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, ${t.texture2D()}(u_textures[0], uv), isInside(uv));\n`;break;case V.WRAP:default:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], fract(uv));\n`}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${wt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = ${t.texture2D()}(u_textures[1], st);\n\n    vec2 offset = vec2(${n}, ${a}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${o}\n\n    ${t.fragColor()} = mix(${t.texture2D()}(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}.TEMPLATE(this._$keyword,r,t,e,i)))}return this._$collection.get(s)}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,p,f,m,x,b,T,v,y,E){let A;T?(A=t.textures,A[0]=0,A[1]=1,E&&(A[2]=2)):E&&(A=t.textures,A[0]=0,A[1]=2);const M=t.mediump;let S=0;T&&(M[S]=e/s,M[S+1]=i/r,M[S+2]=n/s,M[S+3]=(i-r-a)/r,S+=4),v&&(M[S]=e/o,M[S+1]=i/h,M[S+2]=l/o,M[S+3]=(i-h-$)/h,S+=4),E||(_?(M[S]=u,M[S+1]=d,M[S+2]=g,M[S+3]=p,S+=4):(M[S]=u,M[S+1]=d,M[S+2]=g,M[S+3]=p,M[S+4]=f,M[S+5]=m,M[S+6]=x,M[S+7]=b,S+=8)),y&&(M[S++]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,o,h,l,$){const _=t.mediump;_[0]=1/e,_[1]=1/i,_[2]=1/r,_[3]=n/255;let c=4;a||(_[c]=o,_[c+1]=h,_[c+2]=l,_[c+3]=$,c+=4);const u=s.length;for(let t=0;t<u;t++)_[c++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=o/s,g[5]=-h/r,l===V.COLOR&&(g[8]=$,g[9]=_,g[10]=c,g[11]=u)}}class vt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=s.$ceil(5*t/4);this._$collection.set(i,new Kt(this._$gl,this._$context,Mt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r){let n="";for(let t=1;t<i;t++){const e=t-1,r=t,a=`u_mediump[${i+s.$floor(e/4)}][${e%4}]`,o=`u_mediump[${i+s.$floor(r/4)}][${r%4}]`;n+=`\n    if (t <= ${o}) {\n        return mix(${`u_mediump[${e}]`}, ${`u_mediump[${r}]`}, (t - ${a}) / (${o} - ${a}));\n    }\n`}const a=r?"color = pow(color, vec4(0.45454545));":"";return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${i}][0]) {\n        return u_mediump[0];\n    }\n    ${n}\n    return u_mediump[${i-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${a}\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,r,t,e)))}return this._$collection.get(i)}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n]=r[i[0]],a[n+1]=r[i[1]],a[n+2]=r[i[2]],a[n+3]=r[i[3]],n+=4}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const o=t.mediump;for(let t=r;t<n;t++){const e=i[t];o[a]=(e>>16)/255,o[a+1]=(e>>8&255)/255,o[a+2]=(255&e)/255,o[a+3]=s[t],a+=4}for(let t=r;t<n;t++)o[a++]=e[t]}}class yt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(!this._$collection.has(n)){let a=(e?13:5)+(t?1:0)+1;const o=a-1;let h;h=t?Rt.TEMPLATE(this._$keyword,a,o,!0,!1,e):Ct.TEMPLATE(this._$keyword,a,!0,!1,e),this._$collection.set(n,new Kt(this._$gl,this._$context,h,class{static TEMPLATE(t,e,i,s,r,n){const a=s?this.STATEMENT_GRADIENT_TYPE_RADIAL(i,r):this.STATEMENT_GRADIENT_TYPE_LINEAR(i);let o;switch(n){case"reflect":o="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":o="fract(t)";break;default:o="clamp(t, 0.0, 1.0)"}return`${t.version()}\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${e}];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 p = v_uv;\n    ${a}\n    t = ${o};\n    ${t.fragColor()} = ${t.texture2D()}(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}.TEMPLATE(this._$keyword,a,o,i,s,r)))}return this._$collection.get(n)}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",o=i?"y":"n",h=i&&s?"y":"n";let l=0;switch(r){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${o}${h}${l}`}setGradientShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u){let d=0;const g=t.highp;g[0]=a[0],g[1]=a[1],g[2]=a[2],g[4]=a[3],g[5]=a[4],g[6]=a[5],g[8]=a[6],g[9]=a[7],g[10]=a[8],g[12]=o[0],g[13]=o[1],g[14]=o[2],g[16]=o[3],g[17]=o[4],g[18]=o[5],g[11]=o[6],g[15]=o[7],g[19]=o[8],g[3]=h,g[7]=l,d=20,n&&(g[d]=$.parentMatrixA,g[d+1]=$.parentMatrixB,g[d+2]=$.parentMatrixC,g[d+4]=$.parentMatrixD,g[d+5]=$.parentMatrixE,g[d+6]=$.parentMatrixF,g[d+8]=$.parentMatrixG,g[d+9]=$.parentMatrixH,g[d+10]=$.parentMatrixI,g[d+12]=$.ancestorMatrixA,g[d+13]=$.ancestorMatrixB,g[d+14]=$.ancestorMatrixC,g[d+16]=$.ancestorMatrixD,g[d+17]=$.ancestorMatrixE,g[d+18]=$.ancestorMatrixF,g[d+20]=$.ancestorMatrixG,g[d+21]=$.ancestorMatrixH,g[d+22]=$.ancestorMatrixI,g[d+11]=$.parentViewportX,g[d+15]=$.parentViewportY,g[d+19]=$.parentViewportW,g[d+23]=$.parentViewportH,g[d+24]=$.minXST,g[d+25]=$.minYST,g[d+26]=$.minXPQ,g[d+27]=$.minYPQ,g[d+28]=$.maxXST,g[d+29]=$.maxYST,g[d+30]=$.maxXPQ,g[d+31]=$.maxYPQ,d=52),e&&(g[d]=i,g[d+1]=s,g[d+2]=r,d+=4),_?(g[d]=c[5],g[d+1]=u):(g[d]=c[0],g[d+1]=c[1],g[d+2]=c[2],g[d+3]=c[3])}}class Et{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Rt.TEMPLATE(this._$keyword,s,r,!1,!1,e):Ct.TEMPLATE(this._$keyword,s,!1,!1,e),this._$collection.set(i,new Kt(this._$gl,this._$context,n,Ot.SOLID_COLOR(this._$keyword)))}return this._$collection.get(i)}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(!this._$collection.has(s)){const r=(i?13:5)+(t?1:0),n=r;let a;a=t?Rt.TEMPLATE(this._$keyword,r,n,!0,!1,i):Ct.TEMPLATE(this._$keyword,r,!0,!1,i);const o=e?Ot.BITMAP_PATTERN(this._$keyword):Ot.BITMAP_CLIPPED(this._$keyword);this._$collection.set(s,new Kt(this._$gl,this._$context,a,o))}return this._$collection.get(s)}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Rt.TEMPLATE(this._$keyword,s,r,!1,!0,e):Ct.TEMPLATE(this._$keyword,s,!1,!0,e),this._$collection.set(i,new Kt(this._$gl,this._$context,n,Ot.MASK(this._$keyword)))}return this._$collection.get(i)}setSolidColorShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_){const c=t.highp;let u;n?(c[0]=l.parentMatrixA,c[1]=l.parentMatrixB,c[2]=l.parentMatrixC,c[4]=l.parentMatrixD,c[5]=l.parentMatrixE,c[6]=l.parentMatrixF,c[8]=l.parentMatrixG,c[9]=l.parentMatrixH,c[10]=l.parentMatrixI,c[12]=l.ancestorMatrixA,c[13]=l.ancestorMatrixB,c[14]=l.ancestorMatrixC,c[16]=l.ancestorMatrixD,c[17]=l.ancestorMatrixE,c[18]=l.ancestorMatrixF,c[20]=l.ancestorMatrixG,c[21]=l.ancestorMatrixH,c[22]=l.ancestorMatrixI,c[3]=o,c[7]=h,c[11]=l.parentViewportX,c[15]=l.parentViewportY,c[19]=l.parentViewportW,c[23]=l.parentViewportH,c[24]=l.minXST,c[25]=l.minYST,c[26]=l.minXPQ,c[27]=l.minYPQ,c[28]=l.maxXST,c[29]=l.maxYST,c[30]=l.maxXPQ,c[31]=l.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=o,c[7]=h,u=12),e&&(c[u]=i,c[u+1]=s,c[u+2]=r);const d=t.mediump;d[0]=$[0],d[1]=$[1],d[2]=$[2],d[3]=$[3]*_}setBitmapShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,p,f,m,x,b){const T=t.highp;let v;T[0]=a[0],T[1]=a[1],T[2]=a[2],T[4]=a[3],T[5]=a[4],T[6]=a[5],T[8]=a[6],T[9]=a[7],T[10]=a[8],T[12]=o[0],T[13]=o[1],T[14]=o[2],T[16]=o[3],T[17]=o[4],T[18]=o[5],T[11]=o[6],T[15]=o[7],T[19]=o[8],T[3]=h,T[7]=l,v=20,n&&(T[v]=$.parentMatrixA,T[v+1]=$.parentMatrixB,T[v+2]=$.parentMatrixC,T[v+4]=$.parentMatrixD,T[v+5]=$.parentMatrixE,T[v+6]=$.parentMatrixF,T[v+8]=$.parentMatrixG,T[v+9]=$.parentMatrixH,T[v+10]=$.parentMatrixI,T[v+12]=$.ancestorMatrixA,T[v+13]=$.ancestorMatrixB,T[v+14]=$.ancestorMatrixC,T[v+16]=$.ancestorMatrixD,T[v+17]=$.ancestorMatrixE,T[v+18]=$.ancestorMatrixF,T[v+20]=$.ancestorMatrixG,T[v+21]=$.ancestorMatrixH,T[v+22]=$.ancestorMatrixI,T[v+11]=$.parentViewportX,T[v+15]=$.parentViewportY,T[v+19]=$.parentViewportW,T[v+23]=$.parentViewportH,T[v+24]=$.minXST,T[v+25]=$.minYST,T[v+26]=$.minXPQ,T[v+27]=$.minYPQ,T[v+28]=$.maxXST,T[v+29]=$.maxYST,T[v+30]=$.maxXPQ,T[v+31]=$.maxYPQ,v=52),e&&(T[v]=i,T[v+1]=s,T[v+2]=r);const y=t.mediump;y[0]=_,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=p,y[8]=f,y[9]=m,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.highp;e?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=_,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=o,d[8]=h,d[9]=l,d[10]=$,d[3]=_,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class At{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class Mt{static TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static BLEND(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static BLEND_CLIP(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}}class St{static POSITION_ONLY(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_DST_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_dst_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_ALPHA_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[7];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_alpha_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(u_highp[3].xyz, u_highp[4].xyz, u_highp[5].xyz);\n    mat3 alpha_tex_matrix = mat3(\n        u_highp[6].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w),\n        vec3(u_highp[3].w, u_highp[4].w, u_highp[5].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_alpha_tex_coord = (alpha_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static PIXEL_DISSOLVE_COLOR(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (u_src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (u_matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec4 a_color;\n\nuniform mat3 u_highp[3];\n\n${t.varyingOut()} vec2 v_dst_tex_coord;\n${t.varyingOut()} vec4 v_color;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    v_color = a_color;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}}class Ct{static TEMPLATE(t,e,i,s,r){const n=s?this.ATTRIBUTE_BEZIER_ON(t):"",a=s?this.VARYING_BEZIER_ON(t):i?this.VARYING_UV_ON(t):"",o=s?this.STATEMENT_BEZIER_ON():i?this.STATEMENT_UV_ON():"",h=r?At.FUNCTION_GRID_ON(i?5:0):At.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${n}\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${o}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(t){return`\n${t.attribute(1)} vec2 a_bezier;\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static VARYING_BEZIER_ON(t){return`\n${t.varyingOut()} vec2 v_bezier;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class Rt{static TEMPLATE(t,e,i,s,r,n){const a=i-1,o=s?this.VARYING_UV_ON(t):"",h=s?this.STATEMENT_UV_ON():"",l=n?At.FUNCTION_GRID_ON(s?5:0):At.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec2 a_option1;\n${t.attribute(2)} vec2 a_option2;\n${t.attribute(3)} float a_type;\n\nuniform vec4 u_highp[${e}];\n\n${o}\n\n${l}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${a}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${a}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${a}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // \n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // \n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // B\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // A\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // A\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // B\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // \n        float face = u_highp[${a}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${h}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class wt{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n`}}class Ot{static SOLID_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n`}static BITMAP_CLIPPED(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${wt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static BITMAP_PATTERN(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${wt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static MASK(t){return`${t.version()}\n${t.extensionDerivatives()}\nprecision mediump float;\n\n${t.varyingIn()} vec2 v_bezier;\n${t.outColor()}\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        ${t.fragColor()} = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n`}}class Ft{static FILL_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = u_mediump;\n}\n\n`}static COPY_SRC_TEX(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = ${t.texture2D()}(u_src_tex, v_src_tex_coord);\n}\n\n`}static COPY_CHANNEL(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_ch = u_mediump[0];\n    vec4 dst_ch = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    // src_color \n    float src_value = dot(src_color, src_ch);\n\n    // \n    vec4 mixed = mix(dst_color, vec4(src_value), dst_ch);\n\n#if ${t}\n    ${e.fragColor()} = vec4(mixed.rgb * mixed.a, mixed.a);\n#else\n    ${e.fragColor()} = vec4(mixed.rgb, 1.0);\n#endif\n}\n\n`}static MERGE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    vec4 merged = mix(dst_color, src_color, u_mediump);\n\n#if ${t}\n    ${e.fragColor()} = vec4(merged.rgb * merged.a, merged.a);\n#else\n    ${e.fragColor()} = vec4(merged.rgb, 1.0);\n#endif\n}\n\n`}static COPY_PIXELS_WITH_ALPHA_BITMAP_DATA(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.varyingIn()} vec2 v_alpha_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src_color = ${t.texture2D()}(u_textures[0], v_src_tex_coord);\n    float alpha = ${t.texture2D()}(u_textures[1], v_alpha_tex_coord).a;\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    alpha *= src_color.a;\n\n    ${t.fragColor()} = vec4(src_color.rgb * alpha, alpha);\n}\n\n`}static PALETTE_MAP(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n                                                //  256*4\n    vec4 map_r = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.r*255.0)/256.0, 0.125));\n    vec4 map_g = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.g*255.0)/256.0, 0.375));\n    vec4 map_b = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.b*255.0)/256.0, 0.625));\n    vec4 map_a = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.a*255.0)/256.0, 0.875));\n\n    // u_plt_tex(u_textures[1])  BGRA  .bgra\n    // TODO  ARGB  .gbar\n    vec4 color = (map_r + map_g + map_b + map_a).bgra;\n\n    // fract  1.0, 2.0, ...  0.0  1.0 \n    vec4 color_fract = fract(color);\n    color = color_fract + sign(color) - sign(color_fract);\n\n#if ${t}\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#else\n    ${e.fragColor()} = vec4(color.rgb, 1.0);\n#endif\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t}\n    ${e.fragColor()} = src_color;\n#else\n    ${e.fragColor()} = vec4(src_color.rgb, 1.0);\n#endif\n}\n\n`}static COLOR_TRANSFORM(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 ct_mul = u_mediump[0];\n    vec4 ct_add = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n    vec4 color = clamp(ct_mul * src_color + ct_add, 0.0, 1.0);\n\n    color = vec4(color.rgb * color.a, color.a);\n\n#if !${t}\n    color.a = 1.0;\n#endif\n\n    ${e.fragColor()} = color * sign(src_color.a);  // \n}\n\n`}static bitwiseAnd(){return"\n#if __VERSION__ < 130\n// 8bit\nint bitwiseAnd(int a, int b) {\n    //ivec4 c1 = ivec4(1,2,4,8);\n    //ivec4 c2 = ivec4(16,32,64,128);\n\n    //ivec4 a1 = ivec4(a) / c1;\n    //ivec4 a2 = ivec4(a) / c2;\n    //ivec4 b1 = ivec4(b) / c1;\n    //ivec4 b2 = ivec4(b) / c2;\n\n    //ivec4 r = (a1-a1/2*2) * (b1-b1/2*2) * c1\n    //        + (a2-a2/2*2) * (b2-b2/2*2) * c2;\n\n    //return r.x + r.y + r.z + r.w;\n\n    //  intrakusanint\n    //  float\n\n    vec4 a0 = vec4(float(a));\n    vec4 b0 = vec4(float(b));\n    vec4 a1 = floor(a0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 a2 = floor(a0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n    vec4 b1 = floor(b0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 b2 = floor(b0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n\n    return int(dot((a1-floor(a1*0.5)*2.0)*(b1-floor(b1*0.5)*2.0), vec4(1.0,2.0,4.0,8.0))\n             + dot((a2-floor(a2*0.5)*2.0)*(b2-floor(b2*0.5)*2.0), vec4(16.0,32.0,64.0,128.0)));\n}\n\nivec4 bitwiseAnd(ivec4 a, ivec4 b) {\n    return ivec4(bitwiseAnd(a.r, b.r),\n                 bitwiseAnd(a.g, b.g),\n                 bitwiseAnd(a.b, b.b),\n                 bitwiseAnd(a.a, b.a));\n}\n#else\n#define bitwiseAnd(a, b) ((a)&(b))\n#endif\n"}static THRESHOLD(t,e,i,s){return e|=0,i|=0,`${s.version()}\n#if __VERSION__ < 130\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2]; // u_threshold(u_mediump[0]) JS\nuniform ivec4 u_integer;\n\n${s.varyingIn()} vec2 v_src_tex_coord;\n\n#if __VERSION__ < 130\n#define outColor0 gl_FragData[0]\n#define outColor1 gl_FragData[1]\n#else\nlayout (location = 0) out vec4 outColor0;\nlayout (location = 1) out vec4 outColor1;\n#endif\n\n${Ft.bitwiseAnd()}\n\nbool less(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) < 0.0;\n}\n\nbool greater(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) > 0.0;\n}\n\nbool lessEqual(vec4 x) {\n    return !greater(x);\n}\n\nbool greaterEqual(vec4 x) {\n    return !less(x);\n}\n\n//  equal  thresholdEqual \nbool thresholdEqual(vec4 x) {\n    return all(equal(x, u_mediump[0]));\n}\n\n//  notEqual  thresholdNotEqual \nbool thresholdNotEqual(vec4 x) {\n    return any(notEqual(x, u_mediump[0]));\n}\n\nvoid main() {\n    // Flash Player\n\n    vec4 src_color = ${s.texture2D()}(u_src_tex, v_src_tex_coord);\n    ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), u_integer);\n\n    if (${t}(vec4(masked))) {\n        outColor0 = u_mediump[1];\n        outColor1 = vec4(1.0);\n    } else {\n#if ${e}\n    #if ${i}\n        outColor0 = src_color;\n    #else\n        outColor0 = vec4(src_color.rgb, 1.0);\n    #endif\n        outColor1 = vec4(0.0);\n#else\n        discard;\n#endif\n    }\n}\n\n`}static THRESHOLD_SUBTOTAL(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2 src_tex_step   = u_mediump.xy;\n    float subtotal_loop = u_mediump.z;\n\n    float subtotal = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 4095.0; ++i) {      //  4095.0 \n        if (j++ >= subtotal_loop) {           // BitmapData.prototype.threshold \n            break;\n        }\n#else\n    for (float i = 0.0; i < subtotal_loop; ++i) {\n#endif\n        subtotal += ${t.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i).a;\n    }\n\n    vec4 v1 = floor(subtotal * vec4(1.0, 0.00390625, 0.0000152587890625, 5.960464477539063e-8));  // vec4(1.0, 1.0/256.0, 1.0/65536.0, 1.0/16777216.0)\n    vec4 v2 = vec4(v1.yzw, 0.0);\n    ${t.fragColor()} = (v1 - v2*256.0) * 0.00392156862745098;  // 1.0/255.0\n}\n\n`}static GET_COLOR_BOUNDS_RECT(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\nuniform ivec4 u_integer[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\n${Ft.bitwiseAnd()}\n\nvoid main() {\n    vec2 src_tex_step = u_mediump.xy;\n    float scan_loop   = u_mediump.z;\n    ivec4 mask  = u_integer[0];\n    ivec4 color = u_integer[1];\n\n    float found = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 8191.0; ++i) {      // BitmapData  8191 \n        if (j++ >= scan_loop) {\n            break;\n        }\n#else\n    for (float i = 0.0; i < scan_loop; ++i) {\n#endif\n        vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i);\n        ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), mask);\n\n#if ${t}\n        if (all(equal(masked, color))) {\n#else\n        if (any(notEqual(masked, color))) {\n#endif\n            found = 1.0;\n            break;\n        }\n    }\n\n    ${e.fragColor()} = vec4(found);\n}\n\n`}static NOISE(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[3];\n\n${t.outColor()}\n\n// https://stackoverflow.com/a/28095165\n//\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio\n\nvec4 gold_noise(vec2 xy, vec4 seed) {\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvoid main() {\n    vec4 seed = u_mediump[0];\n    vec4 amp  = u_mediump[1];\n    vec4 low  = u_mediump[2];\n\n    vec4 noise = gold_noise(gl_FragCoord.xy, seed);\n    vec4 color = noise * amp + low;\n    ${t.fragColor()} = vec4(color.rgb * color.a, color.a);\n}\n\n`}static GET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb / max(0.0001, color.a), color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr / max(0.0001, color.a), color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.a, color.rgb / max(0.0001, color.a));\n#endif\n}\n\n`}static SET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr * color.a, color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.gba * color.r, color.r);\n#endif\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_dst_tex;\n\n${t.varyingIn()} vec2 v_dst_tex_coord;\n${t.varyingIn()} vec4 v_color;\n${t.outColor()}\n\nvoid main() {\n    float da = ${t.texture2D()}(u_dst_tex, v_dst_tex_coord).a;\n    float a = v_color.a;\n\n    ${t.fragColor()} = max( a, 0.0) * v_color\n                     + max(-a, 0.0) * vec4(v_color.rgb * da, da);\n}\n\n`}}class Bt{static TEMPLATE(t,e){const i=e?"uniform vec4 u_mediump[2];":"",s=e?wt.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${i}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src = ${t.texture2D()}(u_texture, v_coord);\n    ${s}\n    ${t.fragColor()} = src;\n}\n\n`}}const Lt=new Array(32);class It{constructor(){this._$rgb=L.RGB,this._$mode=k.PAD,this._$focalPointRatio=0,this._$points=s.$getFloat32Array6(),this._$stops=s.$getArray(),this._$type=null}linear(t,e,i,s,r=L.RGB,n=k.PAD){return this._$type=w.LINEAR,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,r,n,a,o=L.RGB,h=k.PAD,l=0){return this._$type=w.RADIAL,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=r,this._$points[4]=n,this._$points[5]=a,this._$rgb=o,this._$mode=h,this._$focalPointRatio=s.$clamp(l,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push([t,e]),this._$stops.sort((function(t,e){switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}}))}}class Pt{constructor(t=null,e=null,i=null){this._$initialization(t,e,i)}_$initialization(t=null,e=null,i=null){return this._$texture=t,this._$repeat=e,this._$color_transform=i,this}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$color_transform}}class Dt{constructor(t,e){this._$gl=t;const i=e?s.$min(s.$currentPlayer().getSamples(),t.getParameter(t.MAX_SAMPLES)):0;this._$isWebGL2Context=e,this._$maxTextureSize=s.$min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new Xt,this._$style=this._$contextStyle,this._$fillBuffer=null,this._$strokeBuffer=null,this._$cacheCurrentBounds={x:0,y:0,w:0,h:0},this._$cacheCurrentBuffer=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation=S.NORMAL,this._$matrix=s.$getFloat32Array9(1,0,0,0,1,0,0,0,1),this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new jt(t,e,i),this._$path=new Gt,this._$grid=new Ut,this._$offsetX=0,this._$offsetY=0,this._$blends=[],this._$positions=[],this._$isLayer=!1,this._$shaderList=new Qt(this,t),this._$gradientLUT=new Jt(this,t),this._$vao=new qt(t,e),this._$pbo=new Vt(t,e),this._$mask=new kt(this,t),this._$blend=new Nt(this,t),this._$canvasPatternToWebGL=new Pt,this._$canvasGradientToWebGL=new It}get canvas(){return this._$gl.canvas}get fillStyle(){return this._$style._$fillStyle}set fillStyle(t){this._$style._$fillStyle.constructor===Float32Array&&s.$poolFloat32Array4(this._$style._$fillStyle),this._$style._$fillStyle=t}get strokeStyle(){return this._$style._$strokeStyle}set strokeStyle(t){this._$style._$strokeStyle.constructor===Float32Array&&s.$poolFloat32Array4(this._$style._$strokeStyle),this._$style._$strokeStyle=t}get lineWidth(){return this._$style._$lineWidth}set lineWidth(t){this._$style._$lineWidth=t}get lineCap(){return this._$style._$lineCap}set lineCap(t){switch(t){case C.NONE:case C.SQUARE:this._$style._$lineCap=t;break;default:this._$style._$lineCap=C.ROUND}}get lineJoin(){return this._$style._$lineJoin}set lineJoin(t){switch(t){case I.BEVEL:case I.MITER:this._$style._$lineJoin=t;break;default:this._$style._$lineJoin=I.ROUND}}get miterLimit(){return this._$style._$miterLimit}set miterLimit(t){this._$style._$miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=s.$clamp(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=s.$toBoolean(t)}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get pbo(){return this._$pbo}get blend(){return this._$blend}_$bind(t){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e.dirty||i&&i.dirty)&&(e.dirty=!1,i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}fillRect(t,e,i,r){if(!i||!r)return;this._$viewportWidth=i,this._$viewportHeight=r;let n=!1;if(!this._$fillBuffer){n=!0;const a=this._$path.createRectVertices(t,e,i,r);this._$fillBuffer=this._$vao.createFill(a),s.$poolArray(a.pop()),s.$poolArray(a)}const a=this._$grid.enabled,o=this._$shaderList.shapeShaderVariants,h=o.getSolidColorShapeShader(!1,a),l=h.uniform;o.setSolidColorShapeUniform(l,!1,0,0,0,a,this._$matrix,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha),h._$fill(this._$fillBuffer),n&&(this._$vao.release(this._$fillBuffer),s.$poolArray(this._$fillBuffer.indexRanges)),this.beginPath()}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}transform(t,e,i,s,r,n){const a=this._$matrix[0],o=this._$matrix[1],h=this._$matrix[3],l=this._$matrix[4],$=this._$matrix[6],_=this._$matrix[7];this._$matrix[0]=t*a+e*h,this._$matrix[1]=t*o+e*l,this._$matrix[3]=i*a+s*h,this._$matrix[4]=i*o+s*l,this._$matrix[6]=r*a+n*h+$,this._$matrix[7]=r*o+n*l+_}drawImage(t,e,i,s,r,n=null){let a=1,o=1,h=1,l=this._$globalAlpha,$=0,_=0,c=0;n&&(a=n[0],o=n[1],h=n[2],$=n[4]/255,_=n[5]/255,c=n[6]/255),this._$blend.drawImage(t,e,i,s,r,a,o,h,l,$,_,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$startClip(t,e){return this._$mask._$startClip(t,e)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin(),this._$isGraphics&&(this._$fillBuffer&&(this.vao.release(this._$fillBuffer),this.vao.release(this._$fillBuffer.boundObject),s.$poolArray(this._$fillBuffer.indexRanges),s.$poolArray(this._$fillBuffer.boundObject.indexRanges)),this._$strokeBuffer&&this.vao.release(this._$strokeBuffer)),this._$isGraphics=!1,this._$fillBuffer=null,this._$strokeBuffer=null}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}_$getVertices(){return this._$path.vertices}fill(){let t,e,i,r=this._$matrix;switch(!0){case this.fillStyle.constructor===It:switch(this.fillStyle._$type){case w.LINEAR:break;default:r=this._$stack[this._$stack.length-1]}break;case this.fillStyle.constructor===Pt:r=this._$stack[this._$stack.length-1]}const n=this._$grid.enabled;switch(!0){case this.fillStyle.constructor===It:const a=this.fillStyle,o=a._$stops,h="linearRGB"===a._$rgb;if(t=this._$gradientLUT.generateForShape(o,h),this._$frameBufferManager._$textureManager.bind0(t,!0),e=this._$shaderList.gradientShapeShaderVariants,a._$type===w.LINEAR)i=e.getGradientShapeShader(!1,n,!1,!1,a._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,n,r,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,a._$points,0);else{const t=0!==a._$focalPointRatio;i=e.getGradientShapeShader(!1,n,!0,t,a._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,n,r,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,a._$points,a._$focalPointRatio)}break;case this.fillStyle.constructor===Pt:const l=this.fillStyle,$=l.colorTransform;t=l.texture,this._$frameBufferManager._$textureManager.bind0(t,this._$imageSmoothingEnabled),e=this._$shaderList.shapeShaderVariants,i=e.getBitmapShapeShader(!1,""!==l.repeat,n),$?e.setBitmapShapeUniform(i.uniform,!1,0,0,0,n,r,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,$[0],$[1],$[2],this._$globalAlpha,$[4]/255,$[5]/255,$[6]/255,0):e.setBitmapShapeUniform(i.uniform,!1,0,0,0,n,r,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,1,1,1,this._$globalAlpha,0,0,0,0);break;default:e=this._$shaderList.shapeShaderVariants,i=e.getSolidColorShapeShader(!1,this._$grid.enabled),e.setSolidColorShapeUniform(i.uniform,!1,0,0,0,n,r,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha)}const a=this._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,n);if(a.setMaskShapeUniform(o.uniform,n,r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],this._$viewportWidth,this._$viewportHeight,this._$grid),!this._$fillBuffer){const t=this._$getVertices();if(!t.length)return;const e=s.$getArray();for(let i=0;i<t.length;++i){const s=t[i];9>s.length||e.push(s)}if(!e.length)return;this._$isGraphics=!0,this._$fillBuffer=this._$vao.createFill(e);const i=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(i),s.$poolArray(i.pop()),s.$poolArray(i)}this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),o._$fill(this._$fillBuffer),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),i._$fill(this._$fillBuffer.boundObject),this._$gl.disable(this._$gl.STENCIL_TEST)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}_$unionStencilMask(t,e,i){this._$mask._$unionStencilMask(t,e,i)}closePath(){this._$path.close()}stroke(){if(!this._$strokeBuffer){const t=this._$getVertices();if(!t.length)return;const e=s.$getArray();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return;this._$isGraphics=!0,this._$strokeBuffer=this._$vao.createStroke(t,this.lineCap,this.lineJoin)}let t=this._$matrix;switch(!0){case this.strokeStyle.constructor===It:switch(this.strokeStyle._$type){case w.LINEAR:break;default:t=this._$stack[this._$stack.length-1]}break;case this.strokeStyle.constructor===Pt:t=this._$stack[this._$stack.length-1]}let e=s.$sign(t[0]*t[4]);e>0&&0!==t[1]&&0!==t[3]&&(e=-s.$sign(t[1]*t[3]));let i,r,n=.5*this.lineWidth;this._$grid.enabled?(n*=s.$getSameScaleBase(),i=s.$abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),r=s.$abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(i=s.$abs(t[0]+t[3]),r=s.$abs(t[1]+t[4]));const a=s.$min(i,r),o=s.$max(i,r);let h,l,$;n*=o*(1-.3*s.$cos(.5*s.$PI*(a/o))),n=s.$max(1,n);const _=this._$grid.enabled;switch(!0){case this.strokeStyle.constructor===It:const i=this.strokeStyle,r=i._$stops,a="linearRGB"===i._$rgb;if(h=this._$gradientLUT.generateForShape(r,a),this._$frameBufferManager._$textureManager.bind0(h,!0),l=this._$shaderList.gradientShapeShaderVariants,i._$type===w.LINEAR)$=l.getGradientShapeShader(!0,_,!1,!1,i._$mode),l.setGradientShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,i._$points,0);else{const r=0!==i._$focalPointRatio;$=l.getGradientShapeShader(!0,_,!0,r,i._$mode),l.setGradientShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,i._$points,i._$focalPointRatio)}break;case this.strokeStyle.constructor===Pt:const o=this.strokeStyle,c=o.colorTransform;h=o.texture,this._$frameBufferManager._$textureManager.bind0(h),l=this._$shaderList.shapeShaderVariants,$=l.getBitmapShapeShader(!0,""!==o.repeat,this._$grid.enabled),c?l.setBitmapShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,h.width,h.height,c[0],c[1],c[2],this._$globalAlpha,c[4]/255,c[5]/255,c[6]/255,0):l.setBitmapShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,s.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,h.width,h.height,1,1,1,this._$globalAlpha,0,0,0,0);break;default:l=this._$shaderList.shapeShaderVariants,$=l.getSolidColorShapeShader(!0,this._$grid.enabled),l.setSolidColorShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,this._$viewportWidth,this._$viewportHeight,this._$grid,this.strokeStyle,this._$globalAlpha)}$._$stroke(this._$strokeBuffer)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(t=!1){const e=this._$shaderList.shapeShaderVariants,i=e.getMaskShapeShader(!1,!1),r=i.uniform;if(e.setMaskShapeUniform(r,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),!this._$fillBuffer){this._$fillBuffer=this._$vao.createFill(this._$getVertices());const t=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(t),s.$poolArray(t.pop()),s.$poolArray(t)}this._$mask._$onClip(this._$matrix,this._$viewportWidth,this._$viewportHeight)||(i._$fill(this._$fillBuffer),t&&(this._$vao.release(this._$fillBuffer),this._$vao.release(this._$fillBuffer.boundObject),s.$poolArray(this._$fillBuffer.indexRanges),s.$poolArray(this._$fillBuffer.boundObject.indexRanges),this._$fillBuffer=null),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(s.$getFloat32Array9(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){this._$stack.length&&(s.$poolFloat32Array9(this._$matrix),this._$matrix=this._$stack.pop()),this._$mask._$onRestore()}createPattern(t,e,i){return this._$canvasPatternToWebGL._$initialization(t,e,i)}createLinearGradient(t,e,i,s,r=L.RGB,n=k.PAD){return this._$canvasGradientToWebGL.linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a=L.RGB,o=k.PAD,h=0){return this._$canvasGradientToWebGL.radial(t,e,i,s,r,n,a,o,h)}_$applyBlurFilter(t,e,i){const r=this._$frameBufferManager.currentAttachment,n=r.width,a=r.height;this._$frameBufferManager._$textureManager.bind0(t,!0);const o=s.$ceil(.5*i),h=1-(o-.5*i),l=1+i,$=this._$shaderList.filterShaderVariants,_=$.getBlurFilterShader(o);$.setBlurFilterUniform(_.uniform,n,a,e,h,l),_._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,p,f,m,x,b,T,v,y,E,A,M,S){const C=c===H.INNER,R=this._$frameBufferManager.currentAttachment,w=this._$frameBufferManager.getTextureFromCurrentAttachment();let O;const F=null!==f;let B;F&&(O=this._$gradientLUT.generateForFilter(f,m,x)),C?F?this._$frameBufferManager._$textureManager.bind02(t,O,!0):this._$frameBufferManager._$textureManager.bind0(t):(B=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(B),F?this._$frameBufferManager._$textureManager.bind012(t,w,O,!0):this._$frameBufferManager._$textureManager.bind01(t,w));const L=!(C||c===H.FULL&&u),I=!(e===o&&i===h&&0===l&&0===$),P=!(1===d),D=this._$shaderList.filterShaderVariants,N=D.getBitmapFilterShader(L,I,_,c,u,P,F);D.setBitmapFilterUniform(N.uniform,e,i,s,r,n,a,o,h,l,$,_,d,b,T,v,y,E,A,M,S,L,I,P,F),C?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),N._$drawImage(),C||this._$frameBufferManager.releaseAttachment(R,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager._$textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,o,h,l,$,_){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager._$textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,p=g.getConvolutionFilterShader(e,i,a,o);g.setConvolutionFilterUniform(p.uniform,c,u,s,r,n,o,h,l,$,_),this.blend.reset(),p._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.width,g=t.height,p=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(p),r||(r={x:0,y:0}),this._$frameBufferManager._$textureManager.bind01(t,e);const f=this._$shaderList.filterShaderVariants,m=f.getDisplacementMapFilterShader(n,a,l);f.setDisplacementMapFilterUniform(m.uniform,e.width,e.height,i,s,r.x,r.y,o,h,l,$,_,c,u),this.blend.reset(),m._$drawImage()}getImageData(t,e,i,r){const n=i*r*4,a=s.$getUint8Array(n);this._$gl.readPixels(t,r-(r-e),i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,a);for(let t=0;t<n;t+=4){const e=a[t+3];e&&(a[t]=255&s.$min(255*a[t]/e,255),a[t+1]=255&s.$min(255*a[t+1]/e,255),a[t+2]=255&s.$min(255*a[t+2]/e,255))}return a}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){s.$poolBoundsObject(this._$positions.pop()),this._$isLayer=s.$toBoolean(this._$blends.pop())}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$textureScale(t,e){const i=s.$max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}characterToTexture(t){if(!t.state){if(t.jpegData&&(t.image.complete?(t.width=t.image.width,t.height=t.image.height):(s.$jpegDecoder.parse(t.jpegData),t.width=s.$jpegDecoder.width,t.height=s.$jpegDecoder.height,t.pixels=s.$getUint8Array(s.$jpegDecoder.width*s.$jpegDecoder.height*4),s.$jpegDecoder.copyToImageData(t),t.image=null)),!t.alphaData&&t.alpha&&t.alpha.length){const e=new Zlib.Inflate(t.alpha,{bufferSize:t.width*t.height}).decompress();s.$poolUint8Array(t.alpha),t.alpha=null,t.alphaData=e}t.state=1}const e=this._$frameBufferManager,i=e.currentAttachment,r=t.image?e.createTextureFromImage(t.image):e.createTextureFromPixels(t.width,t.height,t.pixels,!0);if(t.alphaData){const i=e.createTextureAttachmentFrom(r);this._$bind(i);e.createAlphaTextureFromPixels(t.width,t.height,t.alphaData);const s=this._$shaderList.bitmapShaderVariants.getBitmapShader();this.blend.toZeroOne(),s._$drawImage(),e.releaseAttachment(i,!1)}return this._$bind(i),r}changeSamples(t=4){if(this._$isWebGL2Context){t=s.$min(t,this._$gl.getParameter(this._$gl.MAX_SAMPLES));const e=this._$frameBufferManager;e._$objectPool=[],e._$colorBufferPool._$objectPool=[],e._$stencilBufferPool._$objectPool=[],e._$colorBufferPool._$samples=t}}}class Nt{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case S.ADD:this.toAdd();break;case S.SCREEN:this.toScreen();break;case S.ALPHA:this.toAlpha();break;case S.ERASE:this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,i,r,n,a,o,h,l,$,_,c,u,d,g,p,f,m){const x=this._$context._$frameBufferManager.currentAttachment,b=1!==a||1!==o||1!==h||1!==l||0!==$||0!==_||0!==c||0!==u,T=this._$context._$shaderList.blendShaderVariants;switch(d){case S.NORMAL:case S.LAYER:case S.ADD:case S.SCREEN:case S.ALPHA:case S.ERASE:case"copy":{this._$context._$frameBufferManager._$textureManager.bind0(t,m);const x=T.getNormalBlendShader(b);T.setNormalBlendUniform(x.uniform,e,i,r,n,f,g,p,b,a,o,h,l,$,_,c,u);const v=f[0],y=f[1],E=f[3],A=f[4],M=f[6],S=f[7];if(1!==v||0!==y||0!==E||1!==A){const t=e+r,a=i+n,o=+(t*v+a*E+M),h=+(t*v+i*E+M),l=+(e*v+a*E+M),$=+(e*v+i*E+M),_=+(t*y+a*A+S),c=+(t*y+i*A+S),u=+(e*y+a*A+S),d=+(e*y+i*A+S),f=s.$MAX_VALUE,m=+s.$min(s.$min(s.$min(s.$min(f,o),h),l),$),x=+s.$max(s.$max(s.$max(s.$max(-f,o),h),l),$),b=+s.$min(s.$min(s.$min(s.$min(f,_),c),u),d),T=+s.$max(s.$max(s.$max(s.$max(-f,_),c),u),d),C=s.$max(0,0|m),R=s.$max(0,0|b),w=s.$min(s.$max(0,g-C),s.$ceil(s.$abs(x-m))),O=s.$min(s.$max(0,p-R),s.$ceil(s.$abs(T-b)));if(!w||!O)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(C,s.$max(0,p-(R+O)),w+1,O+1)}else{const t=s.$max(0,e+M|0),a=s.$max(0,i+S|0),o=s.$min(s.$max(0,g-t),r),h=s.$min(s.$max(0,p-a),n);if(!o||!h)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,s.$max(0,p-(a+h)),o+1,h+1)}this.toOperation(d),x._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const v=s.$max(0,e+f[6]|0),y=s.$max(0,i+f[7]|0),E=s.$min(s.$max(0,g-v),r),A=s.$min(s.$max(0,p-y),n);if(!E||!A)return;const M=this._$context._$frameBufferManager.getTextureFromCurrentAttachment(),S=this._$context._$frameBufferManager.createTextureAttachment(r,n);this._$context._$bind(S),this._$context._$frameBufferManager._$textureManager.bind0(M);const C=T.getClipShader(),R=C.uniform;T.setClipUniform(R,e,i,r,n,s.$inverseMatrix(f),g,p),this.reset(),C._$drawImage();const w=this._$context._$frameBufferManager.getTextureFromCurrentAttachment();this._$context._$bind(x),this._$context._$frameBufferManager._$textureManager.bind01(w,t,m);const O=T.getBlendShader(d,b);T.setBlendUniform(O.uniform,e,i,r,n,f,g,p,b,a,o,h,l,$,_,c,u),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(v,s.$max(0,p-(y+A)),E,A),this.toOneZero(),O._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),this._$context._$frameBufferManager.releaseAttachment(S,!0)}}}}class Ut{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,i,r,n,a,o,h,l,$,_,c,u,d,g,p,f,m){const x=n.xMax-n.xMin,b=n.yMax-n.yMin,T=a._$width,v=a._$height,y=s.$getSameScaleBase(),E=s.$abs(s.$ceil(x*y)),A=s.$abs(s.$ceil(b*y)),M=T>0?(a._$x-n.xMin)/x:1e-5,S=v>0?(a._$y-n.yMin)/b:1e-5,C=T>0?(a._$x+a._$width-n.xMin)/x:.99999,R=v>0?(a._$y+a._$height-n.yMin)/b:.99999;let w=E*M/i,O=A*S/r,F=(i-E*(1-C))/i,B=(r-A*(1-R))/r;if(w>=F){const t=M/(M+(1-C));w=s.$max(t-1e-5,0),F=s.$min(t+1e-5,1)}if(O>=B){const t=S/(S+(1-R));O=s.$max(t-1e-5,0),B=s.$min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=o,this.parentMatrixB=h,this.parentMatrixD=l,this.parentMatrixE=$,this.parentMatrixG=_,this.parentMatrixH=c,this.ancestorMatrixA=u,this.ancestorMatrixB=d,this.ancestorMatrixD=g,this.ancestorMatrixE=p,this.ancestorMatrixG=f,this.ancestorMatrixH=m,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=i,this.parentViewportH=r,this.minXST=M,this.minYST=S,this.minXPQ=w,this.minYPQ=O,this.maxXST=C,this.maxYST=R,this.maxXPQ=F,this.maxYPQ=B}disable(){this.enabled=!1}}class kt{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$clipStatus=!1,this._$containerClip=!1,this._$poolClip=[],this._$currentClip=!1}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context._$frameBufferManager,e=t.getTextureFromCurrentAttachment(),i=t.currentAttachment;this._$context._$bind(this._$context._$cacheCurrentBuffer),this._$context._$cacheCurrentBuffer=null,this._$context._$blend.disable();const r=this._$context._$cacheCurrentBounds.x,n=this._$context._$cacheCurrentBounds.y,a=this._$context._$cacheCurrentBounds.w,o=this._$context._$cacheCurrentBounds.h;s.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(e,r,n,a,o),this._$context._$blend.enable(),t.releaseAttachment(i,!0)}_$startClip(t,e){const i=s.$multiplicationMatrix(e,t._$transform._$rawMatrix()),r=t._$getBounds(null),n=s.$boundsMatrix(r,i);s.$poolFloat32Array9(i),s.$poolBoundsObject(r);let a=n.xMin,o=n.yMin,h=s.$abs(n.xMax-n.xMin),l=s.$abs(n.yMax-n.yMin);s.$poolBoundsObject(n);const $=this._$context._$frameBufferManager,_=$.currentAttachment;if(h+a>_.texture.width&&(h-=h-_.texture.width+a),l+o>_.texture.height&&(l-=l-_.texture.height+o),0>a&&(h+=a,a=0),0>o&&(l+=o,o=0),0>=h||0>=l)return null;h=s.$ceil(h),l=s.$ceil(l),this._$context._$cacheCurrentBounds.x=a,this._$context._$cacheCurrentBounds.y=o,this._$context._$cacheCurrentBounds.w=h,this._$context._$cacheCurrentBounds.h=l;const c=$.getTextureFromCurrentAttachment();this._$context._$cacheCurrentBuffer=_;const u=s.$currentPlayer(),d=!this._$context._$isWebGL2Context||u._$quality!==X.LOW&&u._$quality!==X.MIDDLE?0:s.$min(s.$HIGH_SAMPLES,this._$gl.getParameter(this._$gl.MAX_SAMPLES)),g=$.createCacheAttachment(h,l,!0,d);return this._$context._$bind(g),s.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(c,-a,-o,c.width,c.height),s.$getFloat32Array9(e[0],e[1],e[2],e[3],e[4]-a,e[5]-o)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context._$frameBufferManager.currentAttachment;t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context._$frameBufferManager.currentAttachment;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context._$frameBufferManager.currentAttachment.clipLevel;let e=0;for(let i=0;i<t;++i)e|=(1<<t-i)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&e,e),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context._$frameBufferManager.currentAttachment;if(--t.clipLevel,t.mask=s.$toBoolean(t.clipLevel),!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context._$cacheCurrentBuffer&&this._$endClip());const e=t.width,i=t.height,r=this._$context._$path.createRectVertices(0,0,e,i),n=this._$context._$vao.createFill(r);s.$poolArray(r.pop()),s.$poolArray(r);const a=this._$context._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,!1),h=o.uniform;a.setMaskShapeUniformIdentity(h,e,i);const l=n.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),o._$containerClip(n,l.first,l.count),this._$context._$vao.release(n),s.$poolArray(n.indexRanges),this._$context._$endClipDef()}_$drawContainerClip(){const t=this._$context._$frameBufferManager.currentAttachment,e=t.clipLevel,i=this._$poolClip.length,s=this._$context._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;let a=e;const o=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);for(let t=0;t<i;++t){const t=this._$poolClip.shift();s.setMaskShapeUniform(n,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const i=t.fillBuffer.indexRanges.length;for(let e=0;e<i;++e){const i=t.fillBuffer.indexRanges[e];this._$gl.stencilMask(1<<a-1),r._$containerClip(t.fillBuffer,i.first,i.count)}++a,a>7&&(this._$context._$unionStencilMask(e,o,h),a=e)}a>e+1&&this._$context._$unionStencilMask(e,o,h)}_$unionStencilMask(t,e,i){const r=this._$context._$path.createRectVertices(0,0,e,i),n=this._$context._$vao.createFill(r);s.$poolArray(r.pop()),s.$poolArray(r);const a=this._$context._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,!1),h=o.uniform;a.setMaskShapeUniformIdentity(h,e,i);const l=n.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),o._$containerClip(n,l.first,l.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT)),this._$context._$vao.release(n),s.$poolArray(n.indexRanges)}_$onClip(t,e,i){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip[this._$poolClip.length]={fillBuffer:this._$context._$fillBuffer,matrixA:t[0],matrixB:t[1],matrixC:t[2],matrixD:t[3],matrixE:t[4],matrixF:t[5],matrixG:t[6],matrixH:t[7],matrixI:t[8],viewportWidth:e,viewportHeight:i},!0)}_$onSave(){this._$clips[this._$clips.length]=this._$clipStatus}_$onRestore(){this._$clips.length&&(this._$clipStatus=s.$toBoolean(this._$clips.pop()))}}class Gt{constructor(){this._$currentPath=[],this._$vertices=[],this._$bounds={xMin:0,xMax:0,yMin:0,yMax:0},this._$resetBounds()}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)s.$poolArray(this._$vertices.pop());this._$resetBounds()}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,r,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(r,n))return;const a=this._$currentPath[this._$currentPath.length-3],o=this._$currentPath[this._$currentPath.length-2];(class{static cubicToQuad(t,e,i,s,r,n,a,o){this._$split2Cubic(t,e,i,s,r,n,a,o,0,16),this._$split2Cubic(Lt[0],Lt[1],Lt[2],Lt[3],Lt[4],Lt[5],Lt[6],Lt[7],0,8),this._$split2Cubic(Lt[16],Lt[17],Lt[18],Lt[19],Lt[20],Lt[21],Lt[22],Lt[23],16,24),this._$split2Quad(Lt[0],Lt[1],Lt[2],Lt[3],Lt[4],Lt[5],Lt[6],Lt[7],0),this._$split2Quad(Lt[8],Lt[9],Lt[10],Lt[11],Lt[12],Lt[13],Lt[14],Lt[15],8),this._$split2Quad(Lt[16],Lt[17],Lt[18],Lt[19],Lt[20],Lt[21],Lt[22],Lt[23],16),this._$split2Quad(Lt[24],Lt[25],Lt[26],Lt[27],Lt[28],Lt[29],Lt[30],Lt[31],24)}static _$split2Cubic(t,e,i,s,r,n,a,o,h,l){const $=.125*(t+3*(i+r)+a),_=.125*(e+3*(s+n)+o),c=.125*(a+r-i-t),u=.125*(o+n-s-e);Lt[h]=t,Lt[h+1]=e,Lt[h+2]=.5*(t+i),Lt[h+3]=.5*(e+s),Lt[h+4]=$-c,Lt[h+5]=_-u,Lt[h+6]=$,Lt[h+7]=_,Lt[l]=$,Lt[l+1]=_,Lt[l+2]=$+c,Lt[l+3]=_+u,Lt[l+4]=.5*(r+a),Lt[l+5]=.5*(n+o),Lt[l+6]=a,Lt[l+7]=o}static _$split2Quad(t,e,i,s,r,n,a,o,h){const l=.125*(t+3*(i+r)+a),$=.125*(e+3*(s+n)+o);Lt[h]=.25*t+.75*i,Lt[h+1]=.25*e+.75*s,Lt[h+2]=l,Lt[h+3]=$,Lt[h+4]=.75*r+.25*a,Lt[h+5]=.75*n+.25*o,Lt[h+6]=a,Lt[h+7]=o}}).cubicToQuad(a,o,t,e,i,s,r,n);const h=Lt.length;for(let t=0;t<h;t+=4)this.quadTo(Lt[t],Lt[t+1],Lt[t+2],Lt[t+3])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=this._$currentPath[0],e=this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=this._$currentPath[this._$currentPath.length-3],s=this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t),this._$currentPath.push(e),this._$currentPath.push(i),this._$bounds.xMin=s.$min(t,this._$bounds.xMin),this._$bounds.xMax=s.$max(t,this._$bounds.xMax),this._$bounds.yMin=s.$min(e,this._$bounds.yMin),this._$bounds.yMax=s.$max(e,this._$bounds.yMax)}_$pushCurrentPathToVertices(){this._$currentPath.length<=3?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=s.$getArray())}_$resetBounds(){const t=s.$MAX_VALUE;this._$bounds.xMin=t,this._$bounds.xMax=-t,this._$bounds.yMin=t,this._$bounds.yMax=-t}getBoundsVertices(){return s.$getArray(s.$getArray(this._$bounds.xMin,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMax,!1,this._$bounds.xMin,this._$bounds.yMax,!1))}createRectVertices(t,e,i,r){return s.$getArray(s.$getArray(t,e,!1,t+i,e,!1,t+i,e+r,!1,t,e+r,!1))}}class Xt{constructor(){this._$fillStyle=new s.$window.Float32Array([1,1,1,1]),this._$strokeStyle=new s.$window.Float32Array([1,1,1,1]),this._$lineWidth=1,this._$lineCap=0,this._$lineJoin=0,this._$miterLimit=5}}class Yt{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=[]}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();return t.stencil=this._$gl.createRenderbuffer(),t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}return this._$objectPool.shift()}create(t,e,i=0){t=s.$max(256,s.$upperPowerOfTwo(t)),e=s.$max(256,s.$upperPowerOfTwo(e));const r=this._$getColorBuffer(t*e);return(r.width<t||r.height<e||i&&r.samples!==i)&&(t=s.$max(t,r.width),e=s.$max(e,r.height),r.samples=i||this._$samples,r.width=t,r.height=e,r.area=t*e,r.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.STENCIL_INDEX8,t,e)),r}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;s.$abs(i-e)>1;){const r=s.$floor((i+e)/2);t<=this._$objectPool[r].area?i=r:e=r}return i}}const Ht={vertices:null};Ht.subhulls=new Array(512),Ht.subhullsIndex=0,Ht.extremePoints=new Array(32),Ht.extremePointsIndex=0,Ht.t=0,Ht.hulls=[new Array(16),new Array(64),new Array(256)],Ht.hullsIndex=0;class jt{constructor(t,e,i){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),this._$frameBufferTexture=null,this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new zt(t,e),this._$colorBufferPool=null,this._$stencilBufferPool=new Wt(t),e&&(this._$frameBufferTexture=t.createFramebuffer(),this._$colorBufferPool=new Yt(t,i),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer))}get currentAttachment(){return this._$currentAttachment}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.length?this._$objectPool.pop():{},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,this._$isWebGL2Context&&i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(n.width,n.height)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}createTextureAttachment(t,e){const i=this._$objectPool.length?this._$objectPool.pop():{},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.length?this._$objectPool.pop():{};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t,e=!1){t.isActive&&(t.msaa?this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):(this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment.msaa)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t){return this._$textureManager.createFromImage(t)}createAlphaTextureFromPixels(t,e,i){return this._$textureManager.createAlpha(t,e,i)}createTextureFromVideo(t,e=!1,i=null){return this._$textureManager.createFromVideo(t,e,i)}createTextureFromCurrentAttachment(){const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class Vt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[]}_$getPixelBufferObject(t){if(!this._$objectPool.length){const t=this._$gl.createBuffer();return t.size=0,t}for(let e=0;e<this._$objectPool.length;e++){const i=this._$objectPool[e];if(i.size===t)return this._$objectPool.splice(e,1),i}return this._$objectPool.shift()}readPixelsAsync(t,e,i,s){if(!this._$isWebGL2Context)return null;const r=i*s*4,n=this._$getPixelBufferObject(r);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,n),n.size!==r&&(n.size=r,this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER,r,this._$gl.DYNAMIC_COPY)),this._$gl.readPixels(t,e,i,s,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,0),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),n}getBufferSubDataAsync(t){const e=s.$getUint8Array(t.size);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,t),this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER,0,e),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),this._$objectPool.push(t),e}release(t){this._$objectPool.push(t)}}class Wt{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;s++){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)return console.log("release: ",t.area,this._$maxWidth,this._$maxHeight),void this._$gl.deleteRenderbuffer(t);if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t)}}}class zt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(e,i){const s=this._$gl.createTexture();return s.width=0,s.height=0,s.area=0,s.dirty=!0,s.smoothing=!0,s._$offsetX=0,s._$offsetY=0,this.bind0(s,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$isWebGL2Context&&(s.width=e,s.height=i,s.area=e*i,s.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,e,i),t.glstats&&glstats.ontex(s.area)),s}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}createAlpha(t,e,i){return this._$alphaTexture?this.bind0(this._$alphaTexture):(this._$alphaTexture=this._$gl.createTexture(),this.bind0(this._$alphaTexture),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST)),this._$alphaTexture.width=t,this._$alphaTexture.height=e,this._$alphaTexture.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.ALPHA,t,e,0,this._$gl.ALPHA,this._$gl.UNSIGNED_BYTE,i),this._$alphaTexture}create(e,i,s=null,r=!1,n=!0){const a=this._$getTexture(e,i);return r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,a.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,e,i,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),t.glstats&&glstats.ontex(a.area)):s&&(a.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,e,i,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s)),r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),a}createFromImage(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromVideo(t,e=!1,i=null){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e,i)}_$createFromElement(e,i,s,r=!1,n=null){const a=n||this._$getTexture(e,i);return a.dirty=!1,this.bind0(a,r),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),t.glstats&&glstats.ontex(a.area)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),a}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i,r){const n=i!==this._$boundTextures[t],a=null!==r&&r!==i.smoothing;if((n||a)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),n&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),a){i.smoothing=r;const t=r&&s.$currentPlayer()._$quality!==X.LOW?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class qt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$extension=e?null:t.getExtension("OES_vertex_array_object"),this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new s.$window.Float32Array([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$createVertexArray(){return this._$isWebGL2Context?this._$gl.createVertexArray():this._$extension.createVertexArrayOES()}_$getVertexArray(t,e){const i=this._$createVertexArray();this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length)return this._$fillVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length)return this._$strokeVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=class{static generate(t){let e=0;for(let i=0;i<t.length;i++)e+=12*(t[i].length/3-2);this._$vertexBufferData=new s.$Float32Array(e),this._$indexRanges=s.$getArray(),this._$currentIndex=0;for(let e=0;e<t.length;e++){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i;this._$indexRanges.push({first:i,count:s})}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}.generate(t),i=e.vertexBufferData,r=this._$getFillVertexArray();return r.indexRanges=e.indexRanges,this.bind(r),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,r.vertexBuffer),r.vertexLength<i.length&&(r.vertexLength=s.$upperPowerOfTwo(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*r.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),r}createStroke(t,e,i){const r=class{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new s.$Float32Array(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new s.$Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new s.$Float32Array(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new s.$Int16Array(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){const a=11;let o=t,h=e;for(let l=1;l<a;l++){const $=l/a,_=1-$,c=(t*_+i*$)*_+(i*_+r*$)*$,u=(e*_+s*$)*_+(s*_+n*$)*$;this._$addLineSegmentMesh(o,h,c,u,2),o=c,h=u}this._$addLineSegmentMesh(o,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,o=n+2,h=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let $=this._$indexBufferPos;l[$++]=n,l[$++]=a,l[$++]=h,l[$++]=h,l[$++]=o,l[$++]=n,this._$indexBufferPos=$,this._$expandVertexBufferIfNeeded(28);const _=this._$vertexBufferData;let c=this._$vertexBufferPos;_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=1,_[c++]=1,_[c++]=1,_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=-1,_[c++]=-1,_[c++]=1,_[c++]=i,_[c++]=s,_[c++]=t,_[c++]=e,_[c++]=-1,_[c++]=-1,_[c++]=r,_[c++]=i,_[c++]=s,_[c++]=t,_[c++]=e,_[c++]=1,_[c++]=1,_[c++]=r,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,r,n,a,o,h,l,$,_){const c=i-t,u=r-e,d=a-i,g=o-r,p=s.$cross(c,u,d,g);if(!(s.$abs(p)<1e-4))if(2!==n)switch(this._$lineJoin){case I.ROUND:this._$addRoundJoinMesh(i,r);break;case I.MITER:this._$addMiterJoinMesh(i,r,t,e,a,o,$,h,l,_);break;default:this._$addBevelJoinMesh(i,r,$,h,l,_)}else this._$addBevelJoinMesh(i,r,$,h,l,_)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,o,h,l){const $=this._$vertexBufferPos/7,_=$+1,c=$+2,u=$+3,d=$+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let p=this._$indexBufferPos;g[p++]=$,g[p++]=a,g[p++]=_,g[p++]=$,g[p++]=_,g[p++]=c,g[p++]=$,g[p++]=c,g[p++]=o,g[p++]=$,g[p++]=h,g[p++]=u,g[p++]=$,g[p++]=u,g[p++]=d,g[p++]=$,g[p++]=d,g[p++]=l,this._$indexBufferPos=p,this._$expandVertexBufferIfNeeded(35);const f=this._$vertexBufferData;let m=this._$vertexBufferPos;f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=s,f[m++]=r,f[m++]=n,f[m++]=0,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=s,f[m++]=r,f[m++]=n,f[m++]=21,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=s,f[m++]=r,f[m++]=n,f[m++]=22,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=s,f[m++]=r,f[m++]=n,f[m++]=23,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=s,f[m++]=r,f[m++]=n,f[m++]=24,this._$vertexBufferPos=m}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let h=this._$indexBufferPos;o[h++]=a,o[h++]=i,o[h++]=s,o[h++]=a,o[h++]=r,o[h++]=n,this._$indexBufferPos=h,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let $=this._$vertexBufferPos;l[$++]=t,l[$++]=e,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,this._$vertexBufferPos=$}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],o=i[e-7],h=i[e-6],l=i[e-5],$=i[e-4],_=t/7,c=e/7;s!==o||r!==h?(this._$addLineCapMesh(s,r,n,a,_,_+1),this._$addLineCapMesh(o,h,l,$,c-1,c-2)):this._$addLineJoinMesh(l,$,s,r,n,a,c-2,c-1,_,_+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case C.ROUND:this._$addRoundJoinMesh(t,e);break;case C.SQUARE:this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,o=a+1;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let l=this._$indexBufferPos;h[l++]=r,h[l++]=a,h[l++]=o,h[l++]=o,h[l++]=n,h[l++]=r,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const $=this._$vertexBufferData;let _=this._$vertexBufferPos;$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=s,$[_++]=-1,$[_++]=-1,$[_++]=10,$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=s,$[_++]=1,$[_++]=1,$[_++]=10,this._$vertexBufferPos=_}}.generate(t,e,i),n=r.vertexBufferData,a=r.indexBufferData,o=this._$getStrokeVertexArray();return o.indexCount=a.length,this.bind(o),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,o.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,o.indexBuffer),o.vertexLength<n.length&&(o.vertexLength=s.$upperPowerOfTwo(n.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*o.vertexLength,this._$gl.DYNAMIC_DRAW)),o.indexLength<a.length&&(o.indexLength=s.$upperPowerOfTwo(a.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*o.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,n),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,a),o}release(t){t.indexBuffer?this._$strokeVertexArrayPool.push(t):this._$fillVertexArrayPool.push(t)}bind(t){if(t){if(t===this._$boundVertexArray)return;this._$boundVertexArray=t}else this._$boundVertexArray=null;this._$isWebGL2Context?this._$gl.bindVertexArray(t):this._$extension.bindVertexArrayOES(t)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class Kt{constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new ee(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(t,e){const s=this._$gl.createProgram();s.id=i++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);this._$gl.shaderSource(r,t),this._$gl.compileShader(r);const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);return this._$gl.shaderSource(n,e),this._$gl.compileShader(n),this._$context._$isWebGL2Context||(this._$gl.bindAttribLocation(s,0,"a_vertex"),this._$gl.bindAttribLocation(s,1,"a_bezier"),this._$gl.bindAttribLocation(s,1,"a_option1"),this._$gl.bindAttribLocation(s,2,"a_option2"),this._$gl.bindAttribLocation(s,3,"a_type")),this._$gl.attachShader(s,r),this._$gl.attachShader(s,n),this._$gl.linkProgram(s),this._$gl.detachShader(s,r),this._$gl.detachShader(s,n),this._$gl.deleteShader(r),this._$gl.deleteShader(n),s}_$attachProgram(){this._$context._$shaderList._$currentProgramId!==this._$program.id&&(this._$context._$shaderList._$currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(e,i){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(e,i),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawElements(this._$gl.TRIANGLES,e.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e);const i=e.indexRanges[e.indexRanges.length-1],s=i.first+i.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,s)}_$containerClip(e,i,s){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.TRIANGLES,i,s)}_$drawPoints(e,i,s){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.POINTS,i,s)}}class Qt{constructor(t,e){const i=new Zt(e,t._$isWebGL2Context);this._$currentProgramId=-1,this._$shapeShaderVariants=new Et(t,e,i),this._$bitmapShaderVariants=new xt(t,e,i),this._$gradientShapeShaderVariants=new yt(t,e,i),this._$gradientLUTShaderVariants=new vt(t,e,i),this._$filterShaderVariants=new Tt(t,e,i),this._$blendShaderVariants=new bt(t,e,i);const s={opaque:new te(t,e,i,St.SRC_TEX_COORD,Ft.COLOR_TRANSFORM.bind(null,!1)),transparent:new te(t,e,i,St.SRC_TEX_COORD,Ft.COLOR_TRANSFORM.bind(null,!0))},r={opaque:new te(t,e,i,St.SRC_AND_DST_TEX_COORD,Ft.COPY_CHANNEL.bind(null,!1)),transparent:new te(t,e,i,St.SRC_AND_DST_TEX_COORD,Ft.COPY_CHANNEL.bind(null,!0))},n={opaque:new te(t,e,i,St.SRC_AND_DST_TEX_COORD,Ft.MERGE.bind(null,!1)),transparent:new te(t,e,i,St.SRC_AND_DST_TEX_COORD,Ft.MERGE.bind(null,!0))},a={opaque:new te(t,e,i,St.SRC_TEX_COORD,Ft.PALETTE_MAP.bind(null,!1)),transparent:new te(t,e,i,St.SRC_TEX_COORD,Ft.PALETTE_MAP.bind(null,!0))},o={color:new te(t,e,i,St.POSITION_ONLY,Ft.FILL_COLOR),texture:{opaque:new te(t,e,i,St.PIXEL_DISSOLVE_TEXTURE,Ft.PIXEL_DISSOLVE_TEXTURE.bind(null,!1)),transparent:new te(t,e,i,St.PIXEL_DISSOLVE_TEXTURE,Ft.PIXEL_DISSOLVE_TEXTURE.bind(null,!0))}},h=new te(t,e,i,St.SRC_TEX_COORD,Ft.COPY_SRC_TEX),l={withAlphaBitmapData:new te(t,e,i,St.SRC_AND_ALPHA_TEX_COORD,Ft.COPY_PIXELS_WITH_ALPHA_BITMAP_DATA),noAlphaBitmapData:h},$=new te(t,e,i,St.POSITION_ONLY,Ft.FILL_COLOR),_=new te(t,e,i,St.POSITION_ONLY,Ft.NOISE),c=function(s){return{discardSource:{opaque:new te(t,e,i,St.SRC_TEX_COORD,Ft.THRESHOLD.bind(null,s,!1,!1)),transparent:new te(t,e,i,St.SRC_TEX_COORD,Ft.THRESHOLD.bind(null,s,!1,!0))},copySource:{opaque:new te(t,e,i,St.SRC_TEX_COORD,Ft.THRESHOLD.bind(null,s,!0,!1)),transparent:new te(t,e,i,St.SRC_TEX_COORD,Ft.THRESHOLD.bind(null,s,!0,!0))}}},u={less:c("less"),lessEqual:c("lessEqual"),greater:c("greater"),greaterEqual:c("greaterEqual"),equal:c("thresholdEqual"),notEqual:c("thresholdNotEqual"),subtotal:new te(t,e,i,St.SRC_TEX_COORD,Ft.THRESHOLD_SUBTOTAL)},d={findColor:new te(t,e,i,St.SRC_TEX_COORD,Ft.GET_COLOR_BOUNDS_RECT.bind(null,!0)),findNotColor:new te(t,e,i,St.SRC_TEX_COORD,Ft.GET_COLOR_BOUNDS_RECT.bind(null,!1))},g={RGBA:new te(t,e,i,St.SRC_TEX_COORD,Ft.GET_PIXELS.bind(null,"RGBA")),BGRA:new te(t,e,i,St.SRC_TEX_COORD,Ft.GET_PIXELS.bind(null,"BGRA")),ARGB:new te(t,e,i,St.SRC_TEX_COORD,Ft.GET_PIXELS.bind(null,"ARGB"))},p={RGBA:new te(t,e,i,St.SRC_TEX_COORD,Ft.SET_PIXELS.bind(null,"RGBA")),BGRA:new te(t,e,i,St.SRC_TEX_COORD,Ft.SET_PIXELS.bind(null,"BGRA")),ARGB:new te(t,e,i,St.SRC_TEX_COORD,Ft.SET_PIXELS.bind(null,"ARGB"))},f=new te(t,e,i,St.SET_PIXEL_QUEUE,Ft.SET_PIXEL_QUEUE);this._$bitmapData={colorTransform:s,copyChannel:r,merge:n,paletteMap:a,pixelDissolve:o,copyPixels:l,scroll:h,fillRect:$,noise:_,threshold:u,getColorBoundsRect:d,getPixels:g,setPixels:p,setPixelQueue:f}}get shapeShaderVariants(){return this._$shapeShaderVariants}get bitmapShaderVariants(){return this._$bitmapShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Jt{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=s.$floor(.75*this._$gl.getParameter(this._$gl.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new s.$Float32Array(256),this._$rgbIdentityTable=new s.$Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=s.$pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,n=this._$context._$shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<r;i+=this._$maxLength-1){const o=s.$min(i+this._$maxLength,r),h=n.getGradientLUTShader(o-i,e),l=h.uniform;n.setGradientLUTUniformForShape(l,t,i,o,a),h._$drawGradient(0===i?0:t[i][0],o===r?1:t[o-1][0])}return this._$context._$bind(i),this._$attachment.texture}generateForFilter(t,e,i){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context._$shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<n;r+=this._$maxLength-1){const o=s.$min(r+this._$maxLength,n),h=a.getGradientLUTShader(o-r,!1),l=h.uniform;a.setGradientLUTUniformForFilter(l,t,e,i,r,o),h._$drawGradient(0===r?0:t[r],o===n?1:t[o-1])}return this._$context._$bind(r),this._$attachment.texture}}class Zt{constructor(t,e){this._$isWebGL2Context=e,e||t.getExtension("OES_standard_derivatives")}version(){return this._$isWebGL2Context?"#version 300 es":""}attribute(t){return this._$isWebGL2Context?`layout (location = ${t}) in`:"attribute"}varyingOut(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"out":"varying"}varyingIn(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"in":"varying"}outColor(){return this._$isWebGL2Context?"out vec4 o_color;":""}fragColor(){return this._$isWebGL2Context?"o_color":"gl_FragColor"}texture2D(){return this._$isWebGL2Context?"texture":"texture2D"}extensionDerivatives(){return this._$isWebGL2Context?"":"#extension GL_OES_standard_derivatives : enable"}}class te{constructor(t,e,i,s,r){this._$context=t,this._$gl=e,this._$keyword=i,this._$vertexSource=s,this._$fragmentSource=r,this._$instance=null}get instance(){return this._$instance||(this._$instance=new Kt(this._$gl,this._$context,this._$vertexSource(this._$keyword),this._$fragmentSource(this._$keyword))),this._$instance}}class ee{constructor(t,e){this._$gl=t,this._$array=[],this._$map=new Map;const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r={},n=this._$gl.getUniformLocation(e,s);if(i.type!==this._$gl.SAMPLER_2D||1!==i.size){switch(i.type){case this._$gl.FLOAT_VEC4:r.method=this._$gl.uniform4fv.bind(this._$gl,n),r.array=new Float32Array(4*i.size),r.assign=-1;break;case this._$gl.INT_VEC4:r.method=this._$gl.uniform4iv.bind(this._$gl,n),r.array=new Int32Array(4*i.size),r.assign=-1;break;case this._$gl.SAMPLER_2D:r.method=this._$gl.uniform1iv.bind(this._$gl,n),r.array=new Int32Array(i.size),r.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(r),this._$map.set(s,r)}}}getArray(t){return this._$map.get(t).array}get textures(){return this._$map.get("u_textures").array}get highp(){return this._$map.get("u_highp").array}get mediump(){return this._$map.get("u_mediump").array}get integer(){return this._$map.get("u_integer").array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array))}}}class ie{constructor(){this._$stage=new G,this._$stage._$player=this,this._$cacheStore=new mt,this._$mode="loader",this._$actionOffset=0,this._$actions=s.$getArray(),this._$loaders=s.$getArray(),this._$sounds=s.$getMap(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$mouseWheelEvent=null,this._$ratio=s.$devicePixelRatio,this._$stopFlag=!0,this._$startTime=0,this._$fps=60,this._$isLoad=!1,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=new s.$window.Float32Array([1,0,0,1,0,0]),this._$backgroundColor="transparent",this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$textarea=null,this._$broadcastEvents=s.$getMap(),this._$context=null,this._$canvas=null,this._$buffer=null,this._$optionWidth=0,this._$optionHeight=0,this._$tagId=null,this._$bgcolor="",this._$base="",this._$quality=X.HIGH,this._$sources=s.$getArray(),this._$videos=s.$getArray(),this._$bindRun=this._$run.bind(this),this._$timerId=-1,this._$loadId=-1}get broadcastEvents(){return this._$broadcastEvents}get base(){return this._$base}set base(t){if("string"==typeof t)if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${s.$location.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else{const e=t.split("?")[0].split("/");e.pop(),this._$base=`${e.join("/")}/`}}get stage(){return this._$stage}get contentElementId(){return`${s.$PREFIX}`}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}play(){if(this._$stopFlag){if(this._$stopFlag=!1,this._$timerId>-1){(0,s.$cancelAnimationFrame)(this._$timerId)}this._$startTime=s.$performance.now(),this._$fps=1e3/this._$stage._$frameRate;const t=s.$requestAnimationFrame;this._$timerId=t(this._$bindRun)}}stop(){(0,s.$cancelAnimationFrame)(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,s.$cacheStore().reset()}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this._$bgcolor=t.bgcolor||this._$bgcolor,this.base=t.base||this._$base),this._$initialize()}_$updateLoadStatus(){if(2===this._$loadStatus)return void this._$loaded();const t=s.$requestAnimationFrame;this._$loadId=t(this._$updateLoadStatus.bind(this))}_$loaded(){const t=s.$document.getElementById(this.contentElementId);if(t){switch(this._$bgcolor&&(this._$backgroundColor=this._$bgcolor),this._$backgroundColor){case"transparent":case!1:this._$context._$setColor(0,0,0,0);break;default:this._$context._$setColor(this._$backgroundColor[0],this._$backgroundColor[1],this._$backgroundColor[2],this._$backgroundColor[3])}this._$deleteNode(),t.appendChild(this._$canvas),this.play(),this._$stage._$prepareActions(),this._$broadcastEvents.has(a.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new a(a.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(a.EXIT_FRAME)&&this._$dispatchEvent(new a(a.EXIT_FRAME));const e=0|this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t instanceof D&&(t._$lock=!1),t.hasEventListener(a.INIT)&&t.dispatchEvent(new a(a.INIT)),t.hasEventListener(a.COMPLETE)&&t.dispatchEvent(new a(a.COMPLETE)),t._$player=null}this._$broadcastEvents.has(a.ACTIVATE)&&this._$dispatchEvent(new a(a.ACTIVATE)),this._$doAction(),this._$draw(0)}}_$initialize(){const t=s.$document;if("loading"===t.readyState){const t=function(e){e.target.removeEventListener("DOMContentLoaded",t),this._$initialize()}.bind(this);return void s.$window.addEventListener("DOMContentLoaded",t)}const e=this.contentElementId;if(null===this._$tagId)t.body.insertAdjacentHTML("beforeend",`<div id="${e}"></div>`);else{const i=t.getElementById(this._$tagId);if(!i)return void alert("Not Found Tag ID:"+this._$tagId);if(t.getElementById(e))this._$deleteNode();else{const s=t.createElement("div");s.id=e,s.tabIndex=-1,i.appendChild(s)}}this._$canvas||this._$initializeCanvas();const i=t.getElementById(e),r=i.parentNode;if(r){this._$initStyle(i),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===r.tagName?s.$window.innerWidth:r.offsetWidth,e=this._$optionHeight?this._$optionHeight:"BODY"===r.tagName?s.$window.innerHeight:r.offsetHeight;"loader"===this._$mode&&t&&e&&(this._$baseWidth=t,this._$baseHeight=e,this._$resize())}"loader"===this._$mode?(this._$loadStatus++,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(e){const i=e.style;i.position="relative",i.top="0",i.left="0",i.backgroundColor="transparent",i.overflow="hidden",i.padding="0",i.margin="0",i.userSelect="none",i.outline="none";const s=this._$optionWidth,r=this._$optionHeight,n=e.parentNode;if("BODY"===n.tagName)return i.width=s?`${s}px`:`${t.innerWidth}px`,void(i.height=r?`${r}px`:`${t.innerHeight}px`);i.width=s?`${s}px`:`${n.offsetWidth}px`,i.height=r?`${r}px`:`${n.offsetHeight}px`}_$buildWait(){const t=s.$document.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=s.$document.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=s.$document.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){const e=s.$document.createElement("canvas");e.width=1,e.height=1,this._$canvas=e;const i={stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1};let r=!0,n=e.getContext("webgl2",i);if(n||(n=e.getContext("webgl",i)||e.getContext("experimental-webgl",i),r=!1),!n)throw alert("WebGL\n"),new Error("WebGL setting is off. Please turn the setting on.");switch(this._$context=new Dt(n,r),t.glstats&&glstats.init(n,r,s.$isChrome,s.$isFireFox),!0){case s.$isTouch:const t=function(){this.removeEventListener(s.$TOUCH_START,t),s.$loadAudioData()};e.addEventListener(s.$TOUCH_START,t),e.addEventListener(s.$TOUCH_START,function(t){s.$event=t,s.$eventType=s.$TOUCH_START,this._$hitTest()}.bind(this)),e.addEventListener(s.$TOUCH_MOVE,function(t){s.$event=t,s.$eventType=s.$TOUCH_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(s.$TOUCH_END,function(t){s.$event=t,s.$eventType=s.$TOUCH_END,this._$hitTest()}.bind(this));break;default:const i=function(t){t.target.removeEventListener(s.$MOUSE_DOWN,i),s.$loadAudioData()};e.addEventListener(s.$MOUSE_DOWN,i),e.addEventListener(s.$MOUSE_DOWN,function(t){s.$event=t,s.$eventType=s.$MOUSE_DOWN,t.button||this._$hitTest()}.bind(this)),e.addEventListener(s.$DOUBLE_CLICK,function(t){s.$event=t,s.$eventType=s.$DOUBLE_CLICK,t.button||this._$hitTest()}.bind(this)),e.addEventListener(s.$MOUSE_LEAVE,function(t){s.$event=t,s.$eventType=s.$MOUSE_LEAVE,this._$hitTest(),s.$event=null,this._$stageX=-1,this._$stageY=-1}.bind(this)),e.addEventListener(s.$MOUSE_UP,function(t){s.$event=t,s.$eventType=s.$MOUSE_UP,t.button||this._$hitTest()}.bind(this)),e.addEventListener(s.$MOUSE_MOVE,function(t){s.$event=t,s.$eventType=s.$MOUSE_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(s.$MOUSE_WHEEL,function(t){this._$mouseWheelEvent=t}.bind(this))}const a=e.style;a.position="absolute",a.top="0",a.left="0",a.webkitTapHighlightColor="rgba(0,0,0,0)",a.backfaceVisibility="hidden",a.transformOrigin="0 0",1!==s.$devicePixelRatio&&(a.transform=`scale(${1/s.$devicePixelRatio})`)}_$resize(){const t=s.$document.getElementById(this.contentElementId);if(t){const e=t.parentNode,i=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?s.$window.innerWidth:e.offsetWidth?e.offsetWidth:s.$parseFloat(e.style.width),r=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?s.$window.innerHeight:e.offsetHeight?e.offsetHeight:s.$parseFloat(e.style.height),n="BODY"===e.tagName?s.$window.innerWidth:e.offsetWidth,a=s.$min(i/this._$baseWidth,r/this._$baseHeight);let o=this._$baseWidth*a|0,h=this._$baseHeight*a|0;const l=t.style;if(l.width=`${o}px`,l.height=`${h}px`,l.top="0",l.left=n/2-o/2+"px",o!==this._$width/this._$ratio||h!==this._$height/this._$ratio){if(o=o*s.$devicePixelRatio|0,h=h*s.$devicePixelRatio|0,this._$scale=a,this._$width=o,this._$height=h,this._$canvas.width=o,this._$canvas.height=h,this._$context._$gl.viewport(0,0,o,h),this._$canvas.style.transform=1===this._$ratio&&1===s.$devicePixelRatio?"":`scale(${1/this._$ratio})`,this._$context){const t=this._$context._$frameBufferManager;this._$buffer&&(t.unbind(),t.releaseAttachment(this._$buffer,!0)),this._$buffer=t.createCacheAttachment(o,h,!1),t._$stencilBufferPool._$maxWidth=o,t._$stencilBufferPool._$maxHeight=h,t._$textureManager._$maxWidth=o,t._$textureManager._$maxHeight=h}const t=this._$scale*this._$ratio;this._$matrix[0]=t,this._$matrix[3]=t,this._$stage._$doChanged(),this._$cacheStore.reset()}}}getSamples(){switch(this._$quality){case X.HIGH:return s.$HIGH_SAMPLES;case X.MEDIUM:return s.$MEDIUM_SAMPLES;default:return s.$LOW_SAMPLES}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t._$eventPhase=h.AT_TARGET;const i=e.length;for(let r=0;r<i;++r){const i=e[r];if(t._$currentTarget=i.target,t._$listener=i.listener,i.listener.call(s.$window,t),t._$stopImmediatePropagation)break}return s.$poolArray(e),!0}}_$wheelEvent(){const t=this._$mouseWheelEvent;t&&(t.defaultPrevented||(s.$event=t,s.$eventType=s.$MOUSE_WHEEL,this._$hitTest()),this._$mouseWheelEvent=null)}_$run(e=0){if(this._$stopFlag)return;t.stats&&stats.begin(),t.glstats&&glstats.begin(),this._$wheelEvent(),this._$doAction();let i=e-this._$startTime;i>this._$fps&&(this._$startTime=e-i%this._$fps,this._$action(),this._$draw(0),!this._$hitTestStart&&"up"===this._$state&&s.$event&&this._$stageX>-1&&this._$stageY>-1&&this._$pointerCheck()),t.stats&&stats.end(),t.glstats&&glstats.end();const r=s.$requestAnimationFrame;this._$timerId=r(this._$bindRun)}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,s.$hitContext.setTransform(1,0,0,1,0,0),s.$hitContext.beginPath(),this._$stage._$mouseHit(s.$hitContext,s.$MATRIX_ARRAY_IDENTITY,this._$hitObject,!0);let i=null,r=null,n=!1,a=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(c.MOUSE_OUT)&&t.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY)),t instanceof U&&"over"===t._$status&&t._$changeState("up")}if(this._$rollOverObject!==i){let s=null;if(this._$rollOverObject)for(r=this._$rollOverObject,r.willTrigger(c.ROLL_OUT)&&r.dispatchEvent(new c(c.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),s=r._$parent;s&&s._$root!==s&&s!==i;){if(s._$mouseEnabled&&s._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===s){t=!0;break}e=e._$parent}if(!t&&s._$parent===i._$parent&&s._$index>i._$index&&(t=!0),t)break}s.willTrigger(c.ROLL_OUT)&&s.dispatchEvent(new c(c.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),s=s._$parent}for(r=i;r.willTrigger(c.ROLL_OVER)&&r.dispatchEvent(new c(c.ROLL_OVER,!1,!1,r.mouseX,r.mouseY)),r=r._$parent,r&&r!==s&&r.stage!==r;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i.willTrigger(c.MOUSE_OVER)&&i.dispatchEvent(new c(c.MOUSE_OVER,!0,!1,i.mouseX,i.mouseY)),this._$mouseOverTarget=i}if(i instanceof U&&"over"!==i._$status&&i._$changeState("over"),"up"===this._$state&&(this._$clickTarget=null),!s.$isTouch&&"up"===this._$state)for(r=i;r&&r.root!==r;){switch(!0){case r instanceof rt:r._$type===nt.DYNAMIC&&(n=!0);break;case r instanceof U:case r.buttonMode:a=!0}if(n||a)break;r=r._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(c.MOUSE_OUT)&&i.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,i.mouseX,i.mouseY))),this._$rollOverObject)for(r=this._$rollOverObject;r&&r.root!==r;)r.willTrigger(c.ROLL_OUT)&&r.dispatchEvent(new c(c.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),r=r._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case n:this._$canvas.style.cursor="text";break;case a:this._$canvas.style.cursor="pointer";break;case!s.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has(a.ENTER_FRAME)&&this._$dispatchEvent(new a(a.ENTER_FRAME)),this._$broadcastEvents.has(a.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new a(a.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(a.EXIT_FRAME)&&this._$dispatchEvent(new a(a.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new a(a.RENDER))),e){for(let i=0;i<e;++i){const e=t[i];e.hasEventListener(a.INIT)&&e.dispatchEvent(new a(a.INIT)),e.hasEventListener(a.COMPLETE)&&e.dispatchEvent(new a(a.COMPLETE))}s.$poolArray(t)}this._$doAction()}_$draw(t=0){const e=this._$canvas,i=e.width,r=e.height,n=this._$context;if(this._$stage._$updated&&n&&i>0&&r>0){if(n._$bind(this._$buffer),s.$resetContext(n),n.setTransform(1,0,0,1,0,0),n.clearRect(0,0,i,r),n.beginPath(),this._$stage._$draw(n,this._$matrix,s.$COLOR_ARRAY_IDENTITY,!1),this._$stage._$updated=!1,this._$sounds.size){for(let[t,e]of this._$sounds)e._$soundPlay();this._$sounds.clear()}const t=n.frameBuffer.getTextureFromCurrentAttachment();n.frameBuffer.unbind(),s.$resetContext(n),n.setTransform(1,0,0,1,0,0),n.clearRect(0,0,i,r),n.drawImage(t,0,0,i,r),n._$bind(this._$buffer)}}_$doAction(){for(;this._$actions.length;){s.$actionProcess=!0;const t=this._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;t._$actionProcess=!0;const i=t._$actions.get(e),r=i.length;for(let e=0;e<r;++e)i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}s.$actionProcess=!1}_$hitTest(){if(this._$stopFlag)return;this._$hitTestStart=!0,s.$isUpdated=!1;const t=s.$event;let e=null,i=null,r=null,n=s.$window.pageXOffset,a=s.$window.pageYOffset;const o=s.$document.getElementById(this.contentElementId);if(o){const t=o.getBoundingClientRect();n+=t.left,a+=t.top}let h=0,$=0;if(s.$isTouch){const e=t.changedTouches[0];h=e.pageX,$=e.pageY}else h=t.pageX,$=t.pageY;h=(h-n)/this._$scale,$=($-a)/this._$scale,t._$stageX=h,t._$stageY=$,this._$stageX=h,this._$stageY=$,this._$hitObject.x=h,this._$hitObject.y=$,this._$hitObject.pointer="",this._$hitObject.hit=null,s.$hitContext.setTransform(1,0,0,1,0,0),s.$hitContext.beginPath(),this._$stage._$mouseHit(s.$hitContext,s.$MATRIX_ARRAY_IDENTITY,this._$hitObject,!0);let _=!1,u=!1,d=!1;switch(s.$eventType){case s.$TOUCH_MOVE:case s.$MOUSE_MOVE:if(s.$dropTarget){const t=s.$dropTarget._$dragMousePoint();let e=t.x,i=t.y;s.$dragRules.lock||(e+=s.$dragRules.position.x,i+=s.$dragRules.position.y);const r=s.$dragRules.bounds;r&&(e=s.$clamp(e,r.left,r.right),i=s.$clamp(i,r.top,r.bottom)),s.$dropTarget.x=e,s.$dropTarget.y=i}break;case s.$TOUCH_START:case s.$MOUSE_DOWN:this._$state="down",d="pointer"===this._$canvas.style.cursor,u=!0;break;case s.$TOUCH_END:case s.$MOUSE_UP:case s.$DOUBLE_CLICK:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case s.$eventType===s.$MOUSE_LEAVE:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(c.MOUSE_OUT)&&e.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,e.mouseX,e.mouseY)),e instanceof U&&"over"===e._$status&&e._$changeState("up")),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(c.ROLL_OUT)&&i.dispatchEvent(new c(c.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,s.$eventType){case s.$MOUSE_WHEEL:this._$stage.hasEventListener(c.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new c(c.MOUSE_WHEEL,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case s.$TOUCH_START:case s.$MOUSE_DOWN:this._$stage.hasEventListener(c.MOUSE_DOWN)&&this._$stage.dispatchEvent(new c(c.MOUSE_DOWN,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case s.$TOUCH_END:case s.$MOUSE_UP:this._$textarea&&(r=this._$textarea._$instance,this._$textarea.dispatchEvent(new s.$window.Event("swf2js_blur")),r.willTrigger(l.FOCUS_OUT)&&r.dispatchEvent(new l(l.FOCUS_OUT,!0)),this._$textarea=null,this.stage.focus=null),this._$stage.hasEventListener(c.CLICK)&&this._$stage.dispatchEvent(new c(c.CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$stage.hasEventListener(c.MOUSE_UP)&&this._$stage.dispatchEvent(new c(c.MOUSE_UP,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case s.$TOUCH_MOVE:case s.$MOUSE_MOVE:this._$stage.hasEventListener(c.MOUSE_MOVE)&&this._$stage.dispatchEvent(new c(c.MOUSE_MOVE,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case s.$DOUBLE_CLICK:this._$stage.hasEventListener(c.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new c(c.DOUBLE_CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY))}break;default:switch(e=this._$hitObject.hit,s.$eventType){case s.$TOUCH_MOVE:case s.$MOUSE_MOVE:if(e.willTrigger(c.MOUSE_MOVE)&&e.dispatchEvent(new c(c.MOUSE_MOVE,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(c.MOUSE_OUT)&&t.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY)),t instanceof U&&"over"===t._$status&&t._$changeState("up")}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(c.ROLL_OUT)&&i.dispatchEvent(new c(c.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(h,$)){let i=!1,s=e;for(;s&&s._$root!==s;){if(s===t){i=!0;break}s=s._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(c.ROLL_OUT)&&t.dispatchEvent(new c(c.ROLL_OUT,!1,!1,t.mouseX,t.mouseY)),t=t._$parent}for(i=e;i.willTrigger(c.ROLL_OVER)&&i.dispatchEvent(new c(c.ROLL_OVER,!1,!1,i.mouseX,i.mouseY)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(c.MOUSE_OVER)&&e.dispatchEvent(new c(c.MOUSE_OVER,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget=e}e instanceof U&&"over"!==e._$status&&e._$changeState("over"),"up"===this._$state&&(this._$clickTarget=null);break;case s.$TOUCH_START:case s.$MOUSE_DOWN:if(this.stage._$focus!==e)switch(!0){case e instanceof rt:case e instanceof U:this._$stage.focus=e;break;default:this._$stage.focus=null}e.willTrigger(c.MOUSE_DOWN)&&e.dispatchEvent(new c(c.MOUSE_DOWN,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=e,e instanceof U&&"down"!==e._$status&&e._$changeState("down");break;case s.$TOUCH_END:case s.$MOUSE_UP:e.willTrigger(c.MOUSE_UP)&&e.dispatchEvent(new c(c.MOUSE_UP,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget===e&&(e.willTrigger(c.CLICK)&&e.dispatchEvent(new c(c.CLICK,!0,!1,e.mouseX,e.mouseY)),e instanceof U&&e._$changeState("up")),this._$clickTarget=null;break;case s.$MOUSE_WHEEL:e.willTrigger(c.MOUSE_WHEEL)&&e.dispatchEvent(new c(c.MOUSE_WHEEL)),e instanceof rt&&(e.scrollV+=t.deltaY);break;case s.$DOUBLE_CLICK:e.willTrigger(c.DOUBLE_CLICK)&&e.dispatchEvent(new c(c.DOUBLE_CLICK))}if(!u&&!s.$isTouch&&"up"===this._$state)for(i=e;i&&i.root!==i;){switch(!0){case i instanceof rt:i._$type===nt.DYNAMIC&&(_=!0);break;case i instanceof U:case i._$buttonMode:d=!0}if(_||d)break;i=i._$parent}}switch(!0){case _:this._$canvas.style.cursor="text";break;case d:this._$canvas.style.cursor="pointer";break;case!s.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}!s.$actionProcess&&this._$actions.length>1&&this._$doAction(),s.$isUpdated&&(t.preventDefault(),this._$stage._$prepareActions(),s.$actionProcess||this._$doAction()),this._$hitTestStart=!1}}s.$window.next2d=new class{constructor(){this._$player=new ie}load(t,e=null){if("develop"===t){const e=s.$location.search.substr(1).split("&")[0];if(!e)return;t=`${s.$location.origin}/${e}`}if(!t)return;e&&"base"in e||(this._$player.base=t),this._$player.setOptions(e);const i=new P,r=i.contentLoaderInfo,n=function(t){t.target.removeEventListener(a.COMPLETE,o),t.target.removeEventListener(_.IO_ERROR,n),alert("Error: "+t.message)},o=function(t){const e=t.target;e.removeEventListener(a.COMPLETE,o),e.removeEventListener(_.IO_ERROR,n);const i=s.$currentPlayer(),r=i.stage,h=e._$data.stage;i.width=h.width,i.height=h.height,i.stage.frameRate=h.fps;const l=s.$intToRGBA(0|`0x${h.bgColor.substr(1)}`);i._$context._$setColor(l.R/255,l.G/255,l.B/255,1),i._$backgroundColor=[l.R/255,l.G/255,l.B/255,1],r.addChild(e.content),i._$resize()};r.addEventListener(_.IO_ERROR,n),r.addEventListener(a.COMPLETE,o),i.load(new ct(t))}createRootMovieClip(t=240,e=240,i=60,s=null){const r=this._$player;return r._$mode="create",r._$stage.frameRate=0|i,r.width=0|t,r.height=0|e,r.setOptions(s),r._$stage.addChild(new E)}},s.$packages(s.$window.next2d),console.log("%c next2d.js %c 1.0.0 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729","")}(window);