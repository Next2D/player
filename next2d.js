/*!
 * licenses: MIT Licenses.
 * version: 1.5.2
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2013-2022 Toshiyuki Ienaga.
 */
"next2d"in window||(t=>{"use strict";let e=0,i=0;const s=t.Math,r={$PREFIX:"__next2d__"};r.$MAX_VALUE=t.Number.MAX_VALUE,r.$MIN_VALUE=t.Number.MIN_VALUE,r.$HIGH_SAMPLES=4,r.$MEDIUM_SAMPLES=2,r.$LOW_SAMPLES=0,r.$LOAD_START="loadstart",r.$PROGRESS="progress",r.$LOADEND="loadend",r.$TOUCH_START="touchstart",r.$TOUCH_MOVE="touchmove",r.$TOUCH_END="touchend",r.$MOUSE_DOWN="mousedown",r.$MOUSE_MOVE="mousemove",r.$MOUSE_UP="mouseup",r.$MOUSE_WHEEL="wheel",r.$DOUBLE_CLICK="dblclick",r.$MOUSE_LEAVE="mouseleave",r.$KEY_DOWN="keydown",r.$KEY_UP="keyup",r.$SCROLL="scroll",r.$P_TAG=t.document.createElement("p"),r.$COLOR_ARRAY_IDENTITY=new Float32Array([1,1,1,1,0,0,0,0]),r.$COLOR_MATRIX_FILTER=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],r.$soundMixerVolume=1,r.$bezierConverterBuffer=new Array(32),r.$window=t,r.$document=t.document,r.$navigator=t.navigator,r.$userAgent=t.navigator.userAgent,r.$location=t.location,r.$RegExp=t.RegExp,r.$isNaN=t.isNaN,r.$Deg2Rad=s.PI/180,r.$Rad2Deg=180/s.PI,r.$Array=t.Array,r.$Map=t.Map,r.$Image=t.Image,r.$URL=t.URL,r.$Blob=t.Blob,r.$parseFloat=t.parseFloat,r.$setTimeout=t.setTimeout,r.$encodeURIComponent=t.encodeURIComponent,r.$Infinity=t.Infinity,r.$WebGLTexture=t.WebGLTexture,r.$clearTimeout=t.clearTimeout,r.$setTimeout=t.setTimeout,r.$audioContext=null,r.$CanvasRenderingContext2D=t.CanvasRenderingContext2D,r.$requestAnimationFrame=t.requestAnimationFrame,r.$cancelAnimationFrame=t.cancelAnimationFrame,r.$performance=t.performance,r.$Float32Array=t.Float32Array,r.$Int16Array=t.Int16Array,r.$variables=new Map,r.$loadedImages=new Map,r.$isUpdated=!1,r.$event=null,r.$dropTarget=null,r.$dragRules={lock:!1,position:{x:0,y:0},bounds:null},r.$rgbToLinearTable=new r.$Float32Array(256),r.$rgbIdentityTable=new r.$Float32Array(256);for(let t=0;t<256;++t)r.$rgbToLinearTable[t]=s.pow(t/255,2.23333333),r.$rgbIdentityTable[t]=t/255;r.$SHORT_INT_MIN=-32768,r.$SHORT_INT_MAX=32767,r.$devicePixelRatio=s.min(2,t.devicePixelRatio),r.$MATRIX_HIT_ARRAY_IDENTITY=new Float32Array([1,0,0,1,0,0]),r.$MATRIX_ARRAY_IDENTITY=new Float32Array([1,0,0,1,0,0]),r.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0=new Float32Array([r.$devicePixelRatio,0,0,r.$devicePixelRatio,0,0]),r.$bounds=[],r.$arrays=[],r.$audios=[],r.$maps=[],r.$preObjects=[],r.$matrices=[],r.$colors=[],r.$float32Array4=[],r.$float32Array6=[],r.$float32Array8=[],r.$float32Array9=[],r.$isAndroid=r.$userAgent.indexOf("Android")>-1,r.isiOS=r.$userAgent.indexOf("iPhone")>-1||r.$userAgent.indexOf("iPod")>-1,r.$isTouch=r.$isAndroid||r.isiOS,r.$isChrome=r.$userAgent.indexOf("Chrome")>-1,r.$isFireFox=r.$userAgent.indexOf("Firefox")>-1,r.$isSafari=-1===r.$userAgent.indexOf("Chrome")&&r.$userAgent.indexOf("Safari")>-1,r.$isEdge=r.$userAgent.indexOf("Edge")>-1,r.$isMac=r.$userAgent.indexOf("Mac")>-1,r.$isWindows=!1===r.$isMac,r.$currentLoaderInfo=null;const n=t.document.createElement("canvas");n.width=1,n.height=1,r.$hitContext=n.getContext("2d"),r.$hitContext.globalAlpha=0,r.$hitContext.imageSmoothingEnabled=!1;const a=t.document.createElement("canvas");a.width=1,a.height=1,r.$textContext=a.getContext("2d"),r.$hitContext.globalAlpha=0,r.$hitContext.imageSmoothingEnabled=!1,r.$DIV=null,r.$isArray=t=>r.$Array.isArray(t),r.$getArray=(...t)=>{const e=r.$arrays.pop()||[];return t.length&&e.push.apply(e,t),e},r.$poolArray=t=>{t.length&&(t.length=0),r.$arrays.push(t)},r.$clamp=(t,e,i,n=null)=>{const a=+t;return r.$isNaN(a)&&null!==n?n:s.min(s.max(e,r.$isNaN(a)?0:a),i)},r.$multiplicationColor=(t,e)=>r.$getFloat32Array8(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),r.$multiplicationMatrix=(t,e)=>r.$getFloat32Array6(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),r.$getBoundsObject=(t=0,e=0,i=0,s=0)=>{const n=r.$bounds.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return n.xMin=t,n.xMax=e,n.yMin=i,n.yMax=s,n},r.$poolBoundsObject=t=>{r.$bounds.push(t)},r.$poolMap=t=>{t.size&&t.clear(),r.$maps.push(t)},r.$getMap=()=>r.$maps.pop()||new r.$Map,r.$getFloat32Array4=(t=0,e=0,i=0,s=0)=>{const n=r.$float32Array4.pop()||new r.$window.Float32Array(4);return n[0]=t,n[1]=e,n[2]=i,n[3]=s,n},r.$poolFloat32Array4=t=>{r.$float32Array4.push(t)},r.$getFloat32Array6=(t=0,e=0,i=0,s=0,n=0,a=0)=>{const o=r.$float32Array6.pop()||new r.$window.Float32Array(6);return o[0]=t,o[1]=e,o[2]=i,o[3]=s,o[4]=n,o[5]=a,o},r.$poolFloat32Array6=t=>{r.$float32Array6.push(t)},r.$getFloat32Array8=(t=1,e=1,i=1,s=1,n=0,a=0,o=0,h=0)=>{const l=r.$float32Array8.pop()||new r.$window.Float32Array(8);return l[0]=t,l[1]=e,l[2]=i,l[3]=s,l[4]=n,l[5]=a,l[6]=o,l[7]=h,l},r.$poolFloat32Array8=t=>{r.$float32Array8.push(t)},r.$getFloat32Array9=(t=0,e=0,i=0,s=0,n=0,a=0,o=0,h=0,l=0)=>{const _=r.$float32Array9.pop()||new r.$window.Float32Array(9);return _[0]=t,_[1]=e,_[2]=i,_[3]=s,_[4]=n,_[5]=a,_[6]=o,_[7]=h,_[8]=l,_},r.$poolFloat32Array9=t=>{r.$float32Array9.push(t)},r.$currentPlayer=()=>t.next2d._$player,r.$currentMousePoint=()=>{const t=r.$currentPlayer();let e=r.$window.pageXOffset,i=r.$window.pageYOffset;const s=r.$document.getElementById(t.contentElementId);if(s){const t=s.getBoundingClientRect();e+=t.left,i+=t.top}let n=r.$event.pageX,a=r.$event.pageY;if(r.$isTouch){const t=r.$event.changedTouches[0];n=t.pageX,a=t.pageY}const o=(n-e)/t._$scale|0,h=(a-i)/t._$scale|0;return new p(o,h)},r.$boundsMatrix=(t,e)=>{const i=t.xMax*e[0]+t.yMax*e[2]+e[4],n=t.xMax*e[0]+t.yMin*e[2]+e[4],a=t.xMin*e[0]+t.yMax*e[2]+e[4],o=t.xMin*e[0]+t.yMin*e[2]+e[4],h=t.xMax*e[1]+t.yMax*e[3]+e[5],l=t.xMax*e[1]+t.yMin*e[3]+e[5],_=t.xMin*e[1]+t.yMax*e[3]+e[5],$=t.xMin*e[1]+t.yMin*e[3]+e[5],c=s.min(r.$MAX_VALUE,i,n,a,o),u=s.max(-r.$MAX_VALUE,i,n,a,o),d=s.min(r.$MAX_VALUE,h,l,_,$),g=s.max(-r.$MAX_VALUE,h,l,_,$);return r.$getBoundsObject(c,u,d,g)},r.$upperPowerOfTwo=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),r.$getMatrix=(t=1,e=0,i=0,s=1,n=0,a=0)=>{if(!r.$matrices.length)return new m(t,e,i,s,n,a);const o=r.$matrices.pop();return o._$matrix=r.$getFloat32Array6(t,e,i,s,n,a),o},r.$poolMatrix=t=>{r.$poolFloat32Array6(t._$matrix),t._$matrix=null,r.$matrices.push(t)},r.$toBoolean=(t=!1)=>{switch(typeof t){case"boolean":return t;case"function":return!0;case"object":case"string":case"number":return!!t;default:return!1}},r.$getColorTransform=(t=1,e=1,i=1,s=1,n=0,a=0,o=0,h=0)=>{if(!r.$colors.length)return new f(t,e,i,s,n,a,o,h);const l=r.$colors.pop();return l._$colorTransform=r.$getFloat32Array8(t,e,i,s,n,a,o,h),l},r.$poolColorTransform=t=>{r.$poolFloat32Array8(t._$colorTransform),t._$colorTransform=null,r.$colors.push(t)},r.$toColorInt=t=>r.$isNaN(+t)?r.$colorStringToInt(t):+t,r.$colorStringToInt=t=>{r.$hitContext.fillStyle=t;const e=r.$hitContext.fillStyle.substr(1);return r.$hitContext.fillStyle="rgba(0, 0, 0, 1)",0|`0x${e}`},r.$intToR=(t,e,i)=>(t>>16)*(i?e:1)/255,r.$intToG=(t,e,i)=>(t>>8&255)*(i?e:1)/255,r.$intToB=(t,e,i)=>(255&t)*(i?e:1)/255,r.$uintToRGBA=t=>({A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}),r.$intToRGBA=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),r.$generateColorTransform=(t,e)=>({R:s.max(0,s.min(t.R*e[0]+e[4],255)),G:s.max(0,s.min(t.G*e[1]+e[5],255)),B:s.max(0,s.min(t.B*e[2]+e[6],255)),A:s.max(0,s.min(255*t.A*e[3]+e[7],255))/255}),r.$cacheStore=()=>r.$currentPlayer()._$cacheStore,r.$inverseMatrix=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return r.$getFloat32Array9(t[4]*e,-t[1]*e,0,-t[3]*e,t[0]*e,0,i*e,s*e,1)},r.$decodeAudioFailed=function(){const t=this._$character?this._$character.buffer:this._$buffer;let e=0;for(;e=t.indexOf(255,e),-1!==e&&224!=(224&t[e+1]);)++e;e>-1&&r.$audioContext.decodeAudioData(t.buffer.subarray(e),r.$decodeAudioSuccess.bind(this))},r.$decodeAudioSuccess=function(t){this._$character?(this._$character.buffer=null,this._$character.audioBuffer=t):(this._$buffer=null,this._$audioBuffer=t)},r.$decodeAudioData=t=>{const e=t._$character?t._$character.buffer:t._$buffer;e&&r.$audioContext.decodeAudioData(e.buffer,r.$decodeAudioSuccess.bind(t),r.$decodeAudioFailed.bind(t))},r.$loadAudioData=()=>{if(r.$audioContext||(r.$audioContext=new r.$window.AudioContext,r.$audioContext.resume()),r.$audioContext){const t=r.$audios.length;for(let e=0;e<t;++e){const t=r.$audios[e];if(t._$character&&t._$character.audioBuffer)return;if(t._$audioBuffer)return;r.$decodeAudioData(t)}r.$audios.length=0}},r.$getImageType=t=>255===t[0]&&216===t[1]?"jpeg":71===t[0]&&73===t[1]&&70===t[2]?"gif":137===t[0]&&80===t[1]&&78===t[2]&&71===t[3]&&13===t[4]&&10===t[5]&&26===t[6]&&10===t[7]?"png":66===t[0]&&77===t[1]?"bmp":null,r.$resizeTimerId=0,r.$resize=()=>{(0,r.$clearTimeout)(r.$resizeTimerId);const t=r.$setTimeout;r.$resizeTimerId=t(r.$resizeExecute,300)},r.$resizeExecute=()=>{const t=r.$currentPlayer();if(t._$loadStatus===ie.LOAD_END){t._$resize();const e=t._$stage;e.willTrigger(o.RESIZE)&&e.dispatchEvent(new o(o.RESIZE))}},r.$window.addEventListener("resize",r.$resize),r.$resetContext=t=>{const e=t._$contextStyle;switch(e._$fillStyle.constructor){case Lt:case Pt:e._$fillStyle=r.$getFloat32Array4(1,1,1,1);break;default:e._$fillStyle[0]=1,e._$fillStyle[1]=1,e._$fillStyle[2]=1,e._$fillStyle[3]=1}switch(e._$strokeStyle.constructor){case Lt:case Pt:e._$strokeStyle=r.$getFloat32Array4(1,1,1,1);break;default:e._$strokeStyle[0]=1,e._$strokeStyle[1]=1,e._$strokeStyle[2]=1,e._$strokeStyle[3]=1}t._$style=e,t._$globalAlpha=1,t._$globalCompositeOperation=S.NORMAL,t._$imageSmoothingEnabled=!1},r.$getPreObject=()=>r.$preObjects.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,currentAttachment:null,currentMaskBuffer:null,currentMaskBounds:null,cacheCurrentBounds:null,blendMode:null,filters:null,layerWidth:null,layerHeight:null},r.$poolPreObject=t=>{t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.currentAttachment=null,t.currentMaskBuffer=null,t.currentMaskBounds=null,t.cacheCurrentBounds=null,t.blendMode=null,t.filters=null,t.layerWidth=null,t.layerHeight=null,r.$preObjects.push(t)},r.$cross=(t,e,i,s)=>t*s-i*e,r.$linearGradientXY=t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],n=-819.2*t[0]+819.2*t[2]+t[4],a=-819.2*t[1]-819.2*t[3]+t[5],o=819.2*t[1]-819.2*t[3]+t[5];let h=n-e,l=-819.2*t[1]+819.2*t[3]+t[5]-a;const _=s.sqrt(h*h+l*l);_?(h/=_,l/=_):(h=0,l=0);const $=(i-e)*h+(o-a)*l;return r.$getArray(e+$*h,a+$*l,i,o)},r.$ajax=(t=null)=>{t||(t={method:"GET"}),"method"in t||(t.method="GET");let e=null;switch(t.method.toUpperCase()){case gt.GET:if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():e[1]+"&"+t.data.toString(),t.url=e.join("?")}break;case gt.PUT:case gt.POST:e=t.data?t.data.toString():null}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),t.withCredentials&&(i.withCredentials=!0),t.event){const e=Object.keys(t.event),s=e.length;for(let r=0;r<s;++r){const s=e[r];i.addEventListener(s,t.event[s])}r.$poolArray(e)}if(t.format===ct.ARRAY_BUFFER&&(i.responseType=ct.ARRAY_BUFFER),t.headers)for(const[e,s]of t.headers)i.setRequestHeader(e,s);i.send(e)},r.$headerToArray=t=>{const e=r.$getArray();if(t){const i=t.trim().split("\n"),s=i.length;for(let t=0;t<s;++t){const s=i[t].split(":");e.push({name:s[0],value:s[1].trim()})}}return e},r.$getClass=t=>{const e=t.split(".");let i=r.$window;for(let t=0;t<e.length;++t){const s=e[t];if(!(s in i))return null;i=i[s]}return i},r.$imageWorkerActive=!1,r.$imageQueues=[],r.$decodeImage=function(){const t=r.$currentPlayer(),e=this.image.width,i=this.image.height,s=new M(e,i,!0,4278190080),n=t._$context,a=n.frameBuffer.currentAttachment;s._$texture=n.frameBuffer.createTextureFromImage(this.image);const o=new U;o.graphics.beginBitmapFill(s,null,!1).drawRect(0,0,e,i);const h=this.scope.contentLoaderInfo;if(h._$content=o,o._$loaderInfo=h,t._$loaders.push(h),a?n._$bind(a):n.frameBuffer.unbind(),r.$imageQueues.length){const t=r.$imageQueues.shift();t.image.decode().then(r.$decodeImage.bind(t)).catch((()=>{throw new Error("image encoding error")}))}else r.$imageWorkerActive=!1},r.$unzipURL=URL.createObjectURL(new Blob(['/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){"use strict";var t=void 0,r=this;function i(i,e){var s,h=i.split("."),n=r;!(h[0]in n)&&n.execScript&&n.execScript("var "+h[0]);for(;h.length&&(s=h.shift());)h.length||e===t?n=n[s]?n[s]:n[s]={}:n[s]=e}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function s(t){var r,i,s,h,n,a,o,f,l,u,c=t.length,b=0,y=Number.POSITIVE_INFINITY;for(f=0;f<c;++f)t[f]>b&&(b=t[f]),t[f]<y&&(y=t[f]);for(r=1<<b,i=new(e?Uint32Array:Array)(r),s=1,h=0,n=2;s<=b;){for(f=0;f<c;++f)if(t[f]===s){for(a=0,o=h,l=0;l<s;++l)a=a<<1|1&o,o>>=1;for(u=s<<16|f,l=a;l<r;l+=n)i[l]=u;++h}++s,h<<=1,n<<=1}return[i,b,y]}function h(t,r){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=e?new Uint8Array(t):t,this.m=!1,this.i=a,this.r=!1,!r&&(r={})||(r.index&&(this.a=r.index),r.bufferSize&&(this.h=r.bufferSize),r.bufferType&&(this.i=r.bufferType),r.resize&&(this.r=r.resize)),this.i){case n:this.b=32768,this.c=new(e?Uint8Array:Array)(32768+this.h+258);break;case a:this.b=0,this.c=new(e?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error("invalid inflate mode")}}var n=0,a=1,o={t:n,s:a};h.prototype.k=function(){for(;!this.m;){var r=S(this,3);switch(1&r&&(this.m=!0),r>>>=1){case 0:var i=this.input,h=this.a,o=this.c,f=this.b,l=i.length,u=t,b=o.length,y=t;if(this.d=this.f=0,h+1>=l)throw Error("invalid uncompressed block header: LEN");if(u=i[h++]|i[h++]<<8,h+1>=l)throw Error("invalid uncompressed block header: NLEN");if(u===~(i[h++]|i[h++]<<8))throw Error("invalid uncompressed block header: length verify");if(h+u>i.length)throw Error("input buffer is broken");switch(this.i){case n:for(;f+u>o.length;){if(u-=y=b-f,e)o.set(i.subarray(h,h+y),f),f+=y,h+=y;else for(;y--;)o[f++]=i[h++];this.b=f,o=this.e(),f=this.b}break;case a:for(;f+u>o.length;)o=this.e({p:2});break;default:throw Error("invalid inflate mode")}if(e)o.set(i.subarray(h,h+u),f),f+=u,h+=u;else for(;u--;)o[f++]=i[h++];this.a=h,this.b=f,this.c=o;break;case 1:this.j(E,z);break;case 2:var p,d,g,v,w=S(this,5)+257,A=S(this,5)+1,k=S(this,4)+4,U=new(e?Uint8Array:Array)(c.length),m=t,I=t,x=t,N=t,j=t;for(j=0;j<k;++j)U[c[j]]=S(this,3);if(!e)for(j=k,k=U.length;j<k;++j)U[c[j]]=0;for(p=s(U),m=new(e?Uint8Array:Array)(w+A),j=0,v=w+A;j<v;)switch(I=T(this,p),I){case 16:for(N=3+S(this,2);N--;)m[j++]=x;break;case 17:for(N=3+S(this,3);N--;)m[j++]=0;x=0;break;case 18:for(N=11+S(this,7);N--;)m[j++]=0;x=0;break;default:x=m[j++]=I}d=s(e?m.subarray(0,w):m.slice(0,w)),g=s(e?m.subarray(w):m.slice(w)),this.j(d,g);break;default:throw Error("unknown BTYPE: "+r)}}return this.n()};var f,l,u=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],c=e?new Uint16Array(u):u,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],y=e?new Uint16Array(b):b,p=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],d=e?new Uint8Array(p):p,g=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],v=e?new Uint16Array(g):g,w=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],A=e?new Uint8Array(w):w,k=new(e?Uint8Array:Array)(288);for(f=0,l=k.length;f<l;++f)k[f]=143>=f?8:255>=f?9:279>=f?7:8;var U,m,E=s(k),I=new(e?Uint8Array:Array)(30);for(U=0,m=I.length;U<m;++U)I[U]=5;var z=s(I);function S(t,r){for(var i,e=t.f,s=t.d,h=t.input,n=t.a,a=h.length;s<r;){if(n>=a)throw Error("input buffer is broken");e|=h[n++]<<s,s+=8}return i=e&(1<<r)-1,t.f=e>>>r,t.d=s-r,t.a=n,i}function T(t,r){for(var i,e,s=t.f,h=t.d,n=t.input,a=t.a,o=n.length,f=r[0],l=r[1];h<l&&!(a>=o);)s|=n[a++]<<h,h+=8;if((e=(i=f[s&(1<<l)-1])>>>16)>h)throw Error("invalid code length: "+e);return t.f=s>>e,t.d=h-e,t.a=a,65535&i}function x(t,r){var i,e;if(this.input=t,this.a=0,!r&&(r={})||(r.index&&(this.a=r.index),r.verify&&(this.A=r.verify)),i=t[this.a++],e=t[this.a++],(15&i)!==N)throw Error("unsupported compression method");if(this.method=N,0!=((i<<8)+e)%31)throw Error("invalid fcheck flag:"+((i<<8)+e)%31);if(32&e)throw Error("fdict flag is not supported");this.q=new h(t,{index:this.a,bufferSize:r.bufferSize,bufferType:r.bufferType,resize:r.resize})}h.prototype.j=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length-258;256!==(s=T(this,t));)if(256>s)e>=o&&(this.b=e,i=this.e(),e=this.b),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e>=o&&(this.b=e,i=this.e(),e=this.b);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.w=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length;256!==(s=T(this,t));)if(256>s)e>=o&&(o=(i=this.e()).length),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e+a>o&&(o=(i=this.e()).length);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.e=function(){var t,r,i=new(e?Uint8Array:Array)(this.b-32768),s=this.b-32768,h=this.c;if(e)i.set(h.subarray(32768,i.length));else for(t=0,r=i.length;t<r;++t)i[t]=h[t+32768];if(this.g.push(i),this.l+=i.length,e)h.set(h.subarray(s,s+32768));else for(t=0;32768>t;++t)h[t]=h[s+t];return this.b=32768,h},h.prototype.z=function(t){var r,i,s,h=this.input.length/this.a+1|0,n=this.input,a=this.c;return t&&("number"==typeof t.p&&(h=t.p),"number"==typeof t.u&&(h+=t.u)),2>h?i=(s=(n.length-this.a)/this.o[2]/2*258|0)<a.length?a.length+s:a.length<<1:i=a.length*h,e?(r=new Uint8Array(i)).set(a):r=a,this.c=r},h.prototype.n=function(){var t,r,i,s,h,n=0,a=this.c,o=this.g,f=new(e?Uint8Array:Array)(this.l+(this.b-32768));if(0===o.length)return e?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(r=0,i=o.length;r<i;++r)for(s=0,h=(t=o[r]).length;s<h;++s)f[n++]=t[s];for(r=32768,i=this.b;r<i;++r)f[n++]=a[r];return this.g=[],this.buffer=f},h.prototype.v=function(){var t,r=this.b;return e?this.r?(t=new Uint8Array(r)).set(this.c.subarray(0,r)):t=this.c.subarray(0,r):(this.c.length>r&&(this.c.length=r),t=this.c),this.buffer=t},x.prototype.k=function(){var t,r,i=this.input;if(t=this.q.k(),this.a=this.q.a,this.A){r=(i[this.a++]<<24|i[this.a++]<<16|i[this.a++]<<8|i[this.a++])>>>0;var e=t;if("string"==typeof e){var s,h,n=e.split("");for(s=0,h=n.length;s<h;s++)n[s]=(255&n[s].charCodeAt(0))>>>0;e=n}for(var a,o=1,f=0,l=e.length,u=0;0<l;){l-=a=1024<l?1024:l;do{f+=o+=e[u++]}while(--a);o%=65521,f%=65521}if(r!==(f<<16|o)>>>0)throw Error("invalid adler-32 checksum")}return t};var N=8;i("Zlib.Inflate",x),i("Zlib.Inflate.prototype.decompress",x.prototype.k);var j,C,O,L,Z={ADAPTIVE:o.s,BLOCK:o.t};if(Object.keys)j=Object.keys(Z);else for(C in j=[],O=0,Z)j[O++]=C;for(O=0,L=j.length;O<L;++O)i("Zlib.Inflate.BufferType."+(C=j[O]),Z[C])}).call(this),this.addEventListener("message",(function(t){const r=new Zlib.Inflate(t.data).decompress();let i="";for(let t=0;t<r.length;++t)i+=String.fromCharCode(r[t]);this.postMessage(JSON.parse(decodeURIComponent(i)))}));'],{type:"text/javascript"})),r.$unzipWorker=null,r.$unzipQueues=[],r.$unzipWorkerActive=!1,r.$unzipHandler=function(t){if(this._$build(t.data),r.$unzipQueues.length){const t=r.$unlzmaQueues.pop(),e=new Uint8Array(t.json.buffer);r.$unzipWorker.onmessage=r.$unzipHandler.bind(t.scope),r.$unzipWorker.postMessage(e,[e.buffer])}else r.$unzipWorkerActive=!1},r.$packages=t=>{t.display={BitmapData:M,BitmapDataChannel:C,BlendMode:S,CapsStyle:R,DisplayObject:T,DisplayObjectContainer:y,FrameLabel:w,GradientType:O,Graphics:I,GraphicsGradientFill:F,InteractiveObject:v,InterpolationMethod:L,JointStyle:P,Loader:D,LoaderInfo:N,MovieClip:A,Shape:U,SpreadMethod:k,Sprite:E,Stage:G},t.events={Event:o,EventDispatcher:h,EventPhase:l,FocusEvent:_,HTTPStatusEvent:$,IOErrorEvent:c,MouseEvent:u,ProgressEvent:d,VideoEvent:g},t.filters={BevelFilter:W,BitmapFilterQuality:j,BitmapFilterType:Y,BlurFilter:V,ColorMatrixFilter:q,ConvolutionFilter:K,DisplacementMapFilter:Q,DisplacementMapFilterMode:z,DropShadowFilter:J,GlowFilter:Z,GradientBevelFilter:tt,GradientGlowFilter:et},t.geom={ColorTransform:f,Matrix:m,Point:p,Rectangle:x,Transform:b},t.media={Sound:ht,SoundMixer:lt,SoundTransform:_t,Video:$t},t.net={URLLoaderDataFormat:ct,URLRequest:ut,URLRequestHeader:dt,URLRequestMethod:gt},t.text={TextField:rt,TextFieldAutoSize:st,TextFieldType:nt,TextFormat:at,TextFormatAlign:it,TextFormatVerticalAlign:ot},t.ui={Easing:ft,Job:mt,Tween:pt}};class o{constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=!!e,this._$cancelable=!!i,this._$target=null,this._$currentTarget=null,this._$eventPhase=l.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1,this._$preventDefault=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get RESIZE(){return"resize"}static get SCROLL(){return"scroll"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}get eventPhase(){return this._$eventPhase}get listener(){return this._$listener}get target(){return this._$target?this._$target:this._$currentTarget}get type(){return this._$type}formatToString(){let t=`[${arguments[0]}`;for(let e=1;e<arguments.length;++e){const i=arguments[e];t+=` ${i}=`;const s=this[i];t+="string"==typeof s?`"${s}"`:`${s}`}return`${t}]`}isDefaultPrevented(){return!!r.$event&&r.$event.defaultPrevented}preventDefault(){this._$preventDefault=!0}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}class h{constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,s=0){let n,a,h=!1;switch(t=`${t}`){case o.ENTER_FRAME:case o.EXIT_FRAME:case o.FRAME_CONSTRUCTED:case o.RENDER:case o.ACTIVATE:case o.DEACTIVATE:case"keyDown":case"keyUp":a=r.$currentPlayer(),a.broadcastEvents.size&&a.broadcastEvents.has(t)||a.broadcastEvents.set(t,r.$getArray()),n=a.broadcastEvents.get(t),h=!0;break;default:this._$events||(this._$events=r.$getMap()),this._$events.size&&this._$events.has(t)||this._$events.set(t,r.$getArray()),n=this._$events.get(t)}let l=n.length;for(let t=0;t<l;++t){const s=n[t];i===s.useCapture&&(s.target===this&&s.listener===e&&(l=t))}n[l]={listener:e,priority:s,useCapture:i,target:this},h?a.broadcastEvents.set(t,n):(n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,n))}dispatchEvent(t){switch(t.type){case o.ENTER_FRAME:case o.EXIT_FRAME:case o.FRAME_CONSTRUCTED:case o.RENDER:case o.ACTIVATE:case o.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:r.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t.type)){const e=i.broadcastEvents.get(t.type),s=e.length;for(let i=0;i<s;++i){const s=e[i];if(s.target===this){t._$eventPhase=l.AT_TARGET,t._$currentTarget=s.target;try{t._$listener=s.listener,s.listener.call(r.$window,t)}catch(t){return!1}}}return!0}}break;default:{let e=r.$getArray();this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type).slice(0));const i=r.$getArray();if(this instanceof T){let e=this._$parent;for(;e;)e.hasEventListener(t.type)&&(i[i.length]=e._$events.get(t.type)),e=e._$parent}if(t._$target=this,e.length||i.length){if(t._$eventPhase=l.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(i.useCapture){t._$currentTarget=i.target,r.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(r.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}if(t._$eventPhase=l.AT_TARGET,!t._$stopImmediatePropagation&&!t._$stopPropagation){const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(!i.useCapture){t._$currentTarget=i.target,r.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(r.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}}switch(t._$eventPhase=l.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(!i.useCapture){t._$currentTarget=i.target,r.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(r.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return r.$poolArray(e),r.$poolArray(i),!0}r.$poolArray(e),r.$poolArray(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case o.ENTER_FRAME:case o.EXIT_FRAME:case o.FRAME_CONSTRUCTED:case o.RENDER:case o.ACTIVATE:case o.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:r.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t)){const e=i.broadcastEvents.get(t);for(let t=0;t<e.length;t++)if(e[t].target===this)return!0}return!1}default:return!!(this._$events&&this._$events.size&&this._$events.has(t))}}removeEventListener(t,e,i=!1){if(t=`${t}`,!this.hasEventListener(t))return;let s,n,a=!1;switch(t){case o.ENTER_FRAME:case o.EXIT_FRAME:case o.FRAME_CONSTRUCTED:case o.RENDER:case o.ACTIVATE:case o.DEACTIVATE:case"keyDown":case"keyUp":a=!0,n=r.$currentPlayer(),n&&(s=n.broadcastEvents.get(t));break;default:s=this._$events.get(t)}const h=s.length;for(let t=0;t<h;++t){const r=s[t];if(i===r.useCapture&&r.listener===e){s.splice(t,1);break}}s.length?a?n.broadcastEvents.set(t,s):(s.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,s)):a?n.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(r.$poolMap(this._$events),this._$events=null))}removeAllEventListener(t,e=!1){if(t=`${t}`,!this.hasEventListener(t))return;let i,s,n=!1;switch(t){case o.ENTER_FRAME:case o.EXIT_FRAME:case o.FRAME_CONSTRUCTED:case o.RENDER:case o.ACTIVATE:case o.DEACTIVATE:case"keyDown":case"keyUp":n=!0,s=r.$currentPlayer(),s&&(i=s.broadcastEvents.get(t));break;default:i=this._$events.get(t)}const a=r.$getArray(),h=i.length;for(let t=0;t<h;++t){const s=i[t];e!==s.useCapture&&a.push(s)}a.length?n?s.broadcastEvents.set(t,a):(a.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,a)):n?s.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(r.$poolMap(this._$events),this._$events=null))}willTrigger(t){if(this.hasEventListener(t))return!0;let e=this._$parent;for(;e;){if(e.hasEventListener(t))return!0;e=e._$parent}return!1}}class l{static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class _ extends o{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class $ extends o{constructor(t,e=!1,i=!1,s=0){super(t,e,i),this._$status=0|s,this._$responseHeaders=[],this._$responseURL=""}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","eventPhase","status","responseURL")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}get responseURL(){return this._$responseURL}get status(){return this._$status}}class c extends o{constructor(t,e=!1,i=!1,s=""){super(t,e,i),this._$text=`${s}`}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}get text(){return this._$text}}class u extends o{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:function(t,e){return e in t?t[e]:r.$event&&e in r.$event?r.$event[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class d extends o{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class g extends o{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class f{constructor(t=1,e=1,i=1,s=1,n=0,a=0,o=0,h=0){this._$colorTransform=r.$getFloat32Array8(1,1,1,1,0,0,0,0),this.redMultiplier=t,this.greenMultiplier=e,this.blueMultiplier=i,this.alphaMultiplier=s,this.redOffset=n,this.greenOffset=a,this.blueOffset=o,this.alphaOffset=h}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=r.$clamp(+t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=r.$clamp(0|t,-255,255,0)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=r.$clamp(+t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=r.$clamp(0|t,-255,255,0)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=r.$clamp(+t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=r.$clamp(0|t,-255,255,0)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=r.$clamp(+t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=r.$clamp(0|t,-255,255,0)}concat(t){const e=r.$multiplicationColor(this._$colorTransform,t._$colorTransform);this.redMultiplier=e[0],this.greenMultiplier=e[1],this.blueMultiplier=e[2],this.alphaMultiplier=e[3],this.redOffset=e[4],this.greenOffset=e[5],this.blueOffset=e[6],this.alphaOffset=e[7],r.$poolFloat32Array8(e)}_$clone(){return r.$getColorTransform(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class m{constructor(t=1,e=0,i=0,s=1,n=0,a=0){this._$matrix=r.$getFloat32Array6(1,0,0,1,0,0),this.a=t,this.b=e,this.c=i,this.d=s,this.tx=n,this.ty=a}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}_$clone(){return this.clone()}clone(){return r.$getMatrix(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let s=e[0]*i[0],r=0,n=0,a=e[3]*i[3],o=e[4]*i[0]+i[4],h=e[5]*i[3]+i[5];(e[1]||e[2]||i[1]||i[2])&&(s+=e[1]*i[2],a+=e[2]*i[1],r+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],o+=e[5]*i[2],h+=e[4]*i[1]),this.a=s,this.b=r,this.c=n,this.d=a,this.tx=o,this.ty=h}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,s=0,r=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(s,r)}createGradientBox(t,e,i=0,s=0,r=0){this.createBox(t/1638.4,e/1638.4,i,s+t/2,r+e/2)}deltaTransformPoint(t){return new p(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){let t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],s=this._$matrix[3],r=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/s,this.tx=-this.a*r,this.ty=-this.d*n;else{const a=t*s-e*i;if(a){const o=1/a;this.a=s*o,this.b=-e*o,this.c=-i*o,this.d=t*o,this.tx=-(this.a*r+this.c*n),this.ty=-(this.b*r+this.d*n)}}}rotate(t){const e=this._$matrix[0],i=this._$matrix[1],r=this._$matrix[2],n=this._$matrix[3],a=this._$matrix[4],o=this._$matrix[5];this.a=e*s.cos(t)-i*s.sin(t),this.b=e*s.sin(t)+i*s.cos(t),this.c=r*s.cos(t)-n*s.sin(t),this.d=r*s.sin(t)+n*s.cos(t),this.tx=a*s.cos(t)-o*s.sin(t),this.ty=a*s.sin(t)+o*s.cos(t)}scale(t,e){this.a*=t,this.c*=t,this.tx*=t,this.b*=e,this.d*=e,this.ty*=e}setTo(t,e,i,s,r,n){this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}transformPoint(t){return new p(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class p{constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return s.sqrt(s.pow(this.x,2)+s.pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}add(t){return new p(this.x+t.x,this.y+t.y)}clone(){return new p(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return s.sqrt(s.pow(t._$x-e._$x,2)+s.pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new p(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new p(t*s.cos(e),t*s.sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new p(this.x-t.x,this.y-t.y)}}class x{constructor(t=0,e=0,i=0,s=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,s)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new p(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new p(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new p(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get x(){return this._$x}set x(t){this._$x=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}clone(){return new x(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=s.max(this.x,t.x),i=s.max(this.y,t.y),r=s.min(this.right,t.right)-e,n=s.min(this.bottom,t.bottom)-i;return r>0&&n>0?new x(e,i,r,n):new x(0,0,0,0)}intersects(t){const e=s.max(this.x,t.x),i=s.max(this.y,t.y),r=s.min(this.right,t.right),n=s.min(this.bottom,t.bottom);return r-e>0&&n-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new x(s.min(this.x,t.x),s.min(this.y,t.y),s.max(this.right-t.left,t.right-this.left),s.max(this.bottom-t.top,t.bottom-this.top))}}class b{constructor(t){if(!(t instanceof T))throw new Error("Transform params is DisplayObject only.");this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.colorTransform,i=new f;return i._$colorTransform=r.$getFloat32Array8(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),i}return this._$transform(),this._$colorTransform._$clone()}set colorTransform(t){t instanceof f&&this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=r.$multiplicationColor(e._$transform._$rawColorTransform(),t),e=e._$parent;return r.$getColorTransform(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.matrix;return r.$getMatrix(e[0],e[1],e[2],e[3],e[4],e[5])}return this._$transform(),this._$matrix._$clone()}set matrix(t){t instanceof m&&this._$transform(t._$matrix,null)}get concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=r.$multiplicationMatrix(e._$transform._$rawMatrix(),t),e=e._$parent;return r.$getMatrix(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){const t=new x(0,0,0,0);if(!this._$displayObject)return t;const e=this._$displayObject._$getBounds(null);return t._$x=e.xMin,t._$y=e.yMin,t._$width=+s.abs(e.xMax-e.xMin),t._$height=+s.abs(e.yMax-e.yMin),r.$poolBoundsObject(e),t}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject._$getPlaceObject();return t?t.matrix:r.$MATRIX_ARRAY_IDENTITY}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject._$getPlaceObject();return t?t.colorTransform:r.$COLOR_ARRAY_IDENTITY}_$transform(t=null,e=null,i=null,s=""){const r=this._$displayObject._$getPlaceObject();this._$setMatrix(t,r),this._$setColorTransform(e,r),this._$setFilters(i,r),this._$setBlendMode(s,r)}_$setMatrix(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),r.$isUpdated=!0),this._$matrix||(this._$matrix=r.$getMatrix(1,0,0,1,0,0),!t&&e&&(t=e.matrix)),t){const e=this._$matrix._$matrix;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5]}}_$setColorTransform(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),r.$isUpdated=!0),this._$colorTransform||(this._$colorTransform=r.$getColorTransform(1,1,1,1,0,0,0,0),!t&&e&&(t=e.colorTransform)),t){const e=this._$colorTransform._$colorTransform;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7]}}_$setFilters(t=null,e=null){if(r.$isArray(t))return this._$filters&&r.$poolArray(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void(r.$isUpdated=!0);if(!this._$filters)if(e){if(e.filters)this._$filters=e.filters.slice(0);else if(e.surfaceFilterList){const t=r.$getArray(),i=e.surfaceFilterList.length;for(let s=0;s<i;++s){const i=e.surfaceFilterList[s],r=next2d.filters[i.class];t.push(new(r.bind.apply(r,i.params)))}e.filters=t,this._$filters=t.slice(0)}}else this._$filters=r.$getArray()}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void(r.$isUpdated=!0);this._$blendMode||(this._$blendMode=e?e.blendMode:S.NORMAL)}}class T extends h{constructor(){super(),this._$id=-1,this._$instanceId=e++,this._$dictionaryId=0,this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$buffer=null,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=null,this._$startFrame=1,this._$endFrame=0,this._$transform=new b(this),this._$variables=null,this._$placeObject=null}static toString(){return"[class DisplayObject]"}static get namespace(){return"next2d.display.DisplayObject"}toString(){return"[object DisplayObject]"}get namespace(){return"next2d.display.DisplayObject"}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=r.$clamp(t,0,1,0);const e=this._$transform.colorTransform;e._$colorTransform[3]=t,e._$colorTransform[7]=0,this._$transform.colorTransform=e,r.$poolColorTransform(e)}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,this._$blendMode;const e=this._$getPlaceObject();return e?(this._$blendMode=e.blendMode,this._$blendMode):(t._$transform(),this._$blendMode=t._$blendMode,this._$blendMode)}set blendMode(t){this._$transform._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters)return this._$filters;const t=this._$transform;if(t._$filters)return this._$filters=t._$filters.slice(0),this._$filters;const e=this._$getPlaceObject();if(e){if(!e.filters){const t=[];if(e.surfaceFilterList){const i=e.surfaceFilterList.length;for(let s=0;s<i;++s){const i=e.surfaceFilterList[s],r=next2d.filters[i.class];t.push(new(r.bind.apply(r,i.params)))}}e.filters=t}return this._$filters||(this._$filters=e.filters),e.filters.slice(0)}return t._$transform(),this._$filters=t._$filters,this._$filters.slice(0)}set filters(t){t||(t=r.$getArray()),this._$transform._$transform(null,null,t,null),this._$filters=t}get height(){const t=r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=s.abs(t.yMax-t.yMin);switch(r.$poolBoundsObject(t),e){case 0:case r.$Infinity:case-r.$Infinity:return 0;default:return e}}set height(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this.rotation?r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=s.abs(e.yMax-e.yMin);switch(r.$poolBoundsObject(e),i){case 0:case r.$Infinity:case-r.$Infinity:this.scaleY=0;break;default:this.scaleY=t/i}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(this._$mask._$isMask=!1,this._$mask=null),t instanceof T&&(t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return r.$event?this.globalToLocal(r.$currentMousePoint()).x:0}get mouseY(){return r.$event?this.globalToLocal(r.$currentMousePoint()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren(),i=t.length;for(let s=0;s<i;++s){const i=t[s];i._$name&&e._$names.set(i.name,i)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){const t=this._$transform._$rawMatrix();return s.atan2(t[1],t[0])*r.$Rad2Deg}set rotation(t){t=r.$clamp(t%360,-360,360,0);const e=this._$transform,i=e.matrix,n=s.sqrt(i.a*i.a+i.b*i.b),a=s.sqrt(i.c*i.c+i.d*i.d);if(0===t)i.a=n,i.b=0,i.c=0,i.d=a;else{let e=s.atan2(i.b,i.a),o=s.atan2(-i.c,i.d);const h=t*r.$Deg2Rad;o=o+h-e,e=h,i.b=n*s.sin(e),1===i.b||-1===i.b?i.a=0:i.a=n*s.cos(e),i.c=-a*s.sin(o),1===i.c||-1===i.c?i.d=0:i.d=a*s.cos(o)}e.matrix=i,r.$poolMatrix(i)}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid=null,t instanceof x&&(this._$scale9Grid=t)}get scaleX(){const t=this._$transform._$rawMatrix(),e=s.sqrt(t[0]*t[0]+t[1]*t[1]);return 0>t[0]?-1*e:e}set scaleX(t){const e=this._$transform,i=e.matrix;if(0===i.b||r.$isNaN(i.b))i.a=t;else{const e=s.atan2(i.b,i.a);i.b=t*s.sin(e),i.a=1===i.b||-1===i.b?0:t*s.cos(e)}e.matrix=i,r.$poolMatrix(i)}get scaleY(){const t=this._$transform._$rawMatrix(),e=s.sqrt(t[2]*t[2]+t[3]*t[3]);return 0>t[3]?-1*e:e}set scaleY(t){const e=this._$transform,i=e.matrix;if(0===i.c||r.$isNaN(i.c))i.d=t;else{const e=s.atan2(-i.c,i.d);i.c=-t*s.sin(e),i.d=1===i.c||-1===i.c?0:t*s.cos(e)}e.matrix=i,r.$poolMatrix(i)}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t instanceof G?t:t._$stage:null}get transform(){return this._$transform}set transform(t){t instanceof b&&(this._$transform=t)}get visible(){return this._$visible}set visible(t){t=!!t,this._$visible!==t&&(this._$doChanged(),r.$isUpdated=!0),this._$visible=!!t}get width(){const t=r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=s.abs(t.xMax-t.xMin);switch(r.$poolBoundsObject(t),!0){case 0===e:case e===r.$Infinity:case e===-r.$Infinity:return 0;default:return e}}set width(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this.rotation?r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=s.abs(e.xMax-e.xMin);switch(r.$poolBoundsObject(e),!0){case 0===i:case i===r.$Infinity:case i===-r.$Infinity:this.scaleX=0;break;default:this.scaleX=t/i}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform,i=this._$transform.matrix;i.tx=t,e.matrix=i,r.$poolMatrix(i)}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform,i=e.matrix;i.ty=t,e.matrix=i,r.$poolMatrix(i)}getBounds(t=null){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,n=r.$boundsMatrix(e,i._$matrix);r.$poolMatrix(i),r.$poolBoundsObject(e);const a=r.$getBoundsObject(n.xMin,n.xMax,n.yMin,n.yMax);r.$poolBoundsObject(n),t||(t=this);const o=t._$transform.concatenatedMatrix;o.invert();const h=r.$boundsMatrix(a,o._$matrix),l=h.xMin,_=h.yMin,$=h.xMax,c=h.yMax;return r.$poolBoundsObject(a),r.$poolBoundsObject(h),r.$poolMatrix(o),new x(l,_,s.abs($-l),s.abs(c-_))}globalToLocal(t){const e=this._$transform.concatenatedMatrix;e.invert();const i=new p(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return r.$poolMatrix(e),i}hitTestObject(t){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,n=r.$boundsMatrix(e,i._$matrix);r.$poolMatrix(i),r.$poolBoundsObject(e);const a=t._$getBounds(null),o=t._$transform.concatenatedMatrix,h=r.$boundsMatrix(a,o._$matrix);r.$poolMatrix(o),r.$poolBoundsObject(a);const l=s.max(n.xMin,h.xMin),_=s.max(n.yMin,h.yMin),$=s.min(n.xMax,h.xMax),c=s.min(n.yMax,h.yMax);return r.$poolBoundsObject(n),r.$poolBoundsObject(h),$-l>=0&&c-_>=0}hitTestPoint(t,e,i=!1){if(i){let i=r.$MATRIX_ARRAY_IDENTITY,s=this._$parent;for(;s;)i=r.$multiplicationMatrix(s._$transform._$rawMatrix(),i),s=s._$parent;r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath();const n=this._$hit(r.$hitContext,i,{x:t,y:e},!0);return r.$poolFloat32Array6(i),n}const s=this._$getBounds(null),n=r.$boundsMatrix(s,this._$transform._$rawMatrix()),a=n.xMin,o=n.yMin,h=n.xMax-n.xMin,l=n.yMax-n.yMin,_=this._$parent?this._$parent.globalToLocal(new p(t,e)):new p(t,e);return r.$poolBoundsObject(n),r.$poolBoundsObject(s),new x(a,o,h,l).containsPoint(_)}localToGlobal(t){const e=this._$transform.concatenatedMatrix,i=new p(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return r.$poolMatrix(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=r.$getMap()),this._$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(r.$poolMap(this._$variables),this._$variables=null))}getGlobalVariable(t){return r.$variables.has(t)?r.$variables.get(t):null}setGlobalVariable(t,e){r.$variables.set(t,e)}hasGlobalVariable(t){return r.$variables.has(t)}deleteGlobalVariable(t){r.$variables.has(t)&&r.$variables.delete(t)}clearGlobalVariable(){return r.$variables.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(null===t)return null;const e=this._$parent;if(!e)return null;const i=e._$placeMap;if(!i||!i.length)return null;const s=i[e._$currentFrame||1];if(!s)return null;this._$placeObject=e._$placeObjects[s[t]]}return this._$placeObject}_$sync(){const t=this.contentName;let e=null;if(next2d.fw.response.has(t)&&(e=next2d.fw.response.get(t)._$loaderInfo),!e&&next2d.fw.cache.has(t)&&(e=next2d.fw.cache.get(t)._$loaderInfo),e||(e=this._$loaderInfo||r.$currentLoaderInfo),!e)return null;const i=e._$data.symbols.get(this.namespace),s=e._$data.characters[i];return this._$characterId=i,this._$loaderInfo=e,s}_$build(t,e){const i=e._$loaderInfo;return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;let t=this._$parent;t&&t._$updateState()}_$doChanged(){this._$isNext=!0,this._$updated=!0;let t=this._$parent;t&&t._$doChanged()}_$getLayerBounds(t=null){const e=this._$getBounds(t);if(!t)return e;const i=this._$filters||this.filters,s=i.length;if(!s)return e;let n=new x(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);r.$poolBoundsObject(e);for(let t=0;t<s;++t)n=i[t]._$generateFilterRect(n,null,null,!0);const a=n._$x,o=n._$x+n._$width,h=n._$y,l=n._$y+n._$height;return r.$getBoundsObject(a,o,h,l)}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger(o.ADDED)&&this.dispatchEvent(new o(o.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger(o.ADDED_TO_STAGE)&&this.dispatchEvent(new o(o.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e,i,n,a=null,o=!1,h=0,l=0){if(this._$isUpdated())return!0;if(o)for(let t=0;t<a.length;++t)if(a[t]._$isUpdated())return!0;const _=r.$cacheStore().get([this._$instanceId,"f"]);switch(!0){case null===_:case _.filterState!==o:case _.layerWidth!==s.ceil(t):case _.layerHeight!==s.ceil(e):case _.matrix!==i[0]+"_"+i[1]+"_"+i[2]+"_"+i[3]+"_"+h+"_"+l:case _.colorTransform!==n[0]+"_"+n[1]+"_"+n[2]+"_"+n[3]+"_"+n[4]+"_"+n[5]+"_"+n[6]+"_"+n[7]:return!0}return!1}_$getFilterTexture(t,e,i,s,n){const a=t.frameBuffer.currentAttachment,o=t.frameBuffer.createCacheAttachment(i.width,i.height);t._$bind(o),r.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;let h=null;for(let i=0;i<e.length;++i)h=e[i]._$applyFilter(t,s);let l=t._$offsetX,_=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,h._$offsetX=l,h._$offsetY=_,h.matrix=s[0]+"_"+s[1]+"_"+s[2]+"_"+s[3]+"_0_0",h.colorTransform=n[0]+"_"+n[1]+"_"+n[2]+"_"+n[3]+"_"+n[4]+"_"+n[5]+"_"+n[6]+"_"+n[7],h.filterState=!0,h.layerWidth=i.width,h.layerHeight=i.height,t._$bind(a),t.frameBuffer.releaseAttachment(o,!1),h}_$preDraw(t,e,i){const n=this._$transform._$rawMatrix(),a=r.$multiplicationMatrix(e,n);if(!a[0]&&!a[1]||!a[2]&&!a[3])return!1;const o=r.$getPreObject();o.matrix=a;const h=this._$filters||this.filters,l=this._$blendMode||this.blendMode;if(h.length>0||l!==S.NORMAL){const e=this._$getBounds(null),_=r.$boundsMatrix(e,a),$=+_.xMax,c=+_.xMin,u=+_.yMax,d=+_.yMin;r.$poolBoundsObject(e),r.$poolBoundsObject(_);const g=s.abs($-c),f=s.abs(u-d);if(0>=g||0>=f)return!1;if(0>c+g||0>d+f)return!1;const m=t.frameBuffer.currentAttachment;if(c>m.width||d>m.height)return!1;o.basePosition.x=n[4],o.basePosition.y=n[5];let p=this._$getLayerBounds(null);const x=r.$boundsMatrix(p,a);let b=s.abs(x.xMax-x.xMin),T=s.abs(x.yMax-x.yMin);r.$poolBoundsObject(x),b===g&&T===f&&(r.$poolBoundsObject(p),p=null);let v=a[4]-s.floor(c),y=a[5]-s.floor(d),E=null;if(p){const t=r.$getFloat32Array6(a[0],a[1],a[2],a[3],0,0);E=r.$boundsMatrix(p,t),r.$poolBoundsObject(p),r.$poolFloat32Array6(t),v+=-s.floor(E.xMin)-v,y+=-s.floor(E.yMin)-y}let A=s.floor(c),M=s.floor(d),C=c,S=d;if(E&&(A-=-s.floor(E.xMin)-(a[4]-A),M-=-s.floor(E.yMin)-(a[5]-M),C-=-E.xMin-(a[4]-C),S-=-E.yMin-(a[5]-S),r.$poolBoundsObject(E)),o.position.dx=A>0?A:0,o.position.dy=M>0?M:0,b+C>m.texture.width&&(b-=b-m.texture.width+C),T+S>m.texture.height&&(T-=T-m.texture.height+S),0>A&&(v+=A,b+=C),0>M&&(y+=M,T+=S),0>=b||0>=T||!b||!T)return r.$poolPreObject(o),!1;t._$startLayer(r.$getBoundsObject(C,0,S,0)),o.canApply=this._$canApply(h);let R=this._$isFilterUpdated(b,T,a,i,h,o.canApply,o.basePosition.x,o.basePosition.y);const w=t._$cacheCurrentBuffer;t._$cacheCurrentBuffer=null;const O=t._$cacheCurrentBounds,I=r.$getBoundsObject(O.x,O.w,O.y,O.h);R&&(this._$buffer=t.frameBuffer.createCacheAttachment(s.ceil(b),s.ceil(T),!1),t._$bind(this._$buffer)),o.isFilter=!0,o.isUpdated=R,o.color=r.$getFloat32Array8(),o.baseMatrix=a,o.baseColor=i,o.currentAttachment=m,o.currentMaskBuffer=w,o.currentMaskBounds=I,o.filters=h,o.blendMode=l,o.layerWidth=b,o.layerHeight=T,o.matrix=r.$getFloat32Array6(a[0],a[1],a[2],a[3],v,y)}return o}_$postDraw(t,e,i,s){const n=[this._$instanceId,"f"];let a=null;if(this._$buffer){a=t.frameBuffer.getTextureFromCurrentAttachment();const e=r.$cacheStore().get(n);e&&(r.$cacheStore().set(n,null),t.frameBuffer.releaseTexture(e))}else a=r.$cacheStore().get(n);s.canApply||(a._$offsetX=0,a._$offsetY=0);let o=a._$offsetX,h=a._$offsetY;if(s.isUpdated&&s.canApply){let i=r.$cacheStore().get(n);i&&(r.$cacheStore().set(n,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,t.frameBuffer.releaseTexture(i),i=null);const l=s.filters.length;if(l){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<l;++i)a=s.filters[i]._$applyFilter(t,e);o=t._$offsetX,h=t._$offsetY,t._$offsetX=0,t._$offsetY=0,a._$offsetX=o,a._$offsetY=h}}if(s.isUpdated){a.filterState=s.canApply;const t=s.baseMatrix;a.matrix=t[0]+"_"+t[1]+"_"+t[2]+"_"+t[3]+"_"+s.basePosition.x+"_"+s.basePosition.y;const e=s.baseColor;a.colorTransform=e[0]+"_"+e[1]+"_"+e[2]+"_"+e[3]+"_"+e[4]+"_"+e[5]+"_"+e[6]+"_"+e[7],a.layerWidth=s.layerWidth,a.layerHeight=s.layerHeight}r.$cacheStore().set(n,a),r.$poolArray(n),t._$bind(s.currentAttachment);const l=a.width,_=a.height;r.$resetContext(t),t.setTransform(1,0,0,1,0,0),t._$globalAlpha=r.$clamp(i[3]+i[7]/255,0,1),t._$globalCompositeOperation=s.blendMode,t.drawImage(a,-o+s.position.dx,-h+s.position.dy,l,_,i),t._$endLayer(),this._$buffer&&(t.frameBuffer.releaseAttachment(this._$buffer,!1),this._$buffer=null),t._$cacheCurrentBuffer=s.currentMaskBuffer,t._$cacheCurrentBounds.x=s.currentMaskBounds.xMin,t._$cacheCurrentBounds.y=s.currentMaskBounds.yMin,t._$cacheCurrentBounds.w=s.currentMaskBounds.xMax,t._$cacheCurrentBounds.h=s.currentMaskBounds.yMax,r.$poolFloat32Array8(s.color),r.$poolFloat32Array6(s.matrix),r.$poolFloat32Array6(s.baseMatrix),r.$poolBoundsObject(s.currentMaskBounds),r.$poolPreObject(s)}_$shouldClip(t){if(this instanceof rt)return!(!this.textWidth||!this.textHeight);const e=this._$getBounds(t),i=s.abs(e.xMax-e.xMin),n=s.abs(e.yMax-e.yMin);return r.$poolBoundsObject(e),!(!i||!n)}_$startClip(t,e){let i=null;return!(!t._$cacheCurrentBuffer&&(i=t._$startClip(this,e),!i))&&(t._$enterClip(),t._$beginClipDef(),this instanceof y&&(t._$mask._$containerClip=!0),this._$clip(t,i||e),this._$updated=!1,t._$mask._$containerClip&&(t._$mask._$containerClip=!1,t._$drawContainerClip()),t._$endClipDef(),i)}}class v extends T{constructor(){super(),this._$mouseEnabled=!0}static toString(){return"[class InteractiveObject]"}static get namespace(){return"next2d.display.InteractiveObject"}toString(){return"[object InteractiveObject]"}get namespace(){return"next2d.display.InteractiveObject"}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=!!t}}class y extends v{constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=r.$getArray(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=r.$getMap(),new Proxy(this,{get:(t,e)=>t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]})}static toString(){return"[class DisplayObjectContainer]"}static get namespace(){return"next2d.display.DisplayObjectContainer"}toString(){return"[object DisplayObjectContainer]"}get namespace(){return"next2d.display.DisplayObjectContainer"}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=!!t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){if(!(t instanceof T))throw new TypeError("TypeError: addChild: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));return this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){if(!(t instanceof T))throw new TypeError("TypeError: addChildAt: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),s=i.length;if(0>e||e>s)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(s&&s>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(!(t instanceof T))throw new TypeError("TypeError: contains: not DisplayObject.");if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren(),i=e.length;for(let s=0;s<i;++s){const i=e[s];if(i._$instanceId===t._$instanceId)return!0;if(i instanceof y&&i.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren(),i=e.length;if(0>t||t>i)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren(),i=e.length;for(let s=0;s<i;++s){const i=e[s];if(i.name===t)return i}return null}getChildIndex(t){if(!(t instanceof T))throw new TypeError("TypeError: getChildIndex: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError("ArgumentError: getChildIndex: not child");const e=this._$getChildren().indexOf(t);if(-1===e)throw new ArgumentError("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(!(t instanceof T))throw new TypeError("TypeError: removeChild: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError(`ArgumentError: removeChild: index error: ${index}`);return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const i=this._$getChildren(),n=i.length;if(n){t=r.$clamp(t,0,2147483646,0)-1,e=r.$clamp(e,1,134217727,134217727);for(let r=s.min(e,n-1);r>t;--r)this._$remove(i[r])}}setChildIndex(t,e){if(!(t instanceof T))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this.getChildIndex(t);if(i===e)return;const s=this._$getChildren();s.splice(i,1),s.splice(e,0,t),this._$doChanged()}swapChildren(t,e){if(!(t instanceof T&&e instanceof T))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this._$getChildren(),s=this.getChildIndex(t),r=this.getChildIndex(e);i[s]=e,i[r]=t,this._$doChanged()}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=r.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==r.$MATRIX_ARRAY_IDENTITY&&(e=r.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),n=this._$needsChildren?this._$getChildren():this._$children,a=n.length;if(!a&&!i){const i=r.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&r.$poolFloat32Array6(e),i}const o=r.$MAX_VALUE;let h=o,l=-o,_=o,$=-o;if(i){const t=r.$boundsMatrix(this._$graphics._$getBounds(),e);h=t.xMin,l=t.xMax,_=t.yMin,$=t.yMax,r.$poolBoundsObject(t)}for(let t=0;t<a;++t){const i=n[t]._$getBounds(e);h=s.min(h,i.xMin),l=s.max(l,i.xMax),_=s.min(_,i.yMin),$=s.max($,i.yMax),r.$poolBoundsObject(i)}return t&&e!==t&&r.$poolFloat32Array6(e),r.$getBoundsObject(h,l,_,$)}_$getLayerBounds(t=null){let e=r.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==r.$MATRIX_ARRAY_IDENTITY&&(e=r.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),n=this._$needsChildren?this._$getChildren():this._$children,a=n.length;if(!a&&!i){const i=r.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&r.$poolFloat32Array6(e),i}const o=r.$MAX_VALUE;let h=o,l=-o,_=o,$=-o;if(i){const t=r.$boundsMatrix(this._$graphics._$getBounds(),e);h=+t.xMin,l=+t.xMax,_=+t.yMin,$=+t.yMax,r.$poolBoundsObject(t)}for(let t=0;t<a;++t){const i=n[t]._$getLayerBounds(e);h=s.min(h,i.xMin),l=s.max(l,i.xMax),_=s.min(_,i.yMin),$=s.max($,i.yMax),r.$poolBoundsObject(i)}if(t&&e!==t&&r.$poolFloat32Array6(e),!t)return r.$getBoundsObject(h,l,_,$);const c=this._$filters||this.filters,u=c.length;if(!u)return r.$getBoundsObject(h,l,_,$);let d=new x(h,_,l-h,$-_);for(let t=0;t<u;++t)d=c[t]._$generateFilterRect(d,null,null,!0);return h=d._$x,l=d._$x+d._$width,_=d._$y,$=d._$y+d._$height,r.$getBoundsObject(h,l,_,$)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=this._$currentFrame||1;if(!this._$controller)return this._$children;let e=this._$controller[t];const i=this._$children.length;if(!i){if(e){const t=e.length;for(let i=0;i<t;++i){const t=this._$createInstance(e[i]);t._$placeId=i,this._$children.push(t),t._$name&&this._$names.set(t._$name,t)}}return this._$children}const s=r.$getMap(),n=r.$getMap();let a=0;const h=r.$getArray();for(let r=0;r<i;++r){const i=this._$children[r],l=i._$parent;if(!l||l._$instanceId!==this._$instanceId)continue;const _=i._$startFrame,$=i._$endFrame;if(1===_&&0===$||_<=t&&$>t){if(i._$filters=null,i._$blendMode=null,-1===i._$id){h.push(i),i._$name&&this._$names.set(i._$name,i);continue}const t=e[a];if(i._$id===t){i._$placeId=a,h.push(i),i._$name&&this._$names.set(i._$name,i),n.has(t)&&n.delete(t),s.set(t,!0),a++;continue}n.set(i._$id,i)}else i.willTrigger(o.REMOVED)&&i.dispatchEvent(new o(o.REMOVED,!0)),i.willTrigger(o.REMOVED_FROM_STAGE)&&i.dispatchEvent(new o(o.REMOVED_FROM_STAGE,!0)),i._$added=!1,i._$addedStage=!1,i._$active=!1,i._$updated=!0,i._$filters=null,i._$blendMode=null,i._$isNext=!0,i instanceof y&&(i._$executeRemovedFromStage(),i._$removeParentAndStage())}if(e)for(let t=0;t<e.length;++t){const i=e[t];if(s.has(i))continue;const r=n.has(i)?n.get(i):this._$createInstance(i);r._$placeId=t,h.push(r),r._$name&&this._$names.set(r._$name,r)}r.$poolMap(s),r.$poolMap(n),r.$poolArray(this._$children),this._$children=null,this._$children=h}return this._$children}_$clearChildren(){this._$doChanged(),r.$isUpdated=!0,this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$stage=this.constructor===G?this:this._$stage,t._$parent=this,t._$root=this.constructor===G?t:this._$root,t instanceof y&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger(o.ADDED)&&t.dispatchEvent(new o(o.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(t.willTrigger(o.ADDED_TO_STAGE)&&t.dispatchEvent(new o(o.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof y&&t._$executeAddedToStage()),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e._$root=this._$root,e._$stage=this._$stage,e instanceof y&&(e._$setParentAndStage(),e._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage||(e.willTrigger(o.ADDED_TO_STAGE)&&e.dispatchEvent(new o(o.ADDED_TO_STAGE)),e._$addedStage=!0),e instanceof y&&e._$executeAddedToStage())}}_$remove(t,e=!0){t._$transform._$transform();const i=this._$needsChildren?this._$getChildren():this._$children,s=this.getChildIndex(t);return i.splice(s,1),this._$names.delete(t.name),e&&(t.willTrigger(o.REMOVED)&&t.dispatchEvent(new o(o.REMOVED,!0)),null!==this._$stage&&(t.willTrigger(o.REMOVED_FROM_STAGE)&&t.dispatchEvent(new o(o.REMOVED_FROM_STAGE)),t instanceof y&&t._$executeRemovedFromStage()),t instanceof y&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,this._$doChanged()),t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0),e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage&&(e.willTrigger(o.REMOVED_FROM_STAGE)&&e.dispatchEvent(new o(o.REMOVED_FROM_STAGE)),e._$addedStage=!1),e instanceof y&&e._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e instanceof y&&e._$removeParentAndStage(),e._$stage=null,e._$root=null,e._$addedStage=!1}if(this._$sounds){const t=this._$sounds.values();for(const e of t)for(let t=0;t<e.length;++t){e[t].stop()}}}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,this._$isNext}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();s!==r.$MATRIX_ARRAY_IDENTITY&&(i=r.$multiplicationMatrix(e,s)),this._$graphics&&this._$graphics._$getBounds()&&this._$graphics._$clip(t,i);const n=this._$getChildren(),a=n.length;for(let e=0;e<a;++e){const s=n[e];s._$isMask||(s._$clip(t,i),s._$updated=!1)}i!==e&&r.$poolFloat32Array6(i)}_$draw(t,e,i){if(!this._$visible)return;let n=i;const a=this._$transform._$rawColorTransform();a!==r.$COLOR_ARRAY_IDENTITY&&(n=r.$multiplicationColor(i,a));if(!r.$clamp(n[3]+n[7]/255,0,1,0))return;const o=this._$needsChildren?this._$getChildren():this._$children,h=o.length;if(!(h||this._$graphics&&this._$graphics._$canDraw))return;const l=this._$preDraw(t,e,i);if(!l)return;if(l.isFilter&&!l.isUpdated)return void this._$postDraw(t,e,n,l);let _=l.matrix;const $=l.isFilter?l.color:n;this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$draw(t,_,$);let c=!0,u=null;const d=r.$getArray(),g=r.$getArray(),f=r.$getArray(),m=r.$getArray(),p=t._$isLayer,x=this._$isUpdated();for(let e=0;e<h;++e){const i=o[e];if(x&&(i._$placeObject=null),i._$isMask)continue;const n=i._$blendMode||i.blendMode;if((n===S.ALPHA||n===S.ERASE)&&!p)continue;if(u&&(i._$placeId>u||i._$clipDepth>0)&&(t.restore(),c&&(t._$leaveClip(),d.length&&(r.$poolFloat32Array6(_),_=d.pop())),u=f.length?f.pop():null,c=m.pop()),!c)continue;if(i._$clipDepth>0){if(t.save(),u&&f.push(u),m.push(c),u=i._$clipDepth,c=i._$shouldClip(_),c){const e=i._$startClip(t,_);if(!1===e){c=!1;continue}e&&(d.push(_),_=e)}continue}const a=i._$mask;if(a){let e;if(a._$updated=!1,this===a._$parent)e=_;else{e=r.$MATRIX_ARRAY_IDENTITY;let i=a._$parent;for(;i;)e=r.$multiplicationMatrix(i._$transform._$rawMatrix(),e),i=i._$parent;const s=this.stage._$player,n=s._$scale*s._$ratio/20,o=r.$getFloat32Array6(n,0,0,n,0,0);if(e=r.$multiplicationMatrix(o,e),t._$isLayer){const i=t._$getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t._$cacheCurrentBuffer&&(e[4]-=t._$cacheCurrentBounds.x,e[5]-=t._$cacheCurrentBounds.y)}if(!a._$shouldClip(e))continue;let i=a._$startClip(t,e);if(t.save(),!1===i){t.restore();continue}if(i){if(g.push(_),this!==a._$parent){const e=this._$transform._$rawMatrix();i[0]=s.abs(_[0])*s.sign(e[0]),i[1]=s.abs(_[1])*s.sign(e[1]),i[2]=s.abs(_[2])*s.sign(e[2]),i[3]=s.abs(_[3])*s.sign(e[3]),i[4]=_[4]-t._$cacheCurrentBounds.x,i[5]=_[5]-t._$cacheCurrentBounds.y}_=i}}i._$draw(t,_,$),i._$updated=!1,a&&(t.restore(),t._$leaveClip(),g.length&&(r.$poolFloat32Array6(_),_=g.pop()))}if(u&&(t.restore(),m.pop()&&t._$leaveClip()),r.$poolArray(d),r.$poolArray(g),r.$poolArray(f),r.$poolArray(m),l.isFilter)return this._$postDraw(t,e,n,l);r.$poolFloat32Array6(_),r.$poolPreObject(l)}_$mouseHit(t,e,i,n=!0){let a=e;const o=this._$transform._$rawMatrix();o!==r.$MATRIX_ARRAY_IDENTITY&&(a=r.$multiplicationMatrix(e,o));const h=this._$getChildren(),l=r.$getArray(),_=r.$getArray(),$=r.$getMap();let c=h.length,u=null,d=null;for(let t=0;t<c;++t){const e=h[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?(d=l.length,u=e._$clipDepth,l.push(e)):(u&&e._$placeId>u&&(d=null,u=null),null!==d&&$.set(e._$instanceId,d),_.push(e)))}const g=s.min(this._$mouseChildren,n);let f=!1;const m=this._$root===this;c=_.length;for(let e=0;e<c;++e){const e=_.pop();if(e._$isMask)continue;if(m&&!(e instanceof v))continue;if($.has(e._$instanceId)){if(!l[$.get(e._$instanceId)]._$hit(t,a,i,!0))continue}const s=e._$mask;if(s)if(this===s._$parent){if(!s._$hit(t,a,i,!0))continue}else{let e=r.$MATRIX_ARRAY_IDENTITY,n=s._$parent;for(;n;)e=r.$multiplicationMatrix(n._$transform._$rawMatrix(),e),n=n._$parent;if(!s._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,a,i,g)||e._$hitArea&&e._$hitArea._$mouseHit(t,a,i,g)){if(e._$root===e)return!0;if(!g)return!0;if(f=!0,e instanceof v){if(!e._$mouseEnabled&&!e._$hitObject)continue;if(!r.$isTouch&&!i.pointer)switch(!0){case e instanceof rt:e._$type===nt.INPUT&&(i.pointer="text");break;case e.buttonMode&&e.useHandCursor:i.pointer="pointer"}return i.hit||(i.hit=!e._$mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}return r.$poolArray(l),r.$poolArray(_),r.$poolMap($),!f&&this._$graphics&&(f=this._$graphics._$hit(t,a,i)),a!==e&&r.$poolFloat32Array6(a),f}_$hit(t,e,i,s=!1){let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a));const o=this._$getChildren();for(let e=o.length-1;e>-1;--e){const r=o[e];if(!r._$isMask&&r._$hit(t,n,i,s))return!0}let h=!1;return this._$graphics&&(h=this._$graphics._$hit(t,n,i)),n!==e&&r.$poolFloat32Array6(n),h}_$createInstance(t){const e=this._$dictionary[t],i=this._$loaderInfo._$data.characters[e.characterId];i.class||(i.class=i.symbol&&r.$getClass(i.symbol)||r.$getClass(i.extends)),r.$currentLoaderInfo=null;const s=new i.class;return s._$build(e,this),s._$id=t,s}_$outCheck(t,e){let i=r.$MATRIX_ARRAY_IDENTITY,s=this._$parent;for(;s;)i=r.$multiplicationMatrix(s._$transform._$rawMatrix(),i),s=s._$parent;return r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath(),this._$mouseHit(r.$hitContext,i,{x:t,y:e})}}class E extends y{constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=!!t}get dropTarget(){return r.$dropTarget}get graphics(){return this._$graphics||(this._$graphics=new I,this._$graphics._$displayObject=this),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=null,t instanceof E&&(this._$hitArea=t,t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new _t),this._$soundTransform}set soundTransform(t){t instanceof _t&&(this._$soundTransform=t)}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=!!t}startDrag(t=!1,e=null){let i=0,s=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,s=this.y-t.y}r.$dropTarget=this,r.$dragRules.lock=t,r.$dragRules.position.x=i,r.$dragRules.position.y=s,r.$dragRules.bounds=e}stopDrag(){r.$dropTarget=null,r.$dragRules.lock=!1,r.$dragRules.position.x=0,r.$dragRules.position.y=0,r.$dragRules.bounds=null}_$sync(){const t=super._$sync();return t&&(this._$controller=t.controller,this._$dictionary=t.dictionary,this._$placeMap=t.placeMap,this._$placeObjects=t.placeObjects),t}_$build(t,e){const i=super._$build(t,e);return this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(r.$currentMousePoint()):this.globalToLocal(r.$currentMousePoint())}}class A extends E{constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=r.$getMap(),this._$frameCache=r.$getMap(),this._$labels=null,this._$sounds=r.$getMap(),this._$channels=r.$getMap(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)?this._$labels.get(t):null}get currentLabels(){return this._$labels?r.$Array.from(this._$labels.values()):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=r.$getMap()),t instanceof w&&this._$labels.set(t.frame,t)}addFrameScript(){const t=arguments.length;for(let e=0;e<t;e+=2){let t=arguments[e];r.$isNaN(0|t)&&(t=this._$getFrameForLabel(t)),t|=0;const i=arguments[e+1];if(i&&t&&this._$totalFrames>=t&&this._$addAction(t,i),t===this._$currentFrame){const t=r.$currentPlayer();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push.apply(t._$actions,e),t._$actionOffset=0}}}}_$getFrameForLabel(t){for(let[e,i]of this._$labels)if(i.name===t)return 0|e;return 0}_$addAction(t,e){(t|=0)&&(this._$actions.has(t)||this._$actions.set(t,r.$getArray()),this._$actions.get(t).push(e))}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e.willTrigger(o.FRAME_LABEL)&&e.dispatchEvent(new o(o.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=r.$currentPlayer();if(t){-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}}_$goToFrame(t){if(r.$isNaN(+t)&&(t=this._$getFrameForLabel(t)),t<1&&(t=1),t>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const e=r.$currentPlayer();switch(!0){case t!==this._$currentFrame:{this._$wait=!1;const i=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",t),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=t,this._$clearChildren(),e._$actionOffset=e._$actions.length;const s=e._$actionOffset?e._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),e._$actionOffset&&e._$actionOffset!==e._$actions.length){const t=e._$actions.splice(0,e._$actionOffset);e._$actions.push.apply(e._$actions,t),e._$actionOffset=0}if(!this._$actionProcess&&(s>-1||!e._$actionOffset))for(;e._$actions.length&&e._$actions.length!==s;){const t=e._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const i=t._$currentFrame;if(!t._$actions.has(i))continue;const s=t._$actions.get(i),n=s.length;for(let e=0;e<n;++e)try{r.$currentLoaderInfo=t._$loaderInfo,s[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=i,this._$clearChildren())}break;case!this._$actionProcess&&e._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=e._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const s=e._$actions.get(i),n=s.length;for(let t=0;t<n;++t)try{r.$currentLoaderInfo=e._$loaderInfo,s[t].apply(e)}catch(t){e.stop()}}}}r.$currentLoaderInfo=null,this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!e._$sounds.has(this._$instanceId)&&e._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$draw(t,e,i){super._$draw(t,e,i);const s=r.$currentPlayer();this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!s._$sounds.has(this._$instanceId)&&s._$sounds.set(this._$instanceId,this)}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:t=!0,this._$canAction=!0,this._$canSound=!0,++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1),this._$clearChildren()}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$setAction(),this._$isNext=t,this._$isNext}_$buildCharacter(t){for(let e=0;e<t.sounds.length;++e){const i=t.sounds[e],s=r.$getArray();for(let t=0;t<i.sound.length;++t){const e=new ht;e._$build(i.sound[t],this),s.push(e)}this._$sounds.set(i.frame,s)}for(let e=0;e<t.actions.length;++e){const i=t.actions[e];i.script||(i.script=Function(i.action)),this._$addAction(i.frame,i.script)}for(let e=0;e<t.labels.length;++e){const i=t.labels[e];this.addFrameLabel(new w(i.name,i.frame))}this._$totalFrames=t.totalFrame||1}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$soundPlay(){const t=this._$sounds.get(this._$currentFrame);if(!t)return;const e=t.length;if(e){let i=this._$soundTransform,s=this._$parent;for(;s;)s._$soundTransform&&(i=s._$soundTransform),s=s._$parent;for(let s=0;s<e;++s){const e=t[s];i&&(e.loop=i.loop,e.volume=i.volume),e.play()}}this._$canSound=!1}}class M{constructor(t=0,i=0,s=!0,n=4294967295){this._$width=0|t,this._$height=0|i,this._$transparent=s,this._$color=this._$toRGBA(r.$clamp(n,0,4294967295,4294967295)),this._$instanceId=e++,this._$buffer=null,this._$image=null,this._$canvas=null,this._$pixelBuffer=null}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get height(){return this._$height}get image(){return this._$image}set image(t){this._$canvas=null,this._$image=t,this._$width=t.width,this._$height=t.height}get canvas(){return this._$canvas}set canvas(t){this._$image=null,this._$canvas=t,this._$width=t.width,this._$height=t.height}get transparent(){return this._$transparent}get width(){return this._$width}get _$texture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=r.$currentPlayer(),s=i._$cacheStore,n=s.generateKeys(this._$instanceId);let a=s.get(n);if(!a){const o=i._$context;switch(!0){case null!==this._$image:a=o.frameBuffer.createTextureFromImage(this._$image),this._$image=null;break;case null!==this._$canvas:a=o.frameBuffer.createTextureFromCanvas(this._$canvas),this._$canvas=null;break;case null!==this._$pixelBuffer:a=o.frameBuffer.createTextureFromPixels(t,e,o.pbo.getBufferSubDataAsync(this._$pixelBuffer),!0),this._$pixelBuffer=null;break;case null!==this._$buffer:a=o.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0),this._$buffer=null;break;default:{const i=o.frameBuffer.currentAttachment,s=o.frameBuffer.createCacheAttachment(t,e,!1);o._$bind(s),r.$resetContext(o),o.fillStyle=[this._$color.R/255,this._$color.G/255,this._$color.B/255,this._$color.A/255],o.setTransform(1,0,0,1,0,0),o.beginPath(),o.fillRect(0,0,t,e),a=o.frameBuffer.getTextureFromCurrentAttachment(),i?o._$bind(i):o.frameBuffer.unbind(),o.frameBuffer.releaseAttachment(s,!1)}}s.set(n,a)}return r.$poolArray(n),a._$bitmapData||(a._$bitmapData=this),a}set _$texture(t){this._$setPixelQueue=null,this._$setPixelCount=0,this._$linePixelsCache=null,this._$linePixelsCacheY=null;const e=r.$currentPlayer(),i=e._$cacheStore,s=i.generateKeys(this._$instanceId),n=i.get(s);n&&(n._$bitmapData&&delete n._$bitmapData,e._$context.frameBuffer.releaseTexture(n),i.set(s,null)),this._$buffer&&(this._$buffer=null),i.set(s,t),r.$poolArray(s),t._$bitmapData||(t._$bitmapData=this)}draw(t,e=null,i=null,s=S.NORMAL,n=null,a=!1){const o=this._$width,h=this._$height;if(!o||!h)return;const l=r.$currentPlayer()._$context,_=l.frameBuffer.currentAttachment,$=l.frameBuffer.createCacheAttachment(o,h,!1);if(l._$bind($),r.$resetContext(l),l.setTransform(1,0,0,1,0,0),n){const t=n.x,e=n.y,i=n.width,s=n.height;l.save(),l._$enterClip(),l._$beginClipDef(),l.setTransform(1,0,0,1,0,0),l.beginPath(),l.moveTo(t,e),l.lineTo(t+i,e),l.lineTo(t+i,e+s),l.lineTo(t,e+s),l.lineTo(t,e),l.clip(!0),l._$endClipDef()}let c=e?e._$matrix:r.$MATRIX_ARRAY_IDENTITY,u=i?i._$colorTransform:r.$COLOR_ARRAY_IDENTITY;if(t instanceof T){const i=t._$transform.matrix;i.invert(),e&&(c=r.$multiplicationMatrix(c,i._$matrix)),t._$draw(l,c,u),r.$poolMatrix(i)}else{new Bitmap(t,PixelSnapping.AUTO,a)._$draw(l,c,u)}n&&(l.restore(),l._$leaveClip());const d=l.frameBuffer.getTextureFromCurrentAttachment(),g=l.frameBuffer.createTextureAttachmentFrom(this._$texture);l._$bind(g),l.frameBuffer.releaseAttachment($,!1),r.$resetContext(l),l.setTransform(1,0,0,1,0,0),l._$imageSmoothingEnabled=a,l._$globalCompositeOperation=s,l.drawImage(d,0,0,o,h),_?l._$bind(_):l.frameBuffer.unbind(),l.frameBuffer.releaseTexture(d),l.frameBuffer.releaseAttachment(g,!1)}_$toRGBA(t){return this._$transparent?r.$uintToRGBA(t):r.$intToRGBA(t)}_$getPixelsAsync(t,e,i,n,a="RGBA"){t=Math.max(t,0),e=Math.max(e,0);const o=s.min(i,this.width-t),h=s.min(n,this.height-e);if(o<=0||h<=0)return;const l=r.$currentPlayer()._$context;if(!l)return;const _=l._$shaderList._$bitmapData.getPixels[a].instance;l._$shaderList.bitmapShaderVariants.setGetPixelsUniform(_.uniform,o/this.width,-h/this.height,t/this.width,1-e/this.height);const $=l.frameBuffer.currentAttachment,c=l.frameBuffer.createCacheAttachment(o,h,!1);l._$bind(c),l._$frameBufferManager._$textureManager.bind0(this._$texture,!1),l.blend.disable(),_._$drawImage(),l.blend.enable(),this._$pixelBuffer=l.pbo.readPixelsAsync(0,0,this.width,this.height),$?l._$bind($):l.frameBuffer.unbind(),l.frameBuffer.releaseAttachment(c)}_$getPixels(t,e,i,n,a="ARGB",o=null){switch(a){case"ARGB":case"RGBA":case"BGRA":break;default:throw new Error(`Unsupported byteOrder: ${a}`)}t=Math.max(t,0),e=Math.max(e,0);const h=s.min(i,this.width-t),l=s.min(n,this.height-e);if(h<=0||l<=0)return new Uint8Array(0);const _=o?o(h*l*4):new Uint8Array(h*l*4),$=r.$currentPlayer()._$context;if(!$)return _;const c=$._$shaderList._$bitmapData.getPixels[a].instance;$._$shaderList.bitmapShaderVariants.setGetPixelsUniform(c.uniform,h/this.width,-l/this.height,t/this.width,1-e/this.height);const u=$.frameBuffer.currentAttachment,d=$.frameBuffer.createCacheAttachment(h,l,!1);$._$bind(d),$._$frameBufferManager._$textureManager.bind0(this._$texture,!1),$.blend.disable(),c._$drawImage(),$.blend.enable();const g=$._$gl;return g.readPixels(0,0,h,l,g.RGBA,g.UNSIGNED_BYTE,_),u?$._$bind(u):$.frameBuffer.unbind(),$.frameBuffer.releaseAttachment(d),_}toImage(){const{width:t,height:e}=this,i=new Image;if(t||e){const s=r.$cacheStore().getCanvas();s.width=t,s.height=e;const n=new ImageData(t,e);n.data.set(this._$getPixels(0,0,t,e,"RGBA"));const a=s.getContext("2d");a.putImageData(n,0,0),i.width=t,i.height=e,i.src=a.canvas.toDataURL(),r.$cacheStore().destroy(a)}return i}toUint8Array(){return this._$buffer?this._$buffer:this._$getPixels(0,0,this.width,this.height,"RGBA")}}class C{static toString(){return"[class BitmapDataChannel]"}static get namespace(){return"next2d.display.BitmapDataChannel"}toString(){return"[object BitmapDataChannel]"}get namespace(){return"next2d.display.BitmapDataChannel"}static get ALPHA(){return 8}static get BLUE(){return 4}static get GREEN(){return 2}static get RED(){return 1}}class S{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}}class R{static toString(){return"[class CapsStyle]"}static get namespace(){return"next2d.display.CapsStyle"}toString(){return"[object CapsStyle]"}get namespace(){return"next2d.display.CapsStyle"}static get NONE(){return"none"}static get ROUND(){return"round"}static get SQUARE(){return"square"}}class w extends h{constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class O{static toString(){return"[class GradientType]"}static get namespace(){return"next2d.display.GradientType"}toString(){return"[object GradientType]"}get namespace(){return"next2d.display.GradientType"}static get LINEAR(){return"linear"}static get RADIAL(){return"radial"}}class I{constructor(t=null){this._$displayObject=t,this.clear()}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}static get BITMAP_STROKE(){return 14}beginBitmapFill(t,e=null,i=!0,s=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=r.$getArray()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$fills.push(I.BEGIN_PATH),this._$fillType=I.BITMAP_FILL,this._$fillBitmap=new B(t,e,i,s),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=r.$getArray()),t=r.$clamp(r.$toColorInt(t),0,16777215,0),e=r.$clamp(e,0,1,1),this._$maxAlpha=s.max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$fills.push(I.BEGIN_PATH);const i=r.$intToRGBA(t,e);return this._$fillType=I.FILL_STYLE,this._$fillStyleR=i.R,this._$fillStyleG=i.G,this._$fillStyleB=i.B,this._$fillStyleA=i.A,this}beginGradientFill(t,e,i,n,a=null,o=k.PAD,h=L.RGB,l=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=r.$getArray());const _=i.length;for(let t=0;t<_;++t)this._$maxAlpha=s.max(this._$maxAlpha,i[t]);return this._$doFill=!0,this._$canDraw=!0,this._$fills.push(I.BEGIN_PATH),this._$fillType=I.GRADIENT_FILL,this._$fillGradient=new F(t,e,i,n,a,o,h,l),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=0,this._$caps=R.NONE,this._$joints=P.ROUND,this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=r.$MAX_VALUE,this._$xMax=-r.$MAX_VALUE,this._$yMin=r.$MAX_VALUE,this._$yMax=-r.$MAX_VALUE,this._$recode&&r.$poolArray(this._$recode),this._$fills&&r.$poolArray(this._$fills),this._$lines&&r.$poolArray(this._$lines),this._$recode=null,this._$fills=null,this._$lines=null,this._$restart(),this}clone(){const t=new I;return t.copyFrom(this),t}copyFrom(t){t instanceof I&&(t._$fillGradient&&(this._$fillGradient=t._$fillGradient.clone()),t._$fillBitmap&&(this._$fillBitmap=t._$fillBitmap.clone()),this._$doFill=t._$doFill,this._$fillType=t._$fillType,this._$fillStyleR=t._$fillStyleR,this._$fillStyleG=t._$fillStyleG,this._$fillStyleB=t._$fillStyleB,this._$fillStyleA=t._$fillStyleA,t._$lineGradient&&(this._$lineGradient=t._$lineGradient.clone()),this._$doLine=t._$doLine,this._$lineType=t._$lineType,this._$caps=t._$caps,this._$joints=t._$joints,this._$miterLimit=t._$miterLimit,this._$lineWidth=t._$lineWidth,this._$lineStyleR=t._$lineStyleR,this._$lineStyleG=t._$lineStyleG,this._$lineStyleB=t._$lineStyleB,this._$lineStyleA=t._$lineStyleA,this._$xMin=t._$xMin,this._$xMax=t._$xMax,this._$yMin=t._$yMin,this._$yMax=t._$yMax,this._$maxAlpha=t._$maxAlpha,this._$pointerX=t._$pointerX,this._$pointerY=t._$pointerY,this._$canDraw=t._$canDraw,t._$fills&&(this._$fills=t._$fills.slice(0)),t._$lines&&(this._$lines=t._$lines.slice(0)),t._$recode&&(this._$recode=t._$recode.slice(0)))}cubicCurveTo(t,e,i,s,n,a){return n=+n||0,a=+a||0,this._$pointerX===n&&this._$pointerY===a||(t=+t||0,e=+e||0,i=+i||0,s=+s||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$setBounds(n,a),this._$margePath(r.$getArray(I.CUBIC,t,e,i,s,n,a)),this._$pointerX=n,this._$pointerY=a,this._$restart()),this}curveTo(t,e,i,s){return i=+i||0,s=+s||0,this._$pointerX===i&&this._$pointerY===s||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$margePath(r.$getArray(I.CURVE_TO,t,e,i,s)),this._$pointerX=i,this._$pointerY=s,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(r.$getArray(I.MOVE_TO,t+i,e,I.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,i,r){const n=(i=+i||0)/2,a=(r=+r||0)/2,o=(t=+t||0)+n,h=(e=+e||0)+a,l=t+i,_=e+r,$=4/3*(s.SQRT2-1),c=$*n,u=$*a;return this.moveTo(o,e).cubicCurveTo(o+c,e,l,h-u,l,h).cubicCurveTo(l,h+u,o+c,_,o,_).cubicCurveTo(o-c,_,t,h+u,t,h).cubicCurveTo(t,h-u,o-c,e,o,e)}drawRect(t,e,i,s){const r=(t=+t||0)+(i=+i||0),n=(e=+e||0)+(s=+s||0);return this.moveTo(t,e).lineTo(t,n).lineTo(r,n).lineTo(r,e).lineTo(t,e)}drawRoundRect(t,e,i,r,n,a=NaN){t=+t||0,e=+e||0,i=+i||0,r=+r||0;const o=(n=+n||0)/2,h=(a=+a||n)/2,l=4/3*(s.SQRT2-1),_=l*o,$=l*h,c=t+o,u=t+i,d=u-o,g=e+h,f=e+r,m=f-h;return this.moveTo(c,e).lineTo(d,e).cubicCurveTo(d+_,e,u,g-$,u,g).lineTo(u,m).cubicCurveTo(u,m+$,d+_,f,d,f).lineTo(c,f).cubicCurveTo(c-_,f,t,m+$,t,m).lineTo(t,g).cubicCurveTo(t,g-$,c-_,e,c,e)}endFill(){if(this._$doFill&&this._$fills.length>6)switch(this._$recode||(this._$recode=r.$getArray()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(I.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push.apply(this._$recode,this._$fills),this._$fillType){case I.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,I.END_FILL);break;case I.GRADIENT_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillGradient.toArray());break;case I.BITMAP_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$fills&&(r.$poolArray(this._$fills),this._$fills=null),this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine)switch(this._$recode||(this._$recode=r.$getArray()),this._$recode.push.apply(this._$recode,this._$lines),r.$poolArray(this._$lines),this._$lines=null,this._$lineType){case I.STROKE_STYLE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,I.END_STROKE);break;case I.GRADIENT_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$lineGradient.toArray());break;case I.BITMAP_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$lineType=0,this._$lineWidth=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps=R.NONE,this._$joints=P.ROUND,this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineBitmapStyle(t,e=null,i=!0,s=!1){return this._$doLine&&this.endLine(),this._$lines||(this._$lines=r.$getArray()),this._$maxAlpha=1,this._$doLine=!0,this._$canDraw=!0,this._$lines.push(I.BEGIN_PATH),this._$lineType=I.BITMAP_STROKE,this._$fillBitmap=new B(t,e,i,s),this}lineGradientStyle(t,e,i,n,a=null,o=k.PAD,h=L.RGB,l=0){if(!this._$doLine)return this;this._$lines||(this._$lines=r.$getArray());const _=i.length;for(let t=0;t<_;++t)this._$maxAlpha=s.max(this._$maxAlpha,i[t]);return this._$lines.push(I.BEGIN_PATH),this._$lineType=I.GRADIENT_STROKE,this._$lineGradient=new F(t,e,i,n,a,o,h,l),this}lineStyle(t=1,e=0,i=1,n=R.ROUND,a=P.ROUND,o=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=r.$getArray()),e=r.$clamp(r.$toColorInt(e),0,16777215,0),i=r.$clamp(+i,0,1,1),this._$maxAlpha=s.max(this._$maxAlpha,i),this._$doLine=!0,this._$canDraw=!0,this._$lines.push(I.BEGIN_PATH,I.MOVE_TO,this._$pointerX,this._$pointerY);const h=r.$intToRGBA(e,i);return this._$lineType=I.STROKE_STYLE,this._$lineStyleR=h.R,this._$lineStyleG=h.G,this._$lineStyleB=h.B,this._$lineStyleA=h.A,this._$lineWidth=t,this._$caps=`${n}`,this._$joints=`${a}`,this._$joints===P.MITER&&(this._$miterLimit=o),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(r.$getArray(I.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){return t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e),this._$margePath(r.$getArray(I.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,e){const i=this._$getBounds(),n=r.$boundsMatrix(i,e);let a=s.ceil(s.abs(n.xMax-n.xMin)),o=s.ceil(s.abs(n.yMax-n.yMin));switch(r.$poolBoundsObject(i),r.$poolBoundsObject(n),!0){case 0===a:case 0===o:case a===-r.$Infinity:case o===-r.$Infinity:case a===r.$Infinity:case o===r.$Infinity:return}r.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$doDraw(t,r.$COLOR_ARRAY_IDENTITY,!0),t.clip()}_$drawFilter(t,e,i,s,n,a,o){const h=this._$displayObject,l=[h._$instanceId,"f"];let _=r.$cacheStore().get(l);const $=h._$isFilterUpdated(a,o,i,s,n,!0);return _&&!$||(_&&(r.$cacheStore().set(l,null),_.layerWidth=0,_.layerHeight=0,_._$offsetX=0,_._$offsetY=0,_.matrix=null,_.colorTransform=null,t.frameBuffer.releaseTexture(_),_=null),e=h._$getFilterTexture(t,n,e,i,s),r.$cacheStore().set(l,e)),_&&(e=_),r.$poolArray(l),e}_$drawBitmap(t,e,i,n=S.NORMAL,a=null){if(!this._$maxAlpha)return;const o=r.$clamp(i[3]+i[7]/255,0,1),h=this._$displayObject;let l=e;const _=h._$transform._$rawMatrix();_!==r.$MATRIX_ARRAY_IDENTITY&&(l=r.$multiplicationMatrix(e,_));const $=this._$getBounds(),c=r.$boundsMatrix($,l),u=c.xMax,d=c.xMin,g=c.yMax,f=c.yMin;r.$poolBoundsObject(c);let b=s.ceil(s.abs(u-d)),T=s.ceil(s.abs(g-f));switch(!0){case 0===b:case 0===T:case b===-r.$Infinity:case T===-r.$Infinity:case b===r.$Infinity:case T===r.$Infinity:return}const v=s.sqrt(l[0]*l[0]+l[1]*l[1]),y=s.sqrt(l[2]*l[2]+l[3]*l[3]);if(0>d+b||0>f+T){if(!(a&&a.length&&h._$canApply(a)))return;{let t=new x(0,0,b,T);for(let e=0;e<a.length;++e)t=a[e]._$generateFilterRect(t,v,y);if(0>t.x+t.width||0>t.y+t.height)return}}const E=t.frameBuffer.currentAttachment;if(d>E.width||f>E.height)return;const A=t._$textureScale(b,T);A<1&&(b*=A,T*=A);const M=r.$cacheStore().generateKeys(h._$instanceId,[v,y],i);let C=r.$cacheStore().get(M);if(!C){const n=t.frameBuffer.createCacheAttachment(b,T,!0);switch(t._$bind(n),r.$resetContext(t),i[3]=1,!0){case 1!==_[0]:case 0!==_[1]:case 0!==_[2]:case 1!==_[3]:{const n=s.atan2(e[1],e[0]);let a=0,o=0;if(n){const t=new m;t.translate(-b/2,-T/2),t.rotate(n),t.translate(b/2,T/2);const e=t.transformPoint(new p(0,0)),i=t.transformPoint(new p(b,0)),r=t.transformPoint(new p(0,T)),h=t.transformPoint(new p(b,T));a=s.min(e.x,i.x,r.x,h.x),o=s.min(e.y,i.y,r.y,h.y)}r.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],-a,-o),t.beginPath(),this._$runTransformCommand(t,_,i)}break;default:t.setTransform(l[0],l[1],l[2],l[3],l[4]-d,l[5]-f),this._$doDraw(t,i)}C=t.frameBuffer.getTextureFromCurrentAttachment(),r.$cacheStore().set(M,C),t.frameBuffer.releaseAttachment(n,!1),t._$bind(E)}let R=!1,w=0,O=0;if(a&&a.length){h._$canApply(a)&&(R=!0,C=this._$drawFilter(t,C,e,i,a,b,T),w=C._$offsetX,O=C._$offsetY)}r.$resetContext(t),t._$globalAlpha=o,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=n,t.setTransform(1,0,0,1,0,0),R?t.drawImage(C,d-w,f-O,C.width,C.height,i):t.drawImage(C,d,f,b,T,i),r.$poolArray(M),r.$poolBoundsObject($)}_$draw(t,e,i,n=S.NORMAL,a=null){if(!this._$maxAlpha)return;const o=r.$clamp(i[3]+i[7]/255,0,1),h=this._$displayObject;let l=null!==h._$scale9Grid,_=null;l&&(_=h._$transform._$rawMatrix(),l=l&&s.abs(_[1])<.001&&s.abs(_[2])<1e-4);const $=this._$getBounds(),c=r.$boundsMatrix($,e),u=c.xMax,d=c.xMin,g=c.yMax,f=c.yMin;r.$poolBoundsObject(c);let m=s.ceil(s.abs(u-d)),p=s.ceil(s.abs(g-f));switch(!0){case 0===m:case 0===p:case m===-r.$Infinity:case p===-r.$Infinity:case m===r.$Infinity:case p===r.$Infinity:return}const b=+s.sqrt(e[0]*e[0]+e[1]*e[1]).toFixed(3),T=+s.sqrt(e[2]*e[2]+e[3]*e[3]).toFixed(3);if(0>d+m||0>f+p){if(!(a&&a.length&&h._$canApply(a)))return;{let t=new x(0,0,m,p);for(let e=0;e<a.length;++e)t=a[e]._$generateFilterRect(t,b,T);if(0>t.x+t.width||0>t.y+t.height)return}}const v=t.frameBuffer.currentAttachment;if(d>v.width||f>v.height)return;const y=r.$cacheStore(),E=y.generateKeys(h._$instanceId,[b,T],i);let A=y.get(E);if(!A){m=s.ceil(s.abs($.xMax-$.xMin)*b),p=s.ceil(s.abs($.yMax-$.yMin)*T);const n=t._$textureScale(m,p);n<1&&(m*=n,p*=n);const a=t.frameBuffer.createCacheAttachment(m,p,!0);if(t._$bind(a),r.$resetContext(t),t.setTransform(b,0,0,T,-$.xMin*b,-$.yMin*T),l){const i=r.$currentPlayer(),n=i._$scale*i._$ratio,a=r.$getFloat32Array6(n,0,0,n,0,0),o=r.$multiplicationMatrix(a,_);r.$poolFloat32Array6(a);const l=h._$parent._$transform._$calculateConcatenatedMatrix()._$matrix,c=r.$getFloat32Array6(l[0],l[1],l[2],l[3],l[4]*n-d,l[5]*n-f),u=r.$multiplicationMatrix(c,o),g=u[4]-(e[4]-d),m=u[5]-(e[5]-f);r.$poolFloat32Array6(u);const p=r.$boundsMatrix($,o),x=+p.xMax,b=+p.xMin,T=+p.yMax,v=+p.yMin,y=s.ceil(s.abs(x-b)),E=s.ceil(s.abs(T-v));r.$poolBoundsObject(p),t.grid.enable(b,v,y,E,$,h._$scale9Grid,o[0],o[1],o[2],o[3],o[4],o[5],c[0],c[1],c[2],c[3],c[4]-g,c[5]-m),r.$poolFloat32Array6(o),r.$poolFloat32Array6(c)}i[3]=1,this._$doDraw(t,i,!1),l&&t.grid.disable(),A=t.frameBuffer.getTextureFromCurrentAttachment(),y.set(E,A),t.frameBuffer.releaseAttachment(a,!1),t._$bind(v)}let M=0,C=0;if(a&&a.length){h._$canApply(a)&&(A=this._$drawFilter(t,A,e,i,a,m,p),M=A._$offsetX,C=A._$offsetY)}r.$resetContext(t),t._$globalAlpha=o,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=n;const R=s.atan2(e[1],e[0]),w=s.atan2(-e[2],e[3]);if(R||w){const i=r.$getBoundsObject($.xMin*b*s.cos(R)-$.yMin*T*s.sin(w),$.xMax*b*s.cos(R)-$.yMax*T*s.sin(w),$.xMin*b*s.sin(R)+$.yMin*T*s.cos(w),$.xMax*b*s.sin(R)+$.yMax*T*s.cos(w));t.setTransform(s.cos(R),s.sin(R),-s.sin(w),s.cos(w),i.xMin+e[4]-M,i.yMin+e[5]-C),r.$poolBoundsObject(i)}else t.setTransform(1,0,0,1,d-M,f-C);t.drawImage(A,0,0,A.width,A.height,i),r.$poolArray(E),_&&r.$poolMatrix(_),r.$poolBoundsObject($)}_$doDraw(t,e,i=!1){r.$resetContext(t),t.beginPath(),this._$runCommand(t,e,i)}_$hit(t,e,i,s=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,s,i)}_$getBounds(){const t=this._$displayObject;return t&&t._$bounds?r.$getBoundsObject(t._$bounds.xMin,t._$bounds.xMax,t._$bounds.yMin,t._$bounds.yMax):r.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){this._$displayObject&&!this._$displayObject._$isUpdated()&&(this._$displayObject._$doChanged(),r.$isUpdated=!0,r.$cacheStore().removeCache(this._$displayObject._$instanceId))}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t,e){this._$xMin=s.min(this._$xMin,t),this._$xMax=s.max(this._$xMax,t),this._$yMin=s.min(this._$yMin,e),this._$yMax=s.max(this._$yMax,e)}_$setLineBounds(t,e){this._$xMin=s.min(this._$xMin,s.min(t,this._$pointerX)),this._$xMax=s.max(this._$xMax,s.max(t,this._$pointerX)),this._$yMin=s.min(this._$yMin,s.min(e,this._$pointerY)),this._$yMax=s.max(this._$yMax,s.max(e,this._$pointerY));const i=this._$lineWidth/2,r=.5*s.PI,n=s.atan2(e-this._$pointerY,t-this._$pointerX),a=s.atan2(this._$pointerY-e,this._$pointerX-t),o=n+r,h=n-r,l=a+r,_=a-r;let $=t+i,c=-i+t,u=this._$pointerX+i,d=-i+this._$pointerX,g=e+i,f=-i+e,m=this._$pointerY+i,p=-i+this._$pointerY;this._$xMin=s.min(this._$xMin,s.min($,s.min(c,s.min(u,d)))),this._$xMax=s.max(this._$xMax,s.max($,s.max(c,s.max(u,d)))),this._$yMin=s.min(this._$yMin,s.min(g,s.min(f,s.min(m,p)))),this._$yMax=s.max(this._$yMax,s.max(g,s.max(f,s.max(m,p)))),s.abs(o)%r!=0&&($=t+s.cos(o)*i),s.abs(h)%r!=0&&(c=t+s.cos(h)*i),s.abs(l)%r!=0&&(u=this._$pointerX+s.cos(l)*i),s.abs(_)%r!=0&&(d=this._$pointerX+s.cos(_)*i),o&&s.abs(o)%s.PI!=0&&(g=e+s.sin(o)*i),h&&s.abs(h)%s.PI!=0&&(f=e+s.sin(h)*i),l&&s.abs(l)%s.PI!=0&&(m=this._$pointerY+s.sin(l)*i),_&&s.abs(_)%s.PI!=0&&(p=this._$pointerY+s.sin(_)*i),this._$xMin=s.min(this._$xMin,s.min($,s.min(c,s.min(u,d)))),this._$xMax=s.max(this._$xMax,s.max($,s.max(c,s.max(u,d)))),this._$yMin=s.min(this._$yMin,s.min(g,s.min(f,s.min(m,p)))),this._$yMax=s.max(this._$yMax,s.max(g,s.max(f,s.max(m,p))));let x=0,b=0,T=0,v=0,y=0,E=0,A=0,M=0;switch(this._$caps){case R.ROUND:s.abs(n)%r!=0&&(x=t+s.cos(n)*i),n&&s.abs(n)%s.PI!=0&&(b=e+s.sin(n)*i),s.abs(a)%r!=0&&(T=this._$pointerX+s.cos(a)*i),a&&s.abs(a)%s.PI!=0&&(v=this._$pointerY+s.sin(a)*i),this._$xMin=s.min(this._$xMin,s.min(x,T)),this._$xMax=s.max(this._$xMax,s.max(x,T)),this._$yMin=s.min(this._$yMin,s.min(b,v)),this._$yMax=s.max(this._$yMax,s.max(b,v));break;case R.SQUARE:if(s.abs(n)%r!=0){const t=s.cos(n)*i;x=$+t,T=c+t}if(s.abs(a)%r!=0){const t=s.cos(a)*i;y=u+t,A=d+t}if(n&&s.abs(n)%s.PI!=0){const t=s.sin(n)*i;b=g+t,v=f+t}if(a&&s.abs(a)%s.PI!=0){const t=s.sin(a)*i;E=m+t,M=p+t}this._$xMin=s.min(this._$xMin,s.min(x,s.min(T,s.min(y,A)))),this._$xMax=s.max(this._$xMax,s.max(x,s.max(T,s.max(y,A)))),this._$yMin=s.min(this._$yMin,s.min(b,s.min(v,s.min(E,M)))),this._$yMax=s.max(this._$yMax,s.max(b,s.max(v,s.max(E,M))))}}_$margePath(t){this._$doFill&&this._$fills.push.apply(this._$fills,t),this._$doLine&&this._$lines.push.apply(this._$lines,t),r.$poolArray(t)}_$runTransformCommand(t,e,i=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;let r=Number.MAX_VALUE,n=-Number.MAX_VALUE,a=Number.MAX_VALUE,o=-Number.MAX_VALUE;const h=this._$recode,l=h.length;for(let _=0;_<l;)switch(h[_++]){case I.BEGIN_PATH:t.beginPath();break;case I.MOVE_TO:{const i=h[_++],l=h[_++],$=i*e[0]+l*e[2],c=i*e[1]+l*e[3];r=s.min($,r),n=s.max($,n),a=s.min(c,a),o=s.max(c,o),t.moveTo($,c)}break;case I.LINE_TO:{const i=h[_++],l=h[_++],$=i*e[0]+l*e[2],c=i*e[1]+l*e[3];r=s.min($,r),n=s.max($,n),a=s.min(c,a),o=s.max(c,o),t.lineTo($,c)}break;case I.CURVE_TO:{const i=h[_++],l=h[_++],$=h[_++],c=h[_++],u=i*e[0]+l*e[2],d=i*e[1]+l*e[3],g=$*e[0]+c*e[2],f=$*e[1]+c*e[3];r=s.min(u,r),n=s.max(u,n),a=s.min(d,a),o=s.max(d,o),r=s.min(g,r),n=s.max(g,n),a=s.min(f,a),o=s.max(f,o),t.quadraticCurveTo(u,d,g,f)}break;case I.CLOSE_PATH:t.closePath();break;case I.CUBIC:{const i=h[_++],l=h[_++],$=h[_++],c=h[_++],u=h[_++],d=h[_++],g=i*e[0]+l*e[2],f=i*e[1]+l*e[3],m=$*e[0]+c*e[2],p=$*e[1]+c*e[3],x=u*e[0]+d*e[2],b=u*e[1]+d*e[3];r=s.min(g,r),n=s.max(g,n),a=s.min(f,a),o=s.max(f,o),r=s.min(m,r),n=s.max(m,n),a=s.min(p,a),o=s.max(p,o),r=s.min(x,r),n=s.max(x,n),a=s.min(b,a),o=s.max(b,o),t.bezierCurveTo(g,f,m,p,x,b)}break;case I.ARC:{const i=h[_++],l=h[_++],$=h[_++],c=i*e[0]+l*e[2],u=i*e[1]+l*e[3];r=s.min(c,r),n=s.max(c,n),a=s.min(u,a),o=s.max(u,o),t.arc(c,u,$,0,2*s.PI)}break;case I.BITMAP_FILL:{t._$matrix[6]-=r*t._$matrix[0]+a*t._$matrix[3],t._$matrix[7]-=r*t._$matrix[1]+a*t._$matrix[4],t.save();const e=h[_++],s=h[_++],n=h[_++],o=h[_++];t.fillStyle=t.createPattern(e._$texture,n,i),s&&t.transform(s[0],s[1],s[2],s[3],s[4],s[5]),t._$imageSmoothingEnabled=o,t.fill(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}_$runCommand(t,e=null,i=!1,n=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;const a=this._$recode,o=a.length;for(let h=0;h<o;)switch(a[h++]){case I.BEGIN_PATH:t.beginPath();break;case I.MOVE_TO:t.moveTo(a[h++],a[h++]);break;case I.LINE_TO:t.lineTo(a[h++],a[h++]);break;case I.CURVE_TO:t.quadraticCurveTo(a[h++],a[h++],a[h++],a[h++]);break;case I.FILL_STYLE:{if(i||n){h+=4;continue}const r=t._$contextStyle;r._$fillStyle[0]=a[h++]/255,r._$fillStyle[1]=a[h++]/255,r._$fillStyle[2]=a[h++]/255,r._$fillStyle[3]=1!==e[3]||0!==e[7]?s.max(0,s.min(a[h++]*e[3]+e[7],255))/255:a[h++]/255,t._$style=r}break;case I.END_FILL:if(n){if(t.isPointInPath(n.x,n.y))return!0;continue}i||t.fill();break;case I.STROKE_STYLE:{if(i||n){h+=8;continue}t.lineWidth=a[h++],t.lineCap=a[h++],t.lineJoin=a[h++],t.miterLimit=a[h++];const r=t._$contextStyle;r._$strokeStyle[0]=a[h++]/255,r._$strokeStyle[1]=a[h++]/255,r._$strokeStyle[2]=a[h++]/255,r._$strokeStyle[3]=1!==e[3]||0!==e[7]?s.max(0,s.min(a[h++]*e[3]+e[7],255))/255:a[h++]/255,t._$style=r}break;case I.END_STROKE:if(n){if(t.isPointInStroke(n.x,n.y))return!0;continue}i||t.stroke();break;case I.CLOSE_PATH:t.closePath();break;case I.CUBIC:t.bezierCurveTo(a[h++],a[h++],a[h++],a[h++],a[h++],a[h++]);break;case I.ARC:{const e=a[h++],i=a[h++],r=a[h++];t.arc(e,i,r,0,2*s.PI)}break;case I.GRADIENT_FILL:{if(n){if(t.isPointInPath(n.x,n.y))return!0;h+=6;continue}if(i){h+=6;continue}const o=a[h++],l=a[h++],_=a[h++],$=a[h++],c=a[h++],u=a[h++];let d=null;if(o===O.LINEAR){const e=r.$linearGradientXY(_);d=t.createLinearGradient(e[0],e[1],e[2],e[3],c,$)}else t.save(),t.transform(_[0],_[1],_[2],_[3],_[4],_[5]),d=t.createRadialGradient(0,0,0,0,0,819.2,c,$,u);const g=l.length;for(let t=0;t<g;++t){const i=l[t];d.addColorStop(i.ratio,r.$getFloat32Array4(0|s.max(0,s.min(i.R*e[0]+e[4],255)),0|s.max(0,s.min(i.G*e[1]+e[5],255)),0|s.max(0,s.min(i.B*e[2]+e[6],255)),0|s.max(0,s.min(i.A*e[3]+e[7],255))))}t.fillStyle=d,t.fill(),o===O.RADIAL&&t.restore()}break;case I.GRADIENT_STROKE:{if(n){if(t.isPointInStroke(n.x,n.y))return!0;h+=12;continue}if(i){h+=12;continue}const o=a[h++],l=a[h++],_=a[h++],$=a[h++],c=a[h++],u=a[h++],d=a[h++],g=a[h++],f=a[h++],m=a[h++];let p=null;if(c===O.LINEAR){const e=r.$linearGradientXY(d);p=t.createLinearGradient(e[0],e[1],e[2],e[3],f,g)}else t.save(),t.transform(d[0],d[1],d[2],d[3],d[4],d[5]),p=t.createRadialGradient(0,0,0,0,0,819.2,f,g,m);const x=u.length;for(let t=0;t<x;++t){const i=u[t];p.addColorStop(i.ratio,r.$getFloat32Array4(0|s.max(0,s.min(i.R*e[0]+e[4],255)),0|s.max(0,s.min(i.G*e[1]+e[5],255)),0|s.max(0,s.min(i.B*e[2]+e[6],255)),0|s.max(0,s.min(i.A*e[3]+e[7],255))))}t.strokeStyle=p,t.lineWidth=o,t.lineCap=l,t.lineJoin=_,t.miterLimit=$,t.stroke(),c===O.RADIAL&&t.restore()}break;case I.BITMAP_FILL:{if(n){if(t.isPointInPath(n.x,n.y))return!0;h+=6;continue}if(i){h+=6;continue}t.save();const s=a[h++],r=a[h++],o=a[h++],l=a[h++];r&&t.transform(r[0],r[1],r[2],r[3],r[4],r[5]),"no-repeat"===o&&s.width===this._$xMax-this._$xMin&&s.height===this._$yMax-this._$yMin?t.drawImage(s._$texture,0,0,s.width,s.height):(t.fillStyle=t.createPattern(s._$texture,o,e),t._$imageSmoothingEnabled=l,t.fill()),t.restore(),t._$imageSmoothingEnabled=!1}break;case I.BITMAP_STROKE:{if(n){if(t.isPointInStroke(n.x,n.y))return!0;h+=9;continue}if(i){h+=9;continue}t.save();const s=a[h++],r=a[h++],o=a[h++],l=a[h++],_=a[h++],$=a[h++],c=a[h++],u=a[h++];$&&t.transform($[0],$[1],$[2],$[3],$[4],$[5]),t.lineWidth=s,t.lineCap=r,t.lineJoin=o,t.miterLimit=l,t.strokeStyle=t.createPattern(_._$texture,c,e),t._$imageSmoothingEnabled=u,t.stroke(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}}class B{constructor(t,e=null,i=!0,s=!1){this._$bitmapData=t,this._$matrix=e,this._$repeat=!!i,this._$smooth=!!s}clone(){return new B(this._$bitmapData.clone(),this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){return r.$getArray(this._$bitmapData,this._$matrix,this._$repeat?"repeat":"no-repeat",this._$smooth)}}class F{constructor(t=O.LINEAR,e=null,i=null,s=null,n=null,a=k.PAD,o=L.RGB,h=0){if(this._$type=O.RADIAL===t?t:O.LINEAR,this._$colors=r.$isArray(e)?this._$toColorInt(e):null,this._$alphas=r.$isArray(i)?this._$toColorInt(i):null,this._$ratios=null,r.$isArray(s)){for(let t=0;t<s.length;++t)s[t]=r.$clamp(s[t],0,255,0);this._$ratios=s}switch(this._$matrix=n,a){case k.REFLECT:case k.REPEAT:this._$spreadMethod=a;break;default:this._$spreadMethod=k.PAD}this._$interpolationMethod=o===L.LINEAR_RGB?o:L.RGB,this._$focalPointRatio=+h||0,this._$colorStops=null}get colorStops(){if(!this._$colorStops){this._$colorStops=r.$getArray();const t=s.min(s.min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=r.$intToRGBA(this._$colors[e],this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:t.R,G:t.G,B:t.B,A:t.A}}}return this._$colorStops}_$toColorInt(t){const e=t.length;for(let i=0;i<e;++i)t[i]=r.$clamp(r.$toColorInt(t[i]),0,16777215,16777215);return t}toArray(){return r.$getArray(this._$type,this.colorStops,this._$matrix?this._$matrix._$matrix:r.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class L{static toString(){return"[class InterpolationMethod]"}static get namespace(){return"next2d.display.InterpolationMethod"}toString(){return"[object InterpolationMethod]"}get namespace(){return"next2d.display.InterpolationMethod"}static get LINEAR_RGB(){return"linearRGB"}static get RGB(){return"rgb"}}class P{static toString(){return"[class JointStyle]"}static get namespace(){return"next2d.display.JointStyle"}toString(){return"[object JointStyle]"}get namespace(){return"next2d.display.JointStyle"}static get BEVEL(){return"bevel"}static get MITER(){return"miter"}static get ROUND(){return"round"}}class D extends y{constructor(){super(),this._$loaderInfo=new N}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo._$content}get contentLoaderInfo(){return this._$loaderInfo}load(t){if(!(t&&t instanceof ut))return;const e=this.contentLoaderInfo;switch(t.responseDataFormat){case ct.JSON:case ct.ARRAY_BUFFER:break;default:return void(e.willTrigger(c.IO_ERROR)&&e.dispatchEvent(new c(c.IO_ERROR,!1,!1,"data format is json or arrayBuffer only.")))}e._$url=t.url,e._$format=t.responseDataFormat,r.$ajax({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(o.OPEN)&&e.dispatchEvent(new o(o.OPEN)),e.willTrigger(d.PROGRESS)&&e.dispatchEvent(new d(d.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(d.PROGRESS)&&e.dispatchEvent(new d(d.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(d.PROGRESS)&&e.dispatchEvent(new d(d.PROGRESS,!1,!1,t.loaded,t.total));const i=r.$getArray(),s=r.$headerToArray(t.target.getAllResponseHeaders()),n=s.length;for(let t=0;t<n;++t){const e=s[t];i.push(new dt(e.name,e.value))}if(e.willTrigger($.HTTP_STATUS)){const s=new $($.HTTP_STATUS,!1,!1,t.target.status);s._$responseURL=t.target.responseURL,s._$responseHeaders=i,e.dispatchEvent(s)}if(199<t.target.status&&400>t.target.status)switch(e.format){case ct.JSON:{const e=JSON.parse(t.target.responseText);if("zlib"===e.type){if(r.$unzipWorkerActive)return void r.$unzipQueues.push({json:e,scope:this});r.$unzipWorkerActive=!0,r.$unzipWorker||(r.$unzipWorker=new Worker(r.$unzipURL));const t=new Uint8Array(e.buffer);r.$unzipWorker.onmessage=r.$unzipHandler.bind(this),r.$unzipWorker.postMessage(t,[t.buffer])}else this._$build(e)}break;case ct.ARRAY_BUFFER:this._$imageDecode(new Uint8Array(t.target.response))}else e.willTrigger(c.IO_ERROR)&&e.dispatchEvent(new c(c.IO_ERROR,!1,!1,t.target.statusText))}.bind(this)}})}loadImage(t){t.responseDataFormat=ct.ARRAY_BUFFER,this.load(t)}_$imageDecode(t){const e={image:new r.$Image,scope:this};e.image.decoding="async",e.image.src=r.$URL.createObjectURL(new r.$Blob([t],{type:`image/${r.$getImageType(t)}`})),r.$imageWorkerActive?r.$imageQueues.push(e):(r.$imageWorkerActive=!0,e.image.decode().then(r.$decodeImage.bind(e)).catch((()=>{throw new Error("image encoding error")})))}_$build(t){const e=this.contentLoaderInfo;let i=null;const s=r.$getMap();if(t.symbols.length)for(let e=0;e<t.symbols.length;++e){const r=t.symbols[e];0===r[1]&&(i=r[0]),s.set(r[0],r[1])}if(e._$data={stage:t.stage,characters:t.characters,symbols:s},i){const t=r.$getClass(i)||A;e._$content=new t}else e._$content=new A;const n=t.characters[0];e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:n.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const a=r.$currentPlayer();a._$loaders.push(e),a._$loadStatus===ie.LOAD_START&&(a._$loadStatus=ie.LOAD_END)}}class N extends h{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format=ct.STRING}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get content(){return this._$content}get url(){return this._$url}get format(){return this._$format}set format(t){this._$format=t}}class U extends T{constructor(){super(),this._$graphics=null,this._$bounds=null,this._$bitmapId=0}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new I(this)),this._$graphics}_$buildCharacter(t,e){const i=this.graphics;if(t.recodes)if(t.bitmapId){this._$bitmapId=t.bitmapId;const n=e._$data.characters[t.bitmapId],a=s.abs(n.bounds.xMax-n.bounds.xMin),o=s.abs(n.bounds.yMax-n.bounds.yMin),h=new M(a,o,!0,0);n._$buffer||(n._$buffer=new Uint8Array(n.buffer),r.$poolArray(n.buffer),n.buffer=null),h._$buffer=n._$buffer.slice(),i._$recode=r.$getArray();const l=t.recodes;if(l[l.length-1]===I.END_FILL){const t=l.length-6;for(let e=0;e<t;++e)i._$recode.push(l[e]);i._$recode.push(I.BITMAP_FILL,h,null,"repeat",!1)}else{const e=l[l.length-9],s=l[l.length-8],n=l[l.length-7],a=l[l.length-6],o=l.length-10;for(let t=0;t<o;++t)i._$recode.push(l[t]);i._$recode.push(I.BITMAP_STROKE,e,s,n,a,h,new r.$Float32Array([1,0,0,1,t.bounds.xMin,t.bounds.yMin]),"repeat",!1)}}else i._$recode=t.recodes.slice(0);else{const e=s.abs(t.bounds.xMax-t.bounds.xMin),n=s.abs(t.bounds.yMax-t.bounds.yMin),a=new M(e,n,!0,0);t._$buffer||(t._$buffer=new Uint8Array(t.buffer),r.$poolArray(t.buffer),t.buffer=null),a._$buffer=t._$buffer.slice(0),i.beginBitmapFill(a,null,!1).drawRect(0,0,e,n)}i._$maxAlpha=1,i._$canDraw=!0,i._$xMin=t.bounds.xMin,i._$xMax=t.bounds.xMax,i._$yMin=t.bounds.yMin,i._$yMax=t.bounds.yMax}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t,this._$loaderInfo),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i,e._$loaderInfo),i}_$getBounds(t=null){if(!this._$graphics)return r.$getBoundsObject(0,0,0,0);const e=this._$graphics._$getBounds();if(t){const i=r.$multiplicationMatrix(t,this._$transform._$rawMatrix()),s=r.$boundsMatrix(e,i);return r.$poolBoundsObject(e),s}return e}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let s=i;const n=this._$transform._$rawColorTransform();n!==r.$COLOR_ARRAY_IDENTITY&&(s=r.$multiplicationColor(i,n));if(!r.$clamp(s[3]+s[7]/255,0,1,0))return void(s!==i&&r.$poolFloat32Array8(s));const a=this._$filters||this.filters,o=this._$blendMode||this.blendMode;if(this._$bitmapId)this._$graphics._$drawBitmap(t,e,s,o,a);else{let i=e;const n=this._$transform._$rawMatrix();n!==r.$MATRIX_ARRAY_IDENTITY&&(i=r.$multiplicationMatrix(e,n)),this._$graphics._$draw(t,i,s,o,a),i!==e&&r.$poolFloat32Array6(i)}s!==i&&r.$poolFloat32Array8(s)}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();s!==r.$MATRIX_ARRAY_IDENTITY&&(i=r.$multiplicationMatrix(e,s)),this._$graphics._$clip(t,i),i!==e&&r.$poolFloat32Array6(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,s){let n=!1;if(this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$getBounds()){let a=e;const o=this._$transform._$rawMatrix();o!==r.$MATRIX_ARRAY_IDENTITY&&(a=r.$multiplicationMatrix(e,o)),n=this._$graphics._$hit(t,a,i,s),a!==e&&r.$poolFloat32Array6(a)}return n}}class k{static toString(){return"[class SpreadMethod]"}static get namespace(){return"next2d.display.SpreadMethod"}toString(){return"[object SpreadMethod]"}get namespace(){return"next2d.display.SpreadMethod"}static get PAD(){return"pad"}static get REFLECT(){return"reflect"}static get REPEAT(){return"repeat"}}class G extends y{constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=r.$clamp(r.$toColorInt(t),0,16777215,16777215);const e=this._$player;if(e){const t=r.$uintToRGBA(this._$color);e._$context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=r.$clamp(+t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get player(){return this._$player}get stageHeight(){return this._$player?this._$player._$height/r.$devicePixelRatio:0}get stageWidth(){return this._$player?this._$player._$width/r.$devicePixelRatio:0}invalidate(){this._$invalidate=!0}}class X{static toString(){return"[class StageQuality]"}static get namespace(){return"next2d.display.StageQuality"}toString(){return"[object StageQuality]"}get namespace(){return"next2d.display.StageQuality"}static get HIGH(){return"high"}static get LOW(){return"low"}static get MEDIUM(){return"medium"}}class H{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,r.$isUpdated=!0}}class Y{static toString(){return"[class BitmapFilterType]"}static get namespace(){return"next2d.filters.BitmapFilterType"}toString(){return"[object BitmapFilterType]"}get namespace(){return"next2d.filters.BitmapFilterType"}static get FULL(){return"full"}static get INNER(){return"inner"}static get OUTER(){return"outer"}}class j{static toString(){return"[class BitmapFilterQuality]"}static get namespace(){return"next2d.filters.BitmapFilterQuality"}toString(){return"[object BitmapFilterQuality]"}get namespace(){return"next2d.filters.BitmapFilterQuality"}static get LOW(){return 1}static get MEDIUM(){return 2}static get HIGH(){return 3}}class z{static toString(){return"[class DisplacementMapFilterMode]"}static get namespace(){return"next2d.filters.DisplacementMapFilterMode"}toString(){return"[object DisplacementMapFilterMode]"}get namespace(){return"next2d.filters.DisplacementMapFilterMode"}static get CLAMP(){return"clamp"}static get COLOR(){return"color"}static get IGNORE(){return"ignore"}static get WRAP(){return"wrap"}}class V extends H{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=r.$clamp(+t,0,255,0))!==this._$blurX&&this._$doChanged(!0),this._$blurX=t}get blurY(){return this._$blurY}set blurY(t){(t=r.$clamp(+t,0,255,0))!==this._$blurY&&this._$doChanged(!0),this._$blurY=t}get quality(){return this._$quality}set quality(t){(t=r.$clamp(0|t,0,15,j.LOW))!==this._$quality&&this._$doChanged(!0),this._$quality=t}clone(){return new V(this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=null,i=null){const r=t.clone();if(!this._$quality)return r;const n=V.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,o=0>=this._$blurY?1:this._$blurY*n;switch(!0){case"number"==typeof e:case"number"==typeof i:a*=e,o*=i;break;default:a=s.round(a),o=s.round(o)}return r.x-=a,r.width+=2*a,r.y-=o,r.height+=2*o,r}_$isSame(t){return this._$quality===t._$quality&&(this._$blurX===t._$blurX&&this._$blurY===t._$blurY)}_$canApply(){return!(!this._$quality||!this._$blurX&&!this._$blurY)}_$applyFilter(t,e,i=!0){this._$doChanged(!1);const n=t.frameBuffer.currentAttachment,a=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return i?a:t.frameBuffer.createTextureFromCurrentAttachment();const o=s.sqrt(e[0]*e[0]+e[1]*e[1]),h=s.sqrt(e[2]*e[2]+e[3]*e[3]),l=new x(0,0,a.width,a.height),_=this._$generateFilterRect(l,o,h),$=0|s.ceil(_.width),c=0|s.ceil(_.height),u=s.ceil(s.abs(_.x)+.5*s.abs($-_.width)),d=s.ceil(s.abs(_.y)+.5*s.abs(c-_.height));t._$offsetX=+(u+t._$offsetX),t._$offsetY=+(d+t._$offsetY);const g=this._$blurX*o,f=this._$blurY*h;let m=1,p=1;g>128?m=.0625:g>64?m=.125:g>32?m=.25:g>16&&(m=.5),f>128?p=.0625:f>64?p=.125:f>32?p=.25:f>16&&(p=.5);const b=g*m,T=f*p;let v=s.ceil($*m),y=s.ceil(c*p);const E=t.frameBuffer.createTextureAttachment(v,y),A=[E,t.frameBuffer.createTextureAttachment(v,y)];let M=0;t._$bind(E),r.$resetContext(t),t.setTransform(m,0,0,p,0,0),t.drawImage(a,u,d,a.width,a.height),t.blend.toOneZero();let C=t.frameBuffer.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(C,!0,b),C=t.frameBuffer.getTextureFromCurrentAttachment()}if(this._$blurY>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(C,!1,T),C=t.frameBuffer.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==m||1!==p){const e=t.frameBuffer.createTextureAttachment($,c);t._$bind(e),r.$resetContext(t),t.imageSmoothingEnabled=!0,t.setTransform(1/m,0,0,1/p,0,0),t.drawImage(C,0,0,v,y),C=t.frameBuffer.getTextureFromCurrentAttachment(),r.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.frameBuffer.releaseAttachment(A[0],!0),t.frameBuffer.releaseAttachment(A[1],!0),i?t.frameBuffer.releaseAttachment(n,!0):t.frameBuffer.releaseAttachment(e,!1)}else t.frameBuffer.releaseAttachment(A[(M+1)%2],!0),i?t.frameBuffer.releaseAttachment(n,!0):t.frameBuffer.releaseAttachment(A[M],!1);return C}}class W extends H{constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,o=4,h=1,l=1,_="inner",$=!1){super(),this._$blurFilter=new V(a,o,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type=Y.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=s,this.shadowColor=r,this.shadowAlpha=n,this.strength=h,this.type=_,this.knockout=!!$}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=r.$clamp(+t,0,1,0))!==this._$highlightAlpha&&this._$doChanged(!0),this._$highlightAlpha=t}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,16777215))!==this._$highlightColor&&this._$doChanged(!0),this._$highlightColor=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=r.$clamp(+t,0,1,0))!==this._$shadowAlpha&&this._$doChanged(!0),this._$shadowAlpha=t}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$shadowColor&&this._$doChanged(!0),this._$shadowColor=t}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case Y.OUTER:case Y.INNER:this._$type=t;break;default:this._$type=Y.FULL}}clone(){return new W(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=+this.angle*s.PI/180,a=s.cos(n)*this.distance,o=s.sin(n)*this.distance;let h=0|s.abs(a),l=0|s.abs(o);return 0>a&&h++,0>o&&l++,0===h&&0>o&&(h=1),0===l&&0>a&&(l=1),r.x-=h,r.width+=2*h,r.y-=l,r.height+=2*l,r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$highlightColor===t._$highlightColor&&(this._$highlightAlpha===t._$highlightAlpha&&(this._$shadowColor===t._$shadowColor&&(this._$shadowAlpha===t._$shadowAlpha&&(this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))))))}_$canApply(){return!(!this._$strength||!this._$distance)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return n;const a=i.width,o=i.height,h=t._$offsetX,l=t._$offsetY,_=s.sqrt(e[0]*e[0]+e[1]*e[1]),$=s.sqrt(e[2]*e[2]+e[3]*e[3]),c=+this._$angle*r.$Deg2Rad,u=+s.cos(c)*this._$distance*_,d=+s.sin(c)*this._$distance*$;let g=t.frameBuffer.createTextureAttachment(a,o);t._$bind(g),r.$resetContext(t),t.drawImage(n,0,0,a,o),t.globalCompositeOperation=S.ERASE,t.drawImage(n,2*u,2*d,a,o);const f=this._$blurFilter._$applyFilter(t,e,!1),m=f.width,p=f.height,x=s.ceil(m+2*s.abs(u)),b=s.ceil(p+2*s.abs(d)),T=this._$type===Y.INNER,v=T?a:x,y=T?o:b,E=s.abs(u),A=s.abs(d),M=(m-a)/2,C=(p-o)/2;let R,w,O,I;return T?(R=0,w=0,O=-M-u,I=-C-d):(R=E+M,w=A+C,O=E-u,I=A-d),t._$bind(i),t._$applyBitmapFilter(f,v,y,a,o,R,w,m,p,O,I,!1,this._$type,this._$knockout,this._$strength,null,null,null,r.$intToR(this._$highlightColor,this._$highlightAlpha,!0),r.$intToG(this._$highlightColor,this._$highlightAlpha,!0),r.$intToB(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,r.$intToR(this._$shadowColor,this._$shadowAlpha,!0),r.$intToG(this._$shadowColor,this._$shadowAlpha,!0),r.$intToB(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=h+R,t._$offsetY=l+w,t.frameBuffer.releaseTexture(f),t.frameBuffer.getTextureFromCurrentAttachment()}}class q extends H{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this._$doApply=!1,this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(r.$isArray(t)&&20===t.length){if(this._$matrix){const e=t.length;for(let i=0;i<e;++i)if(t[i]!==this._$matrix[i]){this._$doChanged(!0),this._$doApply=!0;break}}this._$matrix=t}}clone(){return new q(this._$matrix)}_$generateFilterRect(t){return t}_$isSame(t){const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$doApply}_$applyFilter(t){this._$doChanged(!1);const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment(),s=i.width,n=i.height,a=t.frameBuffer.createTextureAttachment(s,n);return t._$bind(a),r.$resetContext(t),t._$applyColorMatrixFilter(i,this._$matrix),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class K extends H{constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,o=0,h=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=s,this.bias=r,this.preserveAlpha=n,this.clamp=a,this.color=o,this.alpha=h}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get bias(){return this._$bias}set bias(t){(t=+t)!==this._$bias&&this._$doChanged(!0),this._$bias=t}get clamp(){return this._$clamp}set clamp(t){(t=!!t)!==this._$clamp&&this._$doChanged(!0),this._$clamp=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get divisor(){return this._$divisor}set divisor(t){(t=+t)!==this._$divisor&&this._$doChanged(!0),this._$divisor=t}get matrix(){return this._$matrix}set matrix(t){this._$doChanged(!0),this._$matrix&&r.$poolArray(this._$matrix),this._$matrix=r.$getArray(),r.$isArray(t)&&(this._$matrix=t.slice(0))}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|r.$clamp(0|t,0,15,0))!==this._$matrixX&&this._$doChanged(!0),this._$matrixX=t}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|r.$clamp(0|t,0,15,0))!==this._$matrixY&&this._$doChanged(!0),this._$matrixY=t}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){(t=!!t)!==this._$preserveAlpha&&this._$doChanged(!0),this._$preserveAlpha=t}clone(){return new K(this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){if(this._$matrixX!==t._$matrixX)return!1;if(this._$matrixY!==t._$matrixY)return!1;if(this._$divisor!==t._$divisor)return!1;if(this._$bias!==t._$bias)return!1;if(this._$preserveAlpha!==t._$preserveAlpha)return!1;if(this._$clamp!==t._$clamp)return!1;if(this._$color!==t._$color)return!1;if(this._$alpha!==t._$alpha)return!1;const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$doChanged(!1);const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment();return this._$canApply()?(t._$applyConvolutionFilter(i,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,r.$intToR(this._$color,this._$alpha,!1),r.$intToG(this._$color,this._$alpha,!1),r.$intToB(this._$color,this._$alpha,!1),this._$alpha),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()):i}}class Q extends H{constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",o=0,h=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode=z.WRAP,this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=s,this.scaleX=r,this.scaleY=n,this.mode=a,this.color=o,this.alpha=h}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get componentX(){return this._$componentX}set componentX(t){switch((t|=0)!==this._$componentX&&this._$doChanged(!0),this._$componentX=0,t){case C.ALPHA:case C.BLUE:case C.GREEN:case C.RED:this._$componentX=t}}get componentY(){return this._$componentY}set componentY(t){switch((t|=0)!==this._$componentY&&this._$doChanged(!0),this._$componentY=0,t){case C.ALPHA:case C.BLUE:case C.GREEN:case C.RED:this._$componentY=t}}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&this._$doChanged(!0),this._$mapBitmap=null,t instanceof M&&(this._$mapBitmap=t)}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&this._$doChanged(!0),this._$mapPoint=null,t instanceof p&&(this._$mapPoint=t)}get mode(){return this._$mode}set mode(t){switch((t+="")!==this._$mode&&this._$doChanged(!0),this._$mode=z.WRAP,t){case z.CLAMP:case z.COLOR:case z.IGNORE:this._$mode=t}}get scaleX(){return this._$scaleX}set scaleX(t){(t=r.$clamp(+t,-65535,65535,0))!==this._$scaleX&&this._$doChanged(!0),this._$scaleX=t}get scaleY(){return this._$scaleY}set scaleY(t){(t=r.$clamp(+t,-65535,65535,0))!==this._$scaleY&&this._$doChanged(!0),this._$scaleY=t}clone(){return new Q(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){return this._$mapBitmap===t._$mapBitmap&&(this._$mapPoint.x===t._$mapPoint.x&&(this._$mapPoint.y===t._$mapPoint.y&&(this._$componentX===t._$componentX&&(this._$componentY===t._$componentY&&(this._$scaleX===t._$scaleX&&(this._$scaleY===t._$scaleY&&(this._$mode===t._$mode&&(this._$color===t._$color&&this._$alpha===t._$alpha))))))))}_$canApply(){return!(null===this._$mapBitmap||!this._$componentX&&!this._$componentY||!this._$scaleX&&!this._$scaleY)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return n;const a=s.sqrt(e[0]*e[0]+e[1]*e[1]),o=s.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(n,this._$mapBitmap._$texture,n.width/a,n.height/o,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,r.$intToR(this._$color,this._$alpha,!0),r.$intToG(this._$color,this._$alpha,!0),r.$intToB(this._$color,this._$alpha,!0),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class J extends H{constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,o=1,h=!1,l=!1,_=!1){super(),this._$blurFilter=new V(r,n,o),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=s,this.strength=a,this.inner=h,this.knockout=l,this.hideObject=_}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get hideObject(){return this._$hideObject}set hideObject(t){(t=!!t)!==this._$hideObject&&this._$doChanged(!0),this._$hideObject=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new J(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let n=t.clone();if(!this._$canApply())return n;n=this._$blurFilter._$generateFilterRect(n,e,i);const a=+this._$angle*r.$Deg2Rad,o=+s.cos(a)*this._$distance,h=+s.sin(a)*this._$distance;let l=0,_=0,$=0,c=0;if(o<0==!0)l=0|s.floor(o),$=0|-s.round(o/2);else l=0|s.round(o/2),$=o/2|0;if(h<0==!0)_=0|s.floor(h),c=0|-s.round(h/2);else _=0|s.round(h/2),c=h/2|0;return n.x+=l,n.width+=$,n.y+=_,n.height+=c,n}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&(this._$hideObject===t._$hideObject&&this._$blurFilter._$isSame(t._$blurFilter))))))))}_$canApply(){return!(!this._$alpha||!this._$strength)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const n=i.width,a=i.height,o=t._$offsetX,h=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,$=l.height,c=t._$offsetX,u=t._$offsetY,d=c-o,g=u-h,f=+this._$angle*r.$Deg2Rad,m=+s.cos(f)*this._$distance*r.$devicePixelRatio,p=+s.sin(f)*this._$distance*r.$devicePixelRatio,x=this._$inner?n:_+s.max(0,s.abs(m)-d),b=this._$inner?a:$+s.max(0,s.abs(p)-g),T=s.ceil(x),v=s.ceil(b),y=(T-x)/2,E=(v-b)/2;let A,M,C,S,R,w;return this._$inner?(A=0,M=0,C=m-c,S=p-u):(A=s.max(0,d-m)+y,M=s.max(0,g-p)+E,C=(m>0?s.max(0,m-d):0)+y,S=(p>0?s.max(0,p-g):0)+E),this._$inner?(R=Y.INNER,w=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(R=Y.FULL,w=!0):(R=Y.OUTER,w=this._$knockout),t._$bind(i),t._$applyBitmapFilter(l,T,v,n,a,A,M,_,$,C,S,!0,R,w,this._$strength,null,null,null,r.$intToR(this._$color,this._$alpha,!0),r.$intToG(this._$color,this._$alpha,!0),r.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=o+A,t._$offsetY=h+M,t.frameBuffer.releaseTexture(l),t.frameBuffer.getTextureFromCurrentAttachment()}}class Z extends H{constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,o=!1){super(),this._$blurFilter=new V(i,s,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=r,this.inner=a,this.knockout=o}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,4))!==this._$color&&this._$doChanged(!0),this._$color=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new Z(this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){const s=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$isSame(t){return this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))}_$canApply(){return!(!this._$alpha||!this._$strength)&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const s=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,_=h.height,$=t._$offsetX,c=t._$offsetY,u=this._$inner?s:l,d=this._$inner?n:_;let g,f,m,p;this._$inner?(g=0,f=0,m=-$,p=-c):(g=$-a,f=c-o,m=0,p=0);const x=this._$inner?Y.INNER:Y.OUTER;return t._$bind(i),t._$applyBitmapFilter(h,u,d,s,n,g,f,l,_,m,p,!0,x,this._$knockout,this._$strength,null,null,null,r.$intToR(this._$color,this._$alpha,!0),r.$intToG(this._$color,this._$alpha,!0),r.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=o+f,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class tt extends H{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,o=1,h=1,l="inner",_=!1){super(),this._$blurFilter=new V(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=Y.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=o,this.type=l,this.knockout=_}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=r.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-s.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=r.$toColorInt(s.abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i)t[i]=r.$clamp(+t[i],0,255,0);this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case Y.OUTER:case Y.FULL:this._$type=t;break;default:this._$type=Y.INNER}}clone(){return new tt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t){let e=t.clone();if(!this._$canApply())return e;e=this._$blurFilter._$generateFilterRect(e);const i=+this.angle*s.PI/180,r=s.cos(i)*this._$distance,n=s.sin(i)*this._$distance;let a=0|s.abs(r),o=0|s.abs(n);return 0>r&&a++,0>n&&o++,0===a&&0>n&&(a=1),0===o&&0>r&&(o=1),e.x-=a,e.width+=2*a,e.y-=o,e.height+=2*o,e}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$canApply(){return!!(0!==this._$strength&&0!==this._$distance&&this._$alphas&&this._$ratios&&this._$colors)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return n;const a=i.width,o=i.height,h=t._$offsetX,l=t._$offsetY,_=s.sqrt(e[0]*e[0]+e[1]*e[1]),$=s.sqrt(e[2]*e[2]+e[3]*e[3]),c=+this._$angle*r.$Deg2Rad,u=+s.cos(c)*this._$distance*_,d=+s.sin(c)*this._$distance*$;let g=t.frameBuffer.createTextureAttachment(a,o);t._$bind(g),r.$resetContext(t),t.drawImage(n,0,0,a,o),t.globalCompositeOperation=S.ERASE,t.drawImage(n,2*u,2*d,a,o);const f=this._$blurFilter._$applyFilter(t,e,!1),m=f.width,p=f.height,x=s.ceil(m+2*s.abs(u)),b=s.ceil(p+2*s.abs(d)),T=this._$type===Y.INNER,v=T?a:x,y=T?o:b,E=s.abs(u),A=s.abs(d),M=(m-a)/2,C=(p-o)/2;let R,w,O,I;return T?(R=0,w=0,O=-M-u,I=-C-d):(R=E+M,w=A+C,O=E-u,I=A-d),t._$bind(i),t._$applyBitmapFilter(f,v,y,a,o,R,w,m,p,O,I,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=h+R,t._$offsetY=l+w,t.frameBuffer.releaseTexture(f),t.frameBuffer.getTextureFromCurrentAttachment()}}class et extends H{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,o=1,h=1,l="inner",_=!1){super(),this._$blurFilter=new V(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=Y.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=o,this.type=l,this.knockout=_}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=r.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-s.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=r.$toColorInt(s.abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=r.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case Y.OUTER:case Y.FULL:this._$type=t;break;default:this._$type=Y.INNER}}clone(){return new et(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=+this.angle*s.PI/180,a=+s.cos(n)*this.distance,o=+s.sin(n)*this.distance;let h=0,l=0,_=0,$=0;if(a<0==!0)h=0|s.floor(a),_=0|-s.round(a/2);else h=0|s.round(a/2),_=a/2|0;if(o<0==!0)l=0|s.floor(o),$=0|-s.round(o/2);else l=0|s.round(o/2),$=o/2|0;return r.x+=h,r.width+=_,r.y+=l,r.height+=$,r}_$canApply(){return!!(0!==this._$strength&&this._$alphas&&this._$ratios&&this._$colors)}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const n=i.width,a=i.height,o=t._$offsetX,h=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,$=l.height,c=t._$offsetX,u=t._$offsetY,d=c-o,g=u-h,f=s.sqrt(e[0]*e[0]+e[1]*e[1]),m=s.sqrt(e[2]*e[2]+e[3]*e[3]),p=+this._$angle*r.$Deg2Rad,x=+s.cos(p)*this._$distance*f,b=+s.sin(p)*this._$distance*m,T=this.type===Y.INNER,v=T?n:_+s.max(0,s.abs(x)-d),y=T?a:$+s.max(0,s.abs(b)-g),E=s.ceil(v),A=s.ceil(y),M=(E-v)/2,C=(A-y)/2;let S,R,w,O;return T?(S=0,R=0,w=x-c,O=b-u):(S=s.max(0,d-x)+M,R=s.max(0,g-b)+C,w=(x>0?s.max(0,x-d):0)+M,O=(b>0?s.max(0,b-g):0)+C),t._$bind(i),t._$applyBitmapFilter(l,E,A,n,a,S,R,_,$,w,O,!0,this.type,this.knockout,this._$strength,this.ratios,this.colors,this.alphas,0,0,0,0,0,0,0,0),t._$offsetX=o+S,t._$offsetY=h+R,t.frameBuffer.releaseTexture(l),t.frameBuffer.getTextureFromCurrentAttachment()}}class it{static toString(){return"[class TextFormatAlign]"}static get namespace(){return"next2d.text.TextFormatAlign"}toString(){return"[object TextFormatAlign]"}get namespace(){return"next2d.text.TextFormatAlign"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get RIGHT(){return"right"}}class st{static toString(){return"[class TextFieldAutoSize]"}static get namespace(){return"next2d.text.TextFieldAutoSize"}toString(){return"[object TextFieldAutoSize]"}get namespace(){return"next2d.text.TextFieldAutoSize"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get NONE(){return"none"}static get RIGHT(){return"right"}}class rt extends v{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0;const t=new at;t._$setDefault(this),this._$defaultTextFormat=t,this._$decisionTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict=null,this._$isHTML=!1,this._$textData=null,this._$renew=!0,this._$textHeight=null,this._$textWidth=null,this._$widthTable=null,this._$textarea=null,this._$autoSize=st.NONE,this._$autoFontSize=!1,this._$textAppending=!1,this._$heightTable=null,this._$textFormatTable=[],this._$textAreaActive=!1,this._$totalWidth=null,this._$objectTable=null,this._$imageData=null,this._$scroll=!1,this._$type=nt.STATIC,this._$textHeightTable=null,this._$focus=!1,this._$isComposing=!1,this._$thickness=0,this._$thicknessColor=0,this._$verticalAlign=ot.TOP}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}static get TEXT(){return"text"}static get BREAK(){return"break"}static get WRAP(){return"wrap"}static get IMAGE(){return"image"}get autoFontSize(){return this._$autoFontSize}set autoFontSize(t){this._$autoFontSize=!!t}get autoSize(){return this._$autoSize}set autoSize(t){switch(t){case st.CENTER:case st.LEFT:case st.RIGHT:this._$autoSize=t;break;default:this._$autoSize=st.NONE}this._$reload()}get background(){return this._$background}set background(t){this._$background=!!t,this._$reset()}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){this._$backgroundColor=r.$clamp(r.$toColorInt(t),0,16777215,16777215),this._$reset()}get border(){return this._$border}set border(t){this._$border=!!t,this._$reset()}get borderColor(){return this._$borderColor}set borderColor(t){this._$borderColor=r.$clamp(r.$toColorInt(t),0,16777215,0),this._$reset()}get defaultTextFormat(){return this._$defaultTextFormat}set defaultTextFormat(t){t instanceof at&&(t._$merge(this._$defaultTextFormat),t._$textField=this,this._$defaultTextFormat=t)}get focus(){return this._$focus}set focus(t){if(this._$focus!==!!t)if(this._$focus=!!t,this._$focus){if(this._$type===nt.INPUT){const t=r.$currentPlayer(),e=r.$document.getElementById(t.contentElementId);if(!e)return;this._$createTextAreaElement(t._$scale);const i=this._$textarea,n=this._$transform.concatenatedMatrix,a=this._$getBounds(null),o=r.$intToRGBA(this._$defaultTextFormat._$color,100);i.style.color=`rgb(${o.R},${o.G},${o.B})`,i.style.left=(n.tx+a.xMin+t._$tx/t._$scale/r.$devicePixelRatio)*t._$scale+"px",i.style.top=(n.ty+a.yMin+t._$ty/t._$scale/r.$devicePixelRatio)*t._$scale+"px",i.style.width=`${s.ceil((this.width-1)*t._$scale)}px`,i.style.height=`${s.ceil((this.height-1)*t._$scale)}px`,i.value=this.text,e.appendChild(i);(0,r.$requestAnimationFrame)((()=>{i.focus()})),this._$textAreaActive=!0,this.willTrigger(_.FOCUS_IN)&&this.dispatchEvent(new _(_.FOCUS_IN)),this._$doChanged(),r.$isUpdated=!0}}else this._$textarea&&(this._$textarea.dispatchEvent(new r.$window.Event(`${r.$PREFIX}_blur`)),this.willTrigger(_.FOCUS_OUT)&&this.dispatchEvent(new _(_.FOCUS_OUT)),this._$doChanged(),r.$isUpdated=!0,this._$textarea.remove())}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=`${t}`,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable=[],this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1,this._$getTextData();const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=0,s=0;for(;t>s&&(i+=this._$textHeightTable[s],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){this._$multiline=!!t,this._$reset()}get numLines(){return null===this._$textData&&this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=`${t}`}get scroll(){return this._$scroll}set scroll(t){this._$scroll=!!t}get scrollH(){return this._$scrollH}set scrollH(t){t=r.$clamp(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger(o.SCROLL)&&this.dispatchEvent(new o(o.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){t=r.$clamp(0|t,1,this.maxScrollV),this._$scrollV!==t&&(this._$scrollV=t,this._$reset(),this.willTrigger(o.SCROLL)&&this.dispatchEvent(new o(o.SCROLL,!0)))}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData(),i=0|e.length;for(let s=1;s<i;++s){const i=e[s];switch(i.mode){case rt.TEXT:t+=i.text;break;case rt.BREAK:t+="\r"}}return!this._$isHTML&&this._$initText&&(t+="\r"),this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$cacheText="",this._$isHTML=!1,this._$textAppending||(this._$textFormatTable=[]),this._$reload())}get textColor(){return this._$defaultTextFormat.color}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(""===this.text)return 0;if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();let t=0|this._$decisionTextFormat._$leading;const e=this._$textHeightTable.length;1===e&&(this._$textHeight+=t);for(let t=0;t<e;++t)this._$textHeight+=this._$textHeightTable[t]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=s.max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get thickness(){return this._$thickness}set thickness(t){this._$thickness=0|t,this._$reset()}get thicknessColor(){return this._$thicknessColor}set thicknessColor(t){this._$thicknessColor=r.$clamp(r.$toColorInt(t),0,16777215,16777215),this._$reset()}get type(){return this._$type}set type(t){(t+="")===nt.STATIC?(this._$type=t,this._$textarea=null):this._$type=nt.INPUT}get verticalAlign(){return this._$verticalAlign}set verticalAlign(t){switch(t){case ot.MIDDLE:case ot.BOTTOM:this._$verticalAlign=t;break;default:this._$verticalAlign=ot.TOP}}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap=!!t}get width(){return super.width}set width(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this._$getBounds(null),i=s.abs(e.xMin);this._$originBounds.xMax=t+i,this._$originBounds.xMin=i,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}}get height(){return super.height}set height(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this._$getBounds(null),i=s.abs(e.yMin);this._$originBounds.yMax=t+i,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this._$textAppending=!0,this.text=e+`${t}`,this._$textAppending=!1}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),s=e>-1?e:i.length;let r=!1,n=new at,a=t>-1?t:0;for(;a<s;++a){if(i[a].mode===rt.BREAK)continue;const t=i[a].textFormat;r?(n._$align=n._$align!==t._$align?null:t._$align,n._$blockIndent=n._$blockIndent!==t._$blockIndent?null:t._$blockIndent,n._$bold=n._$bold!==t._$bold?null:t._$bold,n._$color=n._$color!==t._$color?null:t._$color,n._$font=n._$font!==t._$font?null:t._$font,n._$indent=n._$indent!==t._$indent?null:t._$indent,n._$italic=n._$italic!==t._$italic?null:t._$italic,n._$leading=n._$leading!==t._$leading?null:t._$leading,n._$leftMargin=n._$leftMargin!==t._$leftMargin?null:t._$leftMargin,n._$letterSpacing=n._$letterSpacing!==t._$letterSpacing?null:t._$letterSpacing,n._$rightMargin=n._$rightMargin!==t._$rightMargin?null:t._$rightMargin,n._$size=n._$size!==t._$size?null:t._$size,n._$underline=n._$underline!==t._$underline?null:t._$underline):(r=!0,n=t._$clone())}return n}getLineText(t){if(!this._$text&&!this._$htmlText)return"";t|=0;let e="";const i=this._$getTextData();for(let s=0;s<i.length;s++){const r=i[s];if(r.yIndex>t)break;r.yIndex===t&&(r.mode===rt.TEXT&&(e+=r.text))}return e}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const s=this.text;t>=s.length?e>=s.length&&e>=t&&(this.text=s+`${i}`):this.text=s.substr(0,t)+`${i}`+s.substr(e,s.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const s=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:{const e=s.length;for(let i=0;i<e;++i)this._$textFormatTable[i]=t._$clone()}break;case e>-1&&-1===i:{let i=e+1,r=s[i];r.mode===rt.WRAP&&(r=s[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let r=0;for(let n=e;n<i;++n){const e=s[n];e&&(e.mode!==rt.WRAP&&e.mode!==rt.BREAK?this._$textFormatTable[n+r]=t._$clone():(++i,--r))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(null===this._$textData){this._$textData=[],this._$imageData=[],this._$heightTable=[],this._$textHeightTable=[],this._$objectTable=[],this._$widthTable=[],this._$heightCache=r.$getMap();let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),r.$P_TAG.innerHTML!==e&&(r.$P_TAG.textContent="",r.$P_TAG.insertAdjacentHTML("afterbegin",e));let s=this._$decisionTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}this._$totalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=this._$getTextHeight(s),this._$widthTable[0]=0;const n={mode:rt.BREAK,x:0,yIndex:0,textFormat:s._$clone()};this._$objectTable[0]=n,this._$textData[0]=n,this._$parseTag(r.$P_TAG,s._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")],i=e.length;for(let s=0;s<i;++s){this._$totalWidth=0;let i=this.defaultTextFormat;const r=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[r]=0,this._$textHeightTable[r]=this._$getTextHeight(i),this._$widthTable[r]=0,r&&(this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(i),i=t}const n={mode:rt.BREAK,x:0,yIndex:r,textFormat:i._$clone()};i=this.defaultTextFormat,this._$objectTable[r]=n,this._$textData[this._$textData.length]=n;const a=e[s];a&&(t=this._$parseText(a,i,t))}}r.$poolMap(this._$heightCache),this._$heightCache=null}return this._$textData}_$parseTag(t,e,i){const n=t.childNodes,a=n.length;for(let t=0;t<a;++t){let a=e._$clone();const o=n[t];if(3!==o.nodeType)switch(o.nodeName){case"P":{if(o.hasAttribute("align")&&(a._$align=o.getAttribute("align").toLowerCase(),1===this._$textData.length&&(this._$textData[0].textFormat._$align=a._$align)),this._$parseTag(o,a,i),!this._$multiline)break;this._$totalWidth=this._$getImageOffsetX();const t=this._$heightTable.length;if(this._$heightTable[t]=0,this._$textHeightTable[t]=0,this._$widthTable[t]=0,t&&(this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(a),a=t}const e={mode:rt.BREAK,x:0,yIndex:t,textFormat:a};this._$objectTable[t]=e,this._$textData.push(e)}break;case"B":a._$bold=!0,this._$parseTag(o,a,i);break;case"I":a._$italic=!0,this._$parseTag(o,a,i);break;case"U":a._$underline=!0,this._$parseTag(o,a,i);break;case"FONT":o.hasAttribute("face")&&(a._$font=o.getAttribute("face")),o.hasAttribute("size")&&(a._$size=0|o.getAttribute("size")),o.hasAttribute("color")&&(a._$color=r.$toColorInt(o.getAttribute("color"))),o.hasAttribute("letterSpacing")&&(a.letterSpacing=0|o.getAttribute("letterSpacing")),this._$parseTag(o,a,i);break;case"TEXTFORMAT":o.hasAttribute("blockindent")&&(a._$blockIndent=0|o.getAttribute("blockindent")),o.hasAttribute("indent")&&(a._$indent=0|o.getAttribute("indent")),o.hasAttribute("leading")&&(a._$leading=0|o.getAttribute("leading")),o.hasAttribute("leftmargin")&&(a._$leftMargin=0|o.getAttribute("leftmargin")),o.hasAttribute("rightmargin")&&(a._$rightMargin=0|o.getAttribute("rightmargin")),this._$parseTag(o,a,i);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0,this._$totalWidth=this._$getImageOffsetX(),a._$indent=0;const e={mode:rt.BREAK,x:0,yIndex:t,textFormat:a};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"IMG":{let t="";o.hasAttribute("src")&&(t=o.getAttribute("src"));let e=null;if(r.$loadedImages.has(t))e=r.$loadedImages.get(t);else{const i=o.getAttribute("width")||0,n=o.getAttribute("height")||0,h=o.getAttribute("vspace")||8,l=o.getAttribute("hspace")||8;let _=0;for(let t=0;t<this._$textHeightTable.length;t++)_+=this._$textHeightTable[t];if(e={mode:rt.IMAGE,src:t,loaded:!1,x:0,y:_,width:0|i,height:0|n,hspace:0|l,vspace:0|h,textFormat:a._$clone()},this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],i=t.y+t.height+2*t.vspace;e.y=s.max(_,i)}this._$loadImage(e),r.$loadedImages.set(t,e)}this._$textData[this._$textData.length]=e,this._$imageData[this._$imageData.length]=e}break;default:this._$parseTag(o,a,i)}else i=this._$parseText(o.nodeValue,a)}}_$loadImage(t){t.scope=this,t.image=new r.$Image,t.image.crossOrigin="anonymous",t.image.addEventListener("load",function(){this.loaded=!0,this.width||(this.width=0|this.image.width),this.height||(this.height=0|this.image.height);const t=this.scope;this.scope=null,r.$loadedImages.set(this.src,this),t._$reload()}.bind(t),!1),t.image.src=t.src}_$parseText(t,e,i){let n=this._$heightTable.length-1|0,a=e._$clone();const o=this._$transform.concatenatedMatrix._$matrix,h=(this._$originBounds.xMax-this._$originBounds.xMin)*(o[0]/o[3]);r.$poolFloat32Array6(o);const l=h-a._$widthMargin()-4;for(let o=0;o<t.length;++o){if(a=e._$clone(),this._$textData.length+i in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+i]._$clone();t._$merge(a),a=t}const h={mode:rt.TEXT,text:t[o],x:0,width:0,fontScale:0,yIndex:n,textFormat:a};let _=null;this._$multiline&&(_="\n"===h.text||"\r"===h.text||"\n\r"===h.text);let $=n?a._$leading:0,c=0,u=0,d=0,g=null;if(r.$textContext.font=a._$generateFontStyle(),c=r.$textContext.measureText(h.text).width+a._$letterSpacing,u=this._$getTextHeight(a),d=u+$,h.height=u,_||this._$wordWrap&&this._$totalWidth+c>l){this._$widthTable[++n]=0,h.yIndex=n,this._$heightTable[n]=this._$heightTable[n-1],this._$textHeightTable[n]=this._$textHeightTable[n-1],this._$totalWidth=this._$getImageOffsetX(),a=a._$clone(),a._$indent=0;g={mode:_?rt.BREAK:rt.WRAP,x:0,yIndex:n,textFormat:a},this._$objectTable[n]=g,_||--i;let t=h.text,e=0,r=!0;const o=/[0-9a-zA-Z?!;:.,]/g;for(;t.match(o);){++e;const i=this._$textData[this._$textData.length-e];if(i.mode!==rt.TEXT){r=!1;break}t=i.text}if(e>1&&this._$textData[this._$textData.length-e+1].text.match(/[0-9a-zA-Z]/g)&&--e,e>0&&r){const t=this._$textData.length-e;this._$textData.splice(t,0,g);let i=1,r=this._$textData[t-i];for(this._$widthTable[n-1]=0,this._$heightTable[n-1]=0,this._$textHeightTable[n-1]=0;r.mode===rt.TEXT;)u=this._$getTextHeight(r.textFormat),d=u+$,this._$widthTable[n-1]+=r.width,this._$heightTable[n-1]=s.max(this._$heightTable[n-1],u),this._$textHeightTable[n-1]=s.max(this._$textHeightTable[n-1],d),++i,r=this._$textData[t-i];for(i=1;this._$textData.length>t+i;)r=this._$textData[t+i],++i,u=this._$getTextHeight(r.textFormat),d=u+$,this._$heightTable[n]=s.max(this._$heightTable[n],u),this._$textHeightTable[n]=s.max(this._$textHeightTable[n],d),r.x=this._$totalWidth,r.yIndex=n,this._$totalWidth+=r.width}else this._$textData[this._$textData.length]=g}_||(h.width=c,h.x=this._$totalWidth,this._$totalWidth+=c,this._$widthTable[n]=s.max(this._$widthTable[n],this._$totalWidth),this._$heightTable[n]=s.max(this._$heightTable[n],u),this._$textHeightTable[n]=s.max(this._$textHeightTable[n],d),this._$textData[this._$textData.length]=h)}return i}_$getTextHeight(t){if(!r.$DIV){const t=r.$document.createElement("div");t.innerHTML="a",t.style.display="block",t.style.position="absolute",t.style.top="-9999px",t.style.left="-9999px",t.style.padding="0",t.style.margin="0",t.style.padding="0",t.style.border="0",t.style.outline="0",t.style.verticalAlign="bottom",t.style.lineHeight="100%",r.$DIV=t,r.$document.body.appendChild(r.$DIV)}const e=t._$size,i=t._$font,s=t._$bold?"bold":"normal",n=`${e}_${i}_${s}`;if(this._$heightCache.has(n))return this._$heightCache.get(n);const a=r.$DIV.style,o=`${e}px`;a.fontSize!==o&&(a.fontSize=o),a.fontFamily!==i&&(a.fontFamily=i),a.fontWeight!==s&&(a.fontWeight=s);const h=10>e?r.$DIV.clientHeight*e*.1:r.$DIV.clientHeight;return this._$heightCache.set(n,h),h}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],s=i.height+2*i.vspace;if(i.y<=t&&t<i.y+s)return i.width+2*i.hspace}return 0}_$reset(){this._$renew=!0,this._$textData=null,this._$imageData=null,this._$textHeight=null,this._$textWidth=null,this._$heightTable=null,this._$textHeightTable=null,this._$widthTable=null,this._$objectTable=null,this._$totalWidth=null,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),r.$isUpdated=!0,r.$cacheStore().removeCache(this._$instanceId)}_$reload(){if(this._$reset(),this._$getTextData(),this._$autoSize===st.NONE&&this._$autoFontSize){const t=this.defaultTextFormat.size;if(this.width&&this.textWidth&&this.textWidth>this.width)for(;this.textWidth>this.width;){if(this.defaultTextFormat.size--,1>this.defaultTextFormat.size){this.defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}if(this.height&&this.textHeight&&this.textHeight>this.height)for(;this.textHeight>this.height;){if(this.defaultTextFormat.size--,1>this.defaultTextFormat.size){this.defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}this.defaultTextFormat.size=t}this._$resize()}_$resize(){if(this._$autoSize!==st.NONE){const t=this._$defaultTextFormat,e=this.textWidth+4+t._$leftMargin+t._$rightMargin;if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case st.LEFT:case st.CENTER:this._$bounds.xMax=e+this._$bounds.xMin;break;case st.RIGHT:this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],r=t.textFormat,n=r._$blockIndent+r._$leftMargin>0?r._$blockIndent+r._$leftMargin:0;switch(!0){case!1===this._$wordWrap&&i>e:return s.max(0,n);case r._$align===it.CENTER:case this._$autoSize===st.CENTER:return s.max(0,e/2-n-r._$rightMargin-i/2);case r._$align===it.RIGHT:case this._$autoSize===st.RIGHT:return s.max(0,e-n-i-r._$rightMargin-2);default:return s.max(0,n+2)}}_$getBounds(t=null){if(t){const e=r.$multiplicationMatrix(t,this._$correctMatrix(this._$transform._$rawMatrix()));return r.$boundsMatrix(this._$bounds,e)}return r.$boundsMatrix(this._$bounds,this._$correctMatrix(r.$MATRIX_ARRAY_IDENTITY))}_$correctMatrix(t){switch(this._$autoSize){case st.CENTER:{const e=this.textWidth+4,i=(this._$originBounds.xMax-this._$originBounds.xMin)/2-e/2;return r.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}case st.RIGHT:{const e=this.textWidth+4,i=this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin);return r.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}default:return t}}_$buildCharacter(t){const e=this.defaultTextFormat;switch(e.font=t.font,e.size=0|t.size,e.align=t.align,e.color=0|t.color,e.leading=t.leading,e.letterSpacing=t.letterSpacing,e.leftMargin=t.leftMargin,e.rightMargin=t.rightMargin,t.fontType){case 1:e.bold=!0;break;case 2:e.italic=!0;break;case 3:e.bold=!0,e.italic=!0}switch(this._$type=t.inputType,this._$multiline=!!t.multiline,this._$wordWrap=!!t.wordWrap,this._$border=!!t.border,this._$scroll=!!t.scroll,this._$thickness=0|t.thickness,this._$thicknessColor=0|t.thicknessColor,this._$bounds.xMin=t.originBounds.xMin,this._$bounds.xMax=t.originBounds.xMax,this._$bounds.yMin=t.originBounds.yMin,this._$bounds.yMax=t.originBounds.yMax,this._$originBounds.xMin=t.originBounds.xMin,this._$originBounds.xMax=t.originBounds.xMax,this._$originBounds.yMin=t.originBounds.yMin,this._$originBounds.yMax=t.originBounds.yMax,t.autoSize){case 1:this.autoSize=t.align;break;case 2:this.autoFontSize=!0}this.text=t.text}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const i=this._$getBounds(),n=i.xMax,a=i.xMin,o=i.yMax,h=i.yMin;r.$poolBoundsObject(i);let l=s.ceil(s.abs(n-a)),_=s.ceil(s.abs(o-h));if(!l||!_)return;let $=e;const c=this._$transform._$rawMatrix();c!==r.$MATRIX_ARRAY_IDENTITY&&($=r.$multiplicationMatrix(e,c)),r.$resetContext(t),t.setTransform($[0],$[1],$[2],$[3],$[4],$[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(l,0),t.lineTo(l,_),t.lineTo(0,_),t.lineTo(0,0),t.clip(!0),$!==e&&r.$poolFloat32Array6($)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let n=i;const a=this._$transform._$rawColorTransform();a!==r.$COLOR_ARRAY_IDENTITY&&(n=r.$multiplicationColor(i,a));const o=r.$clamp(n[3]+n[7]/255,0,1);if(!o)return;let h=e;const l=this._$transform._$rawMatrix();l!==r.$MATRIX_ARRAY_IDENTITY&&(h=r.$multiplicationMatrix(e,l));const _=this._$getBounds(null);_.xMin-=this._$thickness,_.xMax+=this._$thickness,_.yMin-=this._$thickness,_.yMax+=this._$thickness;const $=_.xMin,c=_.xMax,u=_.yMin,d=_.yMax,g=r.$boundsMatrix(_,h),f=+g.xMax,m=+g.xMin,p=+g.yMax,x=+g.yMin;r.$poolBoundsObject(g),r.$poolBoundsObject(_);let b=s.ceil(s.abs(f-m)),T=s.ceil(s.abs(p-x));if(!b||!T)return;if(0>m+b||0>x+T)return;const v=t.frameBuffer.currentAttachment;if(m>v.width||x>v.height)return;const y=+s.sqrt(h[0]*h[0]+h[1]*h[1]).toFixed(3),E=+s.sqrt(h[2]*h[2]+h[3]*h[3]).toFixed(3),A=r.$getArray();A[0]=y,A[1]=E;const M=r.$cacheStore(),C=M.generateKeys(this._$instanceId,A,n);let S=M.get(C);if(S&&(this._$renew||this._$isUpdated())&&(M.set(C,null),M.destroy(S),S=null),b+=4*r.$devicePixelRatio,T+=4*r.$devicePixelRatio,!S){this._$renew=!1,n[3]=1;const i=M.getCanvas();i.width=b,i.height=T;const a=i.getContext("2d");if(this._$background||this._$border){if(a.beginPath(),a.rotate(s.atan2(e[1],e[0])),a.moveTo(0,0),a.lineTo(b,0),a.lineTo(b,T),a.lineTo(0,T),a.lineTo(0,0),this._$background){const t=r.$generateColorTransform(r.$intToRGBA(this._$backgroundColor),n);a.fillStyle=`rgba(${t.R},${t.G},${t.B},${t.A})`,a.fill()}if(this._$border){const t=r.$generateColorTransform(r.$intToRGBA(this._$borderColor),n);a.lineWidth=1,a.strokeStyle=`rgba(${t.R},${t.G},${t.B},${t.A})`,a.stroke()}}a.save(),a.beginPath(),a.moveTo(2,2),a.lineTo(b-2,2),a.lineTo(b-2,T-2),a.lineTo(2,T-2),a.lineTo(2,2),a.clip(),a.beginPath(),a.setTransform(y,0,0,E,0,0),this._$doDraw(a,e,n,!1,b/e[0]),a.restore(),S=t.frameBuffer.createTextureFromCanvas(a.canvas),M.set(C,S),M.destroy(a)}r.$poolArray(C),r.$poolArray(A);let R=0,w=0;const O=this._$filters||this.filters;if(O&&O.length){const s=this._$canApply(O);if(s){const n=[this._$instanceId,"f"];let a=r.$cacheStore().get(n);const o=this._$isFilterUpdated(b,T,e,i,O,s);a&&!o||(a&&(r.$cacheStore().set(n,null),a.layerWidth=0,a.layerHeight=0,a._$offsetX=0,a._$offsetY=0,a.matrix=null,a.colorTransform=null,t.frameBuffer.releaseTexture(a),a=null),S=this._$getFilterTexture(t,O,S,e,i),r.$cacheStore().set(n,S)),a&&(S=a),r.$poolArray(n),R=S._$offsetX,w=S._$offsetY}}r.$resetContext(t),t._$globalAlpha=o,t._$globalCompositeOperation=this._$blendMode||this.blendMode;const I=s.atan2(h[1],h[0]),B=s.atan2(-h[2],h[3]);if(I||B){const e=r.$getBoundsObject($*y*s.cos(I)-u*E*s.sin(B),c*y*s.cos(I)-d*E*s.sin(B),$*y*s.sin(I)+u*E*s.cos(B),c*y*s.sin(I)+d*E*s.cos(B));t.setTransform(s.cos(I),s.sin(I),-s.sin(B),s.cos(B),e.xMin+h[4]-R,e.yMin+h[5]-w),r.$poolBoundsObject(e)}else t.setTransform(1,0,0,1,m-R,x-w);t.drawImage(S,0,0,S.width,S.height,i),h!==e&&r.$poolFloat32Array6(h)}_$doDraw(t,e,i,n,a){const o=this._$getTextData(),h=n?0:this.width,l=n?0:this.height;let _=0,$=0,c=0,u=0;if(this._$verticalAlign!==ot.TOP&&this.height>this.textHeight)switch(this._$verticalAlign){case ot.MIDDLE:u=(this.height-this.textHeight+2)/2;break;case ot.BOTTOM:u=this.height-this.textHeight+2}const d=o.length;for(let g=0;g<d;++g){let d=o[g];if(0===d.width)continue;const f=_+d.x;if(!n&&this._$autoSize===st.NONE&&($>l||f>h))continue;let m=d.textFormat;if(!n){const e=r.$intToRGBA(d.textFormat._$color),n=s.max(0,s.min(255*e.A*i[3]+i[7],255))/255;if(t.fillStyle=`rgba(${e.R},${e.G},${e.B},${n})`,this._$thickness){const e=r.$intToRGBA(this._$thicknessColor),n=s.max(0,s.min(255*e.A*i[3]+i[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${n})`}}const p=0|d.yIndex;switch(d.mode){case rt.BREAK:case rt.WRAP:if(c++,this.scrollV>c)continue;if($+=this._$textHeightTable[p],_=this._$getAlignOffset(this._$objectTable[p],a),m._$underline){const n=d.textFormat._$size/12,a=r.$intToRGBA(m._$color),o=s.max(0,s.min(255*a.A*i[3]+i[7],255))/255;t.lineWidth=s.max(1,1/s.min(e[0],e[3])),t.strokeStyle=`rgba(${a.R},${a.G},${a.B},${o})`,t.beginPath(),t.moveTo(_,u+$-n),t.lineTo(_+this._$widthTable[p],u+$-n),t.stroke()}break;case rt.TEXT:{if(this.scrollV>c)continue;let e=$-this._$heightTable[0];r.$isSafari||(e+=d.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=m._$generateFontStyle(),this._$thickness&&t.strokeText(d.text,f,u+e),t.fillText(d.text,f,u+e)}break;case rt.IMAGE:if(!d.loaded)continue;t.beginPath(),t.drawImage(d.image,d.hspace,u+d.y,d.width,d.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a));const o=this._$getBounds(null),h=r.$boundsMatrix(o,n),l=+h.xMax,_=+h.xMin,$=+h.yMax,c=+h.yMin;r.$poolBoundsObject(h),r.$poolBoundsObject(o);const u=s.ceil(s.abs(l-_)),d=s.ceil(s.abs($-c));return t.setTransform(1,0,0,1,_,c),t.beginPath(),t.moveTo(0,0),t.lineTo(u,0),t.lineTo(u,d),t.lineTo(0,d),t.lineTo(0,0),n!==e&&r.$poolFloat32Array6(n),t.isPointInPath(i.x,i.y)}_$createTextAreaElement(t){if(!this._$textarea){this._$textarea=r.$document.createElement("textarea"),this._$textarea.value=this.text,this._$textarea.id=`${r.$PREFIX}_TextField_${this._$instanceId}`,this._$wordWrap||(this._$textarea.wrap="off");const t=this.defaultTextFormat;if(this._$textarea.style.position="absolute",this._$textarea.style.outline="0",this._$textarea.style.padding=`2px 2px 2px ${s.max(3,0|t.leftMargin)}px`,this._$textarea.style.margin="0",this._$textarea.style.appearance="none",this._$textarea.style.resize="none",this._$textarea.style.border=this._$border?`solid 1px #${this.borderColor.toString(16)}`:"none",this._$textarea.style.overflow="hidden",this._$textarea.style.zIndex=2147483647,this._$textarea.style.verticalAlign="top",this._$textarea.style.backgroundColor=this._$border||this._$background?`#${this.backgroundColor.toString(16)}`:"transparent",this._$textarea.addEventListener(`${r.$PREFIX}_blur`,function(t){let e=t.target.value?t.target.value:"";if(e&&this._$restrict){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new r.$RegExp(t,"gm"));e=i?i.join(""):""}this.text=e;if(r.$document.getElementById(r.$currentPlayer().contentElementId)){const t=r.$document.getElementById(`${r.$PREFIX}_TextField_${this._$instanceId}`);t&&(t.remove(),this._$focus=!1,this._$textAreaActive=!1,r.$isUpdated=!0,this._$doChanged())}}.bind(this)),this._$textarea.addEventListener("input",function(t){let e=t.target.value?t.target.value:"";if(this._$restrict&&!this._$isComposing&&e){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new r.$RegExp(t,"gm"));e=i?i.join(""):""}if(!this._$isComposing&&this.text!==e){this.text=e,t.target.value=e,this.willTrigger(o.CHANGE)&&this.dispatchEvent(new o(o.CHANGE,!0));const i=r.$currentPlayer(),n=this._$textarea,a=this._$transform.concatenatedMatrix,h=this._$getBounds(null);n.style.left=`${s.floor((a.tx+h.xMin+i._$tx/i._$scale/r.$devicePixelRatio)*i._$scale)}px`,n.style.top=`${s.floor((a.ty+h.yMin+i._$ty/i._$scale/r.$devicePixelRatio)*i._$scale)}px`,n.style.width=`${s.ceil((this.width-1)*i._$scale)}px`,n.style.height=`${s.ceil((this.height-1)*i._$scale)}px`}}.bind(this)),this._$textarea.addEventListener("compositionstart",function(){this._$isComposing=!0}.bind(this)),this._$textarea.addEventListener("compositionend",function(t){this._$isComposing=!1;let e=t.target.value?t.target.value:"";if(!this._$restrict||!e)return;let i=this._$restrict;"["!==i[0]&&(i="["+i),"]"!==i[i.length-1]&&(i+="]");const s=e.match(new r.$RegExp(i,"gm"));e=s?s.join(""):"",this.text=e,t.target.value=e}.bind(this)),this._$textarea.addEventListener("click",function(){this.willTrigger(u.CLICK)&&this.dispatchEvent(new u(u.CLICK))}.bind(this)),this._$textarea.addEventListener(r.$MOUSE_WHEEL,function(t){this.scrollV+=t.deltaY}.bind(this)),this._$textarea.addEventListener(r.$SCROLL,function(){if(this._$scrollEventLock)return void(this._$scrollEventLock=!1);const t=parseFloat(this._$textarea.style.height);this.scrollV=this._$textarea.scrollTop/(this._$textarea.scrollHeight-t)*this.maxScrollV+1}.bind(this)),!0===r.$isTouch)this._$textarea.addEventListener(r.$TOUCH_START,(function(){const t=r.$currentPlayer();t&&(t._$state="down")})),this._$textarea.addEventListener(r.$TOUCH_END,(function(){const t=r.$currentPlayer();t&&(t._$state="up")}));else this._$textarea.addEventListener(r.$MOUSE_DOWN,(function(){const t=r.$currentPlayer();t&&(t._$state="down")})),this._$textarea.addEventListener(r.$MOUSE_UP,(function(){const t=r.$currentPlayer();t&&(t._$state="up")}))}const e=this.defaultTextFormat,i=s.ceil(e.size*t*this._$transform.concatenatedMatrix.d);this._$textarea.style.fontSize=`${i}px`,this._$textarea.style.fontFamily=e.font,this._$textarea.style.lineHeight=(i+s.max(0,0|e.leading))/i+"em",this._$autoSize!==st.NONE?this._$textarea.style.textAlign=st.CENTER:this._$textarea.style.textAlign=e.align,this._$textarea.onkeydown||(this._$textarea.onkeydown=function(t){let e=t.target.value?t.target.value:"";if(this._$restrict&&!this._$isComposing&&e){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new r.$RegExp(t,"gm"));e=i?i.join(""):""}if(this._$isComposing||(this.text=e,t.target.value=e),13===t.keyCode&&!this._$multiline)return!1}.bind(this)),this._$textarea.maxLength=2147483647,this._$maxChars&&(this._$textarea.maxLength=this._$maxChars)}}class nt{static toString(){return"[class TextFieldType]"}static get namespace(){return"next2d.text.TextFieldType"}toString(){return"[object TextFieldType]"}get namespace(){return"next2d.text.TextFieldType"}static get INPUT(){return"input"}static get STATIC(){return"static"}}class at{constructor(t=null,e=null,i=null,s=null,n=null,a=null,o=null,h=null,l=null,_=null,$=null,c=null){this._$font=t,this._$size=e,this._$color=null===i?null:r.$clamp(r.$toColorInt(i),0,16777215,16777215),this._$bold=s,this._$italic=n,this._$underline=a,this._$align=o,this._$leftMargin=h,this._$rightMargin=l,this._$indent=_,this._$leading=$,this._$blockIndent=c,this._$letterSpacing=0,this._$textField=null}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){switch(t){case it.CENTER:case it.RIGHT:case it.LEFT:this._$align=t;break;default:this._$align=null}this._$textField&&(this._$textField._$renew=!0)}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t,this._$textField&&(this._$textField._$renew=!0)}get bold(){return this._$bold}set bold(t){this._$bold=!!t,this._$textField&&(this._$textField._$renew=!0)}get color(){return this._$color}set color(t){this._$color=r.$clamp(r.$toColorInt(t),0,16777215,0),this._$textField&&(this._$textField._$renew=!0)}get font(){return this._$font}set font(t){this._$font=`${t}`,this._$textField&&(this._$textField._$renew=!0)}get indent(){return this._$indent}set indent(t){this._$indent=t,this._$textField&&(this._$textField._$renew=!0)}get italic(){return this._$italic}set italic(t){this._$italic=!!t,this._$textField&&(this._$textField._$renew=!0)}get leading(){return this._$leading}set leading(t){this._$leading=t,this._$textField&&(this._$textField._$renew=!0)}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t,this._$textField&&(this._$textField._$renew=!0)}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t,this._$textField&&(this._$textField._$renew=!0)}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t,this._$textField&&(this._$textField._$renew=!0)}get size(){return this._$size}set size(t){this._$size=0|t,this._$textField&&(this._$textField._$renew=!0)}get underline(){return this._$underline}set underline(t){this._$underline=!!t,this._$textField&&(this._$textField._$renew=!0)}_$clone(){const t=new at(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t._$textField=this._$textField,t}_$setDefault(t=null){this._$align=it.LEFT,this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="Times New Roman",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1,this._$textField=t}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t.color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){return this._$indent+this._$leftMargin+this._$rightMargin}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','sans-serif'`}}class ot{static toString(){return"[class TextFormatVerticalAlign]"}static get namespace(){return"next2d.text.TextFormatVerticalAlign"}toString(){return"[object TextFormatVerticalAlign]"}get namespace(){return"next2d.text.TextFormatVerticalAlign"}static get TOP(){return"top"}static get MIDDLE(){return"middle"}static get BOTTOM(){return"bottom"}}class ht extends h{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$buffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=r.$getArray(),this._$volume=1,this._$loop=!1,this._$stopFlag=!0}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=s.min(lt.volume,r.$clamp(t,0,1,1));const e=this._$sources.length;if(e&&r.$audioContext)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume}}clone(){const t=new ht;return t.volume=this.volume,t.loop=this.loop,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){r.$ajax({format:ct.ARRAY_BUFFER,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(o.OPEN)&&this.dispatchEvent(new o(o.OPEN)),this.willTrigger(d.PROGRESS)&&this.dispatchEvent(new d(d.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(d.PROGRESS)&&this.dispatchEvent(new d(d.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(d.PROGRESS)&&this.dispatchEvent(new d(d.PROGRESS,!1,!1,t.loaded,t.total)),199<t.target.status&&400>t.target.status?(this._$buffer=new Uint8Array(t.target.response),r.$audioContext?r.$decodeAudioData(this):r.$audios.push(this),r.$currentPlayer()._$loaders.push(this)):this.willTrigger(c.IO_ERROR)&&this.dispatchEvent(new c(c.IO_ERROR,!1,!1,t.target.statusText,t.target.status))}.bind(this)}})}play(t=0){const e=this._$character?this._$character.audioBuffer:this._$audioBuffer;if(r.$audioContext&&e)this._$createBufferSource(t);else{const e=function(t,i=0){if(null!==(this._$character?this._$character.audioBuffer:this._$audioBuffer)&&null!==r.$audioContext){const e=(r.$performance.now()-t)/1e3;return void this._$createBufferSource(i,e)}(0,r.$requestAnimationFrame)(e)}.bind(this,r.$performance.now(),t);(0,r.$requestAnimationFrame)(e)}}stop(){this._$stopFlag=!0;const t=this._$sources.length;if(t){const e=r.$currentPlayer();if(r.$audioContext)for(let e=0;e<t;++e){const t=this._$sources[e];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect()}e._$sources.splice(e._$sources.indexOf(this),1),this._$sources.length=0}}_$build(t,e){this._$character=e._$loaderInfo._$data.characters[t.characterId],this._$character.init||(this._$character.init=!0,this._$character.buffer=new Uint8Array(this._$character.buffer),r.$audioContext?r.$decodeAudioData(this):r.$audios.push(this)),this._$loop=t.loop,this._$volume=s.min(lt.volume,t.volume)}_$createBufferSource(t=0,e=0){const i=r.$audioContext.createBufferSource();i._$startTime=t,i.onended=this._$endEventHandler.bind(this),i.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,i._$gainNode=r.$audioContext.createGain(),i._$gainNode.connect(r.$audioContext.destination);const n=s.min(lt.volume,this._$volume);i._$gainNode.gain.value=n,i._$volume=n,i.connect(i._$gainNode),i.start(0|t,e);const a=r.$currentPlayer();-1===a._$sources.indexOf(this)&&a._$sources.push(this),this._$sources.push(i),this._$stopFlag=!1}_$endEventHandler(t){const e=t.target;if(this._$sources.splice(this._$sources.indexOf(e),1),this._$loop&&!this._$stopFlag)this._$createBufferSource();else{if(r.$audioContext&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),!this._$sources.length){const t=r.$currentPlayer();t._$sources.splice(t._$sources.indexOf(this),1)}this.willTrigger(o.SOUND_COMPLETE)&&this.dispatchEvent(new o(o.SOUND_COMPLETE))}}}class lt{static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static get volume(){return r.$soundMixerVolume}static set volume(t){r.$soundMixerVolume=r.$clamp(t,0,1,1);const e=r.$currentPlayer()._$sources;for(let t=0;t<e.length;++t){const i=e[t];i._$gainNode.gain.value=s.min(r.$soundMixerVolume,i._$volume)}const i=r.$currentPlayer()._$videos;for(let t=0;t<i.length;++t){const e=i[t];e._$video.volume=s.min(e.volume,r.$soundMixerVolume)}}static stopAll(){const t=r.$currentPlayer(),e=t._$sources;for(;e.length;)e[0].stop();const i=t._$videos;for(let t=0;t<i.length;++t)i[t].pause()}}class _t{constructor(t=1,e=!1){this._$volume=1,this._$loop=!1,this.volume=t,this.loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=!!t}get volume(){return this._$volume}set volume(t){this._$volume=r.$clamp(+t,0,1,0)}}class $t extends T{constructor(t=320,e=240){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=r.$getBoundsObject(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$stop=!0,this._$wait=!1,this._$volume=1}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=!!t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video?(this._$video.removeEventListener("canplaythrough",this._$start),this._$video.addEventListener("canplaythrough",this._$start)):this._$initializeVideo(),this._$video.src=t,this._$video.load()}get videoHeight(){return this._$bounds.yMax}get videoWidth(){return this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=s.min(lt.volume,r.$clamp(t,0,1,1)),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$texture&&r.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$video&&this._$video.pause(),this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause();(0,r.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(r.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),this.dispatchEvent(new g(g.PAUSE),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=r.$currentPlayer();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){if(this._$video&&this._$stop){this._$stop=!1,this._$video.volume=s.min(this._$volume,lt.volume),this._$video.play();const t=r.$requestAnimationFrame;this._$timerId=t(this._$update),this.dispatchEvent(new g(g.PLAY),!1,!1,this._$bytesLoaded,this._$bytesTotal);const e=r.$currentPlayer();-1===e._$videos.indexOf(this)&&e._$videos.push(this)}}seek(t){this._$video&&(this._$video.currentTime=t,this.dispatchEvent(new g(g.SEEK),!1,!1,this._$bytesLoaded,this._$bytesTotal))}_$initializeVideo(){this._$video=r.$document.createElement("video"),this._$update=function(){const t=r.$currentPlayer();if(!this._$stage){this._$video.pause();return(0,r.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(t._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),void t._$videos.splice(t._$videos.indexOf(this),1)}t._$draw(0),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this._$texture=t._$context.frameBuffer.createTextureFromVideo(this._$video,this._$smoothing,this._$texture),this.dispatchEvent(new g(g.PROGRESS),!1,!1,this._$bytesLoaded,this._$bytesTotal),this._$doChanged());const e=r.$requestAnimationFrame;this._$timerId=e(this._$update)}.bind(this),this._$sound=function(){const t=r.$isTouch?r.$TOUCH_END:r.$MOUSE_UP;r.$currentPlayer()._$canvas.removeEventListener(t,this._$sound),this._$video.muted=!1}.bind(this),this._$video.muted=!0,this._$video.autoplay=!1,this._$video.crossOrigin="anonymous",this._$video.type="video/mp4",r.$isTouch&&this._$video.setAttribute("playsinline",""),this._$start=function(){if(this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration,r.$audioContext)this._$video.muted=!1;else{const t=r.$isTouch?r.$TOUCH_END:r.$MOUSE_UP;r.$currentPlayer()._$canvas.addEventListener(t,this._$sound)}if(this._$autoPlay){const t=r.$currentPlayer();-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$wait=!0,this._$doChanged()}}.bind(this),this._$video.addEventListener("canplaythrough",this._$start),this._$video.addEventListener("ended",function(){if(this._$loop)return void(this._$video.currentTime=0);this.dispatchEvent(new g(g.PLAY_END),!1,!1,this._$bytesLoaded,this._$bytesTotal);(0,r.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1}.bind(this))}_$buildCharacter(t){this._$loop=t.loop,this._$autoPlay=t.autoPlay,this._$bounds=t.bounds,this._$video||this._$initializeVideo(),this._$video.src=URL.createObjectURL(new Blob([new Uint8Array(t.buffer)],{type:"video/mp4"})),this._$video.volume=s.min(t.volume,lt.volume),this._$video.load()}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$clip(t,e){let i=this._$bounds.xMax,s=this._$bounds.yMax;if(!i||!s)return;let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a)),r.$resetContext(t),t.setTransform(n[0],n[1],n[2],n[3],n[4],n[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(!0),n!==e&&r.$poolFloat32Array6(n)}_$draw(t,e,i){if(!this._$visible)return;if(this._$wait){this._$stop=!1,this._$video.play(),this.dispatchEvent(new g(g.PLAY_START),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=r.$requestAnimationFrame;this._$timerId=t(this._$update),this._$wait=!1}if(!this._$texture)return;let n=i;const a=this._$transform._$rawColorTransform();a!==r.$COLOR_ARRAY_IDENTITY&&(n=r.$multiplicationColor(i,a));const o=r.$clamp(n[3]+n[7]/255,0,1,0);if(!o)return void(n!==i&&r.$poolFloat32Array8(n));let h=e;const l=this._$transform._$rawMatrix();l!==r.$MATRIX_ARRAY_IDENTITY&&(h=r.$multiplicationMatrix(e,l));const _=r.$boundsMatrix(this._$bounds,h),$=+_.xMax,c=+_.xMin,u=+_.yMax,d=+_.yMin;r.$poolBoundsObject(_);let f=s.ceil(s.abs($-c)),m=s.ceil(s.abs(u-d));if(!f||!m)return;let p=this._$texture,x=0,b=0;const T=this._$filters||this.filters;if(T&&T.length){const s=this._$canApply(T);if(s){const n=[this._$instanceId,"f"];let a=r.$cacheStore().get(n);const o=this._$isFilterUpdated(f,m,e,i,T,s);a&&!o||(a&&(r.$cacheStore().set(n,null),a.layerWidth=0,a.layerHeight=0,a._$offsetX=0,a._$offsetY=0,a.matrix=null,a.colorTransform=null,t.frameBuffer.releaseTexture(a),a=null),p=this._$getFilterTexture(t,T,this._$texture,e,i),r.$cacheStore().set(n,p)),a&&(p=a),r.$poolArray(n),x=p._$offsetX,b=p._$offsetY}}r.$resetContext(t),t._$globalAlpha=o,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=this._$blendMode||this.blendMode,t.setTransform(h[0],h[1],h[2],h[3],h[4],h[5]),t.drawImage(p,-x,-b,p.width,p.height,n)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a));const o=this._$getBounds(null),h=r.$boundsMatrix(o,n),l=+h.xMax,_=+h.xMin,$=+h.yMax,c=+h.yMin;r.$poolBoundsObject(h),r.$poolBoundsObject(o);const u=s.ceil(s.abs(l-_)),d=s.ceil(s.abs($-c));return t.setTransform(1,0,0,1,_,c),t.beginPath(),t.moveTo(0,0),t.lineTo(u,0),t.lineTo(u,d),t.lineTo(0,d),t.lineTo(0,0),n!==e&&r.$poolFloat32Array6(n),t.isPointInPath(i.x,i.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();i!==r.$MATRIX_ARRAY_IDENTITY&&(e=r.$multiplicationMatrix(t,i));const s=r.$boundsMatrix(this._$bounds,e);return e!==t&&r.$poolFloat32Array6(e),s}return r.$getBoundsObject(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}}class ct{static toString(){return"[class URLLoaderDataFormat]"}static get namespace(){return"next2d.net.URLLoaderDataFormat"}toString(){return"[object URLLoaderDataFormat]"}get namespace(){return"next2d.net.URLLoaderDataFormat"}static get ARRAY_BUFFER(){return"arraybuffer"}static get JSON(){return"json"}}class ut{constructor(t=""){this._$url=t,this._$contentType="application/json",this._$data=null,this._$method=gt.GET,this._$requestHeaders=r.$getArray(),this._$userAgent=r.$navigator.userAgent,this._$responseDataFormat=ct.JSON,this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){switch((t+="").toUpperCase()){case gt.DELETE:case gt.HEAD:case gt.OPTIONS:case gt.POST:case gt.PUT:this._$method=t;break;default:this._$method=gt.GET}}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){r.$isArray(t)&&(this._$requestHeaders=t)}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=r.$currentPlayer();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get userAgent(){return this._$userAgent}get responseDataFormat(){return this._$responseDataFormat}set responseDataFormat(t){this._$responseDataFormat=`${t}`}get withCredentials(){return this._$withCredentials}get headers(){const t=r.$getMap();t.set("Content-Type",`${this._$contentType}`);const e=this._$requestHeaders.length;for(let i=0;i<e;++i){const e=this._$requestHeaders[i];e instanceof dt&&t.set(e.name,e.value)}return t}}class dt{constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}get value(){return this._$value}}class gt{static toString(){return"[class URLRequestMethod]"}static get namespace(){return"next2d.net.URLRequestMethod"}toString(){return"[object URLRequestMethod]"}get namespace(){return"next2d.net.URLRequestMethod"}static get DELETE(){return"DELETE"}static get GET(){return"GET"}static get HEAD(){return"HEAD"}static get OPTIONS(){return"OPTIONS"}static get POST(){return"POST"}static get PUT(){return"PUT"}}class ft{static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,s){return t/s*i+e}static inQuad(t,e,i,s){return(t/=s)*t*i+e}static outQuad(t,e,i,s){return-(t/=s)*(t-2)*i+e}static inOutQuad(t,e,i,s){return(t/=s/2)<1?t*t*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,s){return(t/=s)*t*t*i+e}static outCubic(t,e,i,s){return t/=s,(--t*t*t+1)*i+e}static inOutCubic(t,e,i,s){return(t/=s/2)<1?t*t*t*i/2+e:((t-=2)*t*t+2)*i/2+e}static inQuart(t,e,i,s){return(t/=s)*t*t*t*i+e}static outQuart(t,e,i,s){return t/=s,(--t*t*t*t-1)*-i+e}static inOutQuart(t,e,i,s){return(t/=s/2)<1?t*t*t*t*i/2+e:((t-=2)*t*t*t-2)*-i/2+e}static inQuint(t,e,i,s){return(t/=s)*t*t*t*t*i+e}static outQuint(t,e,i,s){return t/=s,(--t*t*t*t*t+1)*i+e}static inOutQuint(t,e,i,s){return(t/=s/2)<1?t*t*t*t*t*i/2+e:((t-=2)*t*t*t*t+2)*i/2+e}static inSine(t,e,i,s){return-i*Math.cos(t/s*(Math.PI/2))+i+e}static outSine(t,e,i,s){return i*Math.sin(t/s*(Math.PI/2))+e}static inOutSine(t,e,i,s){return-i/2*(Math.cos(Math.PI*t/s)-1)+e}static inExpo(t,e,i,s){return i*Math.pow(2,10*(t/s-1))+e}static outExpo(t,e,i,s){return i*(1-Math.pow(2,-10*t/s))+e}static inOutExpo(t,e,i,s){return(t/=s/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*(t-1)))+e}static inCirc(t,e,i,s){return(1-Math.sqrt(1-(t/=s)*t))*i+e}static outCirc(t,e,i,s){return t/=s,Math.sqrt(1- --t*t)*i+e}static inOutCirc(t,e,i,s){return(t/=2*s)<1?(Math.sqrt(1-t*t)-1)/-2*i+e:(Math.sqrt(1-(t-=2)*t)+1)/2*i+e}static inBack(t,e,i,s){return(2.70158*(t/=s)*t*t-1.70158*t*t)*i+e}static outBack(t,e,i,s){return(1+2.70158*Math.pow((t/=s)-1,3)+1.70158*Math.pow(t-1,2))*i+e}static inOutBack(t,e,i,s){let r=1.70158;return(t/=s/2)<1?t*t*((1+(r*=1.525))*t-r)*i/2+e:((t-=2)*t*((1+(r*=1.525))*t+r)+2)*i/2+e}static inElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:-Math.pow(2,(t*=10)-10)*Math.sin((t-10.75)*(2*Math.PI/3))*i+e}static outElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:(Math.pow(2,-10*t)*Math.sin((10*t-.75)*(2*Math.PI/3))+1)*i+e}static inOutElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:t<.5?-Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2*i+e:(Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2+1)*i+e}static outBounce(t,e,i,s){return(t/=s)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,s){return i-ft.outBounce(s-t,0,i,s)+e}static inOutBounce(t,e,i,s){return t<s/2?ft.inBounce(2*t,e,i/2,s):ft.outBounce(2*t-s,e+i/2,i/2,s)}}class mt extends h{constructor(t,e=null,i=null,s=0,r=1,n=null){super(),this._$target=t,this._$delay=s,this._$duration=r,this._$ease=n||ft.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$to=i,this._$update=null}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$stopFlag=!1,this._$startTime=r.$performance.now(),this._$update=this.update.bind(this),this._$names=this.entries(this._$from),this.addEventListener(o.ENTER_FRAME,this._$update)}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],s=i[1];s&&"object"==typeof s&&(i[1]=this.entries(s))}return e}start(){if(this._$delay){(0,r.$setTimeout)(function(){this.initialize()}.bind(this),1e3*this._$delay)}else this.initialize()}stop(){this._$stopFlag=!0,this.removeEventListener(o.ENTER_FRAME,this._$update),this.hasEventListener(o.STOP)&&this.dispatchEvent(new o(o.STOP))}update(){this._$stopFlag?this.removeEventListener(o.ENTER_FRAME,this._$update):(this._$currentTime=.001*(r.$performance.now()-this._$startTime),this.updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener(o.UPDATE)&&this.dispatchEvent(new o(o.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener(o.ENTER_FRAME,this._$update),this.hasEventListener(o.COMPLETE)&&this.dispatchEvent(new o(o.COMPLETE))))}updateProperty(t,e,i,s){for(let r=0;r<s.length;++r){const n=s[r],a=n[0],o=n[1];if(o&&"object"==typeof o){this.updateProperty(t[a],e[a],i[a],o);continue}const h=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,h,i[a]-h,this._$duration):t[a]=i[a]}}}class pt{static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,s=0,r=1,n=null){return new mt(t,e,i,s,r,n)}}class xt{constructor(){this._$pool=r.$getArray(),this._$store=r.$getMap(),this._$lifeCount=2,this._$delayLifeCheck=this.lifeCheck.bind(this),this._$delayBitmapLifeCheck=this.bitmapLifeCheck.bind(this)}reset(){const t=this._$store.values();for(const e of t){const t=e.values();for(const e of t)this.destroy(e);r.$poolMap(e)}this._$store.clear()}destroy(t){if(t)switch(t.constructor){case r.$WebGLTexture:return new Promise((()=>{const e=r.$currentPlayer();if(e._$context){const i=e._$context,s=t._$bitmapData;if(s){s._$getPixelsAsync(0,0,s.width,s.height,"RGBA"),t._$bitmapData=!1;(0,r.$setTimeout)(this._$delayBitmapLifeCheck,2e3,s)}i.frameBuffer.releaseTexture(t)}}));case r.$CanvasRenderingContext2D:return new Promise((()=>{const e=t.canvas,i=e.width,s=e.height;t.clearRect(0,0,i+1,s+1),e.width=e.height=1,this._$pool.push(e)}))}}getCanvas(){return this._$pool.pop()||r.$document.createElement("canvas")}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t),i=e.values();for(const t of i)this.destroy(t);r.$poolMap(e),this._$store.delete(t)}}generateLifeKey(t,e){return`${t}:${e}`}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){const t=this._$store.get(e);if(t.has(i)){const e=`life_${i}`;return 1===t.has(e)&&t.set(e,this._$lifeCount),t.get(i)}}return null}set(t,e=null){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,r.$getMap());const n=this._$store.get(i);if(!e)return n.delete(s),n.delete(`life_${s}`),void(n.size||(r.$poolMap(n),this._$store.delete(i)));const a=n.get(s);a&&a!==e&&this.destroy(a),n.set(s,e),n.set(`life_${s}`,this._$lifeCount);(0,r.$setTimeout)(this._$delayLifeCheck,5e3,i,s)}bitmapLifeCheck(t){if(!t._$pixelBuffer)return;const e=r.$currentPlayer()._$context;t._$buffer=e.pbo.getBufferSubDataAsync(t._$pixelBuffer),t._$pixelBuffer=null}lifeCheck(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t),s=`life_${e}`,n=i.get(s)-1;if(!n)return this.destroy(i.get(e)),i.delete(e),i.delete(s),void(i.size||(r.$poolMap(i),this._$store.delete(t)));i.set(s,n);(0,r.$setTimeout)(this._$delayLifeCheck,5e3,t,e)}generateKeys(t,e=null,i=null){let s="";e&&(s+=`${e[0]}_${e[1]}`),i&&(s+=this.colorToString(i));const n=r.$getArray();return n[1]=s?this.generateHash(s):"_0",n[0]=`${t}`,n}colorToString(t=null){return t&&0!==t[7]?`_${t[7]}`:""}generateHash(t){let e=0;const i=t.length;for(let s=0;s<i;s++){e=(e<<5)-e+t.charCodeAt(s),e|=0}return`_${e}`}}class bt{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n`}}class Tt{static SOLID_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n`}static BITMAP_CLIPPED(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${bt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static BITMAP_PATTERN(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${bt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static MASK(t){return`${t.version()}\n${t.extensionDerivatives()}\nprecision mediump float;\n\n${t.varyingIn()} vec2 v_bezier;\n${t.outColor()}\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        ${t.fragColor()} = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n`}}class vt{static FILL_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = u_mediump;\n}\n\n`}static COPY_SRC_TEX(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = ${t.texture2D()}(u_src_tex, v_src_tex_coord);\n}\n\n`}static COPY_CHANNEL(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_ch = u_mediump[0];\n    vec4 dst_ch = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    // src_color \n    float src_value = dot(src_color, src_ch);\n\n    // \n    vec4 mixed = mix(dst_color, vec4(src_value), dst_ch);\n\n#if ${t}\n    ${e.fragColor()} = vec4(mixed.rgb * mixed.a, mixed.a);\n#else\n    ${e.fragColor()} = vec4(mixed.rgb, 1.0);\n#endif\n}\n\n`}static MERGE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    vec4 merged = mix(dst_color, src_color, u_mediump);\n\n#if ${t}\n    ${e.fragColor()} = vec4(merged.rgb * merged.a, merged.a);\n#else\n    ${e.fragColor()} = vec4(merged.rgb, 1.0);\n#endif\n}\n\n`}static COPY_PIXELS_WITH_ALPHA_BITMAP_DATA(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.varyingIn()} vec2 v_alpha_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src_color = ${t.texture2D()}(u_textures[0], v_src_tex_coord);\n    float alpha = ${t.texture2D()}(u_textures[1], v_alpha_tex_coord).a;\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    alpha *= src_color.a;\n\n    ${t.fragColor()} = vec4(src_color.rgb * alpha, alpha);\n}\n\n`}static PALETTE_MAP(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n                                                //  256*4\n    vec4 map_r = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.r*255.0)/256.0, 0.125));\n    vec4 map_g = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.g*255.0)/256.0, 0.375));\n    vec4 map_b = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.b*255.0)/256.0, 0.625));\n    vec4 map_a = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.a*255.0)/256.0, 0.875));\n\n    // u_plt_tex(u_textures[1])  BGRA  .bgra\n    // TODO  ARGB  .gbar\n    vec4 color = (map_r + map_g + map_b + map_a).bgra;\n\n    // fract  1.0, 2.0, ...  0.0  1.0 \n    vec4 color_fract = fract(color);\n    color = color_fract + sign(color) - sign(color_fract);\n\n#if ${t}\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#else\n    ${e.fragColor()} = vec4(color.rgb, 1.0);\n#endif\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t}\n    ${e.fragColor()} = src_color;\n#else\n    ${e.fragColor()} = vec4(src_color.rgb, 1.0);\n#endif\n}\n\n`}static COLOR_TRANSFORM(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 ct_mul = u_mediump[0];\n    vec4 ct_add = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n    vec4 color = clamp(ct_mul * src_color + ct_add, 0.0, 1.0);\n\n    color = vec4(color.rgb * color.a, color.a);\n\n#if !${t}\n    color.a = 1.0;\n#endif\n\n    ${e.fragColor()} = color * sign(src_color.a);  // \n}\n\n`}static bitwiseAnd(){return"\n#if __VERSION__ < 130\n// 8bit\nint bitwiseAnd(int a, int b) {\n    //ivec4 c1 = ivec4(1,2,4,8);\n    //ivec4 c2 = ivec4(16,32,64,128);\n\n    //ivec4 a1 = ivec4(a) / c1;\n    //ivec4 a2 = ivec4(a) / c2;\n    //ivec4 b1 = ivec4(b) / c1;\n    //ivec4 b2 = ivec4(b) / c2;\n\n    //ivec4 r = (a1-a1/2*2) * (b1-b1/2*2) * c1\n    //        + (a2-a2/2*2) * (b2-b2/2*2) * c2;\n\n    //return r.x + r.y + r.z + r.w;\n\n    //  intrakusanint\n    //  float\n\n    vec4 a0 = vec4(float(a));\n    vec4 b0 = vec4(float(b));\n    vec4 a1 = floor(a0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 a2 = floor(a0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n    vec4 b1 = floor(b0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 b2 = floor(b0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n\n    return int(dot((a1-floor(a1*0.5)*2.0)*(b1-floor(b1*0.5)*2.0), vec4(1.0,2.0,4.0,8.0))\n             + dot((a2-floor(a2*0.5)*2.0)*(b2-floor(b2*0.5)*2.0), vec4(16.0,32.0,64.0,128.0)));\n}\n\nivec4 bitwiseAnd(ivec4 a, ivec4 b) {\n    return ivec4(bitwiseAnd(a.r, b.r),\n                 bitwiseAnd(a.g, b.g),\n                 bitwiseAnd(a.b, b.b),\n                 bitwiseAnd(a.a, b.a));\n}\n#else\n#define bitwiseAnd(a, b) ((a)&(b))\n#endif\n"}static THRESHOLD(t,e,i,s){return e|=0,i|=0,`${s.version()}\n#if __VERSION__ < 130\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2]; // u_threshold(u_mediump[0]) JS\nuniform ivec4 u_integer;\n\n${s.varyingIn()} vec2 v_src_tex_coord;\n\n#if __VERSION__ < 130\n#define outColor0 gl_FragData[0]\n#define outColor1 gl_FragData[1]\n#else\nlayout (location = 0) out vec4 outColor0;\nlayout (location = 1) out vec4 outColor1;\n#endif\n\n${vt.bitwiseAnd()}\n\nbool less(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) < 0.0;\n}\n\nbool greater(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) > 0.0;\n}\n\nbool lessEqual(vec4 x) {\n    return !greater(x);\n}\n\nbool greaterEqual(vec4 x) {\n    return !less(x);\n}\n\n//  equal  thresholdEqual \nbool thresholdEqual(vec4 x) {\n    return all(equal(x, u_mediump[0]));\n}\n\n//  notEqual  thresholdNotEqual \nbool thresholdNotEqual(vec4 x) {\n    return any(notEqual(x, u_mediump[0]));\n}\n\nvoid main() {\n    // Flash Player\n\n    vec4 src_color = ${s.texture2D()}(u_src_tex, v_src_tex_coord);\n    ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), u_integer);\n\n    if (${t}(vec4(masked))) {\n        outColor0 = u_mediump[1];\n        outColor1 = vec4(1.0);\n    } else {\n#if ${e}\n    #if ${i}\n        outColor0 = src_color;\n    #else\n        outColor0 = vec4(src_color.rgb, 1.0);\n    #endif\n        outColor1 = vec4(0.0);\n#else\n        discard;\n#endif\n    }\n}\n\n`}static THRESHOLD_SUBTOTAL(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2 src_tex_step   = u_mediump.xy;\n    float subtotal_loop = u_mediump.z;\n\n    float subtotal = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 4095.0; ++i) {      //  4095.0 \n        if (j++ >= subtotal_loop) {           // BitmapData.prototype.threshold \n            break;\n        }\n#else\n    for (float i = 0.0; i < subtotal_loop; ++i) {\n#endif\n        subtotal += ${t.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i).a;\n    }\n\n    vec4 v1 = floor(subtotal * vec4(1.0, 0.00390625, 0.0000152587890625, 5.960464477539063e-8));  // vec4(1.0, 1.0/256.0, 1.0/65536.0, 1.0/16777216.0)\n    vec4 v2 = vec4(v1.yzw, 0.0);\n    ${t.fragColor()} = (v1 - v2*256.0) * 0.00392156862745098;  // 1.0/255.0\n}\n\n`}static GET_COLOR_BOUNDS_RECT(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\nuniform ivec4 u_integer[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\n${vt.bitwiseAnd()}\n\nvoid main() {\n    vec2 src_tex_step = u_mediump.xy;\n    float scan_loop   = u_mediump.z;\n    ivec4 mask  = u_integer[0];\n    ivec4 color = u_integer[1];\n\n    float found = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 8191.0; ++i) {      // BitmapData  8191 \n        if (j++ >= scan_loop) {\n            break;\n        }\n#else\n    for (float i = 0.0; i < scan_loop; ++i) {\n#endif\n        vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i);\n        ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), mask);\n\n#if ${t}\n        if (all(equal(masked, color))) {\n#else\n        if (any(notEqual(masked, color))) {\n#endif\n            found = 1.0;\n            break;\n        }\n    }\n\n    ${e.fragColor()} = vec4(found);\n}\n\n`}static NOISE(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[3];\n\n${t.outColor()}\n\n// https://stackoverflow.com/a/28095165\n//\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio\n\nvec4 gold_noise(vec2 xy, vec4 seed) {\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvoid main() {\n    vec4 seed = u_mediump[0];\n    vec4 amp  = u_mediump[1];\n    vec4 low  = u_mediump[2];\n\n    vec4 noise = gold_noise(gl_FragCoord.xy, seed);\n    vec4 color = noise * amp + low;\n    ${t.fragColor()} = vec4(color.rgb * color.a, color.a);\n}\n\n`}static GET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb / max(0.0001, color.a), color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr / max(0.0001, color.a), color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.a, color.rgb / max(0.0001, color.a));\n#endif\n}\n\n`}static SET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr * color.a, color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.gba * color.r, color.r);\n#endif\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_dst_tex;\n\n${t.varyingIn()} vec2 v_dst_tex_coord;\n${t.varyingIn()} vec4 v_color;\n${t.outColor()}\n\nvoid main() {\n    float da = ${t.texture2D()}(u_dst_tex, v_dst_tex_coord).a;\n    float a = v_color.a;\n\n    ${t.fragColor()} = max( a, 0.0) * v_color\n                     + max(-a, 0.0) * vec4(v_color.rgb * da, da);\n}\n\n`}}class yt{static TEMPLATE(t,e){const i=e?"uniform vec4 u_mediump[2];":"",s=e?bt.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${i}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src = ${t.texture2D()}(u_texture, v_coord);\n    ${s}\n    ${t.fragColor()} = src;\n}\n\n`}}class Et{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBitmapShader(){return this._$collection.has("b")||this._$collection.set("b",new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),yt.TEMPLATE(this._$keyword,0,0,!1))),this._$collection.get("b")}setBitmapUniform(){}setGetPixelsUniform(t,e,i,s,r){const n=t.highp;n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n[12]=e,n[13]=0,n[14]=0,n[16]=0,n[17]=i,n[18]=0,n[3]=s,n[7]=r,n[11]=1}setSetPixelsUniform(t,e,i,s,r,n,a,o,h){const l=t.highp;l[0]=e,l[1]=0,l[2]=0,l[4]=0,l[5]=i,l[6]=0,l[8]=s,l[9]=r,l[10]=1,l[12]=n,l[13]=0,l[14]=0,l[16]=0,l[17]=a,l[18]=0,l[3]=o,l[7]=h,l[11]=1}setColorTransformUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4]/255,i[5]=e[5]/255,i[6]=e[6]/255,i[7]=e[7]/255}setManipulatePixelsUniform(t,e,i,s,r,n){const a=t.highp;a[0]=e[0],a[1]=e[1],a[2]=e[2],a[4]=e[3],a[5]=e[4],a[6]=e[5],a[8]=e[6],a[9]=e[7],a[10]=e[8],r?(a[12]=s[0],a[13]=s[1],a[14]=s[2],a[16]=s[3],a[17]=s[4],a[18]=s[5],a[20]=s[6],a[21]=s[7],a[22]=s[8],a[24]=n[0],a[25]=n[1],a[26]=n[2],a[3]=n[3],a[7]=n[4],a[11]=n[5],a[15]=n[6],a[19]=n[7],a[23]=n[8]):i&&(a[12]=s[0],a[13]=s[1],a[14]=s[2],a[16]=s[3],a[17]=s[4],a[18]=s[5],a[3]=s[6],a[7]=s[7],a[11]=s[8])}setCopyChannelUniform(t,e,i){const s=t.textures;s[0]=0,s[1]=1;const r=t.mediump;r[0]=1&e,r[1]=e>>1&1,r[2]=e>>2&1,r[3]=e>>3&1,r[4]=1&i,r[5]=i>>1&1,r[6]=i>>2&1,r[7]=i>>3&1}setCopyPixelsUniform(t,e){if(e){const e=t.textures;e[0]=0,e[1]=1}}setFillRectUniform(t,e,i,s,r){const n=t.mediump;n[0]=e,n[1]=i,n[2]=s,n[3]=r}setGetColorBoundsRectUniform(t,e,i,s,r,n){const a=t.highp;a[0]=1,a[1]=0,a[2]=0,a[4]=0,a[5]=1,a[6]=0,a[8]=0,a[9]=0,a[10]=1,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[16]=e[3],a[17]=e[4],a[18]=e[5],a[3]=e[6],a[7]=e[7],a[11]=e[8];const o=t.mediump;o[0]=i[0],o[1]=i[1],o[2]=s;const h=t.integer;h[0]=r[0],h[1]=r[1],h[2]=r[2],h[3]=r[3],h[4]=n[0],h[5]=n[1],h[6]=n[2],h[7]=n[3]}setMergeUniform(t,e,i,s,r){const n=t.textures;n[0]=0,n[1]=1;const a=t.mediump;a[0]=e,a[1]=i,a[2]=s,a[3]=r}setNoiseUniform(t,e,i,s,r,n,a,o,h,l,_,$,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=s,u[3]=r,u[4]=n,u[5]=a,u[6]=o,u[7]=h,u[8]=l,u[9]=_,u[10]=$,u[11]=c}setPaletteMapUniform(t){const e=t.textures;e[0]=0,e[1]=2}setPixelDissolveUniform(t,e,i,s,r){const n=t.mediump;n[0]=e,n[1]=i,n[2]=s,n[3]=r}setFlushSetPixelQueueUniform(t){const e=t.highp;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=-1,e[5]=0,e[6]=0,e[7]=1,e[8]=1}setThresholdUniform(t,e,i,s,r,n,a,o,h,l,_,$,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=s,u[3]=r,u[4]=n,u[5]=a,u[6]=o,u[7]=h;const d=t.integer;d[0]=l,d[1]=_,d[2]=$,d[3]=c}}class At{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getNormalBlendShader(t){const e="n"+(t?"y":"n");return this._$collection.has(e)||this._$collection.set(e,new Kt(this._$gl,this._$context,Ot.BLEND(this._$keyword),yt.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getClipShader(){return this._$collection.has("c")||this._$collection.set("c",new Kt(this._$gl,this._$context,Ot.BLEND_CLIP(this._$keyword),yt.TEMPLATE(this._$keyword,!1))),this._$collection.get("c")}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;return this._$collection.has(i)||this._$collection.set(i,new Kt(this._$gl,this._$context,Ot.BLEND(this._$keyword),class{static TEMPLATE(t,e,i){let s;switch(e){case S.SUBTRACT:s=this.FUNCTION_SUBTRACT();break;case S.MULTIPLY:s=this.FUNCTION_MULTIPLY();break;case S.LIGHTEN:s=this.FUNCTION_LIGHTEN();break;case S.DARKEN:s=this.FUNCTION_DARKEN();break;case S.OVERLAY:s=this.FUNCTION_OVERLAY();break;case S.HARDLIGHT:s=this.FUNCTION_HARDLIGHT();break;case S.DIFFERENCE:s=this.FUNCTION_DIFFERENCE();break;case S.INVERT:s=this.FUNCTION_INVERT();break;default:s=this.FUNCTION_NORMAL()}const r=i?"uniform vec4 u_mediump[2];":"",n=i?bt.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${r}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${s}\n\nvoid main() {\n    vec4 dst = ${t.texture2D()}(u_textures[0], v_coord);\n    vec4 src = ${t.texture2D()}(u_textures[1], v_coord);\n    ${n}\n    ${t.fragColor()} = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}.TEMPLATE(this._$keyword,t,e))),this._$collection.get(i)}setNormalBlendUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u,d,g,f){const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=o,h){const e=t.mediump;e[0]=l,e[1]=_,e[2]=$,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}setClipUniform(t,e,i,s,r,n,a,o){const h=t.highp;h[0]=e,h[1]=i,h[2]=s,h[3]=r,h[4]=n[0],h[5]=n[1],h[6]=n[2],h[8]=n[3],h[9]=n[4],h[10]=n[5],h[12]=n[6],h[13]=n[7],h[14]=n[8],h[7]=a,h[11]=o}setBlendUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u,d,g,f){const m=t.textures;m[0]=0,m[1]=1;const p=t.highp;if(p[0]=e,p[1]=i,p[2]=s,p[3]=r,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=o,h){const e=t.mediump;e[0]=l,e[1]=_,e[2]=$,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class Mt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBlurFilterShader(t){const e=`b${t}`;return this._$collection.has(e)||this._$collection.set(e,new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),class{static TEMPLATE(t,e){const i=e.toFixed(1);return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${i}; i += 1.0) {\n        color += ${t.texture2D()}(u_texture, v_coord + offset * i);\n        color += ${t.texture2D()}(u_texture, v_coord - offset * i);\n    }\n    color += ${t.texture2D()}(u_texture, v_coord + offset * ${i}) * fraction;\n    color += ${t.texture2D()}(u_texture, v_coord - offset * ${i}) * fraction;\n    color /= samples;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getBitmapFilterShader(t,e,i,r,n,a,o){const h=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${r}${n?"y":"n"}${a?"y":"n"}`;if(!this._$collection.has(h)){let l=1;t&&l++,o&&l++;let _=(t?4:0)+(e?4:0)+(a?1:0);o||(_+=i?4:8),_=s.ceil(_/4),this._$collection.set(h,new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,r,n,a,o,h,l){let _=0;const $=s?this.STATEMENT_BASE_TEXTURE_TRANSFORM(t,_++):"",c=r?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(t,_++):this.STATEMENT_BLUR_TEXTURE(t),u=a===Y.INNER,d=_;let g,f,m=4*_;switch(l?g=n?this.STATEMENT_GLOW(t,!1,s,h,l,d,m):this.STATEMENT_BEVEL(t,s,r,h,l,d,m):n?(m+=4,g=this.STATEMENT_GLOW(t,u,s,h,l,d,m)):(m+=8,g=this.STATEMENT_BEVEL(t,s,r,h,l,d,m)),a){case Y.OUTER:f=o?"blur - blur * base.a":"base + blur - blur * base.a";break;case Y.FULL:f=o?"blur":"base - base * blur.a + blur";break;default:f="blur"}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[${e}];\nuniform vec4 u_mediump[${i}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${bt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${$}\n    ${c}\n    ${g}\n    ${t.fragColor()} = ${f};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t,e){return`\n    vec2 base_scale  = u_mediump[${e}].xy;\n    vec2 base_offset = u_mediump[${e}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), ${t.texture2D()}(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(t){return`\n    vec4 blur = ${t.texture2D()}(u_textures[0], v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t,e){return`\n    vec2 blur_scale  = u_mediump[${e}].xy;\n    vec2 blur_offset = u_mediump[${e}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,s,r,n,a){return`\n    ${e?"blur.a = 1.0 - blur.a;":""}\n    ${s?this.STATEMENT_GLOW_STRENGTH(a):""}\n    ${r?this.STATEMENT_GLOW_GRADIENT_COLOR(t,i):this.STATEMENT_GLOW_SOLID_COLOR(n)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${s.floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,s,r,n,a){return`\n    ${i?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t):this.STATEMENT_BLUR_TEXTURE_2(t)}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${s?this.STATEMENT_BEVEL_STRENGTH(a):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${r?this.STATEMENT_BEVEL_GRADIENT_COLOR(t,e):this.STATEMENT_BEVEL_SOLID_COLOR(n)}\n`}static STATEMENT_BLUR_TEXTURE_2(t){return`\n    vec4 blur2 = ${t.texture2D()}(u_textures[0], 1.0 - v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t){return`\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], pq), isInside(pq));\n`}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${s.floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}.TEMPLATE(this._$keyword,l,_,t,e,i,r,n,a,o)))}return this._$collection.get(h)}getColorMatrixFilterShader(){return this._$collection.has("m")||this._$collection.set("m",new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),class{static TEMPLATE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword))),this._$collection.get("m")}getConvolutionFilterShader(t,e,i,r){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${r?"y":"n"}`;if(!this._$collection.has(n)){const a=(r?1:2)+s.ceil(t*e/4);this._$collection.set(n,new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r,n,a){const o=s.floor(.5*i),h=s.floor(.5*r),l=i*r;let _="";const $=a?1:2;for(let t=0;t<l;++t){_+=`\n    result += getWeightedColor(${t}, u_mediump[${$+s.floor(t/4)}][${t%4}]);\n`}const c=n?`result.a = ${t.texture2D()}(u_texture, v_coord).a;`:"",u=a?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${bt.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${i};\n    int i_mod_x = i - ${i} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${o}, ${h} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = ${t.texture2D()}(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${u}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${_}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${c}\n\n    result.rgb *= result.a;\n    ${t.fragColor()} = result;\n}\n\n`}}.TEMPLATE(this._$keyword,a,t,e,i,r)))}return this._$collection.get(n)}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(!this._$collection.has(s)){const r=i===z.COLOR?3:2;this._$collection.set(s,new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,r){let n,a,o;switch(i){case C.RED:n="map_color.r";break;case C.GREEN:n="map_color.g";break;case C.BLUE:n="map_color.b";break;case C.ALPHA:n="map_color.a";break;default:n="0.5"}switch(s){case C.RED:a="map_color.r";break;case C.GREEN:a="map_color.g";break;case C.BLUE:a="map_color.b";break;case C.ALPHA:a="map_color.a";break;default:a="0.5"}switch(r){case z.CLAMP:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], uv);\n`;break;case z.IGNORE:o=`\n    vec4 source_color =${t.texture2D()}(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n`;break;case z.COLOR:o=`\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, ${t.texture2D()}(u_textures[0], uv), isInside(uv));\n`;break;default:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], fract(uv));\n`}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${bt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = ${t.texture2D()}(u_textures[1], st);\n\n    vec2 offset = vec2(${n}, ${a}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${o}\n\n    ${t.fragColor()} = mix(${t.texture2D()}(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}.TEMPLATE(this._$keyword,r,t,e,i)))}return this._$collection.get(s)}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u,d,g,f,m,p,x,b,T,v,y,E){let A;T?(A=t.textures,A[0]=0,A[1]=1,E&&(A[2]=2)):E&&(A=t.textures,A[0]=0,A[1]=2);const M=t.mediump;let C=0;T&&(M[C]=e/s,M[C+1]=i/r,M[C+2]=n/s,M[C+3]=(i-r-a)/r,C+=4),v&&(M[C]=e/o,M[C+1]=i/h,M[C+2]=l/o,M[C+3]=(i-h-_)/h,C+=4),E||($?(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,C+=4):(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,M[C+4]=m,M[C+5]=p,M[C+6]=x,M[C+7]=b,C+=8)),y&&(M[C++]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,o,h,l,_){const $=t.mediump;$[0]=1/e,$[1]=1/i,$[2]=1/r,$[3]=n/255;let c=4;a||($[c]=o,$[c+1]=h,$[c+2]=l,$[c+3]=_,c+=4);const u=s.length;for(let t=0;t<u;t++)$[c++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=o/s,g[5]=-h/r,l===z.COLOR&&(g[8]=_,g[9]=$,g[10]=c,g[11]=u)}}class Ct{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=s.ceil(5*t/4);this._$collection.set(i,new Kt(this._$gl,this._$context,Ot.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r){let n="";for(let t=1;t<i;t++){const e=t-1,r=t,a=`u_mediump[${i+s.floor(e/4)}][${e%4}]`,o=`u_mediump[${i+s.floor(r/4)}][${r%4}]`;n+=`\n    if (t <= ${o}) {\n        return mix(u_mediump[${e}], u_mediump[${r}], (t - ${a}) / (${o} - ${a}));\n    }\n`}const a=r?"color = pow(color, vec4(0.45454545));":"";return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${i}][0]) {\n        return u_mediump[0];\n    }\n    ${n}\n    return u_mediump[${i-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${a}\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,r,t,e)))}return this._$collection.get(i)}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n++]=r[i[0]],a[n++]=r[i[1]],a[n++]=r[i[2]],a[n++]=r[i[3]]}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const o=t.mediump;for(let t=r;t<n;t++){const e=i[t];o[a++]=(e>>16)/255,o[a++]=(e>>8&255)/255,o[a++]=(255&e)/255,o[a++]=s[t]}for(let t=r;t<n;t++)o[a++]=e[t]}}class St{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(!this._$collection.has(n)){let a=(e?13:5)+(t?1:0)+1;const o=a-1;let h;h=t?Ft.TEMPLATE(this._$keyword,a,o,!0,e):Bt.TEMPLATE(this._$keyword,a,!0,!1,e),this._$collection.set(n,new Kt(this._$gl,this._$context,h,class{static TEMPLATE(t,e,i,s,r,n){const a=s?this.STATEMENT_GRADIENT_TYPE_RADIAL(i,r):this.STATEMENT_GRADIENT_TYPE_LINEAR(i);let o;switch(n){case"reflect":o="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":o="fract(t)";break;default:o="clamp(t, 0.0, 1.0)"}return`${t.version()}\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${e}];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 p = v_uv;\n    ${a}\n    t = ${o};\n    ${t.fragColor()} = ${t.texture2D()}(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}.TEMPLATE(this._$keyword,a,o,i,s,r)))}return this._$collection.get(n)}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",o=i?"y":"n",h=i&&s?"y":"n";let l=0;switch(r){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${o}${h}${l}`}setGradientShapeUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=o[0],d[13]=o[1],d[14]=o[2],d[16]=o[3],d[17]=o[4],d[18]=o[5],d[11]=o[6],d[15]=o[7],d[19]=o[8],d[3]=h,d[7]=l;let g=20;n&&(d[g]=_.parentMatrixA,d[g+1]=_.parentMatrixB,d[g+2]=_.parentMatrixC,d[g+4]=_.parentMatrixD,d[g+5]=_.parentMatrixE,d[g+6]=_.parentMatrixF,d[g+8]=_.parentMatrixG,d[g+9]=_.parentMatrixH,d[g+10]=_.parentMatrixI,d[g+12]=_.ancestorMatrixA,d[g+13]=_.ancestorMatrixB,d[g+14]=_.ancestorMatrixC,d[g+16]=_.ancestorMatrixD,d[g+17]=_.ancestorMatrixE,d[g+18]=_.ancestorMatrixF,d[g+20]=_.ancestorMatrixG,d[g+21]=_.ancestorMatrixH,d[g+22]=_.ancestorMatrixI,d[g+11]=_.parentViewportX,d[g+15]=_.parentViewportY,d[g+19]=_.parentViewportW,d[g+23]=_.parentViewportH,d[g+24]=_.minXST,d[g+25]=_.minYST,d[g+26]=_.minXPQ,d[g+27]=_.minYPQ,d[g+28]=_.maxXST,d[g+29]=_.maxYST,d[g+30]=_.maxXPQ,d[g+31]=_.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=s,d[g+2]=r,g+=4),$?(d[g]=c[5],d[g+1]=u):(d[g]=c[0],d[g+1]=c[1],d[g+2]=c[2],d[g+3]=c[3])}}class Rt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Ft.TEMPLATE(this._$keyword,s,r,!1,e):Bt.TEMPLATE(this._$keyword,s,!1,!1,e),this._$collection.set(i,new Kt(this._$gl,this._$context,n,Tt.SOLID_COLOR(this._$keyword)))}return this._$collection.get(i)}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(!this._$collection.has(s)){const r=(i?13:5)+(t?1:0),n=r;let a;a=t?Ft.TEMPLATE(this._$keyword,r,n,!0,i):Bt.TEMPLATE(this._$keyword,r,!0,!1,i);const o=e?Tt.BITMAP_PATTERN(this._$keyword):Tt.BITMAP_CLIPPED(this._$keyword);this._$collection.set(s,new Kt(this._$gl,this._$context,a,o))}return this._$collection.get(s)}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Ft.TEMPLATE(this._$keyword,s,r,!1,e):Bt.TEMPLATE(this._$keyword,s,!1,!0,e),this._$collection.set(i,new Kt(this._$gl,this._$context,n,Tt.MASK(this._$keyword)))}return this._$collection.get(i)}setSolidColorShapeUniform(t,e,i,s,r,n,a,o,h,l,_,$){const c=t.highp;let u;n?(c[0]=l.parentmatrix_a,c[1]=l.parentmatrix_b,c[2]=l.parentmatrix_c,c[4]=l.parentmatrix_d,c[5]=l.parentmatrix_e,c[6]=l.parentmatrix_f,c[8]=l.parentmatrix_g,c[9]=l.parentmatrix_h,c[10]=l.parentmatrix_i,c[12]=l.ancestormatrix_a,c[13]=l.ancestormatrix_b,c[14]=l.ancestormatrix_c,c[16]=l.ancestormatrix_d,c[17]=l.ancestormatrix_e,c[18]=l.ancestormatrix_f,c[20]=l.ancestormatrix_g,c[21]=l.ancestormatrix_h,c[22]=l.ancestormatrix_i,c[3]=o,c[7]=h,c[11]=l.parentViewportX,c[15]=l.parentViewportY,c[19]=l.parentViewportW,c[23]=l.parentViewportH,c[24]=l.minXST,c[25]=l.minYST,c[26]=l.minXPQ,c[27]=l.minYPQ,c[28]=l.maxXST,c[29]=l.maxYST,c[30]=l.maxXPQ,c[31]=l.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=o,c[7]=h,u=12),e&&(c[u]=i,c[u+1]=s,c[u+2]=r);const d=t.mediump;d[0]=_[0],d[1]=_[1],d[2]=_[2],d[3]=_[3]*$}setBitmapShapeUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u,d,g,f,m,p,x,b){const T=t.highp;let v;T[0]=a[0],T[1]=a[1],T[2]=a[2],T[4]=a[3],T[5]=a[4],T[6]=a[5],T[8]=a[6],T[9]=a[7],T[10]=a[8],T[12]=o[0],T[13]=o[1],T[14]=o[2],T[16]=o[3],T[17]=o[4],T[18]=o[5],T[11]=o[6],T[15]=o[7],T[19]=o[8],T[3]=h,T[7]=l,v=20,n&&(T[v]=_.parentmatrix_a,T[v+1]=_.parentmatrix_b,T[v+2]=_.parentmatrix_c,T[v+4]=_.parentmatrix_d,T[v+5]=_.parentmatrix_e,T[v+6]=_.parentmatrix_f,T[v+8]=_.parentmatrix_g,T[v+9]=_.parentmatrix_h,T[v+10]=_.parentmatrix_i,T[v+12]=_.ancestormatrix_a,T[v+13]=_.ancestormatrix_b,T[v+14]=_.ancestormatrix_c,T[v+16]=_.ancestormatrix_d,T[v+17]=_.ancestormatrix_e,T[v+18]=_.ancestormatrix_f,T[v+20]=_.ancestormatrix_g,T[v+21]=_.ancestormatrix_h,T[v+22]=_.ancestormatrix_i,T[v+11]=_.parentViewportX,T[v+15]=_.parentViewportY,T[v+19]=_.parentViewportW,T[v+23]=_.parentViewportH,T[v+24]=_.minXST,T[v+25]=_.minYST,T[v+26]=_.minXPQ,T[v+27]=_.minYPQ,T[v+28]=_.maxXST,T[v+29]=_.maxYST,T[v+30]=_.maxXPQ,T[v+31]=_.maxYPQ,v=52),e&&(T[v]=i,T[v+1]=s,T[v+2]=r);const y=t.mediump;y[0]=$,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=f,y[8]=m,y[9]=p,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,o,h,l,_,$,c,u){const d=t.highp;e?(d[0]=u.parentmatrix_a,d[1]=u.parentmatrix_b,d[2]=u.parentmatrix_c,d[4]=u.parentmatrix_d,d[5]=u.parentmatrix_e,d[6]=u.parentmatrix_f,d[8]=u.parentmatrix_g,d[9]=u.parentmatrix_h,d[10]=u.parentmatrix_i,d[12]=u.ancestormatrix_a,d[13]=u.ancestormatrix_b,d[14]=u.ancestormatrix_c,d[16]=u.ancestormatrix_d,d[17]=u.ancestormatrix_e,d[18]=u.ancestormatrix_f,d[20]=u.ancestormatrix_g,d[21]=u.ancestormatrix_h,d[22]=u.ancestormatrix_i,d[3]=$,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=o,d[8]=h,d[9]=l,d[10]=_,d[3]=$,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class wt{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class Ot{static TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static BLEND(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static BLEND_CLIP(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}}class It{static POSITION_ONLY(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_DST_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_dst_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_ALPHA_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[7];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_alpha_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(u_highp[3].xyz, u_highp[4].xyz, u_highp[5].xyz);\n    mat3 alpha_tex_matrix = mat3(\n        u_highp[6].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w),\n        vec3(u_highp[3].w, u_highp[4].w, u_highp[5].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_alpha_tex_coord = (alpha_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static PIXEL_DISSOLVE_COLOR(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (u_src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (u_matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec4 a_color;\n\nuniform mat3 u_highp[3];\n\n${t.varyingOut()} vec2 v_dst_tex_coord;\n${t.varyingOut()} vec4 v_color;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    v_color = a_color;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}}class Bt{static TEMPLATE(t,e,i,s,r){const n=s?this.ATTRIBUTE_BEZIER_ON(t):"",a=s?this.VARYING_BEZIER_ON(t):i?this.VARYING_UV_ON(t):"",o=s?this.STATEMENT_BEZIER_ON():i?this.STATEMENT_UV_ON():"",h=r?wt.FUNCTION_GRID_ON(i?5:0):wt.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${n}\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${o}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(t){return`\n${t.attribute(1)} vec2 a_bezier;\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static VARYING_BEZIER_ON(t){return`\n${t.varyingOut()} vec2 v_bezier;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class Ft{static TEMPLATE(t,e,i,s,r){const n=i-1,a=s?this.VARYING_UV_ON(t):"",o=s?this.STATEMENT_UV_ON():"",h=r?wt.FUNCTION_GRID_ON(s?5:0):wt.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec2 a_option1;\n${t.attribute(2)} vec2 a_option2;\n${t.attribute(3)} float a_type;\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${n}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${n}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${n}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // \n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // \n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // B\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // A\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // A\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // B\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // \n        float face = u_highp[${n}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${o}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class Lt{constructor(){this._$rgb=L.RGB,this._$mode=k.PAD,this._$focalPointRatio=0,this._$points=r.$getFloat32Array6(),this._$stops=r.$getArray(),this._$type=null}linear(t,e,i,s,r=L.RGB,n=k.PAD){return this._$type=O.LINEAR,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,n,a,o=L.RGB,h=k.PAD,l=0){return this._$type=O.RADIAL,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=n,this._$points[5]=a,this._$rgb=o,this._$mode=h,this._$focalPointRatio=r.$clamp(l,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push([t,e]),this._$stops.sort((function(t,e){switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}}))}}class Pt{constructor(t=null,e=null,i=null){this._$initialization(t,e,i)}_$initialization(t=null,e=null,i=null){return this._$texture=t,this._$repeat=e,this._$color_transform=i,this}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$color_transform}}class Dt{constructor(t,e){this._$gl=t;const i=e?s.min(r.$currentPlayer().getSamples(),t.getParameter(t.MAX_SAMPLES)):0;this._$isWebGL2Context=e,this._$maxTextureSize=s.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new Xt,this._$style=this._$contextStyle,this._$fillBuffer=null,this._$strokeBuffer=null,this._$cacheCurrentBounds={x:0,y:0,w:0,h:0},this._$cacheCurrentBuffer=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation=S.NORMAL,this._$matrix=r.$getFloat32Array9(1,0,0,0,1,0,0,0,1),this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new jt(t,e,i),this._$path=new Gt,this._$grid=new Ut,this._$offsetX=0,this._$offsetY=0,this._$blends=[],this._$positions=[],this._$isLayer=!1,this._$shaderList=new Qt(this,t),this._$gradientLUT=new Jt(this,t),this._$vao=new qt(t,e),this._$pbo=new zt(t,e),this._$mask=new kt(this,t),this._$blend=new Nt(this,t),this._$canvasPatternToWebGL=new Pt,this._$canvasGradientToWebGL=new Lt}get canvas(){return this._$gl.canvas}get fillStyle(){return this._$style._$fillStyle}set fillStyle(t){this._$style._$fillStyle.constructor===Float32Array&&r.$poolFloat32Array4(this._$style._$fillStyle),this._$style._$fillStyle=t}get strokeStyle(){return this._$style._$strokeStyle}set strokeStyle(t){this._$style._$strokeStyle.constructor===Float32Array&&r.$poolFloat32Array4(this._$style._$strokeStyle),this._$style._$strokeStyle=t}get lineWidth(){return this._$style._$lineWidth}set lineWidth(t){this._$style._$lineWidth=t}get lineCap(){return this._$style._$lineCap}set lineCap(t){switch(t){case R.NONE:case R.SQUARE:this._$style._$lineCap=t;break;default:this._$style._$lineCap=R.ROUND}}get lineJoin(){return this._$style._$lineJoin}set lineJoin(t){switch(t){case P.BEVEL:case P.MITER:this._$style._$lineJoin=t;break;default:this._$style._$lineJoin=P.ROUND}}get miterLimit(){return this._$style._$miterLimit}set miterLimit(t){this._$style._$miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=r.$clamp(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=r.$toBoolean(t)}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get pbo(){return this._$pbo}get blend(){return this._$blend}_$bind(t){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e.dirty||i&&i.dirty)&&(e.dirty=!1,i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}fillRect(t,e,i,s){if(!i||!s)return;this._$viewportWidth=i,this._$viewportHeight=s;let n=!1;if(!this._$fillBuffer){n=!0;const a=this._$path.createRectVertices(t,e,i,s);this._$fillBuffer=this._$vao.createFill(a),r.$poolArray(a.pop()),r.$poolArray(a)}const a=this._$grid.enabled,o=this._$shaderList.shapeShaderVariants,h=o.getSolidColorShapeShader(!1,a),l=h.uniform;o.setSolidColorShapeUniform(l,!1,0,0,0,a,this._$matrix,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha),h._$fill(this._$fillBuffer),n&&(this._$vao.release(this._$fillBuffer),r.$poolArray(this._$fillBuffer.indexRanges)),this.beginPath()}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}transform(t,e,i,s,r,n){const a=this._$matrix[0],o=this._$matrix[1],h=this._$matrix[3],l=this._$matrix[4],_=this._$matrix[6],$=this._$matrix[7];this._$matrix[0]=t*a+e*h,this._$matrix[1]=t*o+e*l,this._$matrix[3]=i*a+s*h,this._$matrix[4]=i*o+s*l,this._$matrix[6]=r*a+n*h+_,this._$matrix[7]=r*o+n*l+$}drawImage(t,e,i,s,r,n=null){let a=1,o=1,h=1,l=this._$globalAlpha,_=0,$=0,c=0;n&&(a=n[0],o=n[1],h=n[2],_=n[4]/255,$=n[5]/255,c=n[6]/255),this._$blend.drawImage(t,e,i,s,r,a,o,h,l,_,$,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$startClip(t,e){return this._$mask._$startClip(t,e)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin(),this._$isGraphics&&(this._$fillBuffer&&(this.vao.release(this._$fillBuffer),this.vao.release(this._$fillBuffer.boundObject),r.$poolArray(this._$fillBuffer.indexRanges),r.$poolArray(this._$fillBuffer.boundObject.indexRanges)),this._$strokeBuffer&&this.vao.release(this._$strokeBuffer)),this._$isGraphics=!1,this._$fillBuffer=null,this._$strokeBuffer=null}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}_$getVertices(){return this._$path.vertices}fill(){let t,e,i,s=this._$matrix;switch(!0){case this.fillStyle.constructor===Lt:if(this.fillStyle._$type===O.LINEAR);else s=this._$stack[this._$stack.length-1];break;case this.fillStyle.constructor===Pt:s=this._$stack[this._$stack.length-1]}const n=this._$grid.enabled;switch(!0){case this.fillStyle.constructor===Lt:{const a=this.fillStyle,o=a._$stops,h="linearRGB"===a._$rgb;if(t=this._$gradientLUT.generateForShape(o,h),this._$frameBufferManager._$textureManager.bind0(t,!0),e=this._$shaderList.gradientShapeShaderVariants,a._$type===O.LINEAR)i=e.getGradientShapeShader(!1,n,!1,!1,a._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,a._$points,0);else{const t=0!==a._$focalPointRatio;i=e.getGradientShapeShader(!1,n,!0,t,a._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,a._$points,a._$focalPointRatio)}}break;case this.fillStyle.constructor===Pt:{const a=this.fillStyle,o=a.colorTransform;t=a.texture,this._$frameBufferManager._$textureManager.bind0(t,this._$imageSmoothingEnabled),e=this._$shaderList.shapeShaderVariants,i=e.getBitmapShapeShader(!1,""!==a.repeat,n),o?e.setBitmapShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,o[0],o[1],o[2],this._$globalAlpha,o[4]/255,o[5]/255,o[6]/255,0):e.setBitmapShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:e=this._$shaderList.shapeShaderVariants,i=e.getSolidColorShapeShader(!1,this._$grid.enabled),e.setSolidColorShapeUniform(i.uniform,!1,0,0,0,n,s,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha)}const a=this._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,n);if(a.setMaskShapeUniform(o.uniform,n,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],this._$viewportWidth,this._$viewportHeight,this._$grid),!this._$fillBuffer){const t=this._$getVertices();if(!t.length)return;const e=r.$getArray();for(let i=0;i<t.length;++i){const s=t[i];9>s.length||e.push(s)}if(!e.length)return;this._$isGraphics=!0,this._$fillBuffer=this._$vao.createFill(e);const i=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(i),r.$poolArray(i.pop()),r.$poolArray(i)}this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),o._$fill(this._$fillBuffer),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),i._$fill(this._$fillBuffer.boundObject),this._$gl.disable(this._$gl.STENCIL_TEST)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}_$unionStencilMask(t,e,i){this._$mask._$unionStencilMask(t,e,i)}closePath(){this._$path.close()}stroke(){if(!this._$strokeBuffer){const t=this._$getVertices();if(!t.length)return;const e=r.$getArray();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return;this._$isGraphics=!0,this._$strokeBuffer=this._$vao.createStroke(t,this.lineCap,this.lineJoin)}let t=this._$matrix;switch(!0){case this.strokeStyle.constructor===Lt:if(this.strokeStyle._$type===O.LINEAR);else t=this._$stack[this._$stack.length-1];break;case this.strokeStyle.constructor===Pt:t=this._$stack[this._$stack.length-1]}let e=s.sign(t[0]*t[4]);e>0&&0!==t[1]&&0!==t[3]&&(e=-s.sign(t[1]*t[3]));let i,n,a=.5*this.lineWidth;this._$grid.enabled?(a*=r.$getSameScaleBase(),i=s.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),n=s.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(i=s.abs(t[0]+t[3]),n=s.abs(t[1]+t[4]));const o=s.min(i,n),h=s.max(i,n);let l,_,$;a*=h*(1-.3*s.cos(.5*s.PI*(o/h))),a=s.max(1,a);const c=this._$grid.enabled;switch(!0){case this.strokeStyle.constructor===Lt:{const i=this.strokeStyle,s=i._$stops,n="linearRGB"===i._$rgb;if(l=this._$gradientLUT.generateForShape(s,n),this._$frameBufferManager._$textureManager.bind0(l,!0),_=this._$shaderList.gradientShapeShaderVariants,i._$type===O.LINEAR)$=_.getGradientShapeShader(!0,c,!1,!1,i._$mode),_.setGradientShapeUniform($.uniform,!0,a,e,this.miterLimit,c,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,i._$points,0);else{const s=0!==i._$focalPointRatio;$=_.getGradientShapeShader(!0,c,!0,s,i._$mode),_.setGradientShapeUniform($.uniform,!0,a,e,this.miterLimit,c,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,i._$points,i._$focalPointRatio)}}break;case this.strokeStyle.constructor===Pt:{const i=this.strokeStyle,s=i.colorTransform;l=i.texture,this._$frameBufferManager._$textureManager.bind0(l),_=this._$shaderList.shapeShaderVariants,$=_.getBitmapShapeShader(!0,""!==i.repeat,this._$grid.enabled),s?_.setBitmapShapeUniform($.uniform,!0,a,e,this.miterLimit,c,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,l.width,l.height,s[0],s[1],s[2],this._$globalAlpha,s[4]/255,s[5]/255,s[6]/255,0):_.setBitmapShapeUniform($.uniform,!0,a,e,this.miterLimit,c,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,l.width,l.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:_=this._$shaderList.shapeShaderVariants,$=_.getSolidColorShapeShader(!0,this._$grid.enabled),_.setSolidColorShapeUniform($.uniform,!0,a,e,this.miterLimit,c,t,this._$viewportWidth,this._$viewportHeight,this._$grid,this.strokeStyle,this._$globalAlpha)}$._$stroke(this._$strokeBuffer)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(t=!1){const e=this._$shaderList.shapeShaderVariants,i=e.getMaskShapeShader(!1,!1),s=i.uniform;if(e.setMaskShapeUniform(s,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),!this._$fillBuffer){this._$fillBuffer=this._$vao.createFill(this._$getVertices());const t=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(t),r.$poolArray(t.pop()),r.$poolArray(t)}this._$mask._$onClip(this._$matrix,this._$viewportWidth,this._$viewportHeight)||(i._$fill(this._$fillBuffer),t&&(this._$vao.release(this._$fillBuffer),this._$vao.release(this._$fillBuffer.boundObject),r.$poolArray(this._$fillBuffer.indexRanges),r.$poolArray(this._$fillBuffer.boundObject.indexRanges),this._$fillBuffer=null),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(r.$getFloat32Array9(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){this._$stack.length&&(r.$poolFloat32Array9(this._$matrix),this._$matrix=this._$stack.pop()),this._$mask._$onRestore()}createPattern(t,e,i){return this._$canvasPatternToWebGL._$initialization(t,e,i)}createLinearGradient(t,e,i,s,r=L.RGB,n=k.PAD){return this._$canvasGradientToWebGL.linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a=L.RGB,o=k.PAD,h=0){return this._$canvasGradientToWebGL.radial(t,e,i,s,r,n,a,o,h)}_$applyBlurFilter(t,e,i){const r=this._$frameBufferManager.currentAttachment,n=r.width,a=r.height;this._$frameBufferManager._$textureManager.bind0(t,!0);const o=s.ceil(.5*i),h=1-(o-.5*i),l=1+i,_=this._$shaderList.filterShaderVariants,$=_.getBlurFilterShader(o);_.setBlurFilterUniform($.uniform,n,a,e,h,l),$._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,o,h,l,_,$,c,u,d,g,f,m,p,x,b,T,v,y,E,A){const M=c===Y.INNER,C=this._$frameBufferManager.currentAttachment,S=this._$frameBufferManager.getTextureFromCurrentAttachment();let R;const w=null!==g;let O;w&&(R=this._$gradientLUT.generateForFilter(g,f,m)),M?w?this._$frameBufferManager._$textureManager.bind02(t,R,!0):this._$frameBufferManager._$textureManager.bind0(t):(O=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(O),w?this._$frameBufferManager._$textureManager.bind012(t,S,R,!0):this._$frameBufferManager._$textureManager.bind01(t,S));const I=!(M||c===Y.FULL&&u),B=!(e===o&&i===h&&0===l&&0===_),F=!(1===d),L=this._$shaderList.filterShaderVariants,P=L.getBitmapFilterShader(I,B,$,c,u,F,w);L.setBitmapFilterUniform(P.uniform,e,i,s,r,n,a,o,h,l,_,$,d,p,x,b,T,v,y,E,A,I,B,F,w),M?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),P._$drawImage(),M||this._$frameBufferManager.releaseAttachment(C,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager._$textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,o,h,l,_,$){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager._$textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,o);g.setConvolutionFilterUniform(f.uniform,c,u,s,r,n,o,h,l,_,$),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,o,h,l,_,$,c,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),r||(r={x:0,y:0}),this._$frameBufferManager._$textureManager.bind01(t,e);const m=this._$shaderList.filterShaderVariants,p=m.getDisplacementMapFilterShader(n,a,l);m.setDisplacementMapFilterUniform(p.uniform,e.width,e.height,i,s,r.x,r.y,o,h,l,_,$,c,u),this.blend.reset(),p._$drawImage()}getImageData(t,e,i,n){const a=i*n*4,o=r.$getUint8Array(a);this._$gl.readPixels(t,n-(n-e),i,n,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,o);for(let t=0;t<a;t+=4){const e=o[t+3];e&&(o[t]=255&s.min(255*o[t]/e,255),o[t+1]=255&s.min(255*o[t+1]/e,255),o[t+2]=255&s.min(255*o[t+2]/e,255))}return o}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){r.$poolBoundsObject(this._$positions.pop()),this._$isLayer=r.$toBoolean(this._$blends.pop())}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$textureScale(t,e){const i=s.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}changeSamples(t=4){if(this._$isWebGL2Context){t=s.min(t,this._$gl.getParameter(this._$gl.MAX_SAMPLES));const e=this._$frameBufferManager;e._$objectPool=[],e._$colorBufferPool._$objectPool=[],e._$stencilBufferPool._$objectPool=[],e._$colorBufferPool._$samples=t}}}class Nt{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case S.ADD:this.toAdd();break;case S.SCREEN:this.toScreen();break;case S.ALPHA:this.toAlpha();break;case S.ERASE:this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,i,n,a,o,h,l,_,$,c,u,d,g,f,m,p,x){const b=this._$context._$frameBufferManager.currentAttachment,T=1!==o||1!==h||1!==l||1!==_||0!==$||0!==c||0!==u||0!==d,v=this._$context._$shaderList.blendShaderVariants;switch(g){case S.NORMAL:case S.LAYER:case S.ADD:case S.SCREEN:case S.ALPHA:case S.ERASE:case"copy":{this._$context._$frameBufferManager._$textureManager.bind0(t,x);const b=v.getNormalBlendShader(T);v.setNormalBlendUniform(b.uniform,e,i,n,a,p,f,m,T,o,h,l,_,$,c,u,d);const y=p[0],E=p[1],A=p[3],M=p[4],C=p[6],S=p[7];if(1!==y||0!==E||0!==A||1!==M){const t=e+n,o=i+a,h=+(t*y+o*A+C),l=+(t*y+i*A+C),_=+(e*y+o*A+C),$=+(e*y+i*A+C),c=+(t*E+o*M+S),u=+(t*E+i*M+S),d=+(e*E+o*M+S),g=+(e*E+i*M+S),p=r.$MAX_VALUE,x=+s.min(s.min(s.min(s.min(p,h),l),_),$),b=+s.max(s.max(s.max(s.max(-p,h),l),_),$),T=+s.min(s.min(s.min(s.min(p,c),u),d),g),v=+s.max(s.max(s.max(s.max(-p,c),u),d),g),R=s.max(0,0|x),w=s.max(0,0|T),O=s.min(s.max(0,f-R),s.ceil(s.abs(b-x))),I=s.min(s.max(0,m-w),s.ceil(s.abs(v-T)));if(!O||!I)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(R,s.max(0,m-(w+I)),O+1,I+1)}else{const t=s.max(0,e+C|0),r=s.max(0,i+S|0),o=s.min(s.max(0,f-t),n),h=s.min(s.max(0,m-r),a);if(!o||!h)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,s.max(0,m-(r+h)),o+1,h+1)}this.toOperation(g),b._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const y=s.max(0,e+p[6]|0),E=s.max(0,i+p[7]|0),A=s.min(s.max(0,f-y),n),M=s.min(s.max(0,m-E),a);if(!A||!M)return;const C=this._$context._$frameBufferManager.getTextureFromCurrentAttachment(),S=this._$context._$frameBufferManager.createTextureAttachment(n,a);this._$context._$bind(S),this._$context._$frameBufferManager._$textureManager.bind0(C);const R=v.getClipShader(),w=R.uniform;v.setClipUniform(w,e,i,n,a,r.$inverseMatrix(p),f,m),this.reset(),R._$drawImage();const O=this._$context._$frameBufferManager.getTextureFromCurrentAttachment();this._$context._$bind(b),this._$context._$frameBufferManager._$textureManager.bind01(O,t,x);const I=v.getBlendShader(g,T);v.setBlendUniform(I.uniform,e,i,n,a,p,f,m,T,o,h,l,_,$,c,u,d),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(y,s.max(0,m-(E+M)),A,M),this.toOneZero(),I._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),this._$context._$frameBufferManager.releaseAttachment(S,!0)}}}}class Ut{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}disable(){this.enabled=!1}}class kt{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$clipStatus=!1,this._$containerClip=!1,this._$poolClip=[],this._$currentClip=!1}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context._$frameBufferManager,e=t.getTextureFromCurrentAttachment(),i=t.currentAttachment;this._$context._$bind(this._$context._$cacheCurrentBuffer),this._$context._$cacheCurrentBuffer=null,this._$context._$blend.disable();const s=this._$context._$cacheCurrentBounds.x,n=this._$context._$cacheCurrentBounds.y,a=this._$context._$cacheCurrentBounds.w,o=this._$context._$cacheCurrentBounds.h;r.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(e,s,n,a,o),this._$context._$blend.enable(),t.releaseAttachment(i,!0)}_$startClip(t,e){const i=r.$multiplicationMatrix(e,t._$transform._$rawMatrix()),n=t._$getBounds(null),a=r.$boundsMatrix(n,i);r.$poolFloat32Array9(i),r.$poolBoundsObject(n);let o=a.xMin,h=a.yMin,l=s.abs(a.xMax-a.xMin),_=s.abs(a.yMax-a.yMin);r.$poolBoundsObject(a);const $=this._$context._$frameBufferManager,c=$.currentAttachment;if(l+o>c.texture.width&&(l-=l-c.texture.width+o),_+h>c.texture.height&&(_-=_-c.texture.height+h),0>o&&(l+=o,o=0),0>h&&(_+=h,h=0),0>=l||0>=_)return null;l=s.ceil(l),_=s.ceil(_),this._$context._$cacheCurrentBounds.x=o,this._$context._$cacheCurrentBounds.y=h,this._$context._$cacheCurrentBounds.w=l,this._$context._$cacheCurrentBounds.h=_;const u=$.getTextureFromCurrentAttachment();this._$context._$cacheCurrentBuffer=c;const d=r.$currentPlayer(),g=!this._$context._$isWebGL2Context||d._$quality!==X.LOW&&d._$quality!==X.MIDDLE?0:s.min(r.$HIGH_SAMPLES,this._$gl.getParameter(this._$gl.MAX_SAMPLES)),f=$.createCacheAttachment(l,_,!0,g);return this._$context._$bind(f),r.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(u,-o,-h,u.width,u.height),r.$getFloat32Array9(e[0],e[1],e[2],e[3],e[4]-o,e[5]-h)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context._$frameBufferManager.currentAttachment;t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context._$frameBufferManager.currentAttachment;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context._$frameBufferManager.currentAttachment.clipLevel;let e=0;for(let i=0;i<t;++i)e|=(1<<t-i)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&e,e),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context._$frameBufferManager.currentAttachment;if(--t.clipLevel,t.mask=r.$toBoolean(t.clipLevel),!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context._$cacheCurrentBuffer&&this._$endClip());const e=t.width,i=t.height,s=this._$context._$path.createRectVertices(0,0,e,i),n=this._$context._$vao.createFill(s);r.$poolArray(s.pop()),r.$poolArray(s);const a=this._$context._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,!1),h=o.uniform;a.setMaskShapeUniformIdentity(h,e,i);const l=n.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),o._$containerClip(n,l.first,l.count),this._$context._$vao.release(n),r.$poolArray(n.indexRanges),this._$context._$endClipDef()}_$drawContainerClip(){const t=this._$context._$frameBufferManager.currentAttachment,e=t.clipLevel,i=this._$poolClip.length,s=this._$context._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;let a=e;const o=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);for(let t=0;t<i;++t){const t=this._$poolClip.shift();s.setMaskShapeUniform(n,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const i=t.fillBuffer.indexRanges.length;for(let e=0;e<i;++e){const i=t.fillBuffer.indexRanges[e];this._$gl.stencilMask(1<<a-1),r._$containerClip(t.fillBuffer,i.first,i.count)}++a,a>7&&(this._$context._$unionStencilMask(e,o,h),a=e)}a>e+1&&this._$context._$unionStencilMask(e,o,h)}_$unionStencilMask(t,e,i){const s=this._$context._$path.createRectVertices(0,0,e,i),n=this._$context._$vao.createFill(s);r.$poolArray(s.pop()),r.$poolArray(s);const a=this._$context._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,!1),h=o.uniform;a.setMaskShapeUniformIdentity(h,e,i);const l=n.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),o._$containerClip(n,l.first,l.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT)),this._$context._$vao.release(n),r.$poolArray(n.indexRanges)}_$onClip(t,e,i){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip[this._$poolClip.length]={fillBuffer:this._$context._$fillBuffer,matrixA:t[0],matrixB:t[1],matrixC:t[2],matrixD:t[3],matrixE:t[4],matrixF:t[5],matrixG:t[6],matrixH:t[7],matrixI:t[8],viewportWidth:e,viewportHeight:i},!0)}_$onSave(){this._$clips[this._$clips.length]=this._$clipStatus}_$onRestore(){this._$clips.length&&(this._$clipStatus=r.$toBoolean(this._$clips.pop()))}}class Gt{constructor(){this._$currentPath=[],this._$vertices=[],this._$bounds={xMin:0,xMax:0,yMin:0,yMax:0},this._$resetBounds()}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)r.$poolArray(this._$vertices.pop());this._$resetBounds()}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,n,a){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(n,a))return;const o=this._$currentPath[this._$currentPath.length-3],h=this._$currentPath[this._$currentPath.length-2];(class{static cubicToQuad(t,e,i,s,n,a,o,h){this._$split2Cubic(t,e,i,s,n,a,o,h,0,16),this._$split2Cubic(r.$bezierConverterBuffer[0],r.$bezierConverterBuffer[1],r.$bezierConverterBuffer[2],r.$bezierConverterBuffer[3],r.$bezierConverterBuffer[4],r.$bezierConverterBuffer[5],r.$bezierConverterBuffer[6],r.$bezierConverterBuffer[7],0,8),this._$split2Cubic(r.$bezierConverterBuffer[16],r.$bezierConverterBuffer[17],r.$bezierConverterBuffer[18],r.$bezierConverterBuffer[19],r.$bezierConverterBuffer[20],r.$bezierConverterBuffer[21],r.$bezierConverterBuffer[22],r.$bezierConverterBuffer[23],16,24),this._$split2Quad(r.$bezierConverterBuffer[0],r.$bezierConverterBuffer[1],r.$bezierConverterBuffer[2],r.$bezierConverterBuffer[3],r.$bezierConverterBuffer[4],r.$bezierConverterBuffer[5],r.$bezierConverterBuffer[6],r.$bezierConverterBuffer[7],0),this._$split2Quad(r.$bezierConverterBuffer[8],r.$bezierConverterBuffer[9],r.$bezierConverterBuffer[10],r.$bezierConverterBuffer[11],r.$bezierConverterBuffer[12],r.$bezierConverterBuffer[13],r.$bezierConverterBuffer[14],r.$bezierConverterBuffer[15],8),this._$split2Quad(r.$bezierConverterBuffer[16],r.$bezierConverterBuffer[17],r.$bezierConverterBuffer[18],r.$bezierConverterBuffer[19],r.$bezierConverterBuffer[20],r.$bezierConverterBuffer[21],r.$bezierConverterBuffer[22],r.$bezierConverterBuffer[23],16),this._$split2Quad(r.$bezierConverterBuffer[24],r.$bezierConverterBuffer[25],r.$bezierConverterBuffer[26],r.$bezierConverterBuffer[27],r.$bezierConverterBuffer[28],r.$bezierConverterBuffer[29],r.$bezierConverterBuffer[30],r.$bezierConverterBuffer[31],24)}static _$split2Cubic(t,e,i,s,n,a,o,h,l,_){const $=.125*(t+3*(i+n)+o),c=.125*(e+3*(s+a)+h),u=.125*(o+n-i-t),d=.125*(h+a-s-e);r.$bezierConverterBuffer[l]=t,r.$bezierConverterBuffer[l+1]=e,r.$bezierConverterBuffer[l+2]=.5*(t+i),r.$bezierConverterBuffer[l+3]=.5*(e+s),r.$bezierConverterBuffer[l+4]=$-u,r.$bezierConverterBuffer[l+5]=c-d,r.$bezierConverterBuffer[l+6]=$,r.$bezierConverterBuffer[l+7]=c,r.$bezierConverterBuffer[_]=$,r.$bezierConverterBuffer[_+1]=c,r.$bezierConverterBuffer[_+2]=$+u,r.$bezierConverterBuffer[_+3]=c+d,r.$bezierConverterBuffer[_+4]=.5*(n+o),r.$bezierConverterBuffer[_+5]=.5*(a+h),r.$bezierConverterBuffer[_+6]=o,r.$bezierConverterBuffer[_+7]=h}static _$split2Quad(t,e,i,s,n,a,o,h,l){const _=.125*(t+3*(i+n)+o),$=.125*(e+3*(s+a)+h);r.$bezierConverterBuffer[l]=.25*t+.75*i,r.$bezierConverterBuffer[l+1]=.25*e+.75*s,r.$bezierConverterBuffer[l+2]=_,r.$bezierConverterBuffer[l+3]=$,r.$bezierConverterBuffer[l+4]=.75*n+.25*o,r.$bezierConverterBuffer[l+5]=.75*a+.25*h,r.$bezierConverterBuffer[l+6]=o,r.$bezierConverterBuffer[l+7]=h}}).cubicToQuad(o,h,t,e,i,s,n,a);const l=r.$bezierConverterBuffer.length;for(let t=0;t<l;)this.quadTo(r.$bezierConverterBuffer[t++],r.$bezierConverterBuffer[t++],r.$bezierConverterBuffer[t++],r.$bezierConverterBuffer[t++])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=this._$currentPath[0],e=this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=this._$currentPath[this._$currentPath.length-3],s=this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t),this._$currentPath.push(e),this._$currentPath.push(i),this._$bounds.xMin=s.min(t,this._$bounds.xMin),this._$bounds.xMax=s.max(t,this._$bounds.xMax),this._$bounds.yMin=s.min(e,this._$bounds.yMin),this._$bounds.yMax=s.max(e,this._$bounds.yMax)}_$pushCurrentPathToVertices(){this._$currentPath.length<=3?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=r.$getArray())}_$resetBounds(){const t=r.$MAX_VALUE;this._$bounds.xMin=t,this._$bounds.xMax=-t,this._$bounds.yMin=t,this._$bounds.yMax=-t}getBoundsVertices(){return r.$getArray(r.$getArray(this._$bounds.xMin,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMax,!1,this._$bounds.xMin,this._$bounds.yMax,!1))}createRectVertices(t,e,i,s){return r.$getArray(r.$getArray(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class Xt{constructor(){this._$fillStyle=new r.$window.Float32Array([1,1,1,1]),this._$strokeStyle=new r.$window.Float32Array([1,1,1,1]),this._$lineWidth=1,this._$lineCap=0,this._$lineJoin=0,this._$miterLimit=5}}class Ht{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=[]}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();return t.stencil=this._$gl.createRenderbuffer(),t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}return this._$objectPool.shift()}create(t,e,i=0){t=s.max(256,r.$upperPowerOfTwo(t)),e=s.max(256,r.$upperPowerOfTwo(e));const n=this._$getColorBuffer(t*e);return(n.width<t||n.height<e||i&&n.samples!==i)&&(t=s.max(t,n.width),e=s.max(e,n.height),n.samples=i||this._$samples,n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,n),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,n.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.STENCIL_INDEX8,t,e)),n}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;s.abs(i-e)>1;){const r=s.floor((i+e)/2);t<=this._$objectPool[r].area?i=r:e=r}return i}}const Yt={vertices:null};Yt.subhulls=new Array(512),Yt.subhullsIndex=0,Yt.extremePoints=new Array(32),Yt.extremePointsIndex=0,Yt.t=0,Yt.hulls=[new Array(16),new Array(64),new Array(256)],Yt.hullsIndex=0;class jt{constructor(t,e,i){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),this._$frameBufferTexture=null,this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new Wt(t,e),this._$colorBufferPool=null,this._$stencilBufferPool=new Vt(t),e&&(this._$frameBufferTexture=t.createFramebuffer(),this._$colorBufferPool=new Ht(t,i),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer))}get currentAttachment(){return this._$currentAttachment}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.length?this._$objectPool.pop():{},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,this._$isWebGL2Context&&i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(n.width,n.height)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}createTextureAttachment(t,e){const i=this._$objectPool.length?this._$objectPool.pop():{},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.length?this._$objectPool.pop():{};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t,e=!1){t.isActive&&(t.msaa?this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):(this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment.msaa)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t){return this._$textureManager.createFromImage(t)}createAlphaTextureFromPixels(t,e,i){return this._$textureManager.createAlpha(t,e,i)}createTextureFromVideo(t,e=!1,i=null){return this._$textureManager.createFromVideo(t,e,i)}createTextureFromCurrentAttachment(){const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class zt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$maxWidth=0,this._$maxHeight=0,this._$cacheSize=0}_$getPixelBufferObject(t){if(!this._$objectPool.length){const t=this._$gl.createBuffer();return t.size=0,t}for(let e=0;e<this._$objectPool.length;e++){const i=this._$objectPool[e];if(i.size===t)return this._$objectPool.splice(e,1),this._$cacheSize-=i.size/4,i}const e=this._$objectPool.shift();return this._$cacheSize-=e.size/4,e}readPixelsAsync(t,e,i,s){if(!this._$isWebGL2Context)return null;const r=i*s*4,n=this._$getPixelBufferObject(r);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,n),n.size!==r&&(n.size=r,this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER,r,this._$gl.DYNAMIC_COPY)),this._$gl.readPixels(t,e,i,s,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,0),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),n}getBufferSubDataAsync(t){const e=new Uint8Array(t.size);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,t),this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER,0,e),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),this.release(t),e}release(t){if(t.size>this._$maxWidth*this._$maxHeight*4)this._$gl.deleteBuffer(t);else if(this._$objectPool.push(t),this._$cacheSize+=t.size/4,this._$cacheSize>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$cacheSize-=t.size/4,this._$gl.deleteBuffer(t)}}}class Vt{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;s++){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t)}}}class Wt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(e,i){const s=this._$gl.createTexture();return s.width=0,s.height=0,s.area=0,s.dirty=!0,s.smoothing=!0,s._$offsetX=0,s._$offsetY=0,this.bind0(s,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$isWebGL2Context&&(s.width=e,s.height=i,s.area=e*i,s.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,e,i),t.glstats&&glstats.ontex(s.area)),s}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}createAlpha(t,e,i){return this._$alphaTexture?this.bind0(this._$alphaTexture):(this._$alphaTexture=this._$gl.createTexture(),this.bind0(this._$alphaTexture),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST)),this._$alphaTexture.width=t,this._$alphaTexture.height=e,this._$alphaTexture.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.ALPHA,t,e,0,this._$gl.ALPHA,this._$gl.UNSIGNED_BYTE,i),this._$alphaTexture}create(e,i,s=null,r=!1,n=!0){const a=this._$getTexture(e,i);return r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,a.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,e,i,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),t.glstats&&glstats.ontex(a.area)):s&&(a.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,e,i,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s)),r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),a}createFromImage(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromVideo(t,e=!1,i=null){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e,i)}_$createFromElement(e,i,s,r=!1,n=null){const a=n||this._$getTexture(e,i);return a.dirty=!1,this.bind0(a,r),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),t.glstats&&glstats.ontex(a.area)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),a}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i,s){const n=i!==this._$boundTextures[t],a=null!==s&&s!==i.smoothing;if((n||a||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),n&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),a){i.smoothing=s;const t=s&&r.$currentPlayer()._$quality!==X.LOW?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class qt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$extension=e?null:t.getExtension("OES_vertex_array_object"),this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new r.$window.Float32Array([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$createVertexArray(){return this._$isWebGL2Context?this._$gl.createVertexArray():this._$extension.createVertexArrayOES()}_$getVertexArray(t,e){const i=this._$createVertexArray();this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length)return this._$fillVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length)return this._$strokeVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=class{static generate(t){let e=0;for(let i=0;i<t.length;i++)e+=12*(t[i].length/3-2);this._$vertexBufferData=new r.$Float32Array(e),this._$indexRanges=r.$getArray(),this._$currentIndex=0;for(let e=0;e<t.length;e++){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i;this._$indexRanges.push({first:i,count:s})}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=r.$upperPowerOfTwo(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const n=class{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new r.$Float32Array(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new r.$Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new r.$Float32Array(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new r.$Int16Array(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){const a=11;let o=t,h=e;for(let l=1;l<a;l++){const _=l/a,$=1-_,c=(t*$+i*_)*$+(i*$+r*_)*_,u=(e*$+s*_)*$+(s*$+n*_)*_;this._$addLineSegmentMesh(o,h,c,u,2),o=c,h=u}this._$addLineSegmentMesh(o,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,o=n+2,h=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let _=this._$indexBufferPos;l[_++]=n,l[_++]=a,l[_++]=h,l[_++]=h,l[_++]=o,l[_++]=n,this._$indexBufferPos=_,this._$expandVertexBufferIfNeeded(28);const $=this._$vertexBufferData;let c=this._$vertexBufferPos;$[c++]=t,$[c++]=e,$[c++]=i,$[c++]=s,$[c++]=1,$[c++]=1,$[c++]=1,$[c++]=t,$[c++]=e,$[c++]=i,$[c++]=s,$[c++]=-1,$[c++]=-1,$[c++]=1,$[c++]=i,$[c++]=s,$[c++]=t,$[c++]=e,$[c++]=-1,$[c++]=-1,$[c++]=r,$[c++]=i,$[c++]=s,$[c++]=t,$[c++]=e,$[c++]=1,$[c++]=1,$[c++]=r,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,n,a,o,h,l,_,$,c){const u=i-t,d=n-e,g=o-i,f=h-n,m=r.$cross(u,d,g,f);if(!(s.abs(m)<1e-4))if(2!==a)switch(this._$lineJoin){case P.ROUND:this._$addRoundJoinMesh(i,n);break;case P.MITER:this._$addMiterJoinMesh(i,n,t,e,o,h,$,l,_,c);break;default:this._$addBevelJoinMesh(i,n,$,l,_,c)}else this._$addBevelJoinMesh(i,n,$,l,_,c)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,o,h,l){const _=this._$vertexBufferPos/7,$=_+1,c=_+2,u=_+3,d=_+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=_,g[f++]=a,g[f++]=$,g[f++]=_,g[f++]=$,g[f++]=c,g[f++]=_,g[f++]=c,g[f++]=o,g[f++]=_,g[f++]=h,g[f++]=u,g[f++]=_,g[f++]=u,g[f++]=d,g[f++]=_,g[f++]=d,g[f++]=l,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const m=this._$vertexBufferData;let p=this._$vertexBufferPos;m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=0,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=21,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=22,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=23,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=24,this._$vertexBufferPos=p}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let h=this._$indexBufferPos;o[h++]=a,o[h++]=i,o[h++]=s,o[h++]=a,o[h++]=r,o[h++]=n,this._$indexBufferPos=h,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let _=this._$vertexBufferPos;l[_++]=t,l[_++]=e,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,this._$vertexBufferPos=_}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],o=i[e-7],h=i[e-6],l=i[e-5],_=i[e-4],$=t/7,c=e/7;s!==o||r!==h?(this._$addLineCapMesh(s,r,n,a,$,$+1),this._$addLineCapMesh(o,h,l,_,c-1,c-2)):this._$addLineJoinMesh(l,_,s,r,n,a,c-2,c-1,$,$+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case R.ROUND:this._$addRoundJoinMesh(t,e);break;case R.SQUARE:this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,o=a+1;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let l=this._$indexBufferPos;h[l++]=r,h[l++]=a,h[l++]=o,h[l++]=o,h[l++]=n,h[l++]=r,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const _=this._$vertexBufferData;let $=this._$vertexBufferPos;_[$++]=t,_[$++]=e,_[$++]=i,_[$++]=s,_[$++]=-1,_[$++]=-1,_[$++]=10,_[$++]=t,_[$++]=e,_[$++]=i,_[$++]=s,_[$++]=1,_[$++]=1,_[$++]=10,this._$vertexBufferPos=$}}.generate(t,e,i),a=n.vertexBufferData,o=n.indexBufferData,h=this._$getStrokeVertexArray();return h.indexCount=o.length,this.bind(h),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,h.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,h.indexBuffer),h.vertexLength<a.length&&(h.vertexLength=r.$upperPowerOfTwo(a.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*h.vertexLength,this._$gl.DYNAMIC_DRAW)),h.indexLength<o.length&&(h.indexLength=r.$upperPowerOfTwo(o.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*h.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,a),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,o),h}release(t){t.indexBuffer?this._$strokeVertexArrayPool.push(t):this._$fillVertexArrayPool.push(t)}bind(t){if(t){if(t===this._$boundVertexArray)return;this._$boundVertexArray=t}else this._$boundVertexArray=null;this._$isWebGL2Context?this._$gl.bindVertexArray(t):this._$extension.bindVertexArrayOES(t)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class Kt{constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new ee(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(t,e){const s=this._$gl.createProgram();s.id=i++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);if(this._$gl.shaderSource(r,t),this._$gl.compileShader(r),!this._$gl.getShaderParameter(r,this._$gl.COMPILE_STATUS)){const e=this._$gl.getShaderInfoLog(r);throw new Error("vertex shader compilation failed: "+e+"\n"+t)}const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);if(this._$gl.shaderSource(n,e),this._$gl.compileShader(n),!this._$gl.getShaderParameter(n,this._$gl.COMPILE_STATUS)){const t=this._$gl.getShaderInfoLog(n);throw new Error("fragment shader compilation failed: "+t+"\n"+e)}if(this._$context._$isWebGL2Context||(this._$gl.bindAttribLocation(s,0,"a_vertex"),this._$gl.bindAttribLocation(s,1,"a_bezier"),this._$gl.bindAttribLocation(s,1,"a_option1"),this._$gl.bindAttribLocation(s,2,"a_option2"),this._$gl.bindAttribLocation(s,3,"a_type")),this._$gl.attachShader(s,r),this._$gl.attachShader(s,n),this._$gl.linkProgram(s),!this._$gl.getProgramParameter(s,this._$gl.LINK_STATUS)){const i=this._$gl.getProgramInfoLog(s);throw new Error("link program failed: "+i+"\n"+t+"\n========\n"+e)}return this._$gl.detachShader(s,r),this._$gl.detachShader(s,n),this._$gl.deleteShader(r),this._$gl.deleteShader(n),s}_$attachProgram(){this._$context._$shaderList._$currentProgramId!==this._$program.id&&(this._$context._$shaderList._$currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(e,i){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(e,i),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawElements(this._$gl.TRIANGLES,e.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e);const i=e.indexRanges[e.indexRanges.length-1],s=i.first+i.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,s)}_$containerClip(e,i,s){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.TRIANGLES,i,s)}_$drawPoints(e,i,s){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.POINTS,i,s)}}class Qt{constructor(t,e){const i=new Zt(e,t._$isWebGL2Context);this._$currentProgramId=-1,this._$shapeShaderVariants=new Rt(t,e,i),this._$bitmapShaderVariants=new Et(t,e,i),this._$gradientShapeShaderVariants=new St(t,e,i),this._$gradientLUTShaderVariants=new Ct(t,e,i),this._$filterShaderVariants=new Mt(t,e,i),this._$blendShaderVariants=new At(t,e,i);const s={opaque:new te(t,e,i,It.SRC_TEX_COORD,vt.COLOR_TRANSFORM.bind(null,!1)),transparent:new te(t,e,i,It.SRC_TEX_COORD,vt.COLOR_TRANSFORM.bind(null,!0))},r={opaque:new te(t,e,i,It.SRC_AND_DST_TEX_COORD,vt.COPY_CHANNEL.bind(null,!1)),transparent:new te(t,e,i,It.SRC_AND_DST_TEX_COORD,vt.COPY_CHANNEL.bind(null,!0))},n={opaque:new te(t,e,i,It.SRC_AND_DST_TEX_COORD,vt.MERGE.bind(null,!1)),transparent:new te(t,e,i,It.SRC_AND_DST_TEX_COORD,vt.MERGE.bind(null,!0))},a={opaque:new te(t,e,i,It.SRC_TEX_COORD,vt.PALETTE_MAP.bind(null,!1)),transparent:new te(t,e,i,It.SRC_TEX_COORD,vt.PALETTE_MAP.bind(null,!0))},o={color:new te(t,e,i,It.POSITION_ONLY,vt.FILL_COLOR),texture:{opaque:new te(t,e,i,It.PIXEL_DISSOLVE_TEXTURE,vt.PIXEL_DISSOLVE_TEXTURE.bind(null,!1)),transparent:new te(t,e,i,It.PIXEL_DISSOLVE_TEXTURE,vt.PIXEL_DISSOLVE_TEXTURE.bind(null,!0))}},h=new te(t,e,i,It.SRC_TEX_COORD,vt.COPY_SRC_TEX),l={withAlphaBitmapData:new te(t,e,i,It.SRC_AND_ALPHA_TEX_COORD,vt.COPY_PIXELS_WITH_ALPHA_BITMAP_DATA),noAlphaBitmapData:h},_=new te(t,e,i,It.POSITION_ONLY,vt.FILL_COLOR),$=new te(t,e,i,It.POSITION_ONLY,vt.NOISE),c=function(s){return{discardSource:{opaque:new te(t,e,i,It.SRC_TEX_COORD,vt.THRESHOLD.bind(null,s,!1,!1)),transparent:new te(t,e,i,It.SRC_TEX_COORD,vt.THRESHOLD.bind(null,s,!1,!0))},copySource:{opaque:new te(t,e,i,It.SRC_TEX_COORD,vt.THRESHOLD.bind(null,s,!0,!1)),transparent:new te(t,e,i,It.SRC_TEX_COORD,vt.THRESHOLD.bind(null,s,!0,!0))}}},u={less:c("less"),lessEqual:c("lessEqual"),greater:c("greater"),greaterEqual:c("greaterEqual"),equal:c("thresholdEqual"),notEqual:c("thresholdNotEqual"),subtotal:new te(t,e,i,It.SRC_TEX_COORD,vt.THRESHOLD_SUBTOTAL)},d={findColor:new te(t,e,i,It.SRC_TEX_COORD,vt.GET_COLOR_BOUNDS_RECT.bind(null,!0)),findNotColor:new te(t,e,i,It.SRC_TEX_COORD,vt.GET_COLOR_BOUNDS_RECT.bind(null,!1))},g={RGBA:new te(t,e,i,It.SRC_TEX_COORD,vt.GET_PIXELS.bind(null,"RGBA")),BGRA:new te(t,e,i,It.SRC_TEX_COORD,vt.GET_PIXELS.bind(null,"BGRA")),ARGB:new te(t,e,i,It.SRC_TEX_COORD,vt.GET_PIXELS.bind(null,"ARGB"))},f={RGBA:new te(t,e,i,It.SRC_TEX_COORD,vt.SET_PIXELS.bind(null,"RGBA")),BGRA:new te(t,e,i,It.SRC_TEX_COORD,vt.SET_PIXELS.bind(null,"BGRA")),ARGB:new te(t,e,i,It.SRC_TEX_COORD,vt.SET_PIXELS.bind(null,"ARGB"))},m=new te(t,e,i,It.SET_PIXEL_QUEUE,vt.SET_PIXEL_QUEUE);this._$bitmapData={colorTransform:s,copyChannel:r,merge:n,paletteMap:a,pixelDissolve:o,copyPixels:l,scroll:h,fillRect:_,noise:$,threshold:u,getColorBoundsRect:d,getPixels:g,setPixels:f,setPixelQueue:m}}get shapeShaderVariants(){return this._$shapeShaderVariants}get bitmapShaderVariants(){return this._$bitmapShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Jt{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=s.floor(.75*this._$gl.getParameter(this._$gl.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new r.$Float32Array(256),this._$rgbIdentityTable=new r.$Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=s.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,n=this._$context._$shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<r;i+=this._$maxLength-1){const o=s.min(i+this._$maxLength,r),h=n.getGradientLUTShader(o-i,e),l=h.uniform;n.setGradientLUTUniformForShape(l,t,i,o,a),h._$drawGradient(0===i?0:t[i][0],o===r?1:t[o-1][0])}return this._$context._$bind(i),this._$attachment.texture}generateForFilter(t,e,i){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context._$shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<n;r+=this._$maxLength-1){const o=s.min(r+this._$maxLength,n),h=a.getGradientLUTShader(o-r,!1),l=h.uniform;a.setGradientLUTUniformForFilter(l,t,e,i,r,o),h._$drawGradient(0===r?0:t[r],o===n?1:t[o-1])}return this._$context._$bind(r),this._$attachment.texture}}class Zt{constructor(t,e){this._$isWebGL2Context=e,e||t.getExtension("OES_standard_derivatives")}version(){return this._$isWebGL2Context?"#version 300 es":""}attribute(t){return this._$isWebGL2Context?`layout (location = ${t}) in`:"attribute"}varyingOut(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"out":"varying"}varyingIn(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"in":"varying"}outColor(){return this._$isWebGL2Context?"out vec4 o_color;":""}fragColor(){return this._$isWebGL2Context?"o_color":"gl_FragColor"}texture2D(){return this._$isWebGL2Context?"texture":"texture2D"}extensionDerivatives(){return this._$isWebGL2Context?"":"#extension GL_OES_standard_derivatives : enable"}}class te{constructor(t,e,i,s,r){this._$context=t,this._$gl=e,this._$keyword=i,this._$vertexSource=s,this._$fragmentSource=r,this._$instance=null}get instance(){return this._$instance||(this._$instance=new Kt(this._$gl,this._$context,this._$vertexSource(this._$keyword),this._$fragmentSource(this._$keyword))),this._$instance}}class ee{constructor(t,e){this._$gl=t,this._$array=[],this._$map=new Map;const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r={},n=this._$gl.getUniformLocation(e,s);if(i.type!==this._$gl.SAMPLER_2D||1!==i.size){switch(i.type){case this._$gl.FLOAT_VEC4:r.method=this._$gl.uniform4fv.bind(this._$gl,n),r.array=new Float32Array(4*i.size),r.assign=-1;break;case this._$gl.INT_VEC4:r.method=this._$gl.uniform4iv.bind(this._$gl,n),r.array=new Int32Array(4*i.size),r.assign=-1;break;case this._$gl.SAMPLER_2D:r.method=this._$gl.uniform1iv.bind(this._$gl,n),r.array=new Int32Array(i.size),r.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(r),this._$map.set(s,r)}}}getArray(t){return this._$map.get(t).array}get textures(){return this._$map.get("u_textures").array}get highp(){return this._$map.get("u_highp").array}get mediump(){return this._$map.get("u_mediump").array}get integer(){return this._$map.get("u_integer").array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array))}}}class ie{constructor(){this._$stage=new G,this._$stage._$player=this,this._$cacheStore=new xt,this._$mode="loader",this._$actionOffset=0,this._$actions=r.$getArray(),this._$loaders=r.$getArray(),this._$sounds=r.$getMap(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$mouseWheelEvent=null,this._$ratio=r.$devicePixelRatio,this._$stopFlag=!0,this._$startTime=0,this._$fps=60,this._$isLoad=!1,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=new r.$window.Float32Array([1,0,0,1,0,0]),this._$tx=0,this._$ty=0,this._$backgroundColor=null,this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$broadcastEvents=r.$getMap(),this._$context=null,this._$canvas=null,this._$buffer=null,this._$optionWidth=0,this._$optionHeight=0,this._$tagId=null,this._$bgColor=null,this._$base="",this._$fullScreen=!1,this._$quality=X.HIGH,this._$sources=r.$getArray(),this._$videos=r.$getArray(),this._$textField=null,this._$bindRun=this._$run.bind(this),this._$timerId=-1,this._$loadId=-1}static get LOAD_START(){return 1}static get LOAD_END(){return 2}get broadcastEvents(){return this._$broadcastEvents}get base(){return this._$base}set base(t){if("string"==typeof t)if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${r.$location.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else if(-1===t.indexOf("?"))this._$base="/"===t.slice(-1)?t:`${t}/`;else{const e=t.split("?")[0];this._$base="/"===e.slice(-1)?e:`${e}/`}}get stage(){return this._$stage}get x(){return this._$tx}get y(){return this._$ty}get scaleX(){return this._$matrix[0]}get scaleY(){return this._$matrix[3]}get contentElementId(){return`${r.$PREFIX}`}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}play(){if(this._$stopFlag){if(this._$stopFlag=!1,this._$timerId>-1){(0,r.$cancelAnimationFrame)(this._$timerId)}this._$startTime=r.$performance.now(),this._$fps=1e3/this._$stage._$frameRate;const t=r.$requestAnimationFrame;this._$timerId=t(this._$bindRun)}}stop(){(0,r.$cancelAnimationFrame)(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,lt.stopAll(),r.$cacheStore().reset()}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this.base=t.base||this._$base,this._$fullScreen=!!t.fullScreen,"bgColor"in t&&(this._$bgColor=t.bgColor)),this._$initialize()}_$updateLoadStatus(){if(this._$loadStatus===ie.LOAD_END)return void this._$loaded();const t=r.$requestAnimationFrame;this._$loadId=t(this._$updateLoadStatus.bind(this))}_$loaded(){const t=r.$document.getElementById(this.contentElementId);if(t){null!==this._$bgColor&&(this._$backgroundColor=this._$bgColor),this._$context&&(this._$backgroundColor&&"transparent"!==this._$backgroundColor?this._$context._$setColor(this._$backgroundColor[0],this._$backgroundColor[1],this._$backgroundColor[2],this._$backgroundColor[3]):this._$context._$setColor(0,0,0,0)),this._$deleteNode(),t.appendChild(this._$canvas),this.play(),this._$stage._$prepareActions(),this._$broadcastEvents.has(o.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new o(o.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(o.EXIT_FRAME)&&this._$dispatchEvent(new o(o.EXIT_FRAME));const e=0|this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t instanceof N&&(t._$lock=!1),t.hasEventListener(o.INIT)&&t.dispatchEvent(new o(o.INIT)),t.hasEventListener(o.COMPLETE)&&t.dispatchEvent(new o(o.COMPLETE)),t._$player=null}this._$broadcastEvents.has(o.ACTIVATE)&&this._$dispatchEvent(new o(o.ACTIVATE)),this._$doAction(),this._$draw()}}_$initialize(){const t=r.$document;if("loading"===t.readyState){const t=function(e){e.target.removeEventListener("DOMContentLoaded",t),this._$initialize()}.bind(this);return void r.$window.addEventListener("DOMContentLoaded",t)}const e=this.contentElementId;if(null===this._$tagId)t.body.insertAdjacentHTML("beforeend",`<div id="${e}"></div>`);else{const i=t.getElementById(this._$tagId);if(!i)return void alert("Not Found Tag ID:"+this._$tagId);if(t.getElementById(e))this._$deleteNode();else{const s=t.createElement("div");s.id=e,s.tabIndex=-1,i.appendChild(s)}}this._$canvas||this._$initializeCanvas();const i=t.getElementById(e),s=i.parentNode;if(s){this._$initStyle(i),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===s.tagName?r.$window.innerWidth:s.offsetWidth,e=this._$optionHeight?this._$optionHeight:"BODY"===s.tagName?r.$window.innerHeight:s.offsetHeight;"loader"===this._$mode&&t&&e&&(this._$baseWidth=t,this._$baseHeight=e,this._$resize())}"loader"===this._$mode?(this._$loadStatus=ie.LOAD_START,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(e){const i=e.style;i.position="relative",i.top="0",i.left="0",i.backgroundColor="transparent",i.overflow="hidden",i.padding="0",i.margin="0",i.userSelect="none",i.outline="none";const s=this._$optionWidth,r=this._$optionHeight,n=e.parentNode;if("BODY"===n.tagName)return i.width=s?`${s}px`:`${t.innerWidth}px`,void(i.height=r?`${r}px`:`${t.innerHeight}px`);i.width=s?`${s}px`:`${n.offsetWidth}px`,i.height=r?`${r}px`:`${n.offsetHeight}px`}_$buildWait(){const t=r.$document.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=r.$document.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=r.$document.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){const e=r.$document.createElement("canvas");e.width=1,e.height=1,this._$canvas=e;const i={stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0};let s=!0,n=e.getContext("webgl2",i);if(n||(n=e.getContext("webgl",i)||e.getContext("experimental-webgl",i),s=!1),n?this._$context=new Dt(n,s):alert("WebGL setting is off. Please turn the setting on."),t.glstats&&glstats.init(n,s,r.$isChrome,r.$isFireFox),r.$isTouch){const t=function(e){e.target.removeEventListener(r.$TOUCH_END,t),r.$loadAudioData()};e.addEventListener(r.$TOUCH_END,t),e.addEventListener(r.$TOUCH_START,function(t){r.$event=t,r.$eventType=r.$TOUCH_START,this._$hitTest()}.bind(this)),e.addEventListener(r.$TOUCH_MOVE,function(t){r.$event=t,r.$eventType=r.$TOUCH_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(r.$TOUCH_END,function(t){r.$event=t,r.$eventType=r.$TOUCH_END,this._$hitTest()}.bind(this))}else{const t=function(e){e.target.removeEventListener(r.$MOUSE_DOWN,t),r.$loadAudioData()};e.addEventListener(r.$MOUSE_DOWN,t),e.addEventListener(r.$MOUSE_DOWN,function(t){r.$event=t,r.$eventType=r.$MOUSE_DOWN,t.button||this._$hitTest()}.bind(this)),e.addEventListener(r.$DOUBLE_CLICK,function(t){r.$event=t,r.$eventType=r.$DOUBLE_CLICK,t.button||this._$hitTest()}.bind(this)),e.addEventListener(r.$MOUSE_LEAVE,function(t){r.$event=t,r.$eventType=r.$MOUSE_LEAVE,this._$hitTest(),r.$event=null,this._$stageX=-1,this._$stageY=-1}.bind(this)),e.addEventListener(r.$MOUSE_UP,function(t){r.$event=t,r.$eventType=r.$MOUSE_UP,t.button||this._$hitTest()}.bind(this)),e.addEventListener(r.$MOUSE_MOVE,function(t){r.$event=t,r.$eventType=r.$MOUSE_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(r.$MOUSE_WHEEL,function(t){this._$mouseWheelEvent=t}.bind(this))}const a=e.style;a.position="absolute",a.top="0",a.left="0",a.webkitTapHighlightColor="rgba(0,0,0,0)",a.backfaceVisibility="hidden",a.transformOrigin="0 0",1!==r.$devicePixelRatio&&(a.transform=`scale(${1/r.$devicePixelRatio})`)}_$resize(){const t=r.$document.getElementById(this.contentElementId);if(t){const e=t.parentNode,i=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?r.$window.innerWidth:e.offsetWidth?e.offsetWidth:r.$parseFloat(e.style.width),n=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?r.$window.innerHeight:e.offsetHeight?e.offsetHeight:r.$parseFloat(e.style.height),a="BODY"===e.tagName?r.$window.innerWidth:e.offsetWidth,o=s.min(i/this._$baseWidth,n/this._$baseHeight);let h=this._$fullScreen?i:this._$baseWidth*o|0,l=this._$fullScreen?n:this._$baseHeight*o|0;const _=t.style;if(_.width=`${h}px`,_.height=`${l}px`,_.top="0",_.left=this._$fullScreen?"0":a/2-h/2+"px",h*=r.$devicePixelRatio,l*=r.$devicePixelRatio,this._$scale=o,this._$width=h,this._$height=l,this._$canvas.width=h,this._$canvas.height=l,this._$canvas.style.transform=1===this._$ratio&&1===r.$devicePixelRatio?"":`scale(${1/this._$ratio})`,this._$context){this._$context._$gl.viewport(0,0,h,l);const t=this._$context._$frameBufferManager;this._$buffer&&(t.unbind(),t.releaseAttachment(this._$buffer,!0)),this._$buffer=t.createCacheAttachment(h,l,!1),t._$stencilBufferPool._$maxWidth=h,t._$stencilBufferPool._$maxHeight=l,t._$textureManager._$maxWidth=h,t._$textureManager._$maxHeight=l,this._$context._$pbo._$maxWidth=h,this._$context._$pbo._$maxHeight=l}const $=this._$scale*this._$ratio;this._$matrix[0]=$,this._$matrix[3]=$,this._$fullScreen&&(this._$tx=(h-this._$baseWidth*o*r.$devicePixelRatio)/2,this._$ty=(l-this._$baseHeight*o*r.$devicePixelRatio)/2,this._$matrix[4]=this._$tx,this._$matrix[5]=this._$ty),t.children.length>1&&t.children[1].dispatchEvent(new r.$window.Event(`${r.$PREFIX}_blur`)),this._$stage._$doChanged(),this._$cacheStore.reset()}}getSamples(){switch(this._$quality){case X.HIGH:return r.$HIGH_SAMPLES;case X.MEDIUM:return r.$MEDIUM_SAMPLES;default:return r.$LOW_SAMPLES}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t._$eventPhase=l.AT_TARGET;const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(t._$currentTarget=i.target,t._$listener=i.listener,i.listener.call(r.$window,t),t._$stopImmediatePropagation)break}return r.$poolArray(e),!0}}_$wheelEvent(){const t=this._$mouseWheelEvent;t&&(t.defaultPrevented||(r.$event=t,r.$eventType=r.$MOUSE_WHEEL,this._$hitTest()),this._$mouseWheelEvent=null)}_$run(e=0){if(this._$stopFlag)return;t.stats&&stats.begin(),t.glstats&&glstats.begin(),this._$wheelEvent(),this._$doAction();let i=e-this._$startTime;i>this._$fps&&(this._$startTime=e-i%this._$fps,this._$action(),this._$draw(0),!this._$hitTestStart&&"up"===this._$state&&r.$event&&this._$stageX>-1&&this._$stageY>-1&&this._$pointerCheck()),t.stats&&stats.end(),t.glstats&&glstats.end();const s=r.$requestAnimationFrame;this._$timerId=s(this._$bindRun)}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath(),r.$MATRIX_HIT_ARRAY_IDENTITY[4]=this._$tx/this._$scale/r.$devicePixelRatio,r.$MATRIX_HIT_ARRAY_IDENTITY[5]=this._$ty/this._$scale/r.$devicePixelRatio,this._$stage._$mouseHit(r.$hitContext,r.$MATRIX_HIT_ARRAY_IDENTITY,this._$hitObject,!0);let i=null,s=null,n=!1,a=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(u.MOUSE_OUT)&&t.dispatchEvent(new u(u.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==i){let r=null;if(this._$rollOverObject)for(s=this._$rollOverObject,s.willTrigger(u.ROLL_OUT)&&s.dispatchEvent(new u(u.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),r=s._$parent;r&&r._$root!==r&&r!==i;){if(r._$mouseEnabled&&r._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===r){t=!0;break}e=e._$parent}if(!t&&r._$parent===i._$parent&&r._$index>i._$index&&(t=!0),t)break}r.willTrigger(u.ROLL_OUT)&&r.dispatchEvent(new u(u.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),r=r._$parent}for(s=i;s.willTrigger(u.ROLL_OVER)&&s.dispatchEvent(new u(u.ROLL_OVER,!1,!1,s.mouseX,s.mouseY)),s=s._$parent,s&&s!==r&&s.stage!==s;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i.willTrigger(u.MOUSE_OVER)&&i.dispatchEvent(new u(u.MOUSE_OVER,!0,!1,i.mouseX,i.mouseY)),this._$mouseOverTarget=i}if("up"===this._$state&&(this._$clickTarget=null),!r.$isTouch&&"up"===this._$state)for(s=i;s&&s.root!==s;){switch(!0){case s instanceof rt:s._$type===nt.INPUT&&(n=!0);break;case s.buttonMode:a=!0}if(n||a)break;s=s._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(u.MOUSE_OUT)&&i.dispatchEvent(new u(u.MOUSE_OUT,!0,!1,i.mouseX,i.mouseY))),this._$rollOverObject)for(s=this._$rollOverObject;s&&s.root!==s;)s.willTrigger(u.ROLL_OUT)&&s.dispatchEvent(new u(u.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),s=s._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case n:this._$canvas.style.cursor="text";break;case a:this._$canvas.style.cursor="pointer";break;case!r.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has(o.ENTER_FRAME)&&this._$dispatchEvent(new o(o.ENTER_FRAME)),this._$broadcastEvents.has(o.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new o(o.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(o.EXIT_FRAME)&&this._$dispatchEvent(new o(o.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new o(o.RENDER))),e){for(let i=0;i<e;++i){const e=t[i];e.hasEventListener(o.INIT)&&e.dispatchEvent(new o(o.INIT)),e.hasEventListener(o.COMPLETE)&&e.dispatchEvent(new o(o.COMPLETE))}r.$poolArray(t)}this._$doAction()}_$draw(){const t=this._$canvas,e=t.width,i=t.height,s=this._$context;if(this._$buffer&&this._$stage._$updated&&s&&e>0&&i>0){if(s._$bind(this._$buffer),r.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,e,i),s.beginPath(),this._$stage._$draw(s,this._$matrix,r.$COLOR_ARRAY_IDENTITY),this._$stage._$updated=!1,this._$sounds.size){const t=this._$sounds.values();for(let e of t)e._$soundPlay();this._$sounds.clear()}const t=s.frameBuffer.getTextureFromCurrentAttachment();s.frameBuffer.unbind(),r.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,e,i),s.drawImage(t,0,0,e,i),s._$bind(this._$buffer)}}_$doAction(){for(;this._$actions.length;){r.$actionProcess=!0;const t=this._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;t._$actionProcess=!0;const i=t._$actions.get(e),s=i.length;for(let e=0;e<s;++e)r.$currentLoaderInfo=t._$loaderInfo,i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}r.$currentLoaderInfo=null,r.$actionProcess=!1}_$hitTest(){if(this._$stopFlag)return;this._$hitTestStart=!0,r.$isUpdated=!1;const t=r.$event;let e=null,i=null,s=r.$window.pageXOffset,n=r.$window.pageYOffset;const a=r.$document.getElementById(this.contentElementId);if(a){const t=a.getBoundingClientRect();s+=t.left,n+=t.top}let o=0,h=0;if(r.$isTouch){const e=t.changedTouches[0];o=e.pageX,h=e.pageY}else o=t.pageX,h=t.pageY;o=(o-s)/this._$scale,h=(h-n)/this._$scale,t._$stageX=o,t._$stageY=h,this._$stageX=o,this._$stageY=h,this._$hitObject.x=o,this._$hitObject.y=h,this._$hitObject.pointer="",this._$hitObject.hit=null,r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath(),r.$MATRIX_HIT_ARRAY_IDENTITY[4]=this._$tx/this._$scale/r.$devicePixelRatio,r.$MATRIX_HIT_ARRAY_IDENTITY[5]=this._$ty/this._$scale/r.$devicePixelRatio,this._$stage._$mouseHit(r.$hitContext,r.$MATRIX_HIT_ARRAY_IDENTITY,this._$hitObject,!0),this._$hitObject.hit&&t.preventDefault();let l=!1,_=!1,$=!1;switch(r.$eventType){case r.$TOUCH_MOVE:case r.$MOUSE_MOVE:if(r.$dropTarget){const t=r.$dropTarget._$dragMousePoint();let e=t.x,i=t.y;r.$dragRules.lock||(e+=r.$dragRules.position.x,i+=r.$dragRules.position.y);const s=r.$dragRules.bounds;s&&(e=r.$clamp(e,s.left,s.right),i=r.$clamp(i,s.top,s.bottom)),r.$dropTarget.x=e,r.$dropTarget.y=i}break;case r.$TOUCH_START:case r.$MOUSE_DOWN:this._$state="down",$="pointer"===this._$canvas.style.cursor,_=!0;break;case r.$TOUCH_END:case r.$MOUSE_UP:case r.$DOUBLE_CLICK:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case r.$eventType===r.$MOUSE_LEAVE:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(u.MOUSE_OUT)&&e.dispatchEvent(new u(u.MOUSE_OUT,!0,!1,e.mouseX,e.mouseY))),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(u.ROLL_OUT)&&i.dispatchEvent(new u(u.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,r.$eventType){case r.$MOUSE_WHEEL:this._$stage.hasEventListener(u.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new u(u.MOUSE_WHEEL,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$TOUCH_START:case r.$MOUSE_DOWN:this._$stage.hasEventListener(u.MOUSE_DOWN)&&this._$stage.dispatchEvent(new u(u.MOUSE_DOWN,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$textField&&this._$textField instanceof rt&&(this._$textField.focus=!1,this._$textField=null);break;case r.$TOUCH_END:case r.$MOUSE_UP:this._$textField&&this._$textField instanceof rt&&(this._$textField.focus=!1,this._$textField=null),this._$stage.hasEventListener(u.CLICK)&&this._$stage.dispatchEvent(new u(u.CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$stage.hasEventListener(u.MOUSE_UP)&&this._$stage.dispatchEvent(new u(u.MOUSE_UP,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$TOUCH_MOVE:case r.$MOUSE_MOVE:this._$stage.hasEventListener(u.MOUSE_MOVE)&&this._$stage.dispatchEvent(new u(u.MOUSE_MOVE,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$DOUBLE_CLICK:this._$stage.hasEventListener(u.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new u(u.DOUBLE_CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY))}break;default:switch(e=this._$hitObject.hit,r.$eventType){case r.$TOUCH_MOVE:case r.$MOUSE_MOVE:if(e.willTrigger(u.MOUSE_MOVE)&&e.dispatchEvent(new u(u.MOUSE_MOVE,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(u.MOUSE_OUT)&&t.dispatchEvent(new u(u.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(u.ROLL_OUT)&&i.dispatchEvent(new u(u.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(o,h)){let i=!1,s=e;for(;s&&s._$root!==s;){if(s===t){i=!0;break}s=s._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(u.ROLL_OUT)&&t.dispatchEvent(new u(u.ROLL_OUT,!1,!1,t.mouseX,t.mouseY)),t=t._$parent}for(i=e;i.willTrigger(u.ROLL_OVER)&&i.dispatchEvent(new u(u.ROLL_OVER,!1,!1,i.mouseX,i.mouseY)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(u.MOUSE_OVER)&&e.dispatchEvent(new u(u.MOUSE_OVER,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget=e}"up"===this._$state&&(this._$clickTarget=null);break;case r.$TOUCH_START:case r.$MOUSE_DOWN:e!==this._$textField&&this._$textField instanceof rt&&(this._$textField.focus=!1,this._$textField=null),e instanceof rt&&(e.focus=!0,this._$textField=e),e.willTrigger(u.MOUSE_DOWN)&&e.dispatchEvent(new u(u.MOUSE_DOWN,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=e;break;case r.$TOUCH_END:case r.$MOUSE_UP:e!==this._$textField&&this._$textField instanceof rt&&(this._$textField.focus=!1,this._$textField=null),e.willTrigger(u.MOUSE_UP)&&e.dispatchEvent(new u(u.MOUSE_UP,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget===e&&e.willTrigger(u.CLICK)&&e.dispatchEvent(new u(u.CLICK,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=null;break;case r.$MOUSE_WHEEL:e.willTrigger(u.MOUSE_WHEEL)&&e.dispatchEvent(new u(u.MOUSE_WHEEL)),e instanceof rt&&(e.scrollV+=t.deltaY);break;case r.$DOUBLE_CLICK:e.willTrigger(u.DOUBLE_CLICK)&&e.dispatchEvent(new u(u.DOUBLE_CLICK))}if(!_&&!r.$isTouch&&"up"===this._$state)for(i=e;i&&i.root!==i;){if(i instanceof rt){if(i._$type===nt.INPUT){l=!0;break}}else if(i._$buttonMode){$=!0;break}i=i._$parent}}switch(!0){case l:this._$canvas.style.cursor="text";break;case $:this._$canvas.style.cursor="pointer";break;case!r.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}!r.$actionProcess&&this._$actions.length>1&&this._$doAction(),r.$isUpdated&&(this._$stage._$prepareActions(),r.$actionProcess||this._$doAction()),this._$hitTestStart=!1}}r.$window.next2d=new class{constructor(){this._$player=new ie}load(t,e=null){if("develop"===t){const e=r.$location.search.substr(1).split("&")[0];if(!e)return;t=`${r.$location.origin}/${e}`}if(!t)return;"/"===t.charAt(1)&&(t=t.slice(1)),e&&"base"in e||!(t.indexOf("//")>-1)||(this._$player.base=t),this._$player.setOptions(e);const i=new D,s=i.contentLoaderInfo;s.addEventListener(c.IO_ERROR,(function(t){t.target.removeEventListener(c.IO_ERROR,t.listener),alert("Error: "+t.message)})),s.addEventListener(o.COMPLETE,(function(t){const e=t.target;e.removeEventListener(o.COMPLETE,t.listener);const i=r.$currentPlayer(),s=i.stage,n=e._$data.stage;if(i.width=n.width,i.height=n.height,i.stage.frameRate=n.fps,null===i._$bgColor){const t=r.$intToRGBA(0|`0x${n.bgColor.substr(1)}`);i._$context._$setColor(t.R/255,t.G/255,t.B/255,1),i._$backgroundColor=[t.R/255,t.G/255,t.B/255,1]}s.addChild(e.content),i._$resize()})),i.load(new ut(t))}createRootMovieClip(t=240,e=240,i=24,s=null){const r=this._$player;return r._$loadStatus=ie.LOAD_END,r._$mode="create",r._$stage.frameRate=0|i,r.width=0|t,r.height=0|e,r.setOptions(s),r._$stage.addChild(new E)}},r.$packages(r.$window.next2d),console.log("%c Next2D Player %c 1.5.2 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729","")})(window);