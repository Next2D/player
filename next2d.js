/*!
 * licenses: MIT Licenses.
 * version: 1.7.0
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2013-2022 Toshiyuki Ienaga.
 */
"next2d"in window||(t=>{"use strict";let e=0,i=0;const s=t.Math,r=t.Number,n=t.RegExp,a=t.Float32Array,o=t.Int16Array,h={$PREFIX:"__next2d__",$HIGH_SAMPLES:4,$MEDIUM_SAMPLES:2,$LOW_SAMPLES:0,$LOAD_START:"loadstart",$PROGRESS:"progress",$LOADEND:"loadend",$TOUCH_START:"touchstart",$TOUCH_MOVE:"touchmove",$TOUCH_END:"touchend",$MOUSE_DOWN:"mousedown",$MOUSE_MOVE:"mousemove",$MOUSE_UP:"mouseup",$MOUSE_WHEEL:"wheel",$DOUBLE_CLICK:"dblclick",$MOUSE_LEAVE:"mouseleave",$KEY_DOWN:"keydown",$KEY_UP:"keyup",$SCROLL:"scroll"};h.$P_TAG=t.document.createElement("p"),h.$COLOR_ARRAY_IDENTITY=new a([1,1,1,1,0,0,0,0]),h.$COLOR_MATRIX_FILTER=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],h.$soundMixerVolume=1,h.$bezierConverterBuffer=new Array(32),h.$window=t,h.$document=t.document,h.$navigator=t.navigator,h.$userAgent=t.navigator.userAgent,h.$location=t.location,h.$isNaN=t.isNaN,h.$Deg2Rad=s.PI/180,h.$Rad2Deg=180/s.PI,h.$Array=t.Array,h.$Map=t.Map,h.$Image=t.Image,h.$URL=t.URL,h.$Blob=t.Blob,h.$parseFloat=t.parseFloat,h.$setTimeout=t.setTimeout,h.$encodeURIComponent=t.encodeURIComponent,h.$Infinity=t.Infinity,h.$WebGLTexture=t.WebGLTexture,h.$clearTimeout=t.clearTimeout,h.$setTimeout=t.setTimeout,h.$audioContext=null,h.$CanvasRenderingContext2D=t.CanvasRenderingContext2D,h.$requestAnimationFrame=t.requestAnimationFrame,h.$cancelAnimationFrame=t.cancelAnimationFrame,h.$performance=t.performance,h.$variables=new Map,h.$loadedImages=new Map,h.$isUpdated=!1,h.$event=null,h.$dropTarget=null,h.$dragRules={lock:!1,position:{x:0,y:0},bounds:null},h.$rgbToLinearTable=new a(256),h.$rgbIdentityTable=new a(256);for(let t=0;t<256;++t)h.$rgbToLinearTable[t]=s.pow(t/255,2.23333333),h.$rgbIdentityTable[t]=t/255;h.$SHORT_INT_MIN=-32768,h.$SHORT_INT_MAX=32767,h.$devicePixelRatio=s.min(2,t.devicePixelRatio),h.$MATRIX_HIT_ARRAY_IDENTITY=new a([1,0,0,1,0,0]),h.$MATRIX_ARRAY_IDENTITY=new a([1,0,0,1,0,0]),h.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0=new Float32Array([h.$devicePixelRatio,0,0,h.$devicePixelRatio,0,0]),h.$bounds=[],h.$arrays=[],h.$audios=[],h.$maps=[],h.$preObjects=[],h.$matrices=[],h.$colors=[],h.$float32Array4=[],h.$float32Array6=[],h.$float32Array8=[],h.$float32Array9=[],h.$isAndroid=h.$userAgent.indexOf("Android")>-1,h.isiOS=h.$userAgent.indexOf("iPhone")>-1||h.$userAgent.indexOf("iPod")>-1,h.$isTouch=h.$isAndroid||h.isiOS,h.$isChrome=h.$userAgent.indexOf("Chrome")>-1,h.$isFireFox=h.$userAgent.indexOf("Firefox")>-1,h.$isSafari=-1===h.$userAgent.indexOf("Chrome")&&h.$userAgent.indexOf("Safari")>-1,h.$isEdge=h.$userAgent.indexOf("Edge")>-1,h.$isMac=h.$userAgent.indexOf("Mac")>-1,h.$isWindows=!1===h.$isMac,h.$currentLoaderInfo=null;const l=t.document.createElement("canvas");l.width=1,l.height=1,h.$hitContext=l.getContext("2d"),h.$hitContext.globalAlpha=0,h.$hitContext.imageSmoothingEnabled=!1;const $=t.document.createElement("canvas");$.width=1,$.height=1,h.$textContext=$.getContext("2d"),h.$hitContext.globalAlpha=0,h.$hitContext.imageSmoothingEnabled=!1,h.$DIV=null,h.$isArray=t=>h.$Array.isArray(t),h.$getArray=(...t)=>{const e=h.$arrays.pop()||[];return t.length&&e.push.apply(e,t),e},h.$poolArray=t=>{t.length&&(t.length=0),h.$arrays.push(t)},h.$clamp=(t,e,i,r=null)=>{const n=+t;return h.$isNaN(n)&&null!==r?r:s.min(s.max(e,h.$isNaN(n)?0:n),i)},h.$multiplicationColor=(t,e)=>h.$getFloat32Array8(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),h.$multiplicationMatrix=(t,e)=>h.$getFloat32Array6(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),h.$getBoundsObject=(t=0,e=0,i=0,s=0)=>{const r=h.$bounds.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return r.xMin=t,r.xMax=e,r.yMin=i,r.yMax=s,r},h.$poolBoundsObject=t=>{h.$bounds.push(t)},h.$poolMap=t=>{t.size&&t.clear(),h.$maps.push(t)},h.$getMap=()=>h.$maps.pop()||new h.$Map,h.$getFloat32Array4=(t=0,e=0,i=0,s=0)=>{const r=h.$float32Array4.pop()||new a(4);return r[0]=t,r[1]=e,r[2]=i,r[3]=s,r},h.$poolFloat32Array4=t=>{h.$float32Array4.push(t)},h.$getFloat32Array6=(t=0,e=0,i=0,s=0,r=0,n=0)=>{const o=h.$float32Array6.pop()||new a(6);return o[0]=t,o[1]=e,o[2]=i,o[3]=s,o[4]=r,o[5]=n,o},h.$poolFloat32Array6=t=>{h.$float32Array6.push(t)},h.$getFloat32Array8=(t=1,e=1,i=1,s=1,r=0,n=0,o=0,l=0)=>{const $=h.$float32Array8.pop()||new a(8);return $[0]=t,$[1]=e,$[2]=i,$[3]=s,$[4]=r,$[5]=n,$[6]=o,$[7]=l,$},h.$poolFloat32Array8=t=>{h.$float32Array8.push(t)},h.$getFloat32Array9=(t=0,e=0,i=0,s=0,r=0,n=0,o=0,l=0,$=0)=>{const _=h.$float32Array9.pop()||new a(9);return _[0]=t,_[1]=e,_[2]=i,_[3]=s,_[4]=r,_[5]=n,_[6]=o,_[7]=l,_[8]=$,_},h.$poolFloat32Array9=t=>{h.$float32Array9.push(t)},h.$currentPlayer=()=>t.next2d._$player,h.$currentMousePoint=()=>{const t=h.$currentPlayer();let e=h.$window.pageXOffset,i=h.$window.pageYOffset;const s=h.$document.getElementById(t.contentElementId);if(s){const t=s.getBoundingClientRect();e+=t.left,i+=t.top}let r=h.$event.pageX,n=h.$event.pageY;if(h.$isTouch){const t=h.$event.changedTouches[0];r=t.pageX,n=t.pageY}const a=(r-e)/t._$scale|0,o=(n-i)/t._$scale|0;return new v(a,o)},h.$boundsMatrix=(t,e)=>{const i=t.xMax*e[0]+t.yMax*e[2]+e[4],n=t.xMax*e[0]+t.yMin*e[2]+e[4],a=t.xMin*e[0]+t.yMax*e[2]+e[4],o=t.xMin*e[0]+t.yMin*e[2]+e[4],l=t.xMax*e[1]+t.yMax*e[3]+e[5],$=t.xMax*e[1]+t.yMin*e[3]+e[5],_=t.xMin*e[1]+t.yMax*e[3]+e[5],c=t.xMin*e[1]+t.yMin*e[3]+e[5],u=s.min(r.MAX_VALUE,i,n,a,o),d=s.max(-r.MAX_VALUE,i,n,a,o),g=s.min(r.MAX_VALUE,l,$,_,c),f=s.max(-r.MAX_VALUE,l,$,_,c);return h.$getBoundsObject(u,d,g,f)},h.$upperPowerOfTwo=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),h.$getMatrix=(t=1,e=0,i=0,s=1,r=0,n=0)=>{if(!h.$matrices.length)return new T(t,e,i,s,r,n);const a=h.$matrices.pop();return a._$matrix=h.$getFloat32Array6(t,e,i,s,r,n),a},h.$poolMatrix=t=>{h.$poolFloat32Array6(t._$matrix),t._$matrix=null,h.$matrices.push(t)},h.$toBoolean=(t=!1)=>{switch(typeof t){case"boolean":return t;case"function":return!0;case"object":case"string":case"number":return!!t;default:return!1}},h.$getColorTransform=(t=1,e=1,i=1,s=1,r=0,n=0,a=0,o=0)=>{if(!h.$colors.length)return new b(t,e,i,s,r,n,a,o);const l=h.$colors.pop();return l._$colorTransform=h.$getFloat32Array8(t,e,i,s,r,n,a,o),l},h.$poolColorTransform=t=>{h.$poolFloat32Array8(t._$colorTransform),t._$colorTransform=null,h.$colors.push(t)},h.$toColorInt=t=>h.$isNaN(+t)?h.$colorStringToInt(t):+t,h.$colorStringToInt=t=>{h.$hitContext.fillStyle=t;const e=h.$hitContext.fillStyle.substr(1);return h.$hitContext.fillStyle="rgba(0, 0, 0, 1)",0|`0x${e}`},h.$intToR=(t,e,i)=>(t>>16)*(i?e:1)/255,h.$intToG=(t,e,i)=>(t>>8&255)*(i?e:1)/255,h.$intToB=(t,e,i)=>(255&t)*(i?e:1)/255,h.$uintToRGBA=t=>({A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}),h.$intToRGBA=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),h.$generateColorTransform=(t,e)=>({R:s.max(0,s.min(t.R*e[0]+e[4],255)),G:s.max(0,s.min(t.G*e[1]+e[5],255)),B:s.max(0,s.min(t.B*e[2]+e[6],255)),A:s.max(0,s.min(255*t.A*e[3]+e[7],255))/255}),h.$cacheStore=()=>h.$currentPlayer()._$cacheStore,h.$inverseMatrix=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return h.$getFloat32Array9(t[4]*e,-t[1]*e,0,-t[3]*e,t[0]*e,0,i*e,s*e,1)},h.$decodeAudioFailed=function(){const t=this._$character?this._$character.buffer:this._$buffer;let e=0;for(;e=t.indexOf(255,e),-1!==e&&224!=(224&t[e+1]);)++e;e>-1&&h.$audioContext.decodeAudioData(t.buffer.subarray(e),h.$decodeAudioSuccess.bind(this))},h.$decodeAudioSuccess=function(t){this._$character?(this._$character.buffer=null,this._$character.audioBuffer=t):(this._$buffer=null,this._$audioBuffer=t)},h.$decodeAudioData=t=>{const e=t._$character?t._$character.buffer:t._$buffer;e&&h.$audioContext.decodeAudioData(e.buffer,h.$decodeAudioSuccess.bind(t),h.$decodeAudioFailed.bind(t))},h.$loadAudioData=()=>{if(h.$audioContext||(h.$audioContext=new h.$window.AudioContext,h.$audioContext.resume()),h.$audioContext){const t=h.$audios.length;for(let e=0;e<t;++e){const t=h.$audios[e];if(t._$character&&t._$character.audioBuffer)return;if(t._$audioBuffer)return;h.$decodeAudioData(t)}h.$audios.length=0}},h.$getImageType=t=>255===t[0]&&216===t[1]?"jpeg":71===t[0]&&73===t[1]&&70===t[2]?"gif":137===t[0]&&80===t[1]&&78===t[2]&&71===t[3]&&13===t[4]&&10===t[5]&&26===t[6]&&10===t[7]?"png":66===t[0]&&77===t[1]?"bmp":null,h.$resizeTimerId=0,h.$resize=()=>{(0,h.$clearTimeout)(h.$resizeTimerId);const t=h.$setTimeout;h.$resizeTimerId=t(h.$resizeExecute,300)},h.$resizeExecute=()=>{const t=h.$currentPlayer();if(t._$loadStatus===ae.LOAD_END){t._$resize();const e=t._$stage;e.willTrigger(_.RESIZE)&&e.dispatchEvent(new _(_.RESIZE))}},h.$window.addEventListener("resize",h.$resize),h.$resetContext=t=>{const e=t._$contextStyle;switch(e._$fillStyle.constructor){case Ut:case kt:e._$fillStyle=h.$getFloat32Array4(1,1,1,1);break;default:e._$fillStyle[0]=1,e._$fillStyle[1]=1,e._$fillStyle[2]=1,e._$fillStyle[3]=1}switch(e._$strokeStyle.constructor){case Ut:case kt:e._$strokeStyle=h.$getFloat32Array4(1,1,1,1);break;default:e._$strokeStyle[0]=1,e._$strokeStyle[1]=1,e._$strokeStyle[2]=1,e._$strokeStyle[3]=1}t._$style=e,t._$globalAlpha=1,t._$globalCompositeOperation=I.NORMAL,t._$imageSmoothingEnabled=!1},h.$getPreObject=()=>h.$preObjects.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,currentAttachment:null,currentMaskBuffer:null,currentMaskBounds:null,cacheCurrentBounds:null,blendMode:null,filters:null,layerWidth:null,layerHeight:null},h.$poolPreObject=t=>{t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.currentAttachment=null,t.currentMaskBuffer=null,t.currentMaskBounds=null,t.cacheCurrentBounds=null,t.blendMode=null,t.filters=null,t.layerWidth=null,t.layerHeight=null,h.$preObjects.push(t)},h.$cross=(t,e,i,s)=>t*s-i*e,h.$linearGradientXY=t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],r=-819.2*t[0]+819.2*t[2]+t[4],n=-819.2*t[1]-819.2*t[3]+t[5],a=819.2*t[1]-819.2*t[3]+t[5];let o=r-e,l=-819.2*t[1]+819.2*t[3]+t[5]-n;const $=s.sqrt(o*o+l*l);$?(o/=$,l/=$):(o=0,l=0);const _=(i-e)*o+(a-n)*l;return h.$getArray(e+_*o,n+_*l,i,a)},h.$ajax=(t=null)=>{t||(t={method:"GET"}),"method"in t||(t.method="GET");let e=null;switch(t.method.toUpperCase()){case xt.GET:if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():e[1]+"&"+t.data.toString(),t.url=e.join("?")}break;case xt.PUT:case xt.POST:e=t.data?t.data.toString():null}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),t.withCredentials&&(i.withCredentials=!0),t.event){const e=Object.keys(t.event),s=e.length;for(let r=0;r<s;++r){const s=e[r];i.addEventListener(s,t.event[s])}h.$poolArray(e)}if(t.format===ft.ARRAY_BUFFER&&(i.responseType=ft.ARRAY_BUFFER),t.headers)for(const[e,s]of t.headers)i.setRequestHeader(e,s);i.send(e)},h.$headerToArray=t=>{const e=h.$getArray();if(t){const i=t.trim().split("\n"),s=i.length;for(let t=0;t<s;++t){const s=i[t].split(":");e.push({name:s[0],value:s[1].trim()})}}return e},h.$getClass=t=>{const e=t.split(".");let i=h.$window;for(let t=0;t<e.length;++t){const s=e[t];if(!(s in i))return null;i=i[s]}return i},h.$imageWorkerActive=!1,h.$imageQueues=[],h.$decodeImage=function(){const t=h.$currentPlayer(),e=this.image.width,i=this.image.height,s=new w(e,i,!0,4278190080),r=t._$context,n=r.frameBuffer.currentAttachment;s._$texture=r.frameBuffer.createTextureFromImage(this.image);const a=new H;a.graphics.beginBitmapFill(s,null,!1).drawRect(0,0,e,i);const o=this.scope.contentLoaderInfo;if(o._$content=a,a._$loaderInfo=o,t._$loaders.push(o),n?r._$bind(n):r.frameBuffer.unbind(),h.$imageQueues.length){const t=h.$imageQueues.shift();t.image.decode().then(h.$decodeImage.bind(t)).catch((()=>{throw new Error("image encoding error")}))}else h.$imageWorkerActive=!1},h.$unzipURL=URL.createObjectURL(new Blob(['/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){"use strict";var t=void 0,r=this;function i(i,e){var s,h=i.split("."),n=r;!(h[0]in n)&&n.execScript&&n.execScript("var "+h[0]);for(;h.length&&(s=h.shift());)h.length||e===t?n=n[s]?n[s]:n[s]={}:n[s]=e}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function s(t){var r,i,s,h,n,a,o,f,l,u,c=t.length,b=0,y=Number.POSITIVE_INFINITY;for(f=0;f<c;++f)t[f]>b&&(b=t[f]),t[f]<y&&(y=t[f]);for(r=1<<b,i=new(e?Uint32Array:Array)(r),s=1,h=0,n=2;s<=b;){for(f=0;f<c;++f)if(t[f]===s){for(a=0,o=h,l=0;l<s;++l)a=a<<1|1&o,o>>=1;for(u=s<<16|f,l=a;l<r;l+=n)i[l]=u;++h}++s,h<<=1,n<<=1}return[i,b,y]}function h(t,r){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=e?new Uint8Array(t):t,this.m=!1,this.i=a,this.r=!1,!r&&(r={})||(r.index&&(this.a=r.index),r.bufferSize&&(this.h=r.bufferSize),r.bufferType&&(this.i=r.bufferType),r.resize&&(this.r=r.resize)),this.i){case n:this.b=32768,this.c=new(e?Uint8Array:Array)(32768+this.h+258);break;case a:this.b=0,this.c=new(e?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error("invalid inflate mode")}}var n=0,a=1,o={t:n,s:a};h.prototype.k=function(){for(;!this.m;){var r=S(this,3);switch(1&r&&(this.m=!0),r>>>=1){case 0:var i=this.input,h=this.a,o=this.c,f=this.b,l=i.length,u=t,b=o.length,y=t;if(this.d=this.f=0,h+1>=l)throw Error("invalid uncompressed block header: LEN");if(u=i[h++]|i[h++]<<8,h+1>=l)throw Error("invalid uncompressed block header: NLEN");if(u===~(i[h++]|i[h++]<<8))throw Error("invalid uncompressed block header: length verify");if(h+u>i.length)throw Error("input buffer is broken");switch(this.i){case n:for(;f+u>o.length;){if(u-=y=b-f,e)o.set(i.subarray(h,h+y),f),f+=y,h+=y;else for(;y--;)o[f++]=i[h++];this.b=f,o=this.e(),f=this.b}break;case a:for(;f+u>o.length;)o=this.e({p:2});break;default:throw Error("invalid inflate mode")}if(e)o.set(i.subarray(h,h+u),f),f+=u,h+=u;else for(;u--;)o[f++]=i[h++];this.a=h,this.b=f,this.c=o;break;case 1:this.j(E,z);break;case 2:var p,d,g,v,w=S(this,5)+257,A=S(this,5)+1,k=S(this,4)+4,U=new(e?Uint8Array:Array)(c.length),m=t,I=t,x=t,N=t,j=t;for(j=0;j<k;++j)U[c[j]]=S(this,3);if(!e)for(j=k,k=U.length;j<k;++j)U[c[j]]=0;for(p=s(U),m=new(e?Uint8Array:Array)(w+A),j=0,v=w+A;j<v;)switch(I=T(this,p),I){case 16:for(N=3+S(this,2);N--;)m[j++]=x;break;case 17:for(N=3+S(this,3);N--;)m[j++]=0;x=0;break;case 18:for(N=11+S(this,7);N--;)m[j++]=0;x=0;break;default:x=m[j++]=I}d=s(e?m.subarray(0,w):m.slice(0,w)),g=s(e?m.subarray(w):m.slice(w)),this.j(d,g);break;default:throw Error("unknown BTYPE: "+r)}}return this.n()};var f,l,u=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],c=e?new Uint16Array(u):u,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],y=e?new Uint16Array(b):b,p=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],d=e?new Uint8Array(p):p,g=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],v=e?new Uint16Array(g):g,w=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],A=e?new Uint8Array(w):w,k=new(e?Uint8Array:Array)(288);for(f=0,l=k.length;f<l;++f)k[f]=143>=f?8:255>=f?9:279>=f?7:8;var U,m,E=s(k),I=new(e?Uint8Array:Array)(30);for(U=0,m=I.length;U<m;++U)I[U]=5;var z=s(I);function S(t,r){for(var i,e=t.f,s=t.d,h=t.input,n=t.a,a=h.length;s<r;){if(n>=a)throw Error("input buffer is broken");e|=h[n++]<<s,s+=8}return i=e&(1<<r)-1,t.f=e>>>r,t.d=s-r,t.a=n,i}function T(t,r){for(var i,e,s=t.f,h=t.d,n=t.input,a=t.a,o=n.length,f=r[0],l=r[1];h<l&&!(a>=o);)s|=n[a++]<<h,h+=8;if((e=(i=f[s&(1<<l)-1])>>>16)>h)throw Error("invalid code length: "+e);return t.f=s>>e,t.d=h-e,t.a=a,65535&i}function x(t,r){var i,e;if(this.input=t,this.a=0,!r&&(r={})||(r.index&&(this.a=r.index),r.verify&&(this.A=r.verify)),i=t[this.a++],e=t[this.a++],(15&i)!==N)throw Error("unsupported compression method");if(this.method=N,0!=((i<<8)+e)%31)throw Error("invalid fcheck flag:"+((i<<8)+e)%31);if(32&e)throw Error("fdict flag is not supported");this.q=new h(t,{index:this.a,bufferSize:r.bufferSize,bufferType:r.bufferType,resize:r.resize})}h.prototype.j=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length-258;256!==(s=T(this,t));)if(256>s)e>=o&&(this.b=e,i=this.e(),e=this.b),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e>=o&&(this.b=e,i=this.e(),e=this.b);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.w=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length;256!==(s=T(this,t));)if(256>s)e>=o&&(o=(i=this.e()).length),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e+a>o&&(o=(i=this.e()).length);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.e=function(){var t,r,i=new(e?Uint8Array:Array)(this.b-32768),s=this.b-32768,h=this.c;if(e)i.set(h.subarray(32768,i.length));else for(t=0,r=i.length;t<r;++t)i[t]=h[t+32768];if(this.g.push(i),this.l+=i.length,e)h.set(h.subarray(s,s+32768));else for(t=0;32768>t;++t)h[t]=h[s+t];return this.b=32768,h},h.prototype.z=function(t){var r,i,s,h=this.input.length/this.a+1|0,n=this.input,a=this.c;return t&&("number"==typeof t.p&&(h=t.p),"number"==typeof t.u&&(h+=t.u)),2>h?i=(s=(n.length-this.a)/this.o[2]/2*258|0)<a.length?a.length+s:a.length<<1:i=a.length*h,e?(r=new Uint8Array(i)).set(a):r=a,this.c=r},h.prototype.n=function(){var t,r,i,s,h,n=0,a=this.c,o=this.g,f=new(e?Uint8Array:Array)(this.l+(this.b-32768));if(0===o.length)return e?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(r=0,i=o.length;r<i;++r)for(s=0,h=(t=o[r]).length;s<h;++s)f[n++]=t[s];for(r=32768,i=this.b;r<i;++r)f[n++]=a[r];return this.g=[],this.buffer=f},h.prototype.v=function(){var t,r=this.b;return e?this.r?(t=new Uint8Array(r)).set(this.c.subarray(0,r)):t=this.c.subarray(0,r):(this.c.length>r&&(this.c.length=r),t=this.c),this.buffer=t},x.prototype.k=function(){var t,r,i=this.input;if(t=this.q.k(),this.a=this.q.a,this.A){r=(i[this.a++]<<24|i[this.a++]<<16|i[this.a++]<<8|i[this.a++])>>>0;var e=t;if("string"==typeof e){var s,h,n=e.split("");for(s=0,h=n.length;s<h;s++)n[s]=(255&n[s].charCodeAt(0))>>>0;e=n}for(var a,o=1,f=0,l=e.length,u=0;0<l;){l-=a=1024<l?1024:l;do{f+=o+=e[u++]}while(--a);o%=65521,f%=65521}if(r!==(f<<16|o)>>>0)throw Error("invalid adler-32 checksum")}return t};var N=8;i("Zlib.Inflate",x),i("Zlib.Inflate.prototype.decompress",x.prototype.k);var j,C,O,L,Z={ADAPTIVE:o.s,BLOCK:o.t};if(Object.keys)j=Object.keys(Z);else for(C in j=[],O=0,Z)j[O++]=C;for(O=0,L=j.length;O<L;++O)i("Zlib.Inflate.BufferType."+(C=j[O]),Z[C])}).call(this),this.addEventListener("message",(function(t){const r=new Zlib.Inflate(t.data).decompress();let i="";for(let t=0;t<r.length;++t)i+=String.fromCharCode(r[t]);this.postMessage(JSON.parse(decodeURIComponent(i)))}));'],{type:"text/javascript"})),h.$unzipWorker=null,h.$unzipQueues=[],h.$unzipWorkerActive=!1,h.$unzipHandler=function(t){if(this._$build(t.data),h.$unzipQueues.length){const t=h.$unlzmaQueues.pop(),e=new Uint8Array(t.json.buffer);h.$unzipWorker.onmessage=h.$unzipHandler.bind(t.scope),h.$unzipWorker.postMessage(e,[e.buffer])}else h.$unzipWorkerActive=!1},h.$packages=t=>{t.display={BitmapData:w,BitmapDataChannel:O,BlendMode:I,CapsStyle:B,DisplayObject:A,DisplayObjectContainer:C,FrameLabel:F,GradientType:L,Graphics:P,GraphicsGradientFill:N,InteractiveObject:M,InterpolationMethod:U,JointStyle:k,Loader:G,LoaderInfo:X,MovieClip:R,Shape:H,SpreadMethod:Y,Sprite:S,Stage:j},t.events={Event:_,EventDispatcher:c,EventPhase:u,FocusEvent:d,HTTPStatusEvent:g,IOErrorEvent:f,MouseEvent:p,ProgressEvent:m,VideoEvent:x},t.filters={BevelFilter:J,BitmapFilterQuality:q,BitmapFilterType:W,BlurFilter:Q,ColorMatrixFilter:Z,ConvolutionFilter:tt,DisplacementMapFilter:et,DisplacementMapFilterMode:K,DropShadowFilter:it,GlowFilter:st,GradientBevelFilter:rt,GradientGlowFilter:nt},t.geom={ColorTransform:b,Matrix:T,Point:v,Rectangle:y,Transform:E},t.media={Sound:ct,SoundMixer:ut,SoundTransform:dt,Video:gt},t.net={URLLoaderDataFormat:ft,URLRequest:pt,URLRequestHeader:mt,URLRequestMethod:xt},t.text={TextField:ht,TextFieldAutoSize:ot,TextFieldType:lt,TextFormat:$t,TextFormatAlign:at,TextFormatVerticalAlign:_t},t.ui={Easing:bt,Job:Tt,Tween:vt}};class _{constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=!!e,this._$cancelable=!!i,this._$target=null,this._$currentTarget=null,this._$eventPhase=u.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1,this._$preventDefault=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get RESIZE(){return"resize"}static get SCROLL(){return"scroll"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}get eventPhase(){return this._$eventPhase}get listener(){return this._$listener}get target(){return this._$target?this._$target:this._$currentTarget}get type(){return this._$type}formatToString(){let t=`[${arguments[0]}`;for(let e=1;e<arguments.length;++e){const i=arguments[e];t+=` ${i}=`;const s=this[i];t+="string"==typeof s?`"${s}"`:`${s}`}return`${t}]`}isDefaultPrevented(){return!!h.$event&&h.$event.defaultPrevented}preventDefault(){this._$preventDefault=!0}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}class c{constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,s=0){let r,n,a=!1;switch(t=`${t}`){case _.ENTER_FRAME:case _.EXIT_FRAME:case _.FRAME_CONSTRUCTED:case _.RENDER:case _.ACTIVATE:case _.DEACTIVATE:case"keyDown":case"keyUp":n=h.$currentPlayer(),n.broadcastEvents.size&&n.broadcastEvents.has(t)||n.broadcastEvents.set(t,h.$getArray()),r=n.broadcastEvents.get(t),a=!0;break;default:this._$events||(this._$events=h.$getMap()),this._$events.size&&this._$events.has(t)||this._$events.set(t,h.$getArray()),r=this._$events.get(t)}let o=r.length;for(let t=0;t<o;++t){const s=r[t];i===s.useCapture&&(s.target===this&&s.listener===e&&(o=t))}r[o]={listener:e,priority:s,useCapture:i,target:this},a?n.broadcastEvents.set(t,r):(r.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,r))}dispatchEvent(t){switch(t.type){case _.ENTER_FRAME:case _.EXIT_FRAME:case _.FRAME_CONSTRUCTED:case _.RENDER:case _.ACTIVATE:case _.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:h.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t.type)){const e=i.broadcastEvents.get(t.type),s=e.length;for(let i=0;i<s;++i){const s=e[i];if(s.target===this){t._$eventPhase=u.AT_TARGET,t._$currentTarget=s.target;try{t._$listener=s.listener,s.listener.call(h.$window,t)}catch(t){return!1}}}return!0}}break;default:{let e=h.$getArray();this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type).slice(0));const i=h.$getArray();if(this instanceof A){let e=this._$parent;for(;e;)e.hasEventListener(t.type)&&(i[i.length]=e._$events.get(t.type)),e=e._$parent}if(t._$target=this,e.length||i.length){if(t._$eventPhase=u.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(i.useCapture){t._$currentTarget=i.target,h.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(h.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}if(t._$eventPhase=u.AT_TARGET,!t._$stopImmediatePropagation&&!t._$stopPropagation){const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(!i.useCapture){t._$currentTarget=i.target,h.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(h.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}}switch(t._$eventPhase=u.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(!i.useCapture){t._$currentTarget=i.target,h.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(h.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return h.$poolArray(e),h.$poolArray(i),!0}h.$poolArray(e),h.$poolArray(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case _.ENTER_FRAME:case _.EXIT_FRAME:case _.FRAME_CONSTRUCTED:case _.RENDER:case _.ACTIVATE:case _.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:h.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t)){const e=i.broadcastEvents.get(t);for(let t=0;t<e.length;t++)if(e[t].target===this)return!0}return!1}default:return!!(this._$events&&this._$events.size&&this._$events.has(t))}}removeEventListener(t,e,i=!1){if(t=`${t}`,!this.hasEventListener(t))return;let s,r,n=!1;switch(t){case _.ENTER_FRAME:case _.EXIT_FRAME:case _.FRAME_CONSTRUCTED:case _.RENDER:case _.ACTIVATE:case _.DEACTIVATE:case"keyDown":case"keyUp":n=!0,r=h.$currentPlayer(),r&&(s=r.broadcastEvents.get(t));break;default:s=this._$events.get(t)}const a=s.length;for(let t=0;t<a;++t){const r=s[t];if(i===r.useCapture&&r.listener===e){s.splice(t,1);break}}s.length?n?r.broadcastEvents.set(t,s):(s.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,s)):n?r.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(h.$poolMap(this._$events),this._$events=null))}removeAllEventListener(t,e=!1){if(t=`${t}`,!this.hasEventListener(t))return;let i,s,r=!1;switch(t){case _.ENTER_FRAME:case _.EXIT_FRAME:case _.FRAME_CONSTRUCTED:case _.RENDER:case _.ACTIVATE:case _.DEACTIVATE:case"keyDown":case"keyUp":r=!0,s=h.$currentPlayer(),s&&(i=s.broadcastEvents.get(t));break;default:i=this._$events.get(t)}const n=h.$getArray(),a=i.length;for(let t=0;t<a;++t){const s=i[t];e!==s.useCapture&&n.push(s)}n.length?r?s.broadcastEvents.set(t,n):(n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,n)):r?s.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(h.$poolMap(this._$events),this._$events=null))}willTrigger(t){if(this.hasEventListener(t))return!0;let e=this._$parent;for(;e;){if(e.hasEventListener(t))return!0;e=e._$parent}return!1}}class u{static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class d extends _{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class g extends _{constructor(t,e=!1,i=!1,s=0){super(t,e,i),this._$status=0|s,this._$responseHeaders=[],this._$responseURL=""}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","eventPhase","status","responseURL")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}get responseURL(){return this._$responseURL}get status(){return this._$status}}class f extends _{constructor(t,e=!1,i=!1,s=""){super(t,e,i),this._$text=`${s}`}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}get text(){return this._$text}}class p extends _{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:function(t,e){return e in t?t[e]:h.$event&&e in h.$event?h.$event[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class m extends _{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class x extends _{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class b{constructor(t=1,e=1,i=1,s=1,r=0,n=0,a=0,o=0){this._$colorTransform=h.$getFloat32Array8(1,1,1,1,0,0,0,0),this.redMultiplier=t,this.greenMultiplier=e,this.blueMultiplier=i,this.alphaMultiplier=s,this.redOffset=r,this.greenOffset=n,this.blueOffset=a,this.alphaOffset=o}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=h.$clamp(+t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=h.$clamp(0|t,-255,255,0)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=h.$clamp(+t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=h.$clamp(0|t,-255,255,0)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=h.$clamp(+t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=h.$clamp(0|t,-255,255,0)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=h.$clamp(+t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=h.$clamp(0|t,-255,255,0)}concat(t){const e=h.$multiplicationColor(this._$colorTransform,t._$colorTransform);this.redMultiplier=e[0],this.greenMultiplier=e[1],this.blueMultiplier=e[2],this.alphaMultiplier=e[3],this.redOffset=e[4],this.greenOffset=e[5],this.blueOffset=e[6],this.alphaOffset=e[7],h.$poolFloat32Array8(e)}_$clone(){return h.$getColorTransform(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class T{constructor(t=1,e=0,i=0,s=1,r=0,n=0){this._$matrix=h.$getFloat32Array6(1,0,0,1,0,0),this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}_$clone(){return this.clone()}clone(){return h.$getMatrix(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let s=e[0]*i[0],r=0,n=0,a=e[3]*i[3],o=e[4]*i[0]+i[4],h=e[5]*i[3]+i[5];(e[1]||e[2]||i[1]||i[2])&&(s+=e[1]*i[2],a+=e[2]*i[1],r+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],o+=e[5]*i[2],h+=e[4]*i[1]),this.a=s,this.b=r,this.c=n,this.d=a,this.tx=o,this.ty=h}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,s=0,r=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(s,r)}createGradientBox(t,e,i=0,s=0,r=0){this.createBox(t/1638.4,e/1638.4,i,s+t/2,r+e/2)}deltaTransformPoint(t){return new v(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){let t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],s=this._$matrix[3],r=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/s,this.tx=-this.a*r,this.ty=-this.d*n;else{const a=t*s-e*i;if(a){const o=1/a;this.a=s*o,this.b=-e*o,this.c=-i*o,this.d=t*o,this.tx=-(this.a*r+this.c*n),this.ty=-(this.b*r+this.d*n)}}}rotate(t){const e=this._$matrix[0],i=this._$matrix[1],r=this._$matrix[2],n=this._$matrix[3],a=this._$matrix[4],o=this._$matrix[5];this.a=e*s.cos(t)-i*s.sin(t),this.b=e*s.sin(t)+i*s.cos(t),this.c=r*s.cos(t)-n*s.sin(t),this.d=r*s.sin(t)+n*s.cos(t),this.tx=a*s.cos(t)-o*s.sin(t),this.ty=a*s.sin(t)+o*s.cos(t)}scale(t,e){this.a*=t,this.c*=t,this.tx*=t,this.b*=e,this.d*=e,this.ty*=e}setTo(t,e,i,s,r,n){this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}transformPoint(t){return new v(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class v{constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return s.sqrt(s.pow(this.x,2)+s.pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}add(t){return new v(this.x+t.x,this.y+t.y)}clone(){return new v(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return s.sqrt(s.pow(t._$x-e._$x,2)+s.pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new v(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new v(t*s.cos(e),t*s.sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new v(this.x-t.x,this.y-t.y)}}class y{constructor(t=0,e=0,i=0,s=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,s)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new v(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new v(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new v(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get x(){return this._$x}set x(t){this._$x=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=h.$clamp(+t,h.$SHORT_INT_MIN,h.$SHORT_INT_MAX,0)}clone(){return new y(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=s.max(this.x,t.x),i=s.max(this.y,t.y),r=s.min(this.right,t.right)-e,n=s.min(this.bottom,t.bottom)-i;return r>0&&n>0?new y(e,i,r,n):new y(0,0,0,0)}intersects(t){const e=s.max(this.x,t.x),i=s.max(this.y,t.y),r=s.min(this.right,t.right),n=s.min(this.bottom,t.bottom);return r-e>0&&n-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new y(s.min(this.x,t.x),s.min(this.y,t.y),s.max(this.right-t.left,t.right-this.left),s.max(this.bottom-t.top,t.bottom-this.top))}}class E{constructor(t){if(!(t instanceof A))throw new Error("Transform params is DisplayObject only.");this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.colorTransform,i=new b;return i._$colorTransform=h.$getFloat32Array8(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),i}return this._$transform(),this._$colorTransform._$clone()}set colorTransform(t){t instanceof b&&this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=h.$multiplicationColor(e._$transform._$rawColorTransform(),t),e=e._$parent;return h.$getColorTransform(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.matrix;return h.$getMatrix(e[0],e[1],e[2],e[3],e[4],e[5])}return this._$transform(),this._$matrix._$clone()}set matrix(t){t instanceof T&&this._$transform(t._$matrix,null)}get concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=h.$multiplicationMatrix(e._$transform._$rawMatrix(),t),e=e._$parent;return h.$getMatrix(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){const t=new y(0,0,0,0);if(!this._$displayObject)return t;const e=this._$displayObject._$getBounds(null);return t._$x=e.xMin,t._$y=e.yMin,t._$width=+s.abs(e.xMax-e.xMin),t._$height=+s.abs(e.yMax-e.yMin),h.$poolBoundsObject(e),t}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject._$getPlaceObject();return t?t.matrix:h.$MATRIX_ARRAY_IDENTITY}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject._$getPlaceObject();return t?t.colorTransform:h.$COLOR_ARRAY_IDENTITY}_$transform(t=null,e=null,i=null,s=""){const r=this._$displayObject._$getPlaceObject();this._$setMatrix(t,r),this._$setColorTransform(e,r),this._$setFilters(i,r),this._$setBlendMode(s,r)}_$setMatrix(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),h.$isUpdated=!0),this._$matrix||(this._$matrix=h.$getMatrix(1,0,0,1,0,0),!t&&e&&(t=e.matrix)),t){const e=this._$matrix._$matrix;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5]}}_$setColorTransform(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),h.$isUpdated=!0),this._$colorTransform||(this._$colorTransform=h.$getColorTransform(1,1,1,1,0,0,0,0),!t&&e&&(t=e.colorTransform)),t){const e=this._$colorTransform._$colorTransform;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7]}}_$setFilters(t=null,e=null){if(h.$isArray(t))return this._$filters&&h.$poolArray(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void(h.$isUpdated=!0);if(!this._$filters)if(e){if(e.filters)this._$filters=e.filters.slice(0);else if(e.surfaceFilterList){const t=h.$getArray(),i=e.surfaceFilterList.length;for(let s=0;s<i;++s){const i=e.surfaceFilterList[s],r=next2d.filters[i.class];t.push(new(r.bind.apply(r,i.params)))}e.filters=t,this._$filters=t.slice(0)}}else this._$filters=h.$getArray()}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void(h.$isUpdated=!0);this._$blendMode||(this._$blendMode=e?e.blendMode:I.NORMAL)}}class A extends c{constructor(){super(),this._$id=-1,this._$instanceId=e++,this._$dictionaryId=0,this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$buffer=null,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=null,this._$startFrame=1,this._$endFrame=0,this._$transform=new E(this),this._$variables=null,this._$placeObject=null}static toString(){return"[class DisplayObject]"}static get namespace(){return"next2d.display.DisplayObject"}toString(){return"[object DisplayObject]"}get namespace(){return"next2d.display.DisplayObject"}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=h.$clamp(t,0,1,0);const e=this._$transform.colorTransform;e._$colorTransform[3]=t,e._$colorTransform[7]=0,this._$transform.colorTransform=e,h.$poolColorTransform(e)}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,this._$blendMode;const e=this._$getPlaceObject();return e?(this._$blendMode=e.blendMode,this._$blendMode):(t._$transform(),this._$blendMode=t._$blendMode,this._$blendMode)}set blendMode(t){this._$transform._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters)return this._$filters;const t=this._$transform;if(t._$filters)return this._$filters=t._$filters.slice(0),this._$filters;const e=this._$getPlaceObject();if(e){if(!e.filters){const t=[];if(e.surfaceFilterList){const i=e.surfaceFilterList.length;for(let s=0;s<i;++s){const i=e.surfaceFilterList[s],r=next2d.filters[i.class];t.push(new(r.bind.apply(r,i.params)))}}e.filters=t}return this._$filters||(this._$filters=e.filters),e.filters.slice(0)}return t._$transform(),this._$filters=t._$filters,this._$filters.slice(0)}set filters(t){t||(t=h.$getArray()),this._$transform._$transform(null,null,t,null),this._$filters=t}get height(){const t=h.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=s.abs(t.yMax-t.yMin);switch(h.$poolBoundsObject(t),e){case 0:case h.$Infinity:case-h.$Infinity:return 0;default:return e}}set height(t){if(t=+t,!h.$isNaN(t)&&t>-1){const e=this.rotation?h.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=s.abs(e.yMax-e.yMin);switch(h.$poolBoundsObject(e),i){case 0:case h.$Infinity:case-h.$Infinity:this.scaleY=0;break;default:this.scaleY=t/i}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(this._$mask._$isMask=!1,this._$mask=null),t instanceof A&&(t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return h.$event?this.globalToLocal(h.$currentMousePoint()).x:0}get mouseY(){return h.$event?this.globalToLocal(h.$currentMousePoint()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren(),i=t.length;for(let s=0;s<i;++s){const i=t[s];i._$name&&e._$names.set(i.name,i)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){const t=this._$transform._$rawMatrix();return s.atan2(t[1],t[0])*h.$Rad2Deg}set rotation(t){t=h.$clamp(t%360,-360,360,0);const e=this._$transform,i=e.matrix,r=s.sqrt(i.a*i.a+i.b*i.b),n=s.sqrt(i.c*i.c+i.d*i.d);if(0===t)i.a=r,i.b=0,i.c=0,i.d=n;else{let e=s.atan2(i.b,i.a),a=s.atan2(-i.c,i.d);const o=t*h.$Deg2Rad;a=a+o-e,e=o,i.b=r*s.sin(e),1===i.b||-1===i.b?i.a=0:i.a=r*s.cos(e),i.c=-n*s.sin(a),1===i.c||-1===i.c?i.d=0:i.d=n*s.cos(a)}e.matrix=i,h.$poolMatrix(i)}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid=null,t instanceof y&&(this._$scale9Grid=t)}get scaleX(){const t=this._$transform._$rawMatrix(),e=s.sqrt(t[0]*t[0]+t[1]*t[1]);return 0>t[0]?-1*e:e}set scaleX(t){const e=this._$transform,i=e.matrix;if(0===i.b||h.$isNaN(i.b))i.a=t;else{const e=s.atan2(i.b,i.a);i.b=t*s.sin(e),i.a=1===i.b||-1===i.b?0:t*s.cos(e)}e.matrix=i,h.$poolMatrix(i)}get scaleY(){const t=this._$transform._$rawMatrix(),e=s.sqrt(t[2]*t[2]+t[3]*t[3]);return 0>t[3]?-1*e:e}set scaleY(t){const e=this._$transform,i=e.matrix;if(0===i.c||h.$isNaN(i.c))i.d=t;else{const e=s.atan2(-i.c,i.d);i.c=-t*s.sin(e),i.d=1===i.c||-1===i.c?0:t*s.cos(e)}e.matrix=i,h.$poolMatrix(i)}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t instanceof j?t:t._$stage:null}get transform(){return this._$transform}set transform(t){t instanceof E&&(this._$transform=t)}get visible(){return this._$visible}set visible(t){t=!!t,this._$visible!==t&&(this._$doChanged(),h.$isUpdated=!0),this._$visible=!!t}get width(){const t=h.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=s.abs(t.xMax-t.xMin);switch(h.$poolBoundsObject(t),!0){case 0===e:case e===h.$Infinity:case e===-h.$Infinity:return 0;default:return e}}set width(t){if(t=+t,!h.$isNaN(t)&&t>-1){const e=this.rotation?h.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=s.abs(e.xMax-e.xMin);switch(h.$poolBoundsObject(e),!0){case 0===i:case i===h.$Infinity:case i===-h.$Infinity:this.scaleX=0;break;default:this.scaleX=t/i}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform,i=this._$transform.matrix;i.tx=t,e.matrix=i,h.$poolMatrix(i)}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform,i=e.matrix;i.ty=t,e.matrix=i,h.$poolMatrix(i)}getBounds(t=null){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,r=h.$boundsMatrix(e,i._$matrix);h.$poolMatrix(i),h.$poolBoundsObject(e);const n=h.$getBoundsObject(r.xMin,r.xMax,r.yMin,r.yMax);h.$poolBoundsObject(r),t||(t=this);const a=t._$transform.concatenatedMatrix;a.invert();const o=h.$boundsMatrix(n,a._$matrix),l=o.xMin,$=o.yMin,_=o.xMax,c=o.yMax;return h.$poolBoundsObject(n),h.$poolBoundsObject(o),h.$poolMatrix(a),new y(l,$,s.abs(_-l),s.abs(c-$))}globalToLocal(t){const e=this._$transform.concatenatedMatrix;e.invert();const i=new v(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return h.$poolMatrix(e),i}hitTestObject(t){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,r=h.$boundsMatrix(e,i._$matrix);h.$poolMatrix(i),h.$poolBoundsObject(e);const n=t._$getBounds(null),a=t._$transform.concatenatedMatrix,o=h.$boundsMatrix(n,a._$matrix);h.$poolMatrix(a),h.$poolBoundsObject(n);const l=s.max(r.xMin,o.xMin),$=s.max(r.yMin,o.yMin),_=s.min(r.xMax,o.xMax),c=s.min(r.yMax,o.yMax);return h.$poolBoundsObject(r),h.$poolBoundsObject(o),_-l>=0&&c-$>=0}hitTestPoint(t,e,i=!1){if(i){let i=h.$MATRIX_ARRAY_IDENTITY,s=this._$parent;for(;s;)i=h.$multiplicationMatrix(s._$transform._$rawMatrix(),i),s=s._$parent;h.$hitContext.setTransform(1,0,0,1,0,0),h.$hitContext.beginPath();const r=this._$hit(h.$hitContext,i,{x:t,y:e},!0);return h.$poolFloat32Array6(i),r}const s=this._$getBounds(null),r=h.$boundsMatrix(s,this._$transform._$rawMatrix()),n=r.xMin,a=r.yMin,o=r.xMax-r.xMin,l=r.yMax-r.yMin,$=this._$parent?this._$parent.globalToLocal(new v(t,e)):new v(t,e);return h.$poolBoundsObject(r),h.$poolBoundsObject(s),new y(n,a,o,l).containsPoint($)}localToGlobal(t){const e=this._$transform.concatenatedMatrix,i=new v(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return h.$poolMatrix(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=h.$getMap()),this._$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(h.$poolMap(this._$variables),this._$variables=null))}getGlobalVariable(t){return h.$variables.has(t)?h.$variables.get(t):null}setGlobalVariable(t,e){h.$variables.set(t,e)}hasGlobalVariable(t){return h.$variables.has(t)}deleteGlobalVariable(t){h.$variables.has(t)&&h.$variables.delete(t)}clearGlobalVariable(){return h.$variables.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(null===t)return null;const e=this._$parent;if(!e)return null;const i=e._$placeMap;if(!i||!i.length)return null;const s=i[e._$currentFrame||1];if(!s)return null;this._$placeObject=e._$placeObjects[s[t]]}return this._$placeObject}_$sync(){const t=this.contentName;let e=null;if(next2d.fw.response.has(t)&&(e=next2d.fw.response.get(t)._$loaderInfo),!e&&next2d.fw.cache.has(t)&&(e=next2d.fw.cache.get(t)._$loaderInfo),e||(e=this._$loaderInfo||h.$currentLoaderInfo),!e)return null;const i=e._$data.symbols.get(this.namespace),s=e._$data.characters[i];return this._$characterId=i,this._$loaderInfo=e,s}_$build(t,e){const i=e._$loaderInfo;return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;let t=this._$parent;t&&t._$updateState()}_$doChanged(){this._$isNext=!0,this._$updated=!0;let t=this._$parent;t&&t._$doChanged()}_$drawFilter(t,e,i,s,r,n){const a=[this._$instanceId,"f"];let o=h.$cacheStore().get(a);const l=this._$isFilterUpdated(r,n,i,s,!0);let $;return o&&!l||(o&&(h.$cacheStore().set(a,null),o.layerWidth=0,o.layerHeight=0,o._$offsetX=0,o._$offsetY=0,o.matrix=null,o.colorTransform=null,t.frameBuffer.releaseTexture(o),o=null),$=this._$applyFilter(t,s,e,i,r,n),h.$cacheStore().set(a,$)),o&&($=o),$}_$getLayerBounds(t=null){const e=this._$getBounds(t);if(!t)return e;const i=this._$filters||this.filters,s=i.length;if(!s)return e;let r=new y(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);h.$poolBoundsObject(e);for(let t=0;t<s;++t)r=i[t]._$generateFilterRect(r,null,null,!0);const n=r._$x,a=r._$x+r._$width,o=r._$y,l=r._$y+r._$height;return h.$getBoundsObject(n,a,o,l)}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger(_.ADDED)&&this.dispatchEvent(new _(_.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger(_.ADDED_TO_STAGE)&&this.dispatchEvent(new _(_.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e,i,r=null,n=!1,a=0,o=0){if(this._$isUpdated())return!0;if(n)for(let t=0;t<r.length;++t)if(r[t]._$isUpdated())return!0;const l=h.$cacheStore().get([this._$instanceId,"f"]);switch(!0){case null===l:case l.filterState!==n:case l.layerWidth!==s.ceil(t):case l.layerHeight!==s.ceil(e):case l.matrix!==i[0]+"_"+i[1]+"_"+i[2]+"_"+i[3]+"_"+a+"_"+o:return!0}return!1}_$applyFilter(t,e,i,r,n,a){const o=t.frameBuffer.currentAttachment,l=t.frameBuffer.createCacheAttachment(n,a);t._$bind(l),h.$resetContext(t);const $=s.atan2(r[1],r[0]),_=s.atan2(-r[2],r[3]);if($||_){const e=i.width/2,r=i.height/2,o=s.cos($),l=s.sin($),c=-s.sin(_),u=s.cos(_),d=h.$getFloat32Array6(1,0,0,1,-e,-r),g=h.$getFloat32Array6(o,l,c,u,(n-i.width)/2,(a-i.height)/2),f=h.$multiplicationMatrix(g,d);t.setTransform(o,l,c,u,f[4]+e,f[5]+r),h.$poolFloat32Array6(d),h.$poolFloat32Array6(g),h.$poolFloat32Array6(f)}else t.setTransform(1,0,0,1,0,0);t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;let c=null;for(let i=0;i<e.length;++i)c=e[i]._$applyFilter(t,r);let u=t._$offsetX,d=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,c._$offsetX=u,c._$offsetY=d,c.matrix=r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3]+"_0_0",c.filterState=!0,c.layerWidth=n,c.layerHeight=a,t._$bind(o),t.frameBuffer.releaseAttachment(l,!1),c}_$preDraw(t,e){const i=this._$transform._$rawMatrix(),r=h.$multiplicationMatrix(e,i);if(!r[0]&&!r[1]||!r[2]&&!r[3])return!1;const n=h.$getPreObject();n.matrix=r;const a=this._$filters||this.filters,o=this._$blendMode||this.blendMode;if(a.length>0||o!==I.NORMAL){const e=this._$getBounds(null),l=h.$boundsMatrix(e,r),$=+l.xMax,_=+l.xMin,c=+l.yMax,u=+l.yMin;h.$poolBoundsObject(e),h.$poolBoundsObject(l);const d=s.abs($-_),g=s.abs(c-u);if(0>=d||0>=g)return!1;if(0>_+d||0>u+g)return!1;const f=t.frameBuffer.currentAttachment;if(_>f.width||u>f.height)return!1;n.basePosition.x=i[4],n.basePosition.y=i[5];let p=this._$getLayerBounds(null);const m=h.$boundsMatrix(p,r);let x=s.abs(m.xMax-m.xMin),b=s.abs(m.yMax-m.yMin);h.$poolBoundsObject(m),x===d&&b===g&&(h.$poolBoundsObject(p),p=null);let T=r[4]-s.floor(_),v=r[5]-s.floor(u),y=null;if(p){const t=h.$getFloat32Array6(r[0],r[1],r[2],r[3],0,0);y=h.$boundsMatrix(p,t),h.$poolBoundsObject(p),h.$poolFloat32Array6(t),T+=-s.floor(y.xMin)-T,v+=-s.floor(y.yMin)-v}let E=s.floor(_),A=s.floor(u),M=_,C=u;if(y&&(E-=-s.floor(y.xMin)-(r[4]-E),A-=-s.floor(y.yMin)-(r[5]-A),M-=-y.xMin-(r[4]-M),C-=-y.yMin-(r[5]-C),h.$poolBoundsObject(y)),n.position.dx=E>0?E:0,n.position.dy=A>0?A:0,x+M>f.texture.width&&(x-=x-f.texture.width+M),b+C>f.texture.height&&(b-=b-f.texture.height+C),0>E&&(T+=E,x+=M),0>A&&(v+=A,b+=C),0>=x||0>=b||!x||!b)return h.$poolPreObject(n),!1;t._$startLayer(h.$getBoundsObject(M,0,C,0)),n.canApply=this._$canApply(a);let S=this._$isFilterUpdated(x,b,r,a,n.canApply,n.basePosition.x,n.basePosition.y);const R=t._$cacheCurrentBuffer;t._$cacheCurrentBuffer=null;const w=t._$cacheCurrentBounds,O=h.$getBoundsObject(w.x,w.w,w.y,w.h);S&&(this._$buffer=t.frameBuffer.createCacheAttachment(s.ceil(x),s.ceil(b),!1),t._$bind(this._$buffer)),n.isFilter=!0,n.isUpdated=S,n.color=h.$getFloat32Array8(),n.baseMatrix=r,n.currentAttachment=f,n.currentMaskBuffer=R,n.currentMaskBounds=O,n.filters=a,n.blendMode=o,n.layerWidth=x,n.layerHeight=b,n.matrix=h.$getFloat32Array6(r[0],r[1],r[2],r[3],T,v)}return n}_$postDraw(t,e,i,s){const r=[this._$instanceId,"f"];let n=null;if(this._$buffer){n=t.frameBuffer.getTextureFromCurrentAttachment();const e=h.$cacheStore().get(r);e&&(h.$cacheStore().set(r,null),t.frameBuffer.releaseTexture(e))}else n=h.$cacheStore().get(r);s.canApply||(n._$offsetX=0,n._$offsetY=0);let a=n._$offsetX,o=n._$offsetY;if(s.isUpdated&&s.canApply){let i=h.$cacheStore().get(r);i&&(h.$cacheStore().set(r,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,t.frameBuffer.releaseTexture(i),i=null);const l=s.filters.length;if(l){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<l;++i)n=s.filters[i]._$applyFilter(t,e);a=t._$offsetX,o=t._$offsetY,t._$offsetX=0,t._$offsetY=0,n._$offsetX=a,n._$offsetY=o}}if(s.isUpdated){n.filterState=s.canApply;const t=s.baseMatrix;n.matrix=t[0]+"_"+t[1]+"_"+t[2]+"_"+t[3]+"_"+s.basePosition.x+"_"+s.basePosition.y,n.layerWidth=s.layerWidth,n.layerHeight=s.layerHeight}h.$cacheStore().set(r,n),h.$poolArray(r),t._$bind(s.currentAttachment);const l=n.width,$=n.height;h.$resetContext(t),t._$globalAlpha=h.$clamp(i[3]+i[7]/255,0,1),t._$globalCompositeOperation=s.blendMode,t.setTransform(1,0,0,1,0,0),t.drawImage(n,-a+s.position.dx,-o+s.position.dy,l,$,i),t._$endLayer(),this._$buffer&&(t.frameBuffer.releaseAttachment(this._$buffer,!1),this._$buffer=null),t._$cacheCurrentBuffer=s.currentMaskBuffer,t._$cacheCurrentBounds.x=s.currentMaskBounds.xMin,t._$cacheCurrentBounds.y=s.currentMaskBounds.yMin,t._$cacheCurrentBounds.w=s.currentMaskBounds.xMax,t._$cacheCurrentBounds.h=s.currentMaskBounds.yMax,h.$poolFloat32Array8(s.color),h.$poolFloat32Array6(s.matrix),h.$poolFloat32Array6(s.baseMatrix),h.$poolBoundsObject(s.currentMaskBounds),h.$poolPreObject(s)}_$shouldClip(t){if(this instanceof ht)return!(!this.textWidth||!this.textHeight);const e=this._$getBounds(t),i=s.abs(e.xMax-e.xMin),r=s.abs(e.yMax-e.yMin);return h.$poolBoundsObject(e),!(!i||!r)}_$startClip(t,e){let i=null;return!(!t._$cacheCurrentBuffer&&(i=t._$startClip(this,e),!i))&&(t._$enterClip(),t._$beginClipDef(),this instanceof C&&(t._$mask._$containerClip=!0),this._$clip(t,i||e),this._$updated=!1,t._$mask._$containerClip&&(t._$mask._$containerClip=!1,t._$drawContainerClip()),t._$endClipDef(),i)}}class M extends A{constructor(){super(),this._$mouseEnabled=!0}static toString(){return"[class InteractiveObject]"}static get namespace(){return"next2d.display.InteractiveObject"}toString(){return"[object InteractiveObject]"}get namespace(){return"next2d.display.InteractiveObject"}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=!!t}}class C extends M{constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=h.$getArray(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=h.$getMap(),new Proxy(this,{get:(t,e)=>t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]})}static toString(){return"[class DisplayObjectContainer]"}static get namespace(){return"next2d.display.DisplayObjectContainer"}toString(){return"[object DisplayObjectContainer]"}get namespace(){return"next2d.display.DisplayObjectContainer"}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=!!t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){if(!(t instanceof A))throw new TypeError("TypeError: addChild: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));return this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){if(!(t instanceof A))throw new TypeError("TypeError: addChildAt: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),s=i.length;if(0>e||e>s)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(s&&s>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(!(t instanceof A))throw new TypeError("TypeError: contains: not DisplayObject.");if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren(),i=e.length;for(let s=0;s<i;++s){const i=e[s];if(i._$instanceId===t._$instanceId)return!0;if(i instanceof C&&i.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren(),i=e.length;if(0>t||t>i)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren(),i=e.length;for(let s=0;s<i;++s){const i=e[s];if(i.name===t)return i}return null}getChildIndex(t){if(!(t instanceof A))throw new TypeError("TypeError: getChildIndex: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError("ArgumentError: getChildIndex: not child");const e=this._$getChildren().indexOf(t);if(-1===e)throw new ArgumentError("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(!(t instanceof A))throw new TypeError("TypeError: removeChild: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError(`ArgumentError: removeChild: index error: ${index}`);return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const i=this._$getChildren(),r=i.length;if(r){t=h.$clamp(t,0,2147483646,0)-1,e=h.$clamp(e,1,134217727,134217727);for(let n=s.min(e,r-1);n>t;--n)this._$remove(i[n])}}setChildIndex(t,e){if(!(t instanceof A))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this.getChildIndex(t);if(i===e)return;const s=this._$getChildren();s.splice(i,1),s.splice(e,0,t),this._$doChanged()}swapChildren(t,e){if(!(t instanceof A&&e instanceof A))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this._$getChildren(),s=this.getChildIndex(t),r=this.getChildIndex(e);i[s]=e,i[r]=t,this._$doChanged()}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=h.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==h.$MATRIX_ARRAY_IDENTITY&&(e=h.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),n=this._$needsChildren?this._$getChildren():this._$children,a=n.length;if(!a&&!i){const i=h.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&h.$poolFloat32Array6(e),i}const o=r.MAX_VALUE;let l=o,$=-o,_=o,c=-o;if(i){const t=h.$boundsMatrix(this._$graphics._$getBounds(),e);l=t.xMin,$=t.xMax,_=t.yMin,c=t.yMax,h.$poolBoundsObject(t)}for(let t=0;t<a;++t){const i=n[t]._$getBounds(e);l=s.min(l,i.xMin),$=s.max($,i.xMax),_=s.min(_,i.yMin),c=s.max(c,i.yMax),h.$poolBoundsObject(i)}return t&&e!==t&&h.$poolFloat32Array6(e),h.$getBoundsObject(l,$,_,c)}_$getLayerBounds(t=null){let e=h.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==h.$MATRIX_ARRAY_IDENTITY&&(e=h.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),n=this._$needsChildren?this._$getChildren():this._$children,a=n.length;if(!a&&!i){const i=h.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&h.$poolFloat32Array6(e),i}const o=r.MAX_VALUE;let l=o,$=-o,_=o,c=-o;if(i){const t=h.$boundsMatrix(this._$graphics._$getBounds(),e);l=+t.xMin,$=+t.xMax,_=+t.yMin,c=+t.yMax,h.$poolBoundsObject(t)}for(let t=0;t<a;++t){const i=n[t]._$getLayerBounds(e);l=s.min(l,i.xMin),$=s.max($,i.xMax),_=s.min(_,i.yMin),c=s.max(c,i.yMax),h.$poolBoundsObject(i)}if(t&&e!==t&&h.$poolFloat32Array6(e),!t)return h.$getBoundsObject(l,$,_,c);const u=this._$filters||this.filters,d=u.length;if(!d)return h.$getBoundsObject(l,$,_,c);let g=new y(l,_,$-l,c-_);for(let t=0;t<d;++t)g=u[t]._$generateFilterRect(g,null,null,!0);return l=g._$x,$=g._$x+g._$width,_=g._$y,c=g._$y+g._$height,h.$getBoundsObject(l,$,_,c)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=this._$currentFrame||1;if(!this._$controller)return this._$children;let e=this._$controller[t];const i=this._$children.length;if(!i){if(e){const t=e.length;for(let i=0;i<t;++i){const t=this._$createInstance(e[i]);t._$placeId=i,this._$children.push(t),t._$name&&this._$names.set(t._$name,t)}}return this._$children}const s=h.$getMap(),r=h.$getMap();let n=0;const a=h.$getArray();for(let o=0;o<i;++o){const i=this._$children[o],h=i._$parent;if(!h||h._$instanceId!==this._$instanceId)continue;const l=i._$startFrame,$=i._$endFrame;if(1===l&&0===$||l<=t&&$>t){if(i._$filters=null,i._$blendMode=null,-1===i._$id){a.push(i),i._$name&&this._$names.set(i._$name,i);continue}const t=e[n];if(i._$id===t){i._$placeId=n,a.push(i),i._$name&&this._$names.set(i._$name,i),r.has(t)&&r.delete(t),s.set(t,!0),n++;continue}r.set(i._$id,i)}else i.willTrigger(_.REMOVED)&&i.dispatchEvent(new _(_.REMOVED,!0)),i.willTrigger(_.REMOVED_FROM_STAGE)&&i.dispatchEvent(new _(_.REMOVED_FROM_STAGE,!0)),i._$added=!1,i._$addedStage=!1,i._$active=!1,i._$updated=!0,i._$filters=null,i._$blendMode=null,i._$isNext=!0,i instanceof C&&(i._$executeRemovedFromStage(),i._$removeParentAndStage())}if(e)for(let t=0;t<e.length;++t){const i=e[t];if(s.has(i))continue;const n=r.has(i)?r.get(i):this._$createInstance(i);n._$placeId=t,a.push(n),n._$name&&this._$names.set(n._$name,n)}h.$poolMap(s),h.$poolMap(r),h.$poolArray(this._$children),this._$children=null,this._$children=a}return this._$children}_$clearChildren(){this._$doChanged(),h.$isUpdated=!0,this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$stage=this.constructor===j?this:this._$stage,t._$parent=this,t._$root=this.constructor===j?t:this._$root,t instanceof C&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger(_.ADDED)&&t.dispatchEvent(new _(_.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(t.willTrigger(_.ADDED_TO_STAGE)&&t.dispatchEvent(new _(_.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof C&&t._$executeAddedToStage()),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e._$root=this._$root,e._$stage=this._$stage,e instanceof C&&(e._$setParentAndStage(),e._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage||(e.willTrigger(_.ADDED_TO_STAGE)&&e.dispatchEvent(new _(_.ADDED_TO_STAGE)),e._$addedStage=!0),e instanceof C&&e._$executeAddedToStage())}}_$remove(t,e=!0){t._$transform._$transform();const i=this._$needsChildren?this._$getChildren():this._$children,s=this.getChildIndex(t);return i.splice(s,1),this._$names.delete(t.name),e&&(t.willTrigger(_.REMOVED)&&t.dispatchEvent(new _(_.REMOVED,!0)),null!==this._$stage&&(t.willTrigger(_.REMOVED_FROM_STAGE)&&t.dispatchEvent(new _(_.REMOVED_FROM_STAGE)),t instanceof C&&t._$executeRemovedFromStage()),t instanceof C&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,this._$doChanged()),t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0),e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage&&(e.willTrigger(_.REMOVED_FROM_STAGE)&&e.dispatchEvent(new _(_.REMOVED_FROM_STAGE)),e._$addedStage=!1),e instanceof C&&e._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e instanceof C&&e._$removeParentAndStage(),e._$stage=null,e._$root=null,e._$addedStage=!1}if(this._$sounds){const t=this._$sounds.values();for(const e of t)for(let t=0;t<e.length;++t){e[t].stop()}}}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,this._$isNext}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();s!==h.$MATRIX_ARRAY_IDENTITY&&(i=h.$multiplicationMatrix(e,s)),this._$graphics&&this._$graphics._$getBounds()&&this._$graphics._$clip(t,i);const r=this._$getChildren(),n=r.length;for(let e=0;e<n;++e){const s=r[e];s._$isMask||(s._$clip(t,i),s._$updated=!1)}i!==e&&h.$poolFloat32Array6(i)}_$draw(t,e,i){if(!this._$visible)return;let r=i;const n=this._$transform._$rawColorTransform();n!==h.$COLOR_ARRAY_IDENTITY&&(r=h.$multiplicationColor(i,n));if(!h.$clamp(r[3]+r[7]/255,0,1,0))return;const a=this._$needsChildren?this._$getChildren():this._$children,o=a.length;if(!(o||this._$graphics&&this._$graphics._$canDraw))return;const l=this._$preDraw(t,e);if(!l)return;if(l.isFilter&&!l.isUpdated)return void this._$postDraw(t,e,r,l);let $=l.matrix;const _=l.isFilter?l.color:r;this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$draw(t,$,_);let c=!0,u=null;const d=h.$getArray(),g=h.$getArray(),f=h.$getArray(),p=h.$getArray(),m=t._$isLayer,x=this._$isUpdated();for(let e=0;e<o;++e){const i=a[e];if(x&&(i._$placeObject=null),i._$isMask)continue;const r=i._$blendMode||i.blendMode;if((r===I.ALPHA||r===I.ERASE)&&!m)continue;if(u&&(i._$placeId>u||i._$clipDepth>0)&&(t.restore(),c&&(t._$leaveClip(),d.length&&(h.$poolFloat32Array6($),$=d.pop())),u=f.length?f.pop():null,c=p.pop()),!c)continue;if(i._$clipDepth>0){if(t.save(),u&&f.push(u),p.push(c),u=i._$clipDepth,c=i._$shouldClip($),c){const e=i._$startClip(t,$);if(!1===e){c=!1;continue}e&&(d.push($),$=e)}continue}const n=i._$mask;if(n){let e;if(n._$updated=!1,this===n._$parent)e=$;else{e=h.$MATRIX_ARRAY_IDENTITY;let i=n._$parent;for(;i;)e=h.$multiplicationMatrix(i._$transform._$rawMatrix(),e),i=i._$parent;const s=this.stage._$player,r=s._$scale*s._$ratio/20,a=h.$getFloat32Array6(r,0,0,r,0,0);if(e=h.$multiplicationMatrix(a,e),t._$isLayer){const i=t._$getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t._$cacheCurrentBuffer&&(e[4]-=t._$cacheCurrentBounds.x,e[5]-=t._$cacheCurrentBounds.y)}if(!n._$shouldClip(e))continue;let i=n._$startClip(t,e);if(t.save(),!1===i){t.restore();continue}if(i){if(g.push($),this!==n._$parent){const e=this._$transform._$rawMatrix();i[0]=s.abs($[0])*s.sign(e[0]),i[1]=s.abs($[1])*s.sign(e[1]),i[2]=s.abs($[2])*s.sign(e[2]),i[3]=s.abs($[3])*s.sign(e[3]),i[4]=$[4]-t._$cacheCurrentBounds.x,i[5]=$[5]-t._$cacheCurrentBounds.y}$=i}}i._$draw(t,$,_),i._$updated=!1,n&&(t.restore(),t._$leaveClip(),g.length&&(h.$poolFloat32Array6($),$=g.pop()))}if(u&&(t.restore(),p.pop()&&t._$leaveClip()),h.$poolArray(d),h.$poolArray(g),h.$poolArray(f),h.$poolArray(p),l.isFilter)return this._$postDraw(t,e,r,l);h.$poolFloat32Array6($),h.$poolPreObject(l)}_$mouseHit(t,e,i,r=!0){let n=e;const a=this._$transform._$rawMatrix();a!==h.$MATRIX_ARRAY_IDENTITY&&(n=h.$multiplicationMatrix(e,a));const o=this._$getChildren(),l=h.$getArray(),$=h.$getArray(),_=h.$getMap();let c=o.length,u=null,d=null;for(let t=0;t<c;++t){const e=o[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?(d=l.length,u=e._$clipDepth,l.push(e)):(u&&e._$placeId>u&&(d=null,u=null),null!==d&&_.set(e._$instanceId,d),$.push(e)))}const g=s.min(this._$mouseChildren,r);let f=!1;const p=this._$root===this;c=$.length;for(let e=0;e<c;++e){const e=$.pop();if(e._$isMask)continue;if(p&&!(e instanceof M))continue;if(_.has(e._$instanceId)){if(!l[_.get(e._$instanceId)]._$hit(t,n,i,!0))continue}const s=e._$mask;if(s)if(this===s._$parent){if(!s._$hit(t,n,i,!0))continue}else{let e=h.$MATRIX_ARRAY_IDENTITY,r=s._$parent;for(;r;)e=h.$multiplicationMatrix(r._$transform._$rawMatrix(),e),r=r._$parent;if(!s._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,n,i,g)||e._$hitArea&&e._$hitArea._$mouseHit(t,n,i,g)){if(e._$root===e)return!0;if(!g)return!0;if(f=!0,e instanceof M){if(!e._$mouseEnabled&&!e._$hitObject)continue;if(!h.$isTouch&&!i.pointer)switch(!0){case e instanceof ht:e._$type===lt.INPUT&&(i.pointer="text");break;case e.buttonMode&&e.useHandCursor:i.pointer="pointer"}return i.hit||(i.hit=!e._$mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}return h.$poolArray(l),h.$poolArray($),h.$poolMap(_),!f&&this._$graphics&&(f=this._$graphics._$hit(t,n,i)),n!==e&&h.$poolFloat32Array6(n),f}_$hit(t,e,i,s=!1){let r=e;const n=this._$transform._$rawMatrix();n!==h.$MATRIX_ARRAY_IDENTITY&&(r=h.$multiplicationMatrix(e,n));const a=this._$getChildren();for(let e=a.length-1;e>-1;--e){const n=a[e];if(!n._$isMask&&n._$hit(t,r,i,s))return!0}let o=!1;return this._$graphics&&(o=this._$graphics._$hit(t,r,i)),r!==e&&h.$poolFloat32Array6(r),o}_$createInstance(t){const e=this._$dictionary[t],i=this._$loaderInfo._$data.characters[e.characterId];i.class||(i.class=i.symbol&&h.$getClass(i.symbol)||h.$getClass(i.extends)),h.$currentLoaderInfo=null;const s=new i.class;return s._$build(e,this),s._$id=t,s}_$outCheck(t,e){let i=h.$MATRIX_ARRAY_IDENTITY,s=this._$parent;for(;s;)i=h.$multiplicationMatrix(s._$transform._$rawMatrix(),i),s=s._$parent;return h.$hitContext.setTransform(1,0,0,1,0,0),h.$hitContext.beginPath(),this._$mouseHit(h.$hitContext,i,{x:t,y:e})}}class S extends C{constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=!!t}get dropTarget(){return h.$dropTarget}get graphics(){return this._$graphics||(this._$graphics=new P,this._$graphics._$displayObject=this),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=null,t instanceof S&&(this._$hitArea=t,t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new dt),this._$soundTransform}set soundTransform(t){t instanceof dt&&(this._$soundTransform=t)}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=!!t}startDrag(t=!1,e=null){let i=0,s=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,s=this.y-t.y}h.$dropTarget=this,h.$dragRules.lock=t,h.$dragRules.position.x=i,h.$dragRules.position.y=s,h.$dragRules.bounds=e}stopDrag(){h.$dropTarget=null,h.$dragRules.lock=!1,h.$dragRules.position.x=0,h.$dragRules.position.y=0,h.$dragRules.bounds=null}_$sync(){const t=super._$sync();return t&&(this._$controller=t.controller,this._$dictionary=t.dictionary,this._$placeMap=t.placeMap,this._$placeObjects=t.placeObjects),t}_$build(t,e){const i=super._$build(t,e);return this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(h.$currentMousePoint()):this.globalToLocal(h.$currentMousePoint())}}class R extends S{constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=h.$getMap(),this._$frameCache=h.$getMap(),this._$labels=null,this._$sounds=h.$getMap(),this._$channels=h.$getMap(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)?this._$labels.get(t):null}get currentLabels(){return this._$labels?h.$Array.from(this._$labels.values()):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=h.$getMap()),t instanceof F&&this._$labels.set(t.frame,t)}addFrameScript(){const t=arguments.length;for(let e=0;e<t;e+=2){let t=arguments[e];h.$isNaN(0|t)&&(t=this._$getFrameForLabel(t)),t|=0;const i=arguments[e+1];if(i&&t&&this._$totalFrames>=t&&this._$addAction(t,i),t===this._$currentFrame){const t=h.$currentPlayer();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push.apply(t._$actions,e),t._$actionOffset=0}}}}_$getFrameForLabel(t){for(let[e,i]of this._$labels)if(i.name===t)return 0|e;return 0}_$addAction(t,e){(t|=0)&&(this._$actions.has(t)||this._$actions.set(t,h.$getArray()),this._$actions.get(t).push(e))}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e.willTrigger(_.FRAME_LABEL)&&e.dispatchEvent(new _(_.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=h.$currentPlayer();if(t){-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}}_$goToFrame(t){if(h.$isNaN(+t)&&(t=this._$getFrameForLabel(t)),t<1&&(t=1),t>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const e=h.$currentPlayer();switch(!0){case t!==this._$currentFrame:{this._$wait=!1;const i=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",t),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=t,this._$clearChildren(),e._$actionOffset=e._$actions.length;const s=e._$actionOffset?e._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),e._$actionOffset&&e._$actionOffset!==e._$actions.length){const t=e._$actions.splice(0,e._$actionOffset);e._$actions.push.apply(e._$actions,t),e._$actionOffset=0}if(!this._$actionProcess&&(s>-1||!e._$actionOffset))for(;e._$actions.length&&e._$actions.length!==s;){const t=e._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const i=t._$currentFrame;if(!t._$actions.has(i))continue;const s=t._$actions.get(i),r=s.length;for(let e=0;e<r;++e)try{h.$currentLoaderInfo=t._$loaderInfo,s[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=i,this._$clearChildren())}break;case!this._$actionProcess&&e._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=e._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const s=e._$actions.get(i),r=s.length;for(let t=0;t<r;++t)try{h.$currentLoaderInfo=e._$loaderInfo,s[t].apply(e)}catch(t){e.stop()}}}}h.$currentLoaderInfo=null,this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!e._$sounds.has(this._$instanceId)&&e._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$draw(t,e,i){super._$draw(t,e,i);const s=h.$currentPlayer();this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!s._$sounds.has(this._$instanceId)&&s._$sounds.set(this._$instanceId,this)}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:t=!0,this._$canAction=!0,this._$canSound=!0,++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1),this._$clearChildren()}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$setAction(),this._$isNext=t,this._$isNext}_$buildCharacter(t){for(let e=0;e<t.sounds.length;++e){const i=t.sounds[e],s=h.$getArray();for(let t=0;t<i.sound.length;++t){const e=new ct;e._$build(i.sound[t],this),s.push(e)}this._$sounds.set(i.frame,s)}for(let e=0;e<t.actions.length;++e){const i=t.actions[e];i.script||(i.script=Function(i.action)),this._$addAction(i.frame,i.script)}for(let e=0;e<t.labels.length;++e){const i=t.labels[e];this.addFrameLabel(new F(i.name,i.frame))}this._$totalFrames=t.totalFrame||1}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$soundPlay(){const t=this._$sounds.get(this._$currentFrame);if(!t)return;const e=t.length;if(e){let i=this._$soundTransform,s=this._$parent;for(;s;)s._$soundTransform&&(i=s._$soundTransform),s=s._$parent;for(let s=0;s<e;++s){const e=t[s];i&&(e.loop=i.loop,e.volume=i.volume),e.play()}}this._$canSound=!1}}class w{constructor(t=0,i=0,s=!0,r=4294967295){this._$width=0|t,this._$height=0|i,this._$transparent=s,this._$color=this._$toRGBA(h.$clamp(r,0,4294967295,4294967295)),this._$instanceId=e++,this._$buffer=null,this._$image=null,this._$canvas=null,this._$pixelBuffer=null}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get height(){return this._$height}get image(){return this._$image}set image(t){this._$canvas=null,this._$image=t,this._$width=t.width,this._$height=t.height}get canvas(){return this._$canvas}set canvas(t){this._$image=null,this._$canvas=t,this._$width=t.width,this._$height=t.height}get transparent(){return this._$transparent}get width(){return this._$width}get _$texture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=h.$currentPlayer(),s=i._$cacheStore,r=s.generateKeys(this._$instanceId);let n=s.get(r);if(!n){const a=i._$context;switch(!0){case null!==this._$image:n=a.frameBuffer.createTextureFromImage(this._$image),this._$image=null;break;case null!==this._$canvas:n=a.frameBuffer.createTextureFromCanvas(this._$canvas),this._$canvas=null;break;case null!==this._$pixelBuffer:n=a.frameBuffer.createTextureFromPixels(t,e,a.pbo.getBufferSubDataAsync(this._$pixelBuffer),!0),this._$pixelBuffer=null;break;case null!==this._$buffer:n=a.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0),this._$buffer=null;break;default:{const i=a.frameBuffer.currentAttachment,s=a.frameBuffer.createCacheAttachment(t,e,!1);a._$bind(s),h.$resetContext(a),a.fillStyle=[this._$color.R/255,this._$color.G/255,this._$color.B/255,this._$color.A/255],a.setTransform(1,0,0,1,0,0),a.beginPath(),a.fillRect(0,0,t,e),n=a.frameBuffer.getTextureFromCurrentAttachment(),i?a._$bind(i):a.frameBuffer.unbind(),a.frameBuffer.releaseAttachment(s,!1)}}s.set(r,n)}return h.$poolArray(r),n._$bitmapData||(n._$bitmapData=this),n}set _$texture(t){this._$setPixelQueue=null,this._$setPixelCount=0,this._$linePixelsCache=null,this._$linePixelsCacheY=null;const e=h.$currentPlayer(),i=e._$cacheStore,s=i.generateKeys(this._$instanceId),r=i.get(s);r&&(r._$bitmapData&&delete r._$bitmapData,e._$context.frameBuffer.releaseTexture(r),i.set(s,null)),this._$buffer&&(this._$buffer=null),i.set(s,t),h.$poolArray(s),t._$bitmapData||(t._$bitmapData=this)}draw(t,e=null,i=null,s=I.NORMAL,r=null,n=!1){const a=this._$width,o=this._$height;if(!a||!o)return;const l=h.$currentPlayer()._$context,$=l.frameBuffer.currentAttachment,_=l.frameBuffer.createCacheAttachment(a,o,!1);if(l._$bind(_),h.$resetContext(l),l.setTransform(1,0,0,1,0,0),r){const t=r.x,e=r.y,i=r.width,s=r.height;l.save(),l._$enterClip(),l._$beginClipDef(),l.setTransform(1,0,0,1,0,0),l.beginPath(),l.moveTo(t,e),l.lineTo(t+i,e),l.lineTo(t+i,e+s),l.lineTo(t,e+s),l.lineTo(t,e),l.clip(!0),l._$endClipDef()}let c=e?e._$matrix:h.$MATRIX_ARRAY_IDENTITY,u=i?i._$colorTransform:h.$COLOR_ARRAY_IDENTITY;if(t instanceof A){const i=t._$transform.matrix;i.invert(),e&&(c=h.$multiplicationMatrix(c,i._$matrix)),t._$draw(l,c,u),h.$poolMatrix(i)}else{new Bitmap(t,PixelSnapping.AUTO,n)._$draw(l,c,u)}r&&(l.restore(),l._$leaveClip());const d=l.frameBuffer.getTextureFromCurrentAttachment(),g=l.frameBuffer.createTextureAttachmentFrom(this._$texture);l._$bind(g),l.frameBuffer.releaseAttachment(_,!1),h.$resetContext(l),l.setTransform(1,0,0,1,0,0),l._$imageSmoothingEnabled=n,l._$globalCompositeOperation=s,l.drawImage(d,0,0,a,o),$?l._$bind($):l.frameBuffer.unbind(),l.frameBuffer.releaseTexture(d),l.frameBuffer.releaseAttachment(g,!1)}_$toRGBA(t){return this._$transparent?h.$uintToRGBA(t):h.$intToRGBA(t)}_$getPixelsAsync(t,e,i,r,n="RGBA"){t=Math.max(t,0),e=Math.max(e,0);const a=s.min(i,this.width-t),o=s.min(r,this.height-e);if(a<=0||o<=0)return;const l=h.$currentPlayer()._$context;if(!l)return;const $=l._$shaderList._$bitmapData.getPixels[n].instance;l._$shaderList.bitmapShaderVariants.setGetPixelsUniform($.uniform,a/this.width,-o/this.height,t/this.width,1-e/this.height);const _=l.frameBuffer.currentAttachment,c=l.frameBuffer.createCacheAttachment(a,o,!1);l._$bind(c),l._$frameBufferManager._$textureManager.bind0(this._$texture,!1),l.blend.disable(),$._$drawImage(),l.blend.enable(),this._$pixelBuffer=l.pbo.readPixelsAsync(0,0,this.width,this.height),_?l._$bind(_):l.frameBuffer.unbind(),l.frameBuffer.releaseAttachment(c)}_$getPixels(t,e,i,r,n="ARGB",a=null){switch(n){case"ARGB":case"RGBA":case"BGRA":break;default:throw new Error(`Unsupported byteOrder: ${n}`)}t=Math.max(t,0),e=Math.max(e,0);const o=s.min(i,this.width-t),l=s.min(r,this.height-e);if(o<=0||l<=0)return new Uint8Array(0);const $=a?a(o*l*4):new Uint8Array(o*l*4),_=h.$currentPlayer()._$context;if(!_)return $;const c=_._$shaderList._$bitmapData.getPixels[n].instance;_._$shaderList.bitmapShaderVariants.setGetPixelsUniform(c.uniform,o/this.width,-l/this.height,t/this.width,1-e/this.height);const u=_.frameBuffer.currentAttachment,d=_.frameBuffer.createCacheAttachment(o,l,!1);_._$bind(d),_._$frameBufferManager._$textureManager.bind0(this._$texture,!1),_.blend.disable(),c._$drawImage(),_.blend.enable();const g=_._$gl;return g.readPixels(0,0,o,l,g.RGBA,g.UNSIGNED_BYTE,$),u?_._$bind(u):_.frameBuffer.unbind(),_.frameBuffer.releaseAttachment(d),$}toImage(){const{width:t,height:e}=this,i=new Image;if(t||e){const s=h.$cacheStore().getCanvas();s.width=t,s.height=e;const r=new ImageData(t,e);r.data.set(this._$getPixels(0,0,t,e,"RGBA"));const n=s.getContext("2d");n.putImageData(r,0,0),i.width=t,i.height=e,i.src=n.canvas.toDataURL(),h.$cacheStore().destroy(n)}return i}toUint8Array(){return this._$buffer?this._$buffer:this._$getPixels(0,0,this.width,this.height,"RGBA")}}class O{static toString(){return"[class BitmapDataChannel]"}static get namespace(){return"next2d.display.BitmapDataChannel"}toString(){return"[object BitmapDataChannel]"}get namespace(){return"next2d.display.BitmapDataChannel"}static get ALPHA(){return 8}static get BLUE(){return 4}static get GREEN(){return 2}static get RED(){return 1}}class I{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}}class B{static toString(){return"[class CapsStyle]"}static get namespace(){return"next2d.display.CapsStyle"}toString(){return"[object CapsStyle]"}get namespace(){return"next2d.display.CapsStyle"}static get NONE(){return"none"}static get ROUND(){return"round"}static get SQUARE(){return"square"}}class F extends c{constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class L{static toString(){return"[class GradientType]"}static get namespace(){return"next2d.display.GradientType"}toString(){return"[object GradientType]"}get namespace(){return"next2d.display.GradientType"}static get LINEAR(){return"linear"}static get RADIAL(){return"radial"}}class P{constructor(t=null){this._$displayObject=t,this.clear()}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}static get BITMAP_STROKE(){return 14}beginBitmapFill(t,e=null,i=!0,s=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=h.$getArray()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$fills.push(P.BEGIN_PATH),this._$fillType=P.BITMAP_FILL,this._$fillBitmap=new D(t,e,i,s),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=h.$getArray()),t=h.$clamp(h.$toColorInt(t),0,16777215,0),e=h.$clamp(e,0,1,1),this._$maxAlpha=s.max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$fills.push(P.BEGIN_PATH);const i=h.$intToRGBA(t,e);return this._$fillType=P.FILL_STYLE,this._$fillStyleR=i.R,this._$fillStyleG=i.G,this._$fillStyleB=i.B,this._$fillStyleA=i.A,this}beginGradientFill(t,e,i,r,n=null,a=Y.PAD,o=U.RGB,l=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=h.$getArray());const $=i.length;for(let t=0;t<$;++t)this._$maxAlpha=s.max(this._$maxAlpha,i[t]);return this._$doFill=!0,this._$canDraw=!0,this._$fills.push(P.BEGIN_PATH),this._$fillType=P.GRADIENT_FILL,this._$fillGradient=new N(t,e,i,r,n,a,o,l),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=0,this._$caps=B.NONE,this._$joints=k.ROUND,this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=r.MAX_VALUE,this._$xMax=-r.MAX_VALUE,this._$yMin=r.MAX_VALUE,this._$yMax=-r.MAX_VALUE,this._$recode&&h.$poolArray(this._$recode),this._$fills&&h.$poolArray(this._$fills),this._$lines&&h.$poolArray(this._$lines),this._$recode=null,this._$fills=null,this._$lines=null,this._$restart(),this}clone(){const t=new P;return t.copyFrom(this),t}copyFrom(t){t instanceof P&&(t._$fillGradient&&(this._$fillGradient=t._$fillGradient.clone()),t._$fillBitmap&&(this._$fillBitmap=t._$fillBitmap.clone()),this._$doFill=t._$doFill,this._$fillType=t._$fillType,this._$fillStyleR=t._$fillStyleR,this._$fillStyleG=t._$fillStyleG,this._$fillStyleB=t._$fillStyleB,this._$fillStyleA=t._$fillStyleA,t._$lineGradient&&(this._$lineGradient=t._$lineGradient.clone()),this._$doLine=t._$doLine,this._$lineType=t._$lineType,this._$caps=t._$caps,this._$joints=t._$joints,this._$miterLimit=t._$miterLimit,this._$lineWidth=t._$lineWidth,this._$lineStyleR=t._$lineStyleR,this._$lineStyleG=t._$lineStyleG,this._$lineStyleB=t._$lineStyleB,this._$lineStyleA=t._$lineStyleA,this._$xMin=t._$xMin,this._$xMax=t._$xMax,this._$yMin=t._$yMin,this._$yMax=t._$yMax,this._$maxAlpha=t._$maxAlpha,this._$pointerX=t._$pointerX,this._$pointerY=t._$pointerY,this._$canDraw=t._$canDraw,t._$fills&&(this._$fills=t._$fills.slice(0)),t._$lines&&(this._$lines=t._$lines.slice(0)),t._$recode&&(this._$recode=t._$recode.slice(0)))}cubicCurveTo(t,e,i,s,r,n){return r=+r||0,n=+n||0,this._$pointerX===r&&this._$pointerY===n||(t=+t||0,e=+e||0,i=+i||0,s=+s||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$setBounds(r,n),this._$margePath(h.$getArray(P.CUBIC,t,e,i,s,r,n)),this._$pointerX=r,this._$pointerY=n,this._$restart()),this}curveTo(t,e,i,s){return i=+i||0,s=+s||0,this._$pointerX===i&&this._$pointerY===s||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$margePath(h.$getArray(P.CURVE_TO,t,e,i,s)),this._$pointerX=i,this._$pointerY=s,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(h.$getArray(P.MOVE_TO,t+i,e,P.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,i,r){const n=(i=+i||0)/2,a=(r=+r||0)/2,o=(t=+t||0)+n,h=(e=+e||0)+a,l=t+i,$=e+r,_=4/3*(s.SQRT2-1),c=_*n,u=_*a;return this.moveTo(o,e).cubicCurveTo(o+c,e,l,h-u,l,h).cubicCurveTo(l,h+u,o+c,$,o,$).cubicCurveTo(o-c,$,t,h+u,t,h).cubicCurveTo(t,h-u,o-c,e,o,e)}drawRect(t,e,i,s){const r=(t=+t||0)+(i=+i||0),n=(e=+e||0)+(s=+s||0);return this.moveTo(t,e).lineTo(t,n).lineTo(r,n).lineTo(r,e).lineTo(t,e)}drawRoundRect(t,e,i,r,n,a=NaN){t=+t||0,e=+e||0,i=+i||0,r=+r||0;const o=(n=+n||0)/2,h=(a=+a||n)/2,l=4/3*(s.SQRT2-1),$=l*o,_=l*h,c=t+o,u=t+i,d=u-o,g=e+h,f=e+r,p=f-h;return this.moveTo(c,e).lineTo(d,e).cubicCurveTo(d+$,e,u,g-_,u,g).lineTo(u,p).cubicCurveTo(u,p+_,d+$,f,d,f).lineTo(c,f).cubicCurveTo(c-$,f,t,p+_,t,p).lineTo(t,g).cubicCurveTo(t,g-_,c-$,e,c,e)}endFill(){if(this._$doFill&&this._$fills.length>6)switch(this._$recode||(this._$recode=h.$getArray()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(P.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push.apply(this._$recode,this._$fills),this._$fillType){case P.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,P.END_FILL);break;case P.GRADIENT_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillGradient.toArray());break;case P.BITMAP_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$fills&&(h.$poolArray(this._$fills),this._$fills=null),this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine)switch(this._$recode||(this._$recode=h.$getArray()),this._$recode.push.apply(this._$recode,this._$lines),h.$poolArray(this._$lines),this._$lines=null,this._$lineType){case P.STROKE_STYLE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,P.END_STROKE);break;case P.GRADIENT_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$lineGradient.toArray());break;case P.BITMAP_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$lineType=0,this._$lineWidth=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps=B.NONE,this._$joints=k.ROUND,this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineBitmapStyle(t,e=null,i=!0,s=!1){return this._$doLine&&this.endLine(),this._$lines||(this._$lines=h.$getArray()),this._$maxAlpha=1,this._$doLine=!0,this._$canDraw=!0,this._$lines.push(P.BEGIN_PATH),this._$lineType=P.BITMAP_STROKE,this._$fillBitmap=new D(t,e,i,s),this}lineGradientStyle(t,e,i,r,n=null,a=Y.PAD,o=U.RGB,l=0){if(!this._$doLine)return this;this._$lines||(this._$lines=h.$getArray());const $=i.length;for(let t=0;t<$;++t)this._$maxAlpha=s.max(this._$maxAlpha,i[t]);return this._$lines.push(P.BEGIN_PATH),this._$lineType=P.GRADIENT_STROKE,this._$lineGradient=new N(t,e,i,r,n,a,o,l),this}lineStyle(t=1,e=0,i=1,r=B.ROUND,n=k.ROUND,a=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=h.$getArray()),e=h.$clamp(h.$toColorInt(e),0,16777215,0),i=h.$clamp(+i,0,1,1),this._$maxAlpha=s.max(this._$maxAlpha,i),this._$doLine=!0,this._$canDraw=!0,this._$lines.push(P.BEGIN_PATH,P.MOVE_TO,this._$pointerX,this._$pointerY);const o=h.$intToRGBA(e,i);return this._$lineType=P.STROKE_STYLE,this._$lineStyleR=o.R,this._$lineStyleG=o.G,this._$lineStyleB=o.B,this._$lineStyleA=o.A,this._$lineWidth=t,this._$caps=`${r}`,this._$joints=`${n}`,this._$joints===k.MITER&&(this._$miterLimit=a),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(h.$getArray(P.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){return t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e),this._$margePath(h.$getArray(P.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,e){const i=this._$getBounds(),r=h.$boundsMatrix(i,e);let n=s.ceil(s.abs(r.xMax-r.xMin)),a=s.ceil(s.abs(r.yMax-r.yMin));switch(h.$poolBoundsObject(i),h.$poolBoundsObject(r),!0){case 0===n:case 0===a:case n===-h.$Infinity:case a===-h.$Infinity:case n===h.$Infinity:case a===h.$Infinity:return}h.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$doDraw(t,h.$COLOR_ARRAY_IDENTITY,!0),t.clip()}_$drawBitmap(t,e,i,r=I.NORMAL,n=null){if(!this._$maxAlpha)return;const a=h.$clamp(i[3]+i[7]/255,0,1),o=this._$displayObject;let l=e;const $=o._$transform._$rawMatrix();$!==h.$MATRIX_ARRAY_IDENTITY&&(l=h.$multiplicationMatrix(e,$));const _=this._$getBounds(),c=h.$boundsMatrix(_,l),u=c.xMax,d=c.xMin,g=c.yMax,f=c.yMin;h.$poolBoundsObject(c),h.$poolBoundsObject(_);let p=s.ceil(s.abs(u-d)),m=s.ceil(s.abs(g-f));switch(!0){case 0===p:case 0===m:case p===-h.$Infinity:case m===-h.$Infinity:case p===h.$Infinity:case m===h.$Infinity:return}const x=t.frameBuffer.currentAttachment;if(d>x.width||f>x.height)return;const b=s.sqrt(l[0]*l[0]+l[1]*l[1]),T=s.sqrt(l[2]*l[2]+l[3]*l[3]);if(0>d+p||0>f+m){if(!(n&&n.length&&o._$canApply(n)))return;{let t=new y(0,0,p,m);for(let e=0;e<n.length;++e)t=n[e]._$generateFilterRect(t,b,T);if(0>t.x+t.width||0>t.y+t.height)return}}const v=h.$getArray(l[0],l[1],l[2],l[3]),E=h.$cacheStore().generateKeys(o._$instanceId,v,i);h.$poolArray(v);let A=h.$cacheStore().get(E);if(!A){const s=t._$textureScale(p,m);s<1&&(p*=s,m*=s);const r=t.frameBuffer.createCacheAttachment(p,m,!0);t._$bind(r),h.$resetContext(t),i[3]=1;const n=p/2,a=m/2,o=h.$devicePixelRatio,l=h.$getFloat32Array6(1/o,0,0,1/o),_=h.$getFloat32Array6(e[0],e[1],e[2],e[3],0,0),c=h.$multiplicationMatrix(l,_);h.$poolFloat32Array6(l),h.$poolFloat32Array6(_);const u=h.$getFloat32Array6(1,0,0,1,-n,-a),d=h.$multiplicationMatrix(c,u);h.$poolFloat32Array6(c),h.$poolFloat32Array6(u),h.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],d[4]+n,d[5]+a),h.$poolFloat32Array6(d),t.beginPath(),this._$runTransformCommand(t,$,i),A=t.frameBuffer.getTextureFromCurrentAttachment(),h.$cacheStore().set(E,A),t.frameBuffer.releaseAttachment(r,!1),t._$bind(x)}if(h.$poolArray(E),n&&n.length&&o._$canApply(n)){const s=o._$drawFilter(t,A,e,n,p,m);h.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=r,t.setTransform(1,0,0,1,d-s._$offsetX,f-s._$offsetY),t.drawImage(s,0,0,s.width,s.height,i)}else h.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=r,t.setTransform(1,0,0,1,0,0),t.drawImage(A,d,f,p,m,i);l!==e&&h.$poolFloat32Array6(l)}_$draw(t,e,i,n=I.NORMAL,a=null){if(!this._$maxAlpha)return;const o=h.$clamp(i[3]+i[7]/255,0,1),l=this._$displayObject;let $=null!==l._$scale9Grid,_=null;$&&(_=l._$transform._$rawMatrix(),$=$&&s.abs(_[1])<.001&&s.abs(_[2])<1e-4);const c=this._$getBounds(),u=h.$boundsMatrix(c,e),d=u.xMax,g=u.xMin,f=u.yMax,p=u.yMin;h.$poolBoundsObject(u);let m=s.ceil(s.abs(d-g)),x=s.ceil(s.abs(f-p));switch(!0){case 0===m:case 0===x:case m===-h.$Infinity:case x===-h.$Infinity:case m===h.$Infinity:case x===h.$Infinity:return}const b=t.frameBuffer.currentAttachment;if(g>b.width||p>b.height)return;let T=+s.sqrt(e[0]*e[0]+e[1]*e[1]);if(!r.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}let v=+s.sqrt(e[2]*e[2]+e[3]*e[3]);if(!r.isInteger(v)){const t=v.toString(),e=t.indexOf("e");-1!==e&&(v=+t.slice(0,e)),v=+v.toFixed(4)}if(0>g+m||0>p+x){if(!(a&&a.length&&l._$canApply(a)))return;{let t=new y(0,0,m,x);for(let e=0;e<a.length;++e)t=a[e]._$generateFilterRect(t,T,v);if(0>t.x+t.width||0>t.y+t.height)return}}const E=h.$getArray(T,v),A=h.$cacheStore(),M=A.generateKeys(l._$instanceId,E,i);h.$poolArray(E);let C=A.get(M);if(!C){let r=s.ceil(s.abs(c.xMax-c.xMin)*T),n=s.ceil(s.abs(c.yMax-c.yMin)*v);const a=t._$textureScale(r,n);a<1&&(r*=a,n*=a);const o=t.frameBuffer.createCacheAttachment(r,n,!0);if(t._$bind(o),h.$resetContext(t),t.setTransform(T,0,0,v,-c.xMin*T,-c.yMin*v),$){const i=h.$currentPlayer(),r=i._$scale*i._$ratio,n=h.$getFloat32Array6(r,0,0,r,0,0),a=h.$multiplicationMatrix(n,_);h.$poolFloat32Array6(n);const o=l._$parent._$transform.concatenatedMatrix._$matrix,$=h.$getFloat32Array6(o[0],o[1],o[2],o[3],o[4]*r-g,o[5]*r-p),u=h.$multiplicationMatrix($,a),d=u[4]-(e[4]-g),f=u[5]-(e[5]-p);h.$poolFloat32Array6(u);const m=h.$boundsMatrix(c,a),x=+m.xMax,b=+m.xMin,T=+m.yMax,v=+m.yMin,y=s.ceil(s.abs(x-b)),E=s.ceil(s.abs(T-v));h.$poolBoundsObject(m),t.grid.enable(b,v,y,E,c,l._$scale9Grid,a[0],a[1],a[2],a[3],a[4],a[5],$[0],$[1],$[2],$[3],$[4]-d,$[5]-f),h.$poolFloat32Array6(a),h.$poolFloat32Array6($)}i[3]=1,this._$doDraw(t,i,!1),$&&t.grid.disable(),C=t.frameBuffer.getTextureFromCurrentAttachment(),A.set(M,C),t.frameBuffer.releaseAttachment(o,!1),t._$bind(b)}if(h.$poolArray(M),_&&h.$poolMatrix(_),h.$poolBoundsObject(c),a&&a.length){if(l._$canApply(a)){const s=l._$drawFilter(t,C,e,a,m,x);return h.$resetContext(t),t._$globalAlpha=o,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=n,t.setTransform(1,0,0,1,g-s._$offsetX,p-s._$offsetY),void t.drawImage(s,0,0,s.width,s.height,i)}}h.$resetContext(t),t._$globalAlpha=o,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=n;const S=s.atan2(e[1],e[0]),R=s.atan2(-e[2],e[3]);if(S||R){const i=c.xMin*T,r=c.yMin*v;t.setTransform(s.cos(S),s.sin(S),-s.sin(R),s.cos(R),i*s.cos(S)-r*s.sin(R)+e[4],i*s.sin(S)+r*s.cos(R)+e[5])}else t.setTransform(1,0,0,1,g,p);t.drawImage(C,0,0,C.width,C.height,i)}_$doDraw(t,e,i=!1){h.$resetContext(t),t.beginPath(),this._$runCommand(t,e,i)}_$hit(t,e,i,s=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,s,i)}_$getBounds(){const t=this._$displayObject;return t&&t._$bounds?h.$getBoundsObject(t._$bounds.xMin,t._$bounds.xMax,t._$bounds.yMin,t._$bounds.yMax):h.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){this._$displayObject&&!this._$displayObject._$isUpdated()&&(this._$displayObject._$doChanged(),h.$isUpdated=!0,h.$cacheStore().removeCache(this._$displayObject._$instanceId))}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t,e){this._$xMin=s.min(this._$xMin,t),this._$xMax=s.max(this._$xMax,t),this._$yMin=s.min(this._$yMin,e),this._$yMax=s.max(this._$yMax,e)}_$setLineBounds(t,e){this._$xMin=s.min(this._$xMin,s.min(t,this._$pointerX)),this._$xMax=s.max(this._$xMax,s.max(t,this._$pointerX)),this._$yMin=s.min(this._$yMin,s.min(e,this._$pointerY)),this._$yMax=s.max(this._$yMax,s.max(e,this._$pointerY));const i=this._$lineWidth/2,r=.5*s.PI,n=s.atan2(e-this._$pointerY,t-this._$pointerX),a=s.atan2(this._$pointerY-e,this._$pointerX-t),o=n+r,h=n-r,l=a+r,$=a-r;let _=t+i,c=-i+t,u=this._$pointerX+i,d=-i+this._$pointerX,g=e+i,f=-i+e,p=this._$pointerY+i,m=-i+this._$pointerY;this._$xMin=s.min(this._$xMin,s.min(_,s.min(c,s.min(u,d)))),this._$xMax=s.max(this._$xMax,s.max(_,s.max(c,s.max(u,d)))),this._$yMin=s.min(this._$yMin,s.min(g,s.min(f,s.min(p,m)))),this._$yMax=s.max(this._$yMax,s.max(g,s.max(f,s.max(p,m)))),s.abs(o)%r!=0&&(_=t+s.cos(o)*i),s.abs(h)%r!=0&&(c=t+s.cos(h)*i),s.abs(l)%r!=0&&(u=this._$pointerX+s.cos(l)*i),s.abs($)%r!=0&&(d=this._$pointerX+s.cos($)*i),o&&s.abs(o)%s.PI!=0&&(g=e+s.sin(o)*i),h&&s.abs(h)%s.PI!=0&&(f=e+s.sin(h)*i),l&&s.abs(l)%s.PI!=0&&(p=this._$pointerY+s.sin(l)*i),$&&s.abs($)%s.PI!=0&&(m=this._$pointerY+s.sin($)*i),this._$xMin=s.min(this._$xMin,s.min(_,s.min(c,s.min(u,d)))),this._$xMax=s.max(this._$xMax,s.max(_,s.max(c,s.max(u,d)))),this._$yMin=s.min(this._$yMin,s.min(g,s.min(f,s.min(p,m)))),this._$yMax=s.max(this._$yMax,s.max(g,s.max(f,s.max(p,m))));let x=0,b=0,T=0,v=0,y=0,E=0,A=0,M=0;switch(this._$caps){case B.ROUND:s.abs(n)%r!=0&&(x=t+s.cos(n)*i),n&&s.abs(n)%s.PI!=0&&(b=e+s.sin(n)*i),s.abs(a)%r!=0&&(T=this._$pointerX+s.cos(a)*i),a&&s.abs(a)%s.PI!=0&&(v=this._$pointerY+s.sin(a)*i),this._$xMin=s.min(this._$xMin,s.min(x,T)),this._$xMax=s.max(this._$xMax,s.max(x,T)),this._$yMin=s.min(this._$yMin,s.min(b,v)),this._$yMax=s.max(this._$yMax,s.max(b,v));break;case B.SQUARE:if(s.abs(n)%r!=0){const t=s.cos(n)*i;x=_+t,T=c+t}if(s.abs(a)%r!=0){const t=s.cos(a)*i;y=u+t,A=d+t}if(n&&s.abs(n)%s.PI!=0){const t=s.sin(n)*i;b=g+t,v=f+t}if(a&&s.abs(a)%s.PI!=0){const t=s.sin(a)*i;E=p+t,M=m+t}this._$xMin=s.min(this._$xMin,s.min(x,s.min(T,s.min(y,A)))),this._$xMax=s.max(this._$xMax,s.max(x,s.max(T,s.max(y,A)))),this._$yMin=s.min(this._$yMin,s.min(b,s.min(v,s.min(E,M)))),this._$yMax=s.max(this._$yMax,s.max(b,s.max(v,s.max(E,M))))}}_$margePath(t){this._$doFill&&this._$fills.push.apply(this._$fills,t),this._$doLine&&this._$lines.push.apply(this._$lines,t),h.$poolArray(t)}_$runTransformCommand(t,e,i=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;let r=Number.MAX_VALUE,n=-Number.MAX_VALUE,a=Number.MAX_VALUE,o=-Number.MAX_VALUE;const h=this._$recode,l=h.length;for(let $=0;$<l;)switch(h[$++]){case P.BEGIN_PATH:t.beginPath();break;case P.MOVE_TO:{const i=h[$++],l=h[$++],_=i*e[0]+l*e[2],c=i*e[1]+l*e[3];r=s.min(_,r),n=s.max(_,n),a=s.min(c,a),o=s.max(c,o),t.moveTo(_,c)}break;case P.LINE_TO:{const i=h[$++],l=h[$++],_=i*e[0]+l*e[2],c=i*e[1]+l*e[3];r=s.min(_,r),n=s.max(_,n),a=s.min(c,a),o=s.max(c,o),t.lineTo(_,c)}break;case P.CURVE_TO:{const i=h[$++],l=h[$++],_=h[$++],c=h[$++],u=i*e[0]+l*e[2],d=i*e[1]+l*e[3],g=_*e[0]+c*e[2],f=_*e[1]+c*e[3];r=s.min(u,r),n=s.max(u,n),a=s.min(d,a),o=s.max(d,o),r=s.min(g,r),n=s.max(g,n),a=s.min(f,a),o=s.max(f,o),t.quadraticCurveTo(u,d,g,f)}break;case P.CLOSE_PATH:t.closePath();break;case P.CUBIC:{const i=h[$++],l=h[$++],_=h[$++],c=h[$++],u=h[$++],d=h[$++],g=i*e[0]+l*e[2],f=i*e[1]+l*e[3],p=_*e[0]+c*e[2],m=_*e[1]+c*e[3],x=u*e[0]+d*e[2],b=u*e[1]+d*e[3];r=s.min(g,r),n=s.max(g,n),a=s.min(f,a),o=s.max(f,o),r=s.min(p,r),n=s.max(p,n),a=s.min(m,a),o=s.max(m,o),r=s.min(x,r),n=s.max(x,n),a=s.min(b,a),o=s.max(b,o),t.bezierCurveTo(g,f,p,m,x,b)}break;case P.ARC:{const i=h[$++],l=h[$++],_=h[$++],c=i*e[0]+l*e[2],u=i*e[1]+l*e[3];r=s.min(c,r),n=s.max(c,n),a=s.min(u,a),o=s.max(u,o),t.arc(c,u,_,0,2*s.PI)}break;case P.BITMAP_FILL:{t._$matrix[6]-=r*t._$matrix[0]+a*t._$matrix[3],t._$matrix[7]-=r*t._$matrix[1]+a*t._$matrix[4],t.save();const e=h[$++],s=h[$++],n=h[$++],o=h[$++];t.fillStyle=t.createPattern(e._$texture,n,i),s&&t.transform(s[0],s[1],s[2],s[3],s[4],s[5]),t._$imageSmoothingEnabled=o,t.fill(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}_$runCommand(t,e=null,i=!1,r=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;const n=this._$recode,a=n.length;for(let o=0;o<a;)switch(n[o++]){case P.BEGIN_PATH:t.beginPath();break;case P.MOVE_TO:t.moveTo(n[o++],n[o++]);break;case P.LINE_TO:t.lineTo(n[o++],n[o++]);break;case P.CURVE_TO:t.quadraticCurveTo(n[o++],n[o++],n[o++],n[o++]);break;case P.FILL_STYLE:{if(i||r){o+=4;continue}const a=t._$contextStyle;a._$fillStyle[0]=n[o++]/255,a._$fillStyle[1]=n[o++]/255,a._$fillStyle[2]=n[o++]/255,a._$fillStyle[3]=1!==e[3]||0!==e[7]?s.max(0,s.min(n[o++]*e[3]+e[7],255))/255:n[o++]/255,t._$style=a}break;case P.END_FILL:if(r){if(t.isPointInPath(r.x,r.y))return!0;continue}i||t.fill();break;case P.STROKE_STYLE:{if(i||r){o+=8;continue}t.lineWidth=n[o++],t.lineCap=n[o++],t.lineJoin=n[o++],t.miterLimit=n[o++];const a=t._$contextStyle;a._$strokeStyle[0]=n[o++]/255,a._$strokeStyle[1]=n[o++]/255,a._$strokeStyle[2]=n[o++]/255,a._$strokeStyle[3]=1!==e[3]||0!==e[7]?s.max(0,s.min(n[o++]*e[3]+e[7],255))/255:n[o++]/255,t._$style=a}break;case P.END_STROKE:if(r){if(t.isPointInStroke(r.x,r.y))return!0;continue}i||t.stroke();break;case P.CLOSE_PATH:t.closePath();break;case P.CUBIC:t.bezierCurveTo(n[o++],n[o++],n[o++],n[o++],n[o++],n[o++]);break;case P.ARC:{const e=n[o++],i=n[o++],r=n[o++];t.arc(e,i,r,0,2*s.PI)}break;case P.GRADIENT_FILL:{if(r){if(t.isPointInPath(r.x,r.y))return!0;o+=6;continue}if(i){o+=6;continue}const a=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++],u=n[o++];let d=null;if(a===L.LINEAR){const e=h.$linearGradientXY($);d=t.createLinearGradient(e[0],e[1],e[2],e[3],c,_)}else t.save(),t.transform($[0],$[1],$[2],$[3],$[4],$[5]),d=t.createRadialGradient(0,0,0,0,0,819.2,c,_,u);const g=l.length;for(let t=0;t<g;++t){const i=l[t];d.addColorStop(i.ratio,h.$getFloat32Array4(0|s.max(0,s.min(i.R*e[0]+e[4],255)),0|s.max(0,s.min(i.G*e[1]+e[5],255)),0|s.max(0,s.min(i.B*e[2]+e[6],255)),0|s.max(0,s.min(i.A*e[3]+e[7],255))))}t.fillStyle=d,t.fill(),a===L.RADIAL&&t.restore()}break;case P.GRADIENT_STROKE:{if(r){if(t.isPointInStroke(r.x,r.y))return!0;o+=12;continue}if(i){o+=12;continue}const a=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++],u=n[o++],d=n[o++],g=n[o++],f=n[o++],p=n[o++];let m=null;if(c===L.LINEAR){const e=h.$linearGradientXY(d);m=t.createLinearGradient(e[0],e[1],e[2],e[3],f,g)}else t.save(),t.transform(d[0],d[1],d[2],d[3],d[4],d[5]),m=t.createRadialGradient(0,0,0,0,0,819.2,f,g,p);const x=u.length;for(let t=0;t<x;++t){const i=u[t];m.addColorStop(i.ratio,h.$getFloat32Array4(0|s.max(0,s.min(i.R*e[0]+e[4],255)),0|s.max(0,s.min(i.G*e[1]+e[5],255)),0|s.max(0,s.min(i.B*e[2]+e[6],255)),0|s.max(0,s.min(i.A*e[3]+e[7],255))))}t.strokeStyle=m,t.lineWidth=a,t.lineCap=l,t.lineJoin=$,t.miterLimit=_,t.stroke(),c===L.RADIAL&&t.restore()}break;case P.BITMAP_FILL:{if(r){if(t.isPointInPath(r.x,r.y))return!0;o+=6;continue}if(i){o+=6;continue}t.save();const s=n[o++],a=n[o++],h=n[o++],l=n[o++];a&&t.transform(a[0],a[1],a[2],a[3],a[4],a[5]),"no-repeat"===h&&s.width===this._$xMax-this._$xMin&&s.height===this._$yMax-this._$yMin?t.drawImage(s._$texture,0,0,s.width,s.height):(t.fillStyle=t.createPattern(s._$texture,h,e),t._$imageSmoothingEnabled=l,t.fill()),t.restore(),t._$imageSmoothingEnabled=!1}break;case P.BITMAP_STROKE:{if(r){if(t.isPointInStroke(r.x,r.y))return!0;o+=9;continue}if(i){o+=9;continue}t.save();const s=n[o++],a=n[o++],h=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++],u=n[o++];_&&t.transform(_[0],_[1],_[2],_[3],_[4],_[5]),t.lineWidth=s,t.lineCap=a,t.lineJoin=h,t.miterLimit=l,t.strokeStyle=t.createPattern($._$texture,c,e),t._$imageSmoothingEnabled=u,t.stroke(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}}class D{constructor(t,e=null,i=!0,s=!1){this._$bitmapData=t,this._$matrix=e,this._$repeat=!!i,this._$smooth=!!s}clone(){return new D(this._$bitmapData.clone(),this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){return h.$getArray(this._$bitmapData,this._$matrix,this._$repeat?"repeat":"no-repeat",this._$smooth)}}class N{constructor(t=L.LINEAR,e=null,i=null,s=null,r=null,n=Y.PAD,a=U.RGB,o=0){if(this._$type=L.RADIAL===t?t:L.LINEAR,this._$colors=h.$isArray(e)?this._$toColorInt(e):null,this._$alphas=h.$isArray(i)?this._$toColorInt(i):null,this._$ratios=null,h.$isArray(s)){for(let t=0;t<s.length;++t)s[t]=h.$clamp(s[t],0,255,0);this._$ratios=s}switch(this._$matrix=r,n){case Y.REFLECT:case Y.REPEAT:this._$spreadMethod=n;break;default:this._$spreadMethod=Y.PAD}this._$interpolationMethod=a===U.LINEAR_RGB?a:U.RGB,this._$focalPointRatio=+o||0,this._$colorStops=null}get colorStops(){if(!this._$colorStops){this._$colorStops=h.$getArray();const t=s.min(s.min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=h.$intToRGBA(this._$colors[e],this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:t.R,G:t.G,B:t.B,A:t.A}}}return this._$colorStops}_$toColorInt(t){const e=t.length;for(let i=0;i<e;++i)t[i]=h.$clamp(h.$toColorInt(t[i]),0,16777215,16777215);return t}toArray(){return h.$getArray(this._$type,this.colorStops,this._$matrix?this._$matrix._$matrix:h.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class U{static toString(){return"[class InterpolationMethod]"}static get namespace(){return"next2d.display.InterpolationMethod"}toString(){return"[object InterpolationMethod]"}get namespace(){return"next2d.display.InterpolationMethod"}static get LINEAR_RGB(){return"linearRGB"}static get RGB(){return"rgb"}}class k{static toString(){return"[class JointStyle]"}static get namespace(){return"next2d.display.JointStyle"}toString(){return"[object JointStyle]"}get namespace(){return"next2d.display.JointStyle"}static get BEVEL(){return"bevel"}static get MITER(){return"miter"}static get ROUND(){return"round"}}class G extends C{constructor(){super(),this._$loaderInfo=new X}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo._$content}get contentLoaderInfo(){return this._$loaderInfo}load(t){if(!(t&&t instanceof pt))return;const e=this.contentLoaderInfo;switch(t.responseDataFormat){case ft.JSON:case ft.ARRAY_BUFFER:break;default:return void(e.willTrigger(f.IO_ERROR)&&e.dispatchEvent(new f(f.IO_ERROR,!1,!1,"data format is json or arrayBuffer only.")))}e._$url=t.url,e._$format=t.responseDataFormat,h.$ajax({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(_.OPEN)&&e.dispatchEvent(new _(_.OPEN)),e.willTrigger(m.PROGRESS)&&e.dispatchEvent(new m(m.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(m.PROGRESS)&&e.dispatchEvent(new m(m.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(m.PROGRESS)&&e.dispatchEvent(new m(m.PROGRESS,!1,!1,t.loaded,t.total));const i=h.$getArray(),s=h.$headerToArray(t.target.getAllResponseHeaders()),r=s.length;for(let t=0;t<r;++t){const e=s[t];i.push(new mt(e.name,e.value))}if(e.willTrigger(g.HTTP_STATUS)){const s=new g(g.HTTP_STATUS,!1,!1,t.target.status);s._$responseURL=t.target.responseURL,s._$responseHeaders=i,e.dispatchEvent(s)}if(199<t.target.status&&400>t.target.status)switch(e.format){case ft.JSON:{const e=JSON.parse(t.target.responseText);if("zlib"===e.type){if(h.$unzipWorkerActive)return void h.$unzipQueues.push({json:e,scope:this});h.$unzipWorkerActive=!0,h.$unzipWorker||(h.$unzipWorker=new Worker(h.$unzipURL));const t=new Uint8Array(e.buffer);h.$unzipWorker.onmessage=h.$unzipHandler.bind(this),h.$unzipWorker.postMessage(t,[t.buffer])}else this._$build(e)}break;case ft.ARRAY_BUFFER:this._$imageDecode(new Uint8Array(t.target.response))}else e.willTrigger(f.IO_ERROR)&&e.dispatchEvent(new f(f.IO_ERROR,!1,!1,t.target.statusText))}.bind(this)}})}loadImage(t){t.responseDataFormat=ft.ARRAY_BUFFER,this.load(t)}_$imageDecode(t){const e={image:new h.$Image,scope:this};e.image.decoding="async",e.image.src=h.$URL.createObjectURL(new h.$Blob([t],{type:`image/${h.$getImageType(t)}`})),h.$imageWorkerActive?h.$imageQueues.push(e):(h.$imageWorkerActive=!0,e.image.decode().then(h.$decodeImage.bind(e)).catch((()=>{throw new Error("image encoding error")})))}_$build(t){const e=this.contentLoaderInfo;let i=null;const s=h.$getMap();if(t.symbols.length)for(let e=0;e<t.symbols.length;++e){const r=t.symbols[e];0===r[1]&&(i=r[0]),s.set(r[0],r[1])}if(e._$data={stage:t.stage,characters:t.characters,symbols:s},i){const t=h.$getClass(i)||R;e._$content=new t}else e._$content=new R;const r=t.characters[0];e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:r.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const n=h.$currentPlayer();n._$loaders.push(e),n._$loadStatus===ae.LOAD_START&&(n._$loadStatus=ae.LOAD_END)}}class X extends c{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format=ft.STRING}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get content(){return this._$content}get url(){return this._$url}get format(){return this._$format}set format(t){this._$format=t}}class H extends A{constructor(){super(),this._$graphics=null,this._$bounds=null,this._$bitmapId=0}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new P(this)),this._$graphics}_$buildCharacter(t,e){const i=this.graphics;if(t.recodes)if(t.bitmapId){this._$bitmapId=t.bitmapId;const r=e._$data.characters[t.bitmapId],n=s.abs(r.bounds.xMax-r.bounds.xMin),o=s.abs(r.bounds.yMax-r.bounds.yMin),l=new w(n,o,!0,0);r._$buffer||(r._$buffer=new Uint8Array(r.buffer),h.$poolArray(r.buffer),r.buffer=null),l._$buffer=r._$buffer.slice(),i._$recode=h.$getArray();const $=t.recodes;if($[$.length-1]===P.END_FILL){const t=$.length-6;for(let e=0;e<t;++e)i._$recode.push($[e]);i._$recode.push(P.BITMAP_FILL,l,null,"repeat",!1)}else{const e=$[$.length-9],s=$[$.length-8],r=$[$.length-7],n=$[$.length-6],o=$.length-10;for(let t=0;t<o;++t)i._$recode.push($[t]);i._$recode.push(P.BITMAP_STROKE,e,s,r,n,l,new a([1,0,0,1,t.bounds.xMin,t.bounds.yMin]),"repeat",!1)}}else i._$recode=t.recodes.slice(0);else{const e=s.abs(t.bounds.xMax-t.bounds.xMin),r=s.abs(t.bounds.yMax-t.bounds.yMin),n=new w(e,r,!0,0);t._$buffer||(t._$buffer=new Uint8Array(t.buffer),h.$poolArray(t.buffer),t.buffer=null),n._$buffer=t._$buffer.slice(0),i.beginBitmapFill(n,null,!1).drawRect(0,0,e,r)}i._$maxAlpha=1,i._$canDraw=!0,i._$xMin=t.bounds.xMin,i._$xMax=t.bounds.xMax,i._$yMin=t.bounds.yMin,i._$yMax=t.bounds.yMax}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t,this._$loaderInfo),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i,e._$loaderInfo),i}_$getBounds(t=null){if(!this._$graphics)return h.$getBoundsObject(0,0,0,0);const e=this._$graphics._$getBounds();if(t){const i=h.$multiplicationMatrix(t,this._$transform._$rawMatrix()),s=h.$boundsMatrix(e,i);return h.$poolBoundsObject(e),s}return e}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let s=i;const r=this._$transform._$rawColorTransform();r!==h.$COLOR_ARRAY_IDENTITY&&(s=h.$multiplicationColor(i,r));if(!h.$clamp(s[3]+s[7]/255,0,1,0))return void(s!==i&&h.$poolFloat32Array8(s));const n=this._$filters||this.filters,a=this._$blendMode||this.blendMode;if(this._$bitmapId)this._$graphics._$drawBitmap(t,e,s,a,n);else{let i=e;const r=this._$transform._$rawMatrix();r!==h.$MATRIX_ARRAY_IDENTITY&&(i=h.$multiplicationMatrix(e,r)),this._$graphics._$draw(t,i,s,a,n),i!==e&&h.$poolFloat32Array6(i)}s!==i&&h.$poolFloat32Array8(s)}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();s!==h.$MATRIX_ARRAY_IDENTITY&&(i=h.$multiplicationMatrix(e,s)),this._$graphics._$clip(t,i),i!==e&&h.$poolFloat32Array6(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,s){let r=!1;if(this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$getBounds()){let n=e;const a=this._$transform._$rawMatrix();a!==h.$MATRIX_ARRAY_IDENTITY&&(n=h.$multiplicationMatrix(e,a)),r=this._$graphics._$hit(t,n,i,s),n!==e&&h.$poolFloat32Array6(n)}return r}}class Y{static toString(){return"[class SpreadMethod]"}static get namespace(){return"next2d.display.SpreadMethod"}toString(){return"[object SpreadMethod]"}get namespace(){return"next2d.display.SpreadMethod"}static get PAD(){return"pad"}static get REFLECT(){return"reflect"}static get REPEAT(){return"repeat"}}class j extends C{constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=h.$clamp(h.$toColorInt(t),0,16777215,16777215);const e=this._$player;if(e){const t=h.$uintToRGBA(this._$color);e._$context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=h.$clamp(+t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get player(){return this._$player}get stageHeight(){return this._$player?this._$player._$height/h.$devicePixelRatio:0}get stageWidth(){return this._$player?this._$player._$width/h.$devicePixelRatio:0}invalidate(){this._$invalidate=!0}}class z{static toString(){return"[class StageQuality]"}static get namespace(){return"next2d.display.StageQuality"}toString(){return"[object StageQuality]"}get namespace(){return"next2d.display.StageQuality"}static get HIGH(){return"high"}static get LOW(){return"low"}static get MEDIUM(){return"medium"}}class V{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,h.$isUpdated=!0}}class W{static toString(){return"[class BitmapFilterType]"}static get namespace(){return"next2d.filters.BitmapFilterType"}toString(){return"[object BitmapFilterType]"}get namespace(){return"next2d.filters.BitmapFilterType"}static get FULL(){return"full"}static get INNER(){return"inner"}static get OUTER(){return"outer"}}class q{static toString(){return"[class BitmapFilterQuality]"}static get namespace(){return"next2d.filters.BitmapFilterQuality"}toString(){return"[object BitmapFilterQuality]"}get namespace(){return"next2d.filters.BitmapFilterQuality"}static get LOW(){return 1}static get MEDIUM(){return 2}static get HIGH(){return 3}}class K{static toString(){return"[class DisplacementMapFilterMode]"}static get namespace(){return"next2d.filters.DisplacementMapFilterMode"}toString(){return"[object DisplacementMapFilterMode]"}get namespace(){return"next2d.filters.DisplacementMapFilterMode"}static get CLAMP(){return"clamp"}static get COLOR(){return"color"}static get IGNORE(){return"ignore"}static get WRAP(){return"wrap"}}class Q extends V{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=h.$clamp(+t,0,255,0))!==this._$blurX&&this._$doChanged(!0),this._$blurX=t}get blurY(){return this._$blurY}set blurY(t){(t=h.$clamp(+t,0,255,0))!==this._$blurY&&this._$doChanged(!0),this._$blurY=t}get quality(){return this._$quality}set quality(t){(t=h.$clamp(0|t,0,15,q.LOW))!==this._$quality&&this._$doChanged(!0),this._$quality=t}clone(){return new Q(this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=null,i=null){const r=t.clone();if(!this._$quality)return r;const n=Q.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,o=0>=this._$blurY?1:this._$blurY*n;switch(!0){case"number"==typeof e:case"number"==typeof i:a*=e,o*=i;break;default:a=s.round(a),o=s.round(o)}return r.x-=a,r.width+=2*a,r.y-=o,r.height+=2*o,r}_$isSame(t){return this._$quality===t._$quality&&(this._$blurX===t._$blurX&&this._$blurY===t._$blurY)}_$canApply(){return this._$quality&&this._$blurX&&this._$blurY}_$applyFilter(t,e,i=!0){this._$doChanged(!1);const r=t.frameBuffer.currentAttachment,n=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return i?n:t.frameBuffer.createTextureFromCurrentAttachment();const a=s.sqrt(e[0]*e[0]+e[1]*e[1]),o=s.sqrt(e[2]*e[2]+e[3]*e[3]),l=new y(0,0,n.width,n.height),$=this._$generateFilterRect(l,a,o),_=0|s.ceil($.width),c=0|s.ceil($.height),u=s.ceil(s.abs($.x)+.5*s.abs(_-$.width)),d=s.ceil(s.abs($.y)+.5*s.abs(c-$.height));t._$offsetX=+(u+t._$offsetX),t._$offsetY=+(d+t._$offsetY);const g=this._$blurX*a,f=this._$blurY*o;let p=1,m=1;g>128?p=.0625:g>64?p=.125:g>32?p=.25:g>16&&(p=.5),f>128?m=.0625:f>64?m=.125:f>32?m=.25:f>16&&(m=.5);const x=g*p,b=f*m;let T=s.ceil(_*p),v=s.ceil(c*m);const E=t.frameBuffer.createTextureAttachment(T,v),A=[E,t.frameBuffer.createTextureAttachment(T,v)];let M=0;t._$bind(E),h.$resetContext(t),t.setTransform(p,0,0,m,0,0),t.drawImage(n,u,d,n.width,n.height),t.blend.toOneZero();let C=t.frameBuffer.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(C,!0,x),C=t.frameBuffer.getTextureFromCurrentAttachment()}if(this._$blurY>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(C,!1,b),C=t.frameBuffer.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==p||1!==m){const e=t.frameBuffer.createTextureAttachment(_,c);t._$bind(e),h.$resetContext(t),t.imageSmoothingEnabled=!0,t.setTransform(1/p,0,0,1/m,0,0),t.drawImage(C,0,0,T,v),C=t.frameBuffer.getTextureFromCurrentAttachment(),h.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.frameBuffer.releaseAttachment(A[0],!0),t.frameBuffer.releaseAttachment(A[1],!0),i?t.frameBuffer.releaseAttachment(r,!0):t.frameBuffer.releaseAttachment(e,!1)}else t.frameBuffer.releaseAttachment(A[(M+1)%2],!0),i?t.frameBuffer.releaseAttachment(r,!0):t.frameBuffer.releaseAttachment(A[M],!1);return C}}class J extends V{constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,o=4,h=1,l=1,$="inner",_=!1){super(),this._$blurFilter=new Q(a,o,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type=W.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=s,this.shadowColor=r,this.shadowAlpha=n,this.strength=h,this.type=$,this.knockout=!!_}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=h.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=h.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=h.$clamp(+t,0,1,0))!==this._$highlightAlpha&&this._$doChanged(!0),this._$highlightAlpha=t}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=h.$clamp(h.$toColorInt(t),0,16777215,16777215))!==this._$highlightColor&&this._$doChanged(!0),this._$highlightColor=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=h.$clamp(+t,0,1,0))!==this._$shadowAlpha&&this._$doChanged(!0),this._$shadowAlpha=t}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=h.$clamp(h.$toColorInt(t),0,16777215,0))!==this._$shadowColor&&this._$doChanged(!0),this._$shadowColor=t}get strength(){return this._$strength}set strength(t){(t=h.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case W.OUTER:case W.INNER:this._$type=t;break;default:this._$type=W.FULL}}clone(){return new J(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=this._$angle*h.$Deg2Rad,a=s.abs(s.cos(n)*this._$distance),o=s.abs(s.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-o,r.height+=2*o,r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$highlightColor===t._$highlightColor&&(this._$highlightAlpha===t._$highlightAlpha&&(this._$shadowColor===t._$shadowColor&&(this._$shadowAlpha===t._$shadowAlpha&&(this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))))))}_$canApply(){return this._$strength&&this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=i.width,a=i.height,o=t._$offsetX,l=t._$offsetY,$=s.sqrt(e[0]*e[0]+e[1]*e[1]),_=s.sqrt(e[2]*e[2]+e[3]*e[3]),c=+this._$angle*h.$Deg2Rad,u=+s.cos(c)*this._$distance*$,d=+s.sin(c)*this._$distance*_;let g=t.frameBuffer.createTextureAttachment(n,a);t._$bind(g),h.$resetContext(t),t.drawImage(r,0,0,n,a),t.globalCompositeOperation=I.ERASE,t.drawImage(r,2*u,2*d,n,a);const f=this._$blurFilter._$applyFilter(t,e,!1),p=f.width,m=f.height,x=s.ceil(p+2*s.abs(u)),b=s.ceil(m+2*s.abs(d)),T=this._$type===W.INNER,v=T?n:x,y=T?a:b,E=s.abs(u),A=s.abs(d),M=(p-n)/2,C=(m-a)/2;let S,R,w,O;return T?(S=0,R=0,w=-M-u,O=-C-d):(S=E+M,R=A+C,w=E-u,O=A-d),t._$bind(i),t._$applyBitmapFilter(f,v,y,n,a,S,R,p,m,w,O,!1,this._$type,this._$knockout,this._$strength,null,null,null,h.$intToR(this._$highlightColor,this._$highlightAlpha,!0),h.$intToG(this._$highlightColor,this._$highlightAlpha,!0),h.$intToB(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,h.$intToR(this._$shadowColor,this._$shadowAlpha,!0),h.$intToG(this._$shadowColor,this._$shadowAlpha,!0),h.$intToB(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=o+S,t._$offsetY=l+R,t.frameBuffer.releaseTexture(f),t.frameBuffer.getTextureFromCurrentAttachment()}}class Z extends V{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this._$doApply=!1,this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(h.$isArray(t)&&20===t.length){if(this._$matrix){const e=t.length;for(let i=0;i<e;++i)if(t[i]!==this._$matrix[i]){this._$doChanged(!0),this._$doApply=!0;break}}this._$matrix=t}}clone(){return new Z(this._$matrix)}_$generateFilterRect(t){return t}_$isSame(t){const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$doApply}_$applyFilter(t){this._$doChanged(!1);const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment(),s=i.width,r=i.height,n=t.frameBuffer.createTextureAttachment(s,r);return t._$bind(n),h.$resetContext(t),t._$applyColorMatrixFilter(i,this._$matrix),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class tt extends V{constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,o=0,h=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=s,this.bias=r,this.preserveAlpha=n,this.clamp=a,this.color=o,this.alpha=h}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=h.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get bias(){return this._$bias}set bias(t){(t=+t)!==this._$bias&&this._$doChanged(!0),this._$bias=t}get clamp(){return this._$clamp}set clamp(t){(t=!!t)!==this._$clamp&&this._$doChanged(!0),this._$clamp=t}get color(){return this._$color}set color(t){(t=h.$clamp(h.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get divisor(){return this._$divisor}set divisor(t){(t=+t)!==this._$divisor&&this._$doChanged(!0),this._$divisor=t}get matrix(){return this._$matrix}set matrix(t){this._$doChanged(!0),this._$matrix&&h.$poolArray(this._$matrix),this._$matrix=h.$getArray(),h.$isArray(t)&&(this._$matrix=t.slice(0))}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|h.$clamp(0|t,0,15,0))!==this._$matrixX&&this._$doChanged(!0),this._$matrixX=t}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|h.$clamp(0|t,0,15,0))!==this._$matrixY&&this._$doChanged(!0),this._$matrixY=t}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){(t=!!t)!==this._$preserveAlpha&&this._$doChanged(!0),this._$preserveAlpha=t}clone(){return new tt(this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){if(this._$matrixX!==t._$matrixX)return!1;if(this._$matrixY!==t._$matrixY)return!1;if(this._$divisor!==t._$divisor)return!1;if(this._$bias!==t._$bias)return!1;if(this._$preserveAlpha!==t._$preserveAlpha)return!1;if(this._$clamp!==t._$clamp)return!1;if(this._$color!==t._$color)return!1;if(this._$alpha!==t._$alpha)return!1;const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$doChanged(!1);const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment();return this._$canApply()?(t._$applyConvolutionFilter(i,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,h.$intToR(this._$color,this._$alpha,!1),h.$intToG(this._$color,this._$alpha,!1),h.$intToB(this._$color,this._$alpha,!1),this._$alpha),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()):i}}class et extends V{constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",o=0,h=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode=K.WRAP,this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=s,this.scaleX=r,this.scaleY=n,this.mode=a,this.color=o,this.alpha=h}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=h.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get color(){return this._$color}set color(t){(t=h.$clamp(h.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get componentX(){return this._$componentX}set componentX(t){switch((t|=0)!==this._$componentX&&this._$doChanged(!0),this._$componentX=0,t){case O.ALPHA:case O.BLUE:case O.GREEN:case O.RED:this._$componentX=t}}get componentY(){return this._$componentY}set componentY(t){switch((t|=0)!==this._$componentY&&this._$doChanged(!0),this._$componentY=0,t){case O.ALPHA:case O.BLUE:case O.GREEN:case O.RED:this._$componentY=t}}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&this._$doChanged(!0),this._$mapBitmap=null,t instanceof w&&(this._$mapBitmap=t)}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&this._$doChanged(!0),this._$mapPoint=null,t instanceof v&&(this._$mapPoint=t)}get mode(){return this._$mode}set mode(t){switch((t+="")!==this._$mode&&this._$doChanged(!0),this._$mode=K.WRAP,t){case K.CLAMP:case K.COLOR:case K.IGNORE:this._$mode=t}}get scaleX(){return this._$scaleX}set scaleX(t){(t=h.$clamp(+t,-65535,65535,0))!==this._$scaleX&&this._$doChanged(!0),this._$scaleX=t}get scaleY(){return this._$scaleY}set scaleY(t){(t=h.$clamp(+t,-65535,65535,0))!==this._$scaleY&&this._$doChanged(!0),this._$scaleY=t}clone(){return new et(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){return this._$mapBitmap===t._$mapBitmap&&(this._$mapPoint.x===t._$mapPoint.x&&(this._$mapPoint.y===t._$mapPoint.y&&(this._$componentX===t._$componentX&&(this._$componentY===t._$componentY&&(this._$scaleX===t._$scaleX&&(this._$scaleY===t._$scaleY&&(this._$mode===t._$mode&&(this._$color===t._$color&&this._$alpha===t._$alpha))))))))}_$canApply(){return this._$mapBitmap&&this._$componentX&&this._$componentY&&this._$scaleX&&this._$scaleY}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=s.sqrt(e[0]*e[0]+e[1]*e[1]),a=s.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(r,this._$mapBitmap._$texture,r.width/n,r.height/a,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,h.$intToR(this._$color,this._$alpha,!0),h.$intToG(this._$color,this._$alpha,!0),h.$intToB(this._$color,this._$alpha,!0),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class it extends V{constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,o=1,h=!1,l=!1,$=!1){super(),this._$blurFilter=new Q(r,n,o),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=s,this.strength=a,this.inner=h,this.knockout=l,this.hideObject=$}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=h.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=h.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=h.$clamp(h.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get distance(){return this._$distance}set distance(t){(t=h.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get hideObject(){return this._$hideObject}set hideObject(t){(t=!!t)!==this._$hideObject&&this._$doChanged(!0),this._$hideObject=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=h.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new it(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=this._$angle*h.$Deg2Rad,a=s.cos(n)*this._$distance,o=s.sin(n)*this._$distance;return r.x=s.min(r.x,a),r.width+=s.abs(a),r.y=s.min(r.y,o),r.height+=s.abs(o),r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&(this._$hideObject===t._$hideObject&&this._$blurFilter._$isSame(t._$blurFilter))))))))}_$canApply(){return this._$alpha&&this._$strength&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),$=l.width,_=l.height,c=t._$offsetX,u=t._$offsetY,d=c-a,g=u-o,f=this._$angle*h.$Deg2Rad,p=s.cos(f)*this._$distance*2,m=s.sin(f)*this._$distance*2,x=this._$inner?r:$+s.max(0,s.abs(p)-d),b=this._$inner?n:_+s.max(0,s.abs(m)-g),T=s.ceil(x),v=s.ceil(b),y=(T-x)/2,E=(v-b)/2;let A,M,C,S,R,w;return this._$inner?(A=0,M=0,C=p-c,S=m-u):(A=s.max(0,d-p)+y,M=s.max(0,g-m)+E,C=(p>0?s.max(0,p-d):0)+y,S=(m>0?s.max(0,m-g):0)+E),this._$inner?(R=W.INNER,w=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(R=W.FULL,w=!0):(R=W.OUTER,w=this._$knockout),t._$bind(i),t._$applyBitmapFilter(l,T,v,r,n,A,M,$,_,C,S,!0,R,w,this._$strength,null,null,null,h.$intToR(this._$color,this._$alpha,!0),h.$intToG(this._$color,this._$alpha,!0),h.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+A,t._$offsetY=o+M,t.frameBuffer.releaseTexture(l),t.frameBuffer.getTextureFromCurrentAttachment()}}class st extends V{constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,o=!1){super(),this._$blurFilter=new Q(i,s,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=r,this.inner=a,this.knockout=o}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=h.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=h.$clamp(h.$toColorInt(t),0,16777215,4))!==this._$color&&this._$doChanged(!0),this._$color=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=h.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new st(this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){const s=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$isSame(t){return this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))}_$canApply(){return this._$alpha&&this._$strength&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const s=i.width,r=i.height,n=t._$offsetX,a=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),l=o.width,$=o.height,_=t._$offsetX,c=t._$offsetY,u=this._$inner?s:l,d=this._$inner?r:$;let g,f,p,m;this._$inner?(g=0,f=0,p=-_,m=-c):(g=_-n,f=c-a,p=0,m=0);const x=this._$inner?W.INNER:W.OUTER;return t._$bind(i),t._$applyBitmapFilter(o,u,d,s,r,g,f,l,$,p,m,!0,x,this._$knockout,this._$strength,null,null,null,h.$intToR(this._$color,this._$alpha,!0),h.$intToG(this._$color,this._$alpha,!0),h.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=n+g,t._$offsetY=a+f,t.frameBuffer.releaseTexture(o),t.frameBuffer.getTextureFromCurrentAttachment()}}class rt extends V{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new Q(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=W.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=o,this.type=l,this.knockout=$}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,h.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=h.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=h.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,h.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-s.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=h.$toColorInt(s.abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=h.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,h.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i)t[i]=h.$clamp(+t[i],0,255,0);this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=h.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case W.OUTER:case W.FULL:this._$type=t;break;default:this._$type=W.INNER}}clone(){return new rt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t){let e=t.clone();if(!this._$canApply())return e;e=this._$blurFilter._$generateFilterRect(e);const i=this._$angle*h.$Deg2Rad,r=s.abs(s.cos(i)*this._$distance),n=s.abs(s.sin(i)*this._$distance);return e.x+=-r,e.width+=r,e.y+=-n,e.height+=2*n,e}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$canApply(){return this._$strength&&this._$distance&&this._$alphas&&this._$ratios&&this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=i.width,a=i.height,o=t._$offsetX,l=t._$offsetY,$=s.sqrt(e[0]*e[0]+e[1]*e[1]),_=s.sqrt(e[2]*e[2]+e[3]*e[3]),c=+this._$angle*h.$Deg2Rad,u=+s.cos(c)*this._$distance*$,d=+s.sin(c)*this._$distance*_;let g=t.frameBuffer.createTextureAttachment(n,a);t._$bind(g),h.$resetContext(t),t.drawImage(r,0,0,n,a),t.globalCompositeOperation=I.ERASE,t.drawImage(r,2*u,2*d,n,a);const f=this._$blurFilter._$applyFilter(t,e,!1),p=f.width,m=f.height,x=s.ceil(p+2*s.abs(u)),b=s.ceil(m+2*s.abs(d)),T=this._$type===W.INNER,v=T?n:x,y=T?a:b,E=s.abs(u),A=s.abs(d),M=(p-n)/2,C=(m-a)/2;let S,R,w,O;return T?(S=0,R=0,w=-M-u,O=-C-d):(S=E+M,R=A+C,w=E-u,O=A-d),t._$bind(i),t._$applyBitmapFilter(f,v,y,n,a,S,R,p,m,w,O,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=o+S,t._$offsetY=l+R,t.frameBuffer.releaseTexture(f),t.frameBuffer.getTextureFromCurrentAttachment()}}class nt extends V{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new Q(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=W.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=o,this.type=l,this.knockout=$}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,h.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=h.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=h.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,h.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-s.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=h.$toColorInt(s.abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=h.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,h.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=h.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=h.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case W.OUTER:case W.FULL:this._$type=t;break;default:this._$type=W.INNER}}clone(){return new nt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const n=this._$angle*h.$Deg2Rad,a=s.cos(n)*this._$distance,o=s.sin(n)*this._$distance;return r.x=s.min(r.x,a),r.width+=s.abs(a),r.y=s.min(r.y,o),r.height+=s.abs(o),r}_$canApply(){return this._$strength&&this._$alphas&&this._$ratios&&this._$colors&&this._$blurFilter._$canApply()}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),$=l.width,_=l.height,c=t._$offsetX,u=t._$offsetY,d=c-a,g=u-o,f=s.sqrt(e[0]*e[0]+e[1]*e[1]),p=s.sqrt(e[2]*e[2]+e[3]*e[3]),m=+this._$angle*h.$Deg2Rad,x=+s.cos(m)*this._$distance*f,b=+s.sin(m)*this._$distance*p,T=this.type===W.INNER,v=T?r:$+s.max(0,s.abs(x)-d),y=T?n:_+s.max(0,s.abs(b)-g),E=s.ceil(v),A=s.ceil(y),M=(E-v)/2,C=(A-y)/2;let S,R,w,O;return T?(S=0,R=0,w=x-c,O=b-u):(S=s.max(0,d-x)+M,R=s.max(0,g-b)+C,w=(x>0?s.max(0,x-d):0)+M,O=(b>0?s.max(0,b-g):0)+C),t._$bind(i),t._$applyBitmapFilter(l,E,A,r,n,S,R,$,_,w,O,!0,this.type,this.knockout,this._$strength,this.ratios,this.colors,this.alphas,0,0,0,0,0,0,0,0),t._$offsetX=a+S,t._$offsetY=o+R,t.frameBuffer.releaseTexture(l),t.frameBuffer.getTextureFromCurrentAttachment()}}class at{static toString(){return"[class TextFormatAlign]"}static get namespace(){return"next2d.text.TextFormatAlign"}toString(){return"[object TextFormatAlign]"}get namespace(){return"next2d.text.TextFormatAlign"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get RIGHT(){return"right"}}class ot{static toString(){return"[class TextFieldAutoSize]"}static get namespace(){return"next2d.text.TextFieldAutoSize"}toString(){return"[object TextFieldAutoSize]"}get namespace(){return"next2d.text.TextFieldAutoSize"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get NONE(){return"none"}static get RIGHT(){return"right"}}class ht extends M{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0;const t=new $t;t._$setDefault(this),this._$defaultTextFormat=t,this._$decisionTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict=null,this._$isHTML=!1,this._$textData=null,this._$renew=!0,this._$textHeight=null,this._$textWidth=null,this._$widthTable=null,this._$textarea=null,this._$autoSize=ot.NONE,this._$autoFontSize=!1,this._$textAppending=!1,this._$heightTable=null,this._$textFormatTable=[],this._$textAreaActive=!1,this._$totalWidth=null,this._$objectTable=null,this._$imageData=null,this._$scroll=!1,this._$type=lt.STATIC,this._$textHeightTable=null,this._$focus=!1,this._$isComposing=!1,this._$thickness=0,this._$thicknessColor=0,this._$verticalAlign=_t.TOP}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}static get TEXT(){return"text"}static get BREAK(){return"break"}static get WRAP(){return"wrap"}static get IMAGE(){return"image"}get autoFontSize(){return this._$autoFontSize}set autoFontSize(t){this._$autoFontSize=!!t}get autoSize(){return this._$autoSize}set autoSize(t){switch(t){case ot.CENTER:case ot.LEFT:case ot.RIGHT:this._$autoSize=t;break;default:this._$autoSize=ot.NONE}this._$reload()}get background(){return this._$background}set background(t){this._$background=!!t,this._$reset()}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){this._$backgroundColor=h.$clamp(h.$toColorInt(t),0,16777215,16777215),this._$reset()}get border(){return this._$border}set border(t){this._$border=!!t,this._$reset()}get borderColor(){return this._$borderColor}set borderColor(t){this._$borderColor=h.$clamp(h.$toColorInt(t),0,16777215,0),this._$reset()}get defaultTextFormat(){return this._$defaultTextFormat}set defaultTextFormat(t){t instanceof $t&&(t._$merge(this._$defaultTextFormat),t._$textField=this,this._$defaultTextFormat=t)}get focus(){return this._$focus}set focus(t){if(this._$focus!==!!t)if(this._$focus=!!t,this._$focus){if(this._$type===lt.INPUT){const t=h.$currentPlayer(),e=h.$document.getElementById(t.contentElementId);if(!e)return;this._$createTextAreaElement(t._$scale);const i=this._$textarea,r=this._$transform.concatenatedMatrix,n=this._$getBounds(null),a=h.$intToRGBA(this._$defaultTextFormat._$color,100);i.style.color=`rgb(${a.R},${a.G},${a.B})`,i.style.left=(r.tx+n.xMin+t._$tx/t._$scale/h.$devicePixelRatio)*t._$scale+"px",i.style.top=(r.ty+n.yMin+t._$ty/t._$scale/h.$devicePixelRatio)*t._$scale+"px",i.style.width=`${s.ceil((this.width-1)*t._$scale)}px`,i.style.height=`${s.ceil((this.height-1)*t._$scale)}px`,i.value=this.text,e.appendChild(i);(0,h.$requestAnimationFrame)((()=>{i.focus()})),this._$textAreaActive=!0,this.willTrigger(d.FOCUS_IN)&&this.dispatchEvent(new d(d.FOCUS_IN)),this._$doChanged(),h.$isUpdated=!0}}else this._$textarea&&(this._$textarea.dispatchEvent(new h.$window.Event(`${h.$PREFIX}_blur`)),this.willTrigger(d.FOCUS_OUT)&&this.dispatchEvent(new d(d.FOCUS_OUT)),this._$doChanged(),h.$isUpdated=!0,this._$textarea.remove())}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=`${t}`,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable=[],this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1,this._$getTextData();const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=0,s=0;for(;t>s&&(i+=this._$textHeightTable[s],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){this._$multiline=!!t,this._$reset()}get numLines(){return null===this._$textData&&this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=`${t}`}get scroll(){return this._$scroll}set scroll(t){this._$scroll=!!t}get scrollH(){return this._$scrollH}set scrollH(t){t=h.$clamp(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger(_.SCROLL)&&this.dispatchEvent(new _(_.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){t=h.$clamp(0|t,1,this.maxScrollV),this._$scrollV!==t&&(this._$scrollV=t,this._$reset(),this.willTrigger(_.SCROLL)&&this.dispatchEvent(new _(_.SCROLL,!0)))}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData(),i=0|e.length;for(let s=1;s<i;++s){const i=e[s];switch(i.mode){case ht.TEXT:t+=i.text;break;case ht.BREAK:t+="\r"}}return!this._$isHTML&&this._$initText&&(t+="\r"),this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$cacheText="",this._$isHTML=!1,this._$textAppending||(this._$textFormatTable=[]),this._$reload())}get textColor(){return this._$defaultTextFormat.color}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(""===this.text)return 0;if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();let t=0|this._$decisionTextFormat._$leading;const e=this._$textHeightTable.length;1===e&&(this._$textHeight+=t);for(let t=0;t<e;++t)this._$textHeight+=this._$textHeightTable[t]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=s.max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get thickness(){return this._$thickness}set thickness(t){this._$thickness=0|t,this._$reset()}get thicknessColor(){return this._$thicknessColor}set thicknessColor(t){this._$thicknessColor=h.$clamp(h.$toColorInt(t),0,16777215,16777215),this._$reset()}get type(){return this._$type}set type(t){(t+="")===lt.STATIC?(this._$type=t,this._$textarea=null):this._$type=lt.INPUT}get verticalAlign(){return this._$verticalAlign}set verticalAlign(t){switch(t){case _t.MIDDLE:case _t.BOTTOM:this._$verticalAlign=t;break;default:this._$verticalAlign=_t.TOP}}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap=!!t}get width(){return super.width}set width(t){if(t=+t,!h.$isNaN(t)&&t>-1){const e=this._$getBounds(null),i=s.abs(e.xMin);this._$originBounds.xMax=t+i,this._$originBounds.xMin=i,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}}get height(){return super.height}set height(t){if(t=+t,!h.$isNaN(t)&&t>-1){const e=this._$getBounds(null),i=s.abs(e.yMin);this._$originBounds.yMax=t+i,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this._$textAppending=!0,this.text=e+`${t}`,this._$textAppending=!1}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),s=e>-1?e:i.length;let r=!1,n=new $t,a=t>-1?t:0;for(;a<s;++a){if(i[a].mode===ht.BREAK)continue;const t=i[a].textFormat;r?(n._$align=n._$align!==t._$align?null:t._$align,n._$blockIndent=n._$blockIndent!==t._$blockIndent?null:t._$blockIndent,n._$bold=n._$bold!==t._$bold?null:t._$bold,n._$color=n._$color!==t._$color?null:t._$color,n._$font=n._$font!==t._$font?null:t._$font,n._$indent=n._$indent!==t._$indent?null:t._$indent,n._$italic=n._$italic!==t._$italic?null:t._$italic,n._$leading=n._$leading!==t._$leading?null:t._$leading,n._$leftMargin=n._$leftMargin!==t._$leftMargin?null:t._$leftMargin,n._$letterSpacing=n._$letterSpacing!==t._$letterSpacing?null:t._$letterSpacing,n._$rightMargin=n._$rightMargin!==t._$rightMargin?null:t._$rightMargin,n._$size=n._$size!==t._$size?null:t._$size,n._$underline=n._$underline!==t._$underline?null:t._$underline):(r=!0,n=t._$clone())}return n}getLineText(t){if(!this._$text&&!this._$htmlText)return"";t|=0;let e="";const i=this._$getTextData();for(let s=0;s<i.length;s++){const r=i[s];if(r.yIndex>t)break;r.yIndex===t&&(r.mode===ht.TEXT&&(e+=r.text))}return e}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const s=this.text;t>=s.length?e>=s.length&&e>=t&&(this.text=s+`${i}`):this.text=s.substr(0,t)+`${i}`+s.substr(e,s.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const s=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:{const e=s.length;for(let i=0;i<e;++i)this._$textFormatTable[i]=t._$clone()}break;case e>-1&&-1===i:{let i=e+1,r=s[i];r.mode===ht.WRAP&&(r=s[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let r=0;for(let n=e;n<i;++n){const e=s[n];e&&(e.mode!==ht.WRAP&&e.mode!==ht.BREAK?this._$textFormatTable[n+r]=t._$clone():(++i,--r))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(null===this._$textData){this._$textData=[],this._$imageData=[],this._$heightTable=[],this._$textHeightTable=[],this._$objectTable=[],this._$widthTable=[],this._$heightCache=h.$getMap();let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),h.$P_TAG.innerHTML!==e&&(h.$P_TAG.textContent="",h.$P_TAG.insertAdjacentHTML("afterbegin",e));let s=this._$decisionTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}this._$totalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=this._$getTextHeight(s),this._$widthTable[0]=0;const r={mode:ht.BREAK,x:0,yIndex:0,textFormat:s._$clone()};this._$objectTable[0]=r,this._$textData[0]=r,this._$parseTag(h.$P_TAG,s._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")],i=e.length;for(let s=0;s<i;++s){this._$totalWidth=0;let i=this.defaultTextFormat;const r=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[r]=0,this._$textHeightTable[r]=this._$getTextHeight(i),this._$widthTable[r]=0,r&&(this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(i),i=t}const n={mode:ht.BREAK,x:0,yIndex:r,textFormat:i._$clone()};i=this.defaultTextFormat,this._$objectTable[r]=n,this._$textData[this._$textData.length]=n;const a=e[s];a&&(t=this._$parseText(a,i,t))}}h.$poolMap(this._$heightCache),this._$heightCache=null}return this._$textData}_$parseTag(t,e,i){const r=t.childNodes,n=r.length;for(let t=0;t<n;++t){let n=e._$clone();const a=r[t];if(3!==a.nodeType)switch(a.nodeName){case"P":{if(a.hasAttribute("align")&&(n._$align=a.getAttribute("align").toLowerCase(),1===this._$textData.length&&(this._$textData[0].textFormat._$align=n._$align)),this._$parseTag(a,n,i),!this._$multiline)break;this._$totalWidth=this._$getImageOffsetX();const t=this._$heightTable.length;if(this._$heightTable[t]=0,this._$textHeightTable[t]=0,this._$widthTable[t]=0,t&&(this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(n),n=t}const e={mode:ht.BREAK,x:0,yIndex:t,textFormat:n};this._$objectTable[t]=e,this._$textData.push(e)}break;case"B":n._$bold=!0,this._$parseTag(a,n,i);break;case"I":n._$italic=!0,this._$parseTag(a,n,i);break;case"U":n._$underline=!0,this._$parseTag(a,n,i);break;case"FONT":a.hasAttribute("face")&&(n._$font=a.getAttribute("face")),a.hasAttribute("size")&&(n._$size=0|a.getAttribute("size")),a.hasAttribute("color")&&(n._$color=h.$toColorInt(a.getAttribute("color"))),a.hasAttribute("letterSpacing")&&(n.letterSpacing=0|a.getAttribute("letterSpacing")),this._$parseTag(a,n,i);break;case"TEXTFORMAT":a.hasAttribute("blockindent")&&(n._$blockIndent=0|a.getAttribute("blockindent")),a.hasAttribute("indent")&&(n._$indent=0|a.getAttribute("indent")),a.hasAttribute("leading")&&(n._$leading=0|a.getAttribute("leading")),a.hasAttribute("leftmargin")&&(n._$leftMargin=0|a.getAttribute("leftmargin")),a.hasAttribute("rightmargin")&&(n._$rightMargin=0|a.getAttribute("rightmargin")),this._$parseTag(a,n,i);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0,this._$totalWidth=this._$getImageOffsetX(),n._$indent=0;const e={mode:ht.BREAK,x:0,yIndex:t,textFormat:n};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"IMG":{let t="";a.hasAttribute("src")&&(t=a.getAttribute("src"));let e=null;if(h.$loadedImages.has(t))e=h.$loadedImages.get(t);else{const i=a.getAttribute("width")||0,r=a.getAttribute("height")||0,o=a.getAttribute("vspace")||8,l=a.getAttribute("hspace")||8;let $=0;for(let t=0;t<this._$textHeightTable.length;t++)$+=this._$textHeightTable[t];if(e={mode:ht.IMAGE,src:t,loaded:!1,x:0,y:$,width:0|i,height:0|r,hspace:0|l,vspace:0|o,textFormat:n._$clone()},this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],i=t.y+t.height+2*t.vspace;e.y=s.max($,i)}this._$loadImage(e),h.$loadedImages.set(t,e)}this._$textData[this._$textData.length]=e,this._$imageData[this._$imageData.length]=e}break;default:this._$parseTag(a,n,i)}else i=this._$parseText(a.nodeValue,n)}}_$loadImage(t){t.scope=this,t.image=new h.$Image,t.image.crossOrigin="anonymous",t.image.addEventListener("load",function(){this.loaded=!0,this.width||(this.width=0|this.image.width),this.height||(this.height=0|this.image.height);const t=this.scope;this.scope=null,h.$loadedImages.set(this.src,this),t._$reload()}.bind(t),!1),t.image.src=t.src}_$parseText(t,e,i){let r=this._$heightTable.length-1|0,n=e._$clone();const a=this._$transform.concatenatedMatrix._$matrix,o=(this._$originBounds.xMax-this._$originBounds.xMin)*(a[0]/a[3]);h.$poolFloat32Array6(a);const l=o-n._$widthMargin()-4;for(let a=0;a<t.length;++a){if(n=e._$clone(),this._$textData.length+i in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+i]._$clone();t._$merge(n),n=t}const o={mode:ht.TEXT,text:t[a],x:0,width:0,fontScale:0,yIndex:r,textFormat:n};let $=null;this._$multiline&&($="\n"===o.text||"\r"===o.text||"\n\r"===o.text);let _=r?n._$leading:0,c=0,u=0,d=0,g=null;if(h.$textContext.font=n._$generateFontStyle(),c=h.$textContext.measureText(o.text).width+n._$letterSpacing,u=this._$getTextHeight(n),d=u+_,o.height=u,$||this._$wordWrap&&this._$totalWidth+c>l){this._$widthTable[++r]=0,o.yIndex=r,this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1],this._$totalWidth=this._$getImageOffsetX(),n=n._$clone(),n._$indent=0;g={mode:$?ht.BREAK:ht.WRAP,x:0,yIndex:r,textFormat:n},this._$objectTable[r]=g,$||--i;let t=o.text,e=0,a=!0;const h=/[0-9a-zA-Z?!;:.,]/g;for(;t.match(h);){++e;const i=this._$textData[this._$textData.length-e];if(i.mode!==ht.TEXT){a=!1;break}t=i.text}if(e>1&&this._$textData[this._$textData.length-e+1].text.match(/[0-9a-zA-Z]/g)&&--e,e>0&&a){const t=this._$textData.length-e;this._$textData.splice(t,0,g);let i=1,n=this._$textData[t-i];for(this._$widthTable[r-1]=0,this._$heightTable[r-1]=0,this._$textHeightTable[r-1]=0;n.mode===ht.TEXT;)u=this._$getTextHeight(n.textFormat),d=u+_,this._$widthTable[r-1]+=n.width,this._$heightTable[r-1]=s.max(this._$heightTable[r-1],u),this._$textHeightTable[r-1]=s.max(this._$textHeightTable[r-1],d),++i,n=this._$textData[t-i];for(i=1;this._$textData.length>t+i;)n=this._$textData[t+i],++i,u=this._$getTextHeight(n.textFormat),d=u+_,this._$heightTable[r]=s.max(this._$heightTable[r],u),this._$textHeightTable[r]=s.max(this._$textHeightTable[r],d),n.x=this._$totalWidth,n.yIndex=r,this._$totalWidth+=n.width}else this._$textData[this._$textData.length]=g}$||(o.width=c,o.x=this._$totalWidth,this._$totalWidth+=c,this._$widthTable[r]=s.max(this._$widthTable[r],this._$totalWidth),this._$heightTable[r]=s.max(this._$heightTable[r],u),this._$textHeightTable[r]=s.max(this._$textHeightTable[r],d),this._$textData[this._$textData.length]=o)}return i}_$getTextHeight(t){if(!h.$DIV){const t=h.$document.createElement("div");t.innerHTML="a",t.style.display="block",t.style.position="absolute",t.style.top="-9999px",t.style.left="-9999px",t.style.padding="0",t.style.margin="0",t.style.padding="0",t.style.border="0",t.style.outline="0",t.style.verticalAlign="bottom",t.style.lineHeight="100%",h.$DIV=t,h.$document.body.appendChild(h.$DIV)}const e=t._$size,i=t._$font,s=t._$bold?"bold":"normal",r=`${e}_${i}_${s}`;if(this._$heightCache.has(r))return this._$heightCache.get(r);const n=h.$DIV.style,a=`${e}px`;n.fontSize!==a&&(n.fontSize=a),n.fontFamily!==i&&(n.fontFamily=i),n.fontWeight!==s&&(n.fontWeight=s);const o=10>e?h.$DIV.clientHeight*e*.1:h.$DIV.clientHeight;return this._$heightCache.set(r,o),o}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],s=i.height+2*i.vspace;if(i.y<=t&&t<i.y+s)return i.width+2*i.hspace}return 0}_$reset(){this._$renew=!0,this._$textData=null,this._$imageData=null,this._$textHeight=null,this._$textWidth=null,this._$heightTable=null,this._$textHeightTable=null,this._$widthTable=null,this._$objectTable=null,this._$totalWidth=null,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),h.$isUpdated=!0,h.$cacheStore().removeCache(this._$instanceId)}_$reload(){if(this._$reset(),this._$getTextData(),this._$autoSize===ot.NONE&&this._$autoFontSize){const t=this.defaultTextFormat.size;if(this.width&&this.textWidth&&this.textWidth>this.width)for(;this.textWidth>this.width;){if(this.defaultTextFormat.size--,1>this.defaultTextFormat.size){this.defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}if(this.height&&this.textHeight&&this.textHeight>this.height)for(;this.textHeight>this.height;){if(this.defaultTextFormat.size--,1>this.defaultTextFormat.size){this.defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}this.defaultTextFormat.size=t}this._$resize()}_$resize(){if(this._$autoSize!==ot.NONE){const t=this._$defaultTextFormat,e=this.textWidth+4+t._$leftMargin+t._$rightMargin;if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case ot.LEFT:case ot.CENTER:this._$bounds.xMax=e+this._$bounds.xMin;break;case ot.RIGHT:this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],r=t.textFormat,n=r._$blockIndent+r._$leftMargin>0?r._$blockIndent+r._$leftMargin:0;switch(!0){case!1===this._$wordWrap&&i>e:return s.max(0,n);case r._$align===at.CENTER:case this._$autoSize===ot.CENTER:return s.max(0,e/2-n-r._$rightMargin-i/2);case r._$align===at.RIGHT:case this._$autoSize===ot.RIGHT:return s.max(0,e-n-i-r._$rightMargin-2);default:return s.max(0,n+2)}}_$getBounds(t=null){if(t){const e=h.$multiplicationMatrix(t,this._$correctMatrix(this._$transform._$rawMatrix()));return h.$boundsMatrix(this._$bounds,e)}return h.$boundsMatrix(this._$bounds,this._$correctMatrix(h.$MATRIX_ARRAY_IDENTITY))}_$correctMatrix(t){switch(this._$autoSize){case ot.CENTER:{const e=this.textWidth+4,i=(this._$originBounds.xMax-this._$originBounds.xMin)/2-e/2;return h.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}case ot.RIGHT:{const e=this.textWidth+4,i=this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin);return h.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}default:return t}}_$buildCharacter(t){const e=this.defaultTextFormat;switch(e.font=t.font,e.size=0|t.size,e.align=t.align,e.color=0|t.color,e.leading=t.leading,e.letterSpacing=t.letterSpacing,e.leftMargin=t.leftMargin,e.rightMargin=t.rightMargin,t.fontType){case 1:e.bold=!0;break;case 2:e.italic=!0;break;case 3:e.bold=!0,e.italic=!0}switch(this._$type=t.inputType,this._$multiline=!!t.multiline,this._$wordWrap=!!t.wordWrap,this._$border=!!t.border,this._$scroll=!!t.scroll,this._$thickness=0|t.thickness,this._$thicknessColor=0|t.thicknessColor,this._$bounds.xMin=t.originBounds.xMin,this._$bounds.xMax=t.originBounds.xMax,this._$bounds.yMin=t.originBounds.yMin,this._$bounds.yMax=t.originBounds.yMax,this._$originBounds.xMin=t.originBounds.xMin,this._$originBounds.xMax=t.originBounds.xMax,this._$originBounds.yMin=t.originBounds.yMin,this._$originBounds.yMax=t.originBounds.yMax,t.autoSize){case 1:this.autoSize=t.align;break;case 2:this.autoFontSize=!0}this.text=t.text}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const i=this._$getBounds(),r=i.xMax,n=i.xMin,a=i.yMax,o=i.yMin;h.$poolBoundsObject(i);let l=s.ceil(s.abs(r-n)),$=s.ceil(s.abs(a-o));if(!l||!$)return;let _=e;const c=this._$transform._$rawMatrix();c!==h.$MATRIX_ARRAY_IDENTITY&&(_=h.$multiplicationMatrix(e,c)),h.$resetContext(t),t.setTransform(_[0],_[1],_[2],_[3],_[4],_[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(l,0),t.lineTo(l,$),t.lineTo(0,$),t.lineTo(0,0),t.clip(!0),_!==e&&h.$poolFloat32Array6(_)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let n=i;const a=this._$transform._$rawColorTransform();a!==h.$COLOR_ARRAY_IDENTITY&&(n=h.$multiplicationColor(i,a));const o=h.$clamp(n[3]+n[7]/255,0,1);if(!o)return;let l=e;const $=this._$transform._$rawMatrix();$!==h.$MATRIX_ARRAY_IDENTITY&&(l=h.$multiplicationMatrix(e,$));const _=this._$getBounds(null);_.xMin-=this._$thickness,_.xMax+=this._$thickness,_.yMin-=this._$thickness,_.yMax+=this._$thickness;const c=_.xMin,u=_.yMin,d=h.$boundsMatrix(_,l),g=+d.xMax,f=+d.xMin,p=+d.yMax,m=+d.yMin;h.$poolBoundsObject(d);let x=s.ceil(s.abs(g-f)),b=s.ceil(s.abs(p-m));switch(!0){case 0===x:case 0===b:case x===-h.$Infinity:case b===-h.$Infinity:case x===h.$Infinity:case b===h.$Infinity:return}if(0>f+x||0>m+b)return;const T=t.frameBuffer.currentAttachment;if(f>T.width||m>T.height)return;let v=+s.sqrt(l[0]*l[0]+l[1]*l[1]);if(!r.isInteger(v)){const t=v.toString(),e=t.indexOf("e");-1!==e&&(v=+t.slice(0,e)),v=+v.toFixed(4)}let E=+s.sqrt(l[2]*l[2]+l[3]*l[3]);if(!r.isInteger(E)){const t=E.toString(),e=t.indexOf("e");-1!==e&&(E=+t.slice(0,e)),E=+E.toFixed(4)}const A=this._$filters||this.filters;if(0>f+x||0>m+b){if(!(A&&A.length&&this._$canApply(A)))return;{let t=new y(0,0,x,b);for(let e=0;e<A.length;++e)t=A[e]._$generateFilterRect(t,v,E);if(0>t.x+t.width||0>t.y+t.height)return}}const M=h.$getArray(v,E),C=h.$cacheStore(),S=C.generateKeys(this._$instanceId,M,n);let R=C.get(S);if(h.$poolArray(M),R&&(this._$renew||this._$isUpdated())&&(C.removeCache(this._$instanceId),R=null),!R){const i=s.ceil(s.abs(_.xMax-_.xMin)*v),r=s.ceil(s.abs(_.yMax-_.yMin)*E);this._$renew=!1,n[3]=1;const a=C.getCanvas();a.width=i,a.height=r;const o=a.getContext("2d");if(this._$background||this._$border){if(o.beginPath(),o.moveTo(0,0),o.lineTo(i,0),o.lineTo(i,r),o.lineTo(0,r),o.lineTo(0,0),this._$background){const t=h.$intToRGBA(this._$backgroundColor),e=s.max(0,s.min(255*t.A*n[3]+n[7],255))/255;o.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,o.fill()}if(this._$border){const t=h.$intToRGBA(this._$borderColor),e=s.max(0,s.min(255*t.A*n[3]+n[7],255))/255;o.lineWidth=1,o.strokeStyle=`rgba(${t.R},${t.G},${t.B},${e})`,o.stroke()}}o.save(),o.beginPath(),o.moveTo(2,2),o.lineTo(i-2,2),o.lineTo(i-2,r-2),o.lineTo(2,r-2),o.lineTo(2,2),o.clip(),o.beginPath(),o.setTransform(v,0,0,E,0,0),this._$doDraw(o,e,n,i/e[0]),o.restore(),R=t.frameBuffer.createTextureFromCanvas(o.canvas),C.set(S,R),C.destroy(o)}h.$poolArray(S),h.$poolBoundsObject(_);const w=this._$blendMode||this.blendMode;if(A&&A.length){if(this._$canApply(A)){const s=this._$drawFilter(t,R,l,A,x,b);return h.$resetContext(t),t._$globalAlpha=o,t._$globalCompositeOperation=w,t.setTransform(1,0,0,1,f-s._$offsetX,m-s._$offsetY),t.drawImage(s,0,0,s.width,s.height,n),l!==e&&h.$poolFloat32Array6(l),void(n!==i&&h.$poolFloat32Array8(n))}}h.$resetContext(t),t._$globalAlpha=o,t._$globalCompositeOperation=w;const O=s.atan2(l[1],l[0]),I=s.atan2(-l[2],l[3]);if(O||I){const e=c*v,i=u*E;t.setTransform(s.cos(O),s.sin(O),-s.sin(I),s.cos(I),e*s.cos(O)-i*s.sin(I)+l[4],e*s.sin(O)+i*s.cos(I)+l[5])}else t.setTransform(1,0,0,1,f,m);t.drawImage(R,0,0,R.width,R.height,n),l!==e&&h.$poolFloat32Array6(l),n!==i&&h.$poolFloat32Array8(n)}_$doDraw(t,e,i,r){const n=this._$getTextData(),a=this.width,o=this.height;let l=0,$=0,_=0,c=0;if(this._$verticalAlign!==_t.TOP&&this.height>this.textHeight)switch(this._$verticalAlign){case _t.MIDDLE:c=(this.height-this.textHeight+2)/2;break;case _t.BOTTOM:c=this.height-this.textHeight+2}const u=n.length;for(let d=0;d<u;++d){let u=n[d];if(0===u.width)continue;const g=l+u.x;if(this._$autoSize===ot.NONE&&($>o||g>a))continue;let f=u.textFormat;const p=h.$intToRGBA(u.textFormat._$color),m=s.max(0,s.min(255*p.A*i[3]+i[7],255))/255;if(t.fillStyle=`rgba(${p.R},${p.G},${p.B},${m})`,this._$thickness){const e=h.$intToRGBA(this._$thicknessColor),r=s.max(0,s.min(255*e.A*i[3]+i[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${r})`}const x=0|u.yIndex;switch(u.mode){case ht.BREAK:case ht.WRAP:if(_++,this.scrollV>_)continue;if($+=this._$textHeightTable[x],l=this._$getAlignOffset(this._$objectTable[x],r),f._$underline){const r=u.textFormat._$size/12,n=h.$intToRGBA(f._$color),a=s.max(0,s.min(255*n.A*i[3]+i[7],255))/255;t.lineWidth=s.max(1,1/s.min(e[0],e[3])),t.strokeStyle=`rgba(${n.R},${n.G},${n.B},${a})`,t.beginPath(),t.moveTo(l,c+$-r),t.lineTo(l+this._$widthTable[x],c+$-r),t.stroke()}break;case ht.TEXT:{if(this.scrollV>_)continue;let e=$-this._$heightTable[0];h.$isSafari||(e+=u.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=f._$generateFontStyle(),this._$thickness&&t.strokeText(u.text,g,c+e),t.fillText(u.text,g,c+e)}break;case ht.IMAGE:if(!u.loaded)continue;t.beginPath(),t.drawImage(u.image,u.hspace,c+u.y,u.width,u.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let r=e;const n=this._$transform._$rawMatrix();n!==h.$MATRIX_ARRAY_IDENTITY&&(r=h.$multiplicationMatrix(e,n));const a=this._$getBounds(null),o=h.$boundsMatrix(a,r),l=+o.xMax,$=+o.xMin,_=+o.yMax,c=+o.yMin;h.$poolBoundsObject(o),h.$poolBoundsObject(a);const u=s.ceil(s.abs(l-$)),d=s.ceil(s.abs(_-c));return t.setTransform(1,0,0,1,$,c),t.beginPath(),t.moveTo(0,0),t.lineTo(u,0),t.lineTo(u,d),t.lineTo(0,d),t.lineTo(0,0),r!==e&&h.$poolFloat32Array6(r),t.isPointInPath(i.x,i.y)}_$createTextAreaElement(t){if(!this._$textarea){this._$textarea=h.$document.createElement("textarea"),this._$textarea.value=this.text,this._$textarea.id=`${h.$PREFIX}_TextField_${this._$instanceId}`,this._$wordWrap||(this._$textarea.wrap="off");const t=this.defaultTextFormat;if(this._$textarea.style.position="absolute",this._$textarea.style.outline="0",this._$textarea.style.padding=`2px 2px 2px ${s.max(3,0|t.leftMargin)}px`,this._$textarea.style.margin="0",this._$textarea.style.appearance="none",this._$textarea.style.resize="none",this._$textarea.style.border=this._$border?`solid 1px #${this.borderColor.toString(16)}`:"none",this._$textarea.style.overflow="hidden",this._$textarea.style.zIndex=2147483647,this._$textarea.style.verticalAlign="top",this._$textarea.style.backgroundColor=this._$border||this._$background?`#${this.backgroundColor.toString(16)}`:"transparent",this._$textarea.addEventListener(`${h.$PREFIX}_blur`,function(t){let e=t.target.value?t.target.value:"";if(e&&this._$restrict){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new n(t,"gm"));e=i?i.join(""):""}this.text=e;if(h.$document.getElementById(h.$currentPlayer().contentElementId)){const t=h.$document.getElementById(`${h.$PREFIX}_TextField_${this._$instanceId}`);t&&(t.remove(),this._$focus=!1,this._$textAreaActive=!1,h.$isUpdated=!0,this._$doChanged())}}.bind(this)),this._$textarea.addEventListener("input",function(t){let e=t.target.value?t.target.value:"";if(this._$restrict&&!this._$isComposing&&e){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new n(t,"gm"));e=i?i.join(""):""}if(!this._$isComposing&&this.text!==e){this.text=e,t.target.value=e,this.willTrigger(_.CHANGE)&&this.dispatchEvent(new _(_.CHANGE,!0));const i=h.$currentPlayer(),r=this._$textarea,n=this._$transform.concatenatedMatrix,a=this._$getBounds(null);r.style.left=`${s.floor((n.tx+a.xMin+i._$tx/i._$scale/h.$devicePixelRatio)*i._$scale)}px`,r.style.top=`${s.floor((n.ty+a.yMin+i._$ty/i._$scale/h.$devicePixelRatio)*i._$scale)}px`,r.style.width=`${s.ceil((this.width-1)*i._$scale)}px`,r.style.height=`${s.ceil((this.height-1)*i._$scale)}px`}}.bind(this)),this._$textarea.addEventListener("compositionstart",function(){this._$isComposing=!0}.bind(this)),this._$textarea.addEventListener("compositionend",function(t){this._$isComposing=!1;let e=t.target.value?t.target.value:"";if(!this._$restrict||!e)return;let i=this._$restrict;"["!==i[0]&&(i="["+i),"]"!==i[i.length-1]&&(i+="]");const s=e.match(new n(i,"gm"));e=s?s.join(""):"",this.text=e,t.target.value=e}.bind(this)),this._$textarea.addEventListener("click",function(){this.willTrigger(p.CLICK)&&this.dispatchEvent(new p(p.CLICK))}.bind(this)),this._$textarea.addEventListener(h.$MOUSE_WHEEL,function(t){this.scrollV+=t.deltaY}.bind(this)),this._$textarea.addEventListener(h.$SCROLL,function(){if(this._$scrollEventLock)return void(this._$scrollEventLock=!1);const t=parseFloat(this._$textarea.style.height);this.scrollV=this._$textarea.scrollTop/(this._$textarea.scrollHeight-t)*this.maxScrollV+1}.bind(this)),!0===h.$isTouch)this._$textarea.addEventListener(h.$TOUCH_START,(function(){const t=h.$currentPlayer();t&&(t._$state="down")})),this._$textarea.addEventListener(h.$TOUCH_END,(function(){const t=h.$currentPlayer();t&&(t._$state="up")}));else this._$textarea.addEventListener(h.$MOUSE_DOWN,(function(){const t=h.$currentPlayer();t&&(t._$state="down")})),this._$textarea.addEventListener(h.$MOUSE_UP,(function(){const t=h.$currentPlayer();t&&(t._$state="up")}))}const e=this.defaultTextFormat,i=s.ceil(e.size*t*this._$transform.concatenatedMatrix.d);this._$textarea.style.fontSize=`${i}px`,this._$textarea.style.fontFamily=e.font,this._$textarea.style.lineHeight=(i+s.max(0,0|e.leading))/i+"em",this._$autoSize!==ot.NONE?this._$textarea.style.textAlign=ot.CENTER:this._$textarea.style.textAlign=e.align,this._$textarea.onkeydown||(this._$textarea.onkeydown=function(t){let e=t.target.value?t.target.value:"";if(this._$restrict&&!this._$isComposing&&e){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new n(t,"gm"));e=i?i.join(""):""}if(this._$isComposing||(this.text=e,t.target.value=e),13===t.keyCode&&!this._$multiline)return!1}.bind(this)),this._$textarea.maxLength=2147483647,this._$maxChars&&(this._$textarea.maxLength=this._$maxChars)}}class lt{static toString(){return"[class TextFieldType]"}static get namespace(){return"next2d.text.TextFieldType"}toString(){return"[object TextFieldType]"}get namespace(){return"next2d.text.TextFieldType"}static get INPUT(){return"input"}static get STATIC(){return"static"}}class $t{constructor(t=null,e=null,i=null,s=null,r=null,n=null,a=null,o=null,l=null,$=null,_=null,c=null){this._$font=t,this._$size=e,this._$color=null===i?null:h.$clamp(h.$toColorInt(i),0,16777215,16777215),this._$bold=s,this._$italic=r,this._$underline=n,this._$align=a,this._$leftMargin=o,this._$rightMargin=l,this._$indent=$,this._$leading=_,this._$blockIndent=c,this._$letterSpacing=0,this._$textField=null}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){switch(t){case at.CENTER:case at.RIGHT:case at.LEFT:this._$align=t;break;default:this._$align=null}this._$textField&&(this._$textField._$renew=!0)}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t,this._$textField&&(this._$textField._$renew=!0)}get bold(){return this._$bold}set bold(t){this._$bold=!!t,this._$textField&&(this._$textField._$renew=!0)}get color(){return this._$color}set color(t){this._$color=h.$clamp(h.$toColorInt(t),0,16777215,0),this._$textField&&(this._$textField._$renew=!0)}get font(){return this._$font}set font(t){this._$font=`${t}`,this._$textField&&(this._$textField._$renew=!0)}get indent(){return this._$indent}set indent(t){this._$indent=t,this._$textField&&(this._$textField._$renew=!0)}get italic(){return this._$italic}set italic(t){this._$italic=!!t,this._$textField&&(this._$textField._$renew=!0)}get leading(){return this._$leading}set leading(t){this._$leading=t,this._$textField&&(this._$textField._$renew=!0)}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t,this._$textField&&(this._$textField._$renew=!0)}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t,this._$textField&&(this._$textField._$renew=!0)}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t,this._$textField&&(this._$textField._$renew=!0)}get size(){return this._$size}set size(t){this._$size=0|t,this._$textField&&(this._$textField._$renew=!0)}get underline(){return this._$underline}set underline(t){this._$underline=!!t,this._$textField&&(this._$textField._$renew=!0)}_$clone(){const t=new $t(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t._$textField=this._$textField,t}_$setDefault(t=null){this._$align=at.LEFT,this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="Times New Roman",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1,this._$textField=t}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t.color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){return this._$indent+this._$leftMargin+this._$rightMargin}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','sans-serif'`}}class _t{static toString(){return"[class TextFormatVerticalAlign]"}static get namespace(){return"next2d.text.TextFormatVerticalAlign"}toString(){return"[object TextFormatVerticalAlign]"}get namespace(){return"next2d.text.TextFormatVerticalAlign"}static get TOP(){return"top"}static get MIDDLE(){return"middle"}static get BOTTOM(){return"bottom"}}class ct extends c{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$buffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=h.$getArray(),this._$volume=1,this._$loop=!1,this._$stopFlag=!0}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=s.min(ut.volume,h.$clamp(t,0,1,1));const e=this._$sources.length;if(e&&h.$audioContext)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume}}clone(){const t=new ct;return t.volume=this.volume,t.loop=this.loop,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){h.$ajax({format:ft.ARRAY_BUFFER,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(_.OPEN)&&this.dispatchEvent(new _(_.OPEN)),this.willTrigger(m.PROGRESS)&&this.dispatchEvent(new m(m.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(m.PROGRESS)&&this.dispatchEvent(new m(m.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(m.PROGRESS)&&this.dispatchEvent(new m(m.PROGRESS,!1,!1,t.loaded,t.total)),199<t.target.status&&400>t.target.status?(this._$buffer=new Uint8Array(t.target.response),h.$audioContext?h.$decodeAudioData(this):h.$audios.push(this),h.$currentPlayer()._$loaders.push(this)):this.willTrigger(f.IO_ERROR)&&this.dispatchEvent(new f(f.IO_ERROR,!1,!1,t.target.statusText,t.target.status))}.bind(this)}})}play(t=0){const e=this._$character?this._$character.audioBuffer:this._$audioBuffer;if(h.$audioContext&&e)this._$createBufferSource(t);else{const e=function(t,i=0){if(null!==(this._$character?this._$character.audioBuffer:this._$audioBuffer)&&null!==h.$audioContext){const e=(h.$performance.now()-t)/1e3;return void this._$createBufferSource(i,e)}(0,h.$requestAnimationFrame)(e)}.bind(this,h.$performance.now(),t);(0,h.$requestAnimationFrame)(e)}}stop(){this._$stopFlag=!0;const t=this._$sources.length;if(t){const e=h.$currentPlayer();if(h.$audioContext)for(let e=0;e<t;++e){const t=this._$sources[e];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect()}e._$sources.splice(e._$sources.indexOf(this),1),this._$sources.length=0}}_$build(t,e){this._$character=e._$loaderInfo._$data.characters[t.characterId],this._$character.init||(this._$character.init=!0,this._$character.buffer=new Uint8Array(this._$character.buffer),h.$audioContext?h.$decodeAudioData(this):h.$audios.push(this)),this._$loop=t.loop,this._$volume=s.min(ut.volume,t.volume)}_$createBufferSource(t=0,e=0){const i=h.$audioContext.createBufferSource();i._$startTime=t,i.onended=this._$endEventHandler.bind(this),i.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,i._$gainNode=h.$audioContext.createGain(),i._$gainNode.connect(h.$audioContext.destination);const r=s.min(ut.volume,this._$volume);i._$gainNode.gain.value=r,i._$volume=r,i.connect(i._$gainNode),i.start(0|t,e);const n=h.$currentPlayer();-1===n._$sources.indexOf(this)&&n._$sources.push(this),this._$sources.push(i),this._$stopFlag=!1}_$endEventHandler(t){const e=t.target;if(this._$sources.splice(this._$sources.indexOf(e),1),this._$loop&&!this._$stopFlag)this._$createBufferSource();else{if(h.$audioContext&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),!this._$sources.length){const t=h.$currentPlayer();t._$sources.splice(t._$sources.indexOf(this),1)}this.willTrigger(_.SOUND_COMPLETE)&&this.dispatchEvent(new _(_.SOUND_COMPLETE))}}}class ut{static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static get volume(){return h.$soundMixerVolume}static set volume(t){h.$soundMixerVolume=h.$clamp(t,0,1,1);const e=h.$currentPlayer()._$sources;for(let t=0;t<e.length;++t){const i=e[t];i._$gainNode.gain.value=s.min(h.$soundMixerVolume,i._$volume)}const i=h.$currentPlayer()._$videos;for(let t=0;t<i.length;++t){const e=i[t];e._$video.volume=s.min(e.volume,h.$soundMixerVolume)}}static stopAll(){const t=h.$currentPlayer(),e=t._$sources;for(;e.length;)e[0].stop();const i=t._$videos;for(let t=0;t<i.length;++t)i[t].pause()}}class dt{constructor(t=1,e=!1){this._$volume=1,this._$loop=!1,this.volume=t,this.loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=!!t}get volume(){return this._$volume}set volume(t){this._$volume=h.$clamp(+t,0,1,0)}}class gt extends A{constructor(t=320,e=240){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=h.$getBoundsObject(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$stop=!0,this._$wait=!1,this._$volume=1}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=!!t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video?(this._$video.removeEventListener("canplaythrough",this._$start),this._$video.addEventListener("canplaythrough",this._$start)):this._$initializeVideo(),this._$video.src=t,this._$video.load()}get videoHeight(){return this._$video?this._$video.videoHeight:this._$bounds.yMax}get videoWidth(){return this._$video?this._$video.videoWidth:this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=s.min(ut.volume,h.$clamp(t,0,1,1)),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$texture&&h.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$video&&this._$video.pause(),this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause();(0,h.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(h.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),this.dispatchEvent(new x(x.PAUSE),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=h.$currentPlayer();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){if(this._$video&&this._$stop){this._$stop=!1,this._$video.volume=s.min(this._$volume,ut.volume),this._$video.play();const t=h.$requestAnimationFrame;this._$timerId=t(this._$update),this.dispatchEvent(new x(x.PLAY),!1,!1,this._$bytesLoaded,this._$bytesTotal);const e=h.$currentPlayer();-1===e._$videos.indexOf(this)&&e._$videos.push(this)}}seek(t){this._$video&&(this._$video.currentTime=t,this.dispatchEvent(new x(x.SEEK),!1,!1,this._$bytesLoaded,this._$bytesTotal))}_$initializeVideo(){this._$video=h.$document.createElement("video"),this._$update=function(){const t=h.$currentPlayer();if(!this._$stage){this._$video.pause();return(0,h.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(t._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),void t._$videos.splice(t._$videos.indexOf(this),1)}t._$draw(0),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this._$texture=t._$context.frameBuffer.createTextureFromVideo(this._$video,this._$smoothing,this._$texture),this.dispatchEvent(new x(x.PROGRESS),!1,!1,this._$bytesLoaded,this._$bytesTotal),this._$doChanged());const e=h.$requestAnimationFrame;this._$timerId=e(this._$update)}.bind(this),this._$sound=function(){const t=h.$isTouch?h.$TOUCH_END:h.$MOUSE_UP;h.$currentPlayer()._$canvas.removeEventListener(t,this._$sound),this._$video.muted=!1}.bind(this),this._$video.muted=!0,this._$video.autoplay=!1,this._$video.crossOrigin="anonymous",this._$video.type="video/mp4",h.$isTouch&&this._$video.setAttribute("playsinline",""),this._$start=function(){if(this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration,h.$audioContext)this._$video.muted=!1;else{const t=h.$isTouch?h.$TOUCH_END:h.$MOUSE_UP;h.$currentPlayer()._$canvas.addEventListener(t,this._$sound)}if(this._$autoPlay){const t=h.$currentPlayer();-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$wait=!0,this._$doChanged()}}.bind(this),this._$video.addEventListener("canplaythrough",this._$start),this._$video.addEventListener("ended",function(){if(this._$loop)return void(this._$video.currentTime=0);this.dispatchEvent(new x(x.PLAY_END),!1,!1,this._$bytesLoaded,this._$bytesTotal);(0,h.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1}.bind(this))}_$buildCharacter(t){this._$loop=t.loop,this._$autoPlay=t.autoPlay,this._$bounds=t.bounds,this._$video||this._$initializeVideo(),this._$video.src=URL.createObjectURL(new Blob([new Uint8Array(t.buffer)],{type:"video/mp4"})),this._$video.volume=s.min(t.volume,ut.volume),this._$video.load()}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$clip(t,e){let i=this._$bounds.xMax,s=this._$bounds.yMax;if(!i||!s)return;let r=e;const n=this._$transform._$rawMatrix();n!==h.$MATRIX_ARRAY_IDENTITY&&(r=h.$multiplicationMatrix(e,n)),h.$resetContext(t),t.setTransform(r[0],r[1],r[2],r[3],r[4],r[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(!0),r!==e&&h.$poolFloat32Array6(r)}_$draw(t,e,i){if(!this._$visible)return;if(this._$wait){this._$stop=!1,this._$video.play(),this.dispatchEvent(new x(x.PLAY_START),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=h.$requestAnimationFrame;this._$timerId=t(this._$update),this._$wait=!1}if(!this._$texture)return;let r=i;const n=this._$transform._$rawColorTransform();n!==h.$COLOR_ARRAY_IDENTITY&&(r=h.$multiplicationColor(i,n));const a=h.$clamp(r[3]+r[7]/255,0,1,0);if(!a)return void(r!==i&&h.$poolFloat32Array8(r));let o=e;const l=this._$transform._$rawMatrix();l!==h.$MATRIX_ARRAY_IDENTITY&&(o=h.$multiplicationMatrix(e,l));const $=h.$boundsMatrix(this._$bounds,o),_=+$.xMax,c=+$.xMin,u=+$.yMax,d=+$.yMin;h.$poolBoundsObject($);let g=s.ceil(s.abs(_-c)),f=s.ceil(s.abs(u-d));switch(!0){case 0===g:case 0===f:case g===-h.$Infinity:case f===-h.$Infinity:case g===h.$Infinity:case f===h.$Infinity:return}const p=t.frameBuffer.currentAttachment;if(c>p.width||d>p.height)return;let m=+s.sqrt(o[0]*o[0]+o[1]*o[1]),b=+s.sqrt(o[2]*o[2]+o[3]*o[3]);const T=this._$filters||this.filters;if(0>c+g||0>d+f){if(!(T&&T.length&&this._$canApply(T)))return;{let t=new y(0,0,g,f);for(let e=0;e<T.length;++e)t=T[e]._$generateFilterRect(t,m,b);if(0>t.x+t.width||0>t.y+t.height)return}}let v=this._$texture;const E=this._$blendMode||this.blendMode;if(T&&T.length&&this._$canApply(T)){let e=this._$texture;if(1!==m||1!==b){const i=t.frameBuffer.currentAttachment,s=t.frameBuffer.createCacheAttachment(e.width*m,e.height*b);t._$bind(s),h.$resetContext(t),t.setTransform(m,0,0,b,0,0),t.drawImage(this._$texture,0,0,this._$texture.width,this._$texture.height),e=t.frameBuffer.getTextureFromCurrentAttachment(),t._$bind(i),t.frameBuffer.releaseAttachment(s,!1)}v=this._$drawFilter(t,e,o,T,g,f),h.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=E;const i=h.$boundsMatrix(this._$bounds,o);t.setTransform(1,0,0,1,i.xMin-v._$offsetX,i.yMin-v._$offsetY),t.drawImage(v,0,0,v.width,v.height,r),h.$poolBoundsObject(i)}else h.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=E,t.setTransform(o[0],o[1],o[2],o[3],o[4],o[5]),t.drawImage(v,0,0,v.width,v.height,r);o!==e&&h.$poolFloat32Array6(o),r!==i&&h.$poolFloat32Array8(r)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let r=e;const n=this._$transform._$rawMatrix();n!==h.$MATRIX_ARRAY_IDENTITY&&(r=h.$multiplicationMatrix(e,n));const a=this._$getBounds(null),o=h.$boundsMatrix(a,r),l=+o.xMax,$=+o.xMin,_=+o.yMax,c=+o.yMin;h.$poolBoundsObject(o),h.$poolBoundsObject(a);const u=s.ceil(s.abs(l-$)),d=s.ceil(s.abs(_-c));return t.setTransform(1,0,0,1,$,c),t.beginPath(),t.moveTo(0,0),t.lineTo(u,0),t.lineTo(u,d),t.lineTo(0,d),t.lineTo(0,0),r!==e&&h.$poolFloat32Array6(r),t.isPointInPath(i.x,i.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();i!==h.$MATRIX_ARRAY_IDENTITY&&(e=h.$multiplicationMatrix(t,i));const s=h.$boundsMatrix(this._$bounds,e);return e!==t&&h.$poolFloat32Array6(e),s}return h.$getBoundsObject(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}}class ft{static toString(){return"[class URLLoaderDataFormat]"}static get namespace(){return"next2d.net.URLLoaderDataFormat"}toString(){return"[object URLLoaderDataFormat]"}get namespace(){return"next2d.net.URLLoaderDataFormat"}static get ARRAY_BUFFER(){return"arraybuffer"}static get JSON(){return"json"}}class pt{constructor(t=""){this._$url=t,this._$contentType="application/json",this._$data=null,this._$method=xt.GET,this._$requestHeaders=h.$getArray(),this._$userAgent=h.$navigator.userAgent,this._$responseDataFormat=ft.JSON,this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){switch((t+="").toUpperCase()){case xt.DELETE:case xt.HEAD:case xt.OPTIONS:case xt.POST:case xt.PUT:this._$method=t;break;default:this._$method=xt.GET}}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){h.$isArray(t)&&(this._$requestHeaders=t)}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=h.$currentPlayer();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get userAgent(){return this._$userAgent}get responseDataFormat(){return this._$responseDataFormat}set responseDataFormat(t){this._$responseDataFormat=`${t}`}get withCredentials(){return this._$withCredentials}get headers(){const t=h.$getMap();t.set("Content-Type",`${this._$contentType}`);const e=this._$requestHeaders.length;for(let i=0;i<e;++i){const e=this._$requestHeaders[i];e instanceof mt&&t.set(e.name,e.value)}return t}}class mt{constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}get value(){return this._$value}}class xt{static toString(){return"[class URLRequestMethod]"}static get namespace(){return"next2d.net.URLRequestMethod"}toString(){return"[object URLRequestMethod]"}get namespace(){return"next2d.net.URLRequestMethod"}static get DELETE(){return"DELETE"}static get GET(){return"GET"}static get HEAD(){return"HEAD"}static get OPTIONS(){return"OPTIONS"}static get POST(){return"POST"}static get PUT(){return"PUT"}}class bt{static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,s){return t/s*i+e}static inQuad(t,e,i,s){return(t/=s)*t*i+e}static outQuad(t,e,i,s){return-(t/=s)*(t-2)*i+e}static inOutQuad(t,e,i,s){return(t/=s/2)<1?t*t*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,s){return(t/=s)*t*t*i+e}static outCubic(t,e,i,s){return t/=s,(--t*t*t+1)*i+e}static inOutCubic(t,e,i,s){return(t/=s/2)<1?t*t*t*i/2+e:((t-=2)*t*t+2)*i/2+e}static inQuart(t,e,i,s){return(t/=s)*t*t*t*i+e}static outQuart(t,e,i,s){return t/=s,(--t*t*t*t-1)*-i+e}static inOutQuart(t,e,i,s){return(t/=s/2)<1?t*t*t*t*i/2+e:((t-=2)*t*t*t-2)*-i/2+e}static inQuint(t,e,i,s){return(t/=s)*t*t*t*t*i+e}static outQuint(t,e,i,s){return t/=s,(--t*t*t*t*t+1)*i+e}static inOutQuint(t,e,i,s){return(t/=s/2)<1?t*t*t*t*t*i/2+e:((t-=2)*t*t*t*t+2)*i/2+e}static inSine(t,e,i,s){return-i*Math.cos(t/s*(Math.PI/2))+i+e}static outSine(t,e,i,s){return i*Math.sin(t/s*(Math.PI/2))+e}static inOutSine(t,e,i,s){return-i/2*(Math.cos(Math.PI*t/s)-1)+e}static inExpo(t,e,i,s){return i*Math.pow(2,10*(t/s-1))+e}static outExpo(t,e,i,s){return i*(1-Math.pow(2,-10*t/s))+e}static inOutExpo(t,e,i,s){return(t/=s/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*(t-1)))+e}static inCirc(t,e,i,s){return(1-Math.sqrt(1-(t/=s)*t))*i+e}static outCirc(t,e,i,s){return t/=s,Math.sqrt(1- --t*t)*i+e}static inOutCirc(t,e,i,s){return(t/=2*s)<1?(Math.sqrt(1-t*t)-1)/-2*i+e:(Math.sqrt(1-(t-=2)*t)+1)/2*i+e}static inBack(t,e,i,s){return(2.70158*(t/=s)*t*t-1.70158*t*t)*i+e}static outBack(t,e,i,s){return(1+2.70158*Math.pow((t/=s)-1,3)+1.70158*Math.pow(t-1,2))*i+e}static inOutBack(t,e,i,s){let r=1.70158;return(t/=s/2)<1?t*t*((1+(r*=1.525))*t-r)*i/2+e:((t-=2)*t*((1+(r*=1.525))*t+r)+2)*i/2+e}static inElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:-Math.pow(2,(t*=10)-10)*Math.sin((t-10.75)*(2*Math.PI/3))*i+e}static outElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:(Math.pow(2,-10*t)*Math.sin((10*t-.75)*(2*Math.PI/3))+1)*i+e}static inOutElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:t<.5?-Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2*i+e:(Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2+1)*i+e}static outBounce(t,e,i,s){return(t/=s)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,s){return i-bt.outBounce(s-t,0,i,s)+e}static inOutBounce(t,e,i,s){return t<s/2?bt.inBounce(2*t,e,i/2,s):bt.outBounce(2*t-s,e+i/2,i/2,s)}}class Tt extends c{constructor(t,e=null,i=null,s=0,r=1,n=null){super(),this._$target=t,this._$delay=s,this._$duration=r,this._$ease=n||bt.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$to=i,this._$update=null}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$stopFlag=!1,this._$startTime=h.$performance.now(),this._$update=this.update.bind(this),this._$names=this.entries(this._$from),this.addEventListener(_.ENTER_FRAME,this._$update)}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],s=i[1];s&&"object"==typeof s&&(i[1]=this.entries(s))}return e}start(){if(this._$delay){(0,h.$setTimeout)(function(){this.initialize()}.bind(this),1e3*this._$delay)}else this.initialize()}stop(){this._$stopFlag=!0,this.removeEventListener(_.ENTER_FRAME,this._$update),this.hasEventListener(_.STOP)&&this.dispatchEvent(new _(_.STOP))}update(){this._$stopFlag?this.removeEventListener(_.ENTER_FRAME,this._$update):(this._$currentTime=.001*(h.$performance.now()-this._$startTime),this.updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener(_.UPDATE)&&this.dispatchEvent(new _(_.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener(_.ENTER_FRAME,this._$update),this.hasEventListener(_.COMPLETE)&&this.dispatchEvent(new _(_.COMPLETE))))}updateProperty(t,e,i,s){for(let r=0;r<s.length;++r){const n=s[r],a=n[0],o=n[1];if(o&&"object"==typeof o){this.updateProperty(t[a],e[a],i[a],o);continue}const h=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,h,i[a]-h,this._$duration):t[a]=i[a]}}}class vt{static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,s=0,r=1,n=null){return new Tt(t,e,i,s,r,n)}}class yt{constructor(){this._$pool=h.$getArray(),this._$store=h.$getMap(),this._$lifeCount=2,this._$delayLifeCheck=this.lifeCheck.bind(this),this._$delayBitmapLifeCheck=this.bitmapLifeCheck.bind(this)}reset(){const t=this._$store.values();for(const e of t){const t=e.values();for(const e of t)this.destroy(e);h.$poolMap(e)}this._$store.clear()}destroy(t){if(t)switch(t.constructor){case h.$WebGLTexture:return new Promise((()=>{const e=h.$currentPlayer();if(e._$context){const i=e._$context,s=t._$bitmapData;if(s){s._$getPixelsAsync(0,0,s.width,s.height,"RGBA"),t._$bitmapData=!1;(0,h.$setTimeout)(this._$delayBitmapLifeCheck,2e3,s)}i.frameBuffer.releaseTexture(t)}}));case h.$CanvasRenderingContext2D:return new Promise((()=>{const e=t.canvas,i=e.width,s=e.height;t.clearRect(0,0,i+1,s+1),e.width=e.height=1,this._$pool.push(e)}))}}getCanvas(){return this._$pool.pop()||h.$document.createElement("canvas")}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t),i=e.values();for(const t of i)this.destroy(t);h.$poolMap(e),this._$store.delete(t)}}generateLifeKey(t,e){return`${t}:${e}`}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){const t=this._$store.get(e);if(t.has(i)){const e=`life_${i}`;return 1===t.has(e)&&t.set(e,this._$lifeCount),t.get(i)}}return null}set(t,e=null){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,h.$getMap());const r=this._$store.get(i);if(!e)return r.delete(s),r.delete(`life_${s}`),void(r.size||(h.$poolMap(r),this._$store.delete(i)));const n=r.get(s);n&&n!==e&&this.destroy(n),r.set(s,e),r.set(`life_${s}`,this._$lifeCount);(0,h.$setTimeout)(this._$delayLifeCheck,5e3,i,s)}bitmapLifeCheck(t){if(!t._$pixelBuffer)return;const e=h.$currentPlayer()._$context;t._$buffer=e.pbo.getBufferSubDataAsync(t._$pixelBuffer),t._$pixelBuffer=null}lifeCheck(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t),s=`life_${e}`,r=i.get(s)-1;if(!r)return this.destroy(i.get(e)),i.delete(e),i.delete(s),void(i.size||(h.$poolMap(i),this._$store.delete(t)));i.set(s,r);(0,h.$setTimeout)(this._$delayLifeCheck,5e3,t,e)}generateKeys(t,e=null,i=null){let s="";e&&(s+=`${e.join("_")}`),i&&(s+=this.colorToString(i));const r=h.$getArray();return r[1]=s?this.generateHash(s):"_0",r[0]=`${t}`,r}colorToString(t=null){return t&&0!==t[7]?`_${t[7]}`:""}generateHash(t){let e=0;const i=t.length;for(let s=0;s<i;s++){e=(e<<5)-e+t.charCodeAt(s),e|=0}return`_${e}`}}class Et{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n`}}class At{static SOLID_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n`}static BITMAP_CLIPPED(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${Et.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static BITMAP_PATTERN(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${Et.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static MASK(t){return`${t.version()}\n${t.extensionDerivatives()}\nprecision mediump float;\n\n${t.varyingIn()} vec2 v_bezier;\n${t.outColor()}\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        ${t.fragColor()} = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n`}}class Mt{static FILL_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = u_mediump;\n}\n\n`}static COPY_SRC_TEX(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = ${t.texture2D()}(u_src_tex, v_src_tex_coord);\n}\n\n`}static COPY_CHANNEL(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_ch = u_mediump[0];\n    vec4 dst_ch = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    // src_color \n    float src_value = dot(src_color, src_ch);\n\n    // \n    vec4 mixed = mix(dst_color, vec4(src_value), dst_ch);\n\n#if ${t}\n    ${e.fragColor()} = vec4(mixed.rgb * mixed.a, mixed.a);\n#else\n    ${e.fragColor()} = vec4(mixed.rgb, 1.0);\n#endif\n}\n\n`}static MERGE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    vec4 merged = mix(dst_color, src_color, u_mediump);\n\n#if ${t}\n    ${e.fragColor()} = vec4(merged.rgb * merged.a, merged.a);\n#else\n    ${e.fragColor()} = vec4(merged.rgb, 1.0);\n#endif\n}\n\n`}static COPY_PIXELS_WITH_ALPHA_BITMAP_DATA(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.varyingIn()} vec2 v_alpha_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src_color = ${t.texture2D()}(u_textures[0], v_src_tex_coord);\n    float alpha = ${t.texture2D()}(u_textures[1], v_alpha_tex_coord).a;\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    alpha *= src_color.a;\n\n    ${t.fragColor()} = vec4(src_color.rgb * alpha, alpha);\n}\n\n`}static PALETTE_MAP(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n                                                //  256*4\n    vec4 map_r = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.r*255.0)/256.0, 0.125));\n    vec4 map_g = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.g*255.0)/256.0, 0.375));\n    vec4 map_b = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.b*255.0)/256.0, 0.625));\n    vec4 map_a = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.a*255.0)/256.0, 0.875));\n\n    // u_plt_tex(u_textures[1])  BGRA  .bgra\n    // TODO  ARGB  .gbar\n    vec4 color = (map_r + map_g + map_b + map_a).bgra;\n\n    // fract  1.0, 2.0, ...  0.0  1.0 \n    vec4 color_fract = fract(color);\n    color = color_fract + sign(color) - sign(color_fract);\n\n#if ${t}\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#else\n    ${e.fragColor()} = vec4(color.rgb, 1.0);\n#endif\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t}\n    ${e.fragColor()} = src_color;\n#else\n    ${e.fragColor()} = vec4(src_color.rgb, 1.0);\n#endif\n}\n\n`}static COLOR_TRANSFORM(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 ct_mul = u_mediump[0];\n    vec4 ct_add = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n    vec4 color = clamp(ct_mul * src_color + ct_add, 0.0, 1.0);\n\n    color = vec4(color.rgb * color.a, color.a);\n\n#if !${t}\n    color.a = 1.0;\n#endif\n\n    ${e.fragColor()} = color * sign(src_color.a);  // \n}\n\n`}static bitwiseAnd(){return"\n#if __VERSION__ < 130\n// 8bit\nint bitwiseAnd(int a, int b) {\n    //ivec4 c1 = ivec4(1,2,4,8);\n    //ivec4 c2 = ivec4(16,32,64,128);\n\n    //ivec4 a1 = ivec4(a) / c1;\n    //ivec4 a2 = ivec4(a) / c2;\n    //ivec4 b1 = ivec4(b) / c1;\n    //ivec4 b2 = ivec4(b) / c2;\n\n    //ivec4 r = (a1-a1/2*2) * (b1-b1/2*2) * c1\n    //        + (a2-a2/2*2) * (b2-b2/2*2) * c2;\n\n    //return r.x + r.y + r.z + r.w;\n\n    //  intrakusanint\n    //  float\n\n    vec4 a0 = vec4(float(a));\n    vec4 b0 = vec4(float(b));\n    vec4 a1 = floor(a0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 a2 = floor(a0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n    vec4 b1 = floor(b0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 b2 = floor(b0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n\n    return int(dot((a1-floor(a1*0.5)*2.0)*(b1-floor(b1*0.5)*2.0), vec4(1.0,2.0,4.0,8.0))\n             + dot((a2-floor(a2*0.5)*2.0)*(b2-floor(b2*0.5)*2.0), vec4(16.0,32.0,64.0,128.0)));\n}\n\nivec4 bitwiseAnd(ivec4 a, ivec4 b) {\n    return ivec4(bitwiseAnd(a.r, b.r),\n                 bitwiseAnd(a.g, b.g),\n                 bitwiseAnd(a.b, b.b),\n                 bitwiseAnd(a.a, b.a));\n}\n#else\n#define bitwiseAnd(a, b) ((a)&(b))\n#endif\n"}static THRESHOLD(t,e,i,s){return e|=0,i|=0,`${s.version()}\n#if __VERSION__ < 130\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2]; // u_threshold(u_mediump[0]) JS\nuniform ivec4 u_integer;\n\n${s.varyingIn()} vec2 v_src_tex_coord;\n\n#if __VERSION__ < 130\n#define outColor0 gl_FragData[0]\n#define outColor1 gl_FragData[1]\n#else\nlayout (location = 0) out vec4 outColor0;\nlayout (location = 1) out vec4 outColor1;\n#endif\n\n${Mt.bitwiseAnd()}\n\nbool less(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) < 0.0;\n}\n\nbool greater(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) > 0.0;\n}\n\nbool lessEqual(vec4 x) {\n    return !greater(x);\n}\n\nbool greaterEqual(vec4 x) {\n    return !less(x);\n}\n\n//  equal  thresholdEqual \nbool thresholdEqual(vec4 x) {\n    return all(equal(x, u_mediump[0]));\n}\n\n//  notEqual  thresholdNotEqual \nbool thresholdNotEqual(vec4 x) {\n    return any(notEqual(x, u_mediump[0]));\n}\n\nvoid main() {\n    // Flash Player\n\n    vec4 src_color = ${s.texture2D()}(u_src_tex, v_src_tex_coord);\n    ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), u_integer);\n\n    if (${t}(vec4(masked))) {\n        outColor0 = u_mediump[1];\n        outColor1 = vec4(1.0);\n    } else {\n#if ${e}\n    #if ${i}\n        outColor0 = src_color;\n    #else\n        outColor0 = vec4(src_color.rgb, 1.0);\n    #endif\n        outColor1 = vec4(0.0);\n#else\n        discard;\n#endif\n    }\n}\n\n`}static THRESHOLD_SUBTOTAL(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2 src_tex_step   = u_mediump.xy;\n    float subtotal_loop = u_mediump.z;\n\n    float subtotal = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 4095.0; ++i) {      //  4095.0 \n        if (j++ >= subtotal_loop) {           // BitmapData.prototype.threshold \n            break;\n        }\n#else\n    for (float i = 0.0; i < subtotal_loop; ++i) {\n#endif\n        subtotal += ${t.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i).a;\n    }\n\n    vec4 v1 = floor(subtotal * vec4(1.0, 0.00390625, 0.0000152587890625, 5.960464477539063e-8));  // vec4(1.0, 1.0/256.0, 1.0/65536.0, 1.0/16777216.0)\n    vec4 v2 = vec4(v1.yzw, 0.0);\n    ${t.fragColor()} = (v1 - v2*256.0) * 0.00392156862745098;  // 1.0/255.0\n}\n\n`}static GET_COLOR_BOUNDS_RECT(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\nuniform ivec4 u_integer[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\n${Mt.bitwiseAnd()}\n\nvoid main() {\n    vec2 src_tex_step = u_mediump.xy;\n    float scan_loop   = u_mediump.z;\n    ivec4 mask  = u_integer[0];\n    ivec4 color = u_integer[1];\n\n    float found = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 8191.0; ++i) {      // BitmapData  8191 \n        if (j++ >= scan_loop) {\n            break;\n        }\n#else\n    for (float i = 0.0; i < scan_loop; ++i) {\n#endif\n        vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i);\n        ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), mask);\n\n#if ${t}\n        if (all(equal(masked, color))) {\n#else\n        if (any(notEqual(masked, color))) {\n#endif\n            found = 1.0;\n            break;\n        }\n    }\n\n    ${e.fragColor()} = vec4(found);\n}\n\n`}static NOISE(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[3];\n\n${t.outColor()}\n\n// https://stackoverflow.com/a/28095165\n//\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio\n\nvec4 gold_noise(vec2 xy, vec4 seed) {\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvoid main() {\n    vec4 seed = u_mediump[0];\n    vec4 amp  = u_mediump[1];\n    vec4 low  = u_mediump[2];\n\n    vec4 noise = gold_noise(gl_FragCoord.xy, seed);\n    vec4 color = noise * amp + low;\n    ${t.fragColor()} = vec4(color.rgb * color.a, color.a);\n}\n\n`}static GET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb / max(0.0001, color.a), color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr / max(0.0001, color.a), color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.a, color.rgb / max(0.0001, color.a));\n#endif\n}\n\n`}static SET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr * color.a, color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.gba * color.r, color.r);\n#endif\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_dst_tex;\n\n${t.varyingIn()} vec2 v_dst_tex_coord;\n${t.varyingIn()} vec4 v_color;\n${t.outColor()}\n\nvoid main() {\n    float da = ${t.texture2D()}(u_dst_tex, v_dst_tex_coord).a;\n    float a = v_color.a;\n\n    ${t.fragColor()} = max( a, 0.0) * v_color\n                     + max(-a, 0.0) * vec4(v_color.rgb * da, da);\n}\n\n`}}class Ct{static TEMPLATE(t,e){const i=e?"uniform vec4 u_mediump[2];":"",s=e?Et.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${i}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src = ${t.texture2D()}(u_texture, v_coord);\n    ${s}\n    ${t.fragColor()} = src;\n}\n\n`}}class St{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBitmapShader(){return this._$collection.has("b")||this._$collection.set("b",new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),Ct.TEMPLATE(this._$keyword,0,0,!1))),this._$collection.get("b")}setBitmapUniform(){}setGetPixelsUniform(t,e,i,s,r){const n=t.highp;n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n[12]=e,n[13]=0,n[14]=0,n[16]=0,n[17]=i,n[18]=0,n[3]=s,n[7]=r,n[11]=1}setSetPixelsUniform(t,e,i,s,r,n,a,o,h){const l=t.highp;l[0]=e,l[1]=0,l[2]=0,l[4]=0,l[5]=i,l[6]=0,l[8]=s,l[9]=r,l[10]=1,l[12]=n,l[13]=0,l[14]=0,l[16]=0,l[17]=a,l[18]=0,l[3]=o,l[7]=h,l[11]=1}setColorTransformUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4]/255,i[5]=e[5]/255,i[6]=e[6]/255,i[7]=e[7]/255}setManipulatePixelsUniform(t,e,i,s,r,n){const a=t.highp;a[0]=e[0],a[1]=e[1],a[2]=e[2],a[4]=e[3],a[5]=e[4],a[6]=e[5],a[8]=e[6],a[9]=e[7],a[10]=e[8],r?(a[12]=s[0],a[13]=s[1],a[14]=s[2],a[16]=s[3],a[17]=s[4],a[18]=s[5],a[20]=s[6],a[21]=s[7],a[22]=s[8],a[24]=n[0],a[25]=n[1],a[26]=n[2],a[3]=n[3],a[7]=n[4],a[11]=n[5],a[15]=n[6],a[19]=n[7],a[23]=n[8]):i&&(a[12]=s[0],a[13]=s[1],a[14]=s[2],a[16]=s[3],a[17]=s[4],a[18]=s[5],a[3]=s[6],a[7]=s[7],a[11]=s[8])}setCopyChannelUniform(t,e,i){const s=t.textures;s[0]=0,s[1]=1;const r=t.mediump;r[0]=1&e,r[1]=e>>1&1,r[2]=e>>2&1,r[3]=e>>3&1,r[4]=1&i,r[5]=i>>1&1,r[6]=i>>2&1,r[7]=i>>3&1}setCopyPixelsUniform(t,e){if(e){const e=t.textures;e[0]=0,e[1]=1}}setFillRectUniform(t,e,i,s,r){const n=t.mediump;n[0]=e,n[1]=i,n[2]=s,n[3]=r}setGetColorBoundsRectUniform(t,e,i,s,r,n){const a=t.highp;a[0]=1,a[1]=0,a[2]=0,a[4]=0,a[5]=1,a[6]=0,a[8]=0,a[9]=0,a[10]=1,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[16]=e[3],a[17]=e[4],a[18]=e[5],a[3]=e[6],a[7]=e[7],a[11]=e[8];const o=t.mediump;o[0]=i[0],o[1]=i[1],o[2]=s;const h=t.integer;h[0]=r[0],h[1]=r[1],h[2]=r[2],h[3]=r[3],h[4]=n[0],h[5]=n[1],h[6]=n[2],h[7]=n[3]}setMergeUniform(t,e,i,s,r){const n=t.textures;n[0]=0,n[1]=1;const a=t.mediump;a[0]=e,a[1]=i,a[2]=s,a[3]=r}setNoiseUniform(t,e,i,s,r,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=s,u[3]=r,u[4]=n,u[5]=a,u[6]=o,u[7]=h,u[8]=l,u[9]=$,u[10]=_,u[11]=c}setPaletteMapUniform(t){const e=t.textures;e[0]=0,e[1]=2}setPixelDissolveUniform(t,e,i,s,r){const n=t.mediump;n[0]=e,n[1]=i,n[2]=s,n[3]=r}setFlushSetPixelQueueUniform(t){const e=t.highp;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=-1,e[5]=0,e[6]=0,e[7]=1,e[8]=1}setThresholdUniform(t,e,i,s,r,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=s,u[3]=r,u[4]=n,u[5]=a,u[6]=o,u[7]=h;const d=t.integer;d[0]=l,d[1]=$,d[2]=_,d[3]=c}}class Rt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getNormalBlendShader(t){const e="n"+(t?"y":"n");return this._$collection.has(e)||this._$collection.set(e,new te(this._$gl,this._$context,Lt.BLEND(this._$keyword),Ct.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getClipShader(){return this._$collection.has("c")||this._$collection.set("c",new te(this._$gl,this._$context,Lt.BLEND_CLIP(this._$keyword),Ct.TEMPLATE(this._$keyword,!1))),this._$collection.get("c")}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;return this._$collection.has(i)||this._$collection.set(i,new te(this._$gl,this._$context,Lt.BLEND(this._$keyword),class{static TEMPLATE(t,e,i){let s;switch(e){case I.SUBTRACT:s=this.FUNCTION_SUBTRACT();break;case I.MULTIPLY:s=this.FUNCTION_MULTIPLY();break;case I.LIGHTEN:s=this.FUNCTION_LIGHTEN();break;case I.DARKEN:s=this.FUNCTION_DARKEN();break;case I.OVERLAY:s=this.FUNCTION_OVERLAY();break;case I.HARDLIGHT:s=this.FUNCTION_HARDLIGHT();break;case I.DIFFERENCE:s=this.FUNCTION_DIFFERENCE();break;case I.INVERT:s=this.FUNCTION_INVERT();break;default:s=this.FUNCTION_NORMAL()}const r=i?"uniform vec4 u_mediump[2];":"",n=i?Et.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${r}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${s}\n\nvoid main() {\n    vec4 dst = ${t.texture2D()}(u_textures[0], v_coord);\n    vec4 src = ${t.texture2D()}(u_textures[1], v_coord);\n    ${n}\n    ${t.fragColor()} = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}.TEMPLATE(this._$keyword,t,e))),this._$collection.get(i)}setNormalBlendUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,f){const p=t.highp;if(p[0]=e,p[1]=i,p[2]=s,p[3]=r,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}setClipUniform(t,e,i,s,r,n,a,o){const h=t.highp;h[0]=e,h[1]=i,h[2]=s,h[3]=r,h[4]=n[0],h[5]=n[1],h[6]=n[2],h[8]=n[3],h[9]=n[4],h[10]=n[5],h[12]=n[6],h[13]=n[7],h[14]=n[8],h[7]=a,h[11]=o}setBlendUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,f){const p=t.textures;p[0]=0,p[1]=1;const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class wt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBlurFilterShader(t){const e=`b${t}`;return this._$collection.has(e)||this._$collection.set(e,new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e){const i=e.toFixed(1);return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${i}; i += 1.0) {\n        color += ${t.texture2D()}(u_texture, v_coord + offset * i);\n        color += ${t.texture2D()}(u_texture, v_coord - offset * i);\n    }\n    color += ${t.texture2D()}(u_texture, v_coord + offset * ${i}) * fraction;\n    color += ${t.texture2D()}(u_texture, v_coord - offset * ${i}) * fraction;\n    color /= samples;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getBitmapFilterShader(t,e,i,r,n,a,o){const h=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${r}${n?"y":"n"}${a?"y":"n"}`;if(!this._$collection.has(h)){let l=1;t&&l++,o&&l++;let $=(t?4:0)+(e?4:0)+(a?1:0);o||($+=i?4:8),$=s.ceil($/4),this._$collection.set(h,new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,r,n,a,o,h,l){let $=0;const _=s?this.STATEMENT_BASE_TEXTURE_TRANSFORM(t,$++):"",c=r?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(t,$++):this.STATEMENT_BLUR_TEXTURE(t),u=a===W.INNER,d=$;let g,f,p=4*$;switch(l?g=n?this.STATEMENT_GLOW(t,!1,s,h,l,d,p):this.STATEMENT_BEVEL(t,s,r,h,l,d,p):n?(p+=4,g=this.STATEMENT_GLOW(t,u,s,h,l,d,p)):(p+=8,g=this.STATEMENT_BEVEL(t,s,r,h,l,d,p)),a){case W.OUTER:f=o?"blur - blur * base.a":"base + blur - blur * base.a";break;case W.FULL:f=o?"blur":"base - base * blur.a + blur";break;default:f="blur"}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[${e}];\nuniform vec4 u_mediump[${i}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${Et.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${_}\n    ${c}\n    ${g}\n    ${t.fragColor()} = ${f};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t,e){return`\n    vec2 base_scale  = u_mediump[${e}].xy;\n    vec2 base_offset = u_mediump[${e}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), ${t.texture2D()}(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(t){return`\n    vec4 blur = ${t.texture2D()}(u_textures[0], v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t,e){return`\n    vec2 blur_scale  = u_mediump[${e}].xy;\n    vec2 blur_offset = u_mediump[${e}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,s,r,n,a){return`\n    ${e?"blur.a = 1.0 - blur.a;":""}\n    ${s?this.STATEMENT_GLOW_STRENGTH(a):""}\n    ${r?this.STATEMENT_GLOW_GRADIENT_COLOR(t,i):this.STATEMENT_GLOW_SOLID_COLOR(n)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${s.floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,s,r,n,a){return`\n    ${i?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t):this.STATEMENT_BLUR_TEXTURE_2(t)}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${s?this.STATEMENT_BEVEL_STRENGTH(a):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${r?this.STATEMENT_BEVEL_GRADIENT_COLOR(t,e):this.STATEMENT_BEVEL_SOLID_COLOR(n)}\n`}static STATEMENT_BLUR_TEXTURE_2(t){return`\n    vec4 blur2 = ${t.texture2D()}(u_textures[0], 1.0 - v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t){return`\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], pq), isInside(pq));\n`}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${s.floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}.TEMPLATE(this._$keyword,l,$,t,e,i,r,n,a,o)))}return this._$collection.get(h)}getColorMatrixFilterShader(){return this._$collection.has("m")||this._$collection.set("m",new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),class{static TEMPLATE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword))),this._$collection.get("m")}getConvolutionFilterShader(t,e,i,r){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${r?"y":"n"}`;if(!this._$collection.has(n)){const a=(r?1:2)+s.ceil(t*e/4);this._$collection.set(n,new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r,n,a){const o=s.floor(.5*i),h=s.floor(.5*r),l=i*r;let $="";const _=a?1:2;for(let t=0;t<l;++t){$+=`\n    result += getWeightedColor(${t}, u_mediump[${_+s.floor(t/4)}][${t%4}]);\n`}const c=n?`result.a = ${t.texture2D()}(u_texture, v_coord).a;`:"",u=a?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${Et.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${i};\n    int i_mod_x = i - ${i} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${o}, ${h} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = ${t.texture2D()}(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${u}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${$}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${c}\n\n    result.rgb *= result.a;\n    ${t.fragColor()} = result;\n}\n\n`}}.TEMPLATE(this._$keyword,a,t,e,i,r)))}return this._$collection.get(n)}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(!this._$collection.has(s)){const r=i===K.COLOR?3:2;this._$collection.set(s,new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,r){let n,a,o;switch(i){case O.RED:n="map_color.r";break;case O.GREEN:n="map_color.g";break;case O.BLUE:n="map_color.b";break;case O.ALPHA:n="map_color.a";break;default:n="0.5"}switch(s){case O.RED:a="map_color.r";break;case O.GREEN:a="map_color.g";break;case O.BLUE:a="map_color.b";break;case O.ALPHA:a="map_color.a";break;default:a="0.5"}switch(r){case K.CLAMP:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], uv);\n`;break;case K.IGNORE:o=`\n    vec4 source_color =${t.texture2D()}(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n`;break;case K.COLOR:o=`\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, ${t.texture2D()}(u_textures[0], uv), isInside(uv));\n`;break;default:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], fract(uv));\n`}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${Et.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = ${t.texture2D()}(u_textures[1], st);\n\n    vec2 offset = vec2(${n}, ${a}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${o}\n\n    ${t.fragColor()} = mix(${t.texture2D()}(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}.TEMPLATE(this._$keyword,r,t,e,i)))}return this._$collection.get(s)}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,f,p,m,x,b,T,v,y,E){let A;T?(A=t.textures,A[0]=0,A[1]=1,E&&(A[2]=2)):E&&(A=t.textures,A[0]=0,A[1]=2);const M=t.mediump;let C=0;T&&(M[C]=e/s,M[C+1]=i/r,M[C+2]=n/s,M[C+3]=(i-r-a)/r,C+=4),v&&(M[C]=e/o,M[C+1]=i/h,M[C+2]=l/o,M[C+3]=(i-h-$)/h,C+=4),E||(_?(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,C+=4):(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,M[C+4]=p,M[C+5]=m,M[C+6]=x,M[C+7]=b,C+=8)),y&&(M[C++]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,o,h,l,$){const _=t.mediump;_[0]=1/e,_[1]=1/i,_[2]=1/r,_[3]=n/255;let c=4;a||(_[c]=o,_[c+1]=h,_[c+2]=l,_[c+3]=$,c+=4);const u=s.length;for(let t=0;t<u;t++)_[c++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=o/s,g[5]=-h/r,l===K.COLOR&&(g[8]=$,g[9]=_,g[10]=c,g[11]=u)}}class Ot{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=s.ceil(5*t/4);this._$collection.set(i,new te(this._$gl,this._$context,Lt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r){let n="";for(let t=1;t<i;t++){const e=t-1,r=t,a=`u_mediump[${i+s.floor(e/4)}][${e%4}]`,o=`u_mediump[${i+s.floor(r/4)}][${r%4}]`;n+=`\n    if (t <= ${o}) {\n        return mix(u_mediump[${e}], u_mediump[${r}], (t - ${a}) / (${o} - ${a}));\n    }\n`}const a=r?"color = pow(color, vec4(0.45454545));":"";return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${i}][0]) {\n        return u_mediump[0];\n    }\n    ${n}\n    return u_mediump[${i-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${a}\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,r,t,e)))}return this._$collection.get(i)}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n++]=r[i[0]],a[n++]=r[i[1]],a[n++]=r[i[2]],a[n++]=r[i[3]]}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const o=t.mediump;for(let t=r;t<n;t++){const e=i[t];o[a++]=(e>>16)/255,o[a++]=(e>>8&255)/255,o[a++]=(255&e)/255,o[a++]=s[t]}for(let t=r;t<n;t++)o[a++]=e[t]}}class It{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(!this._$collection.has(n)){let a=(e?13:5)+(t?1:0)+1;const o=a-1;let h;h=t?Nt.TEMPLATE(this._$keyword,a,o,!0,e):Dt.TEMPLATE(this._$keyword,a,!0,!1,e),this._$collection.set(n,new te(this._$gl,this._$context,h,class{static TEMPLATE(t,e,i,s,r,n){const a=s?this.STATEMENT_GRADIENT_TYPE_RADIAL(i,r):this.STATEMENT_GRADIENT_TYPE_LINEAR(i);let o;switch(n){case"reflect":o="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":o="fract(t)";break;default:o="clamp(t, 0.0, 1.0)"}return`${t.version()}\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${e}];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 p = v_uv;\n    ${a}\n    t = ${o};\n    ${t.fragColor()} = ${t.texture2D()}(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}.TEMPLATE(this._$keyword,a,o,i,s,r)))}return this._$collection.get(n)}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",o=i?"y":"n",h=i&&s?"y":"n";let l=0;switch(r){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${o}${h}${l}`}setGradientShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=o[0],d[13]=o[1],d[14]=o[2],d[16]=o[3],d[17]=o[4],d[18]=o[5],d[11]=o[6],d[15]=o[7],d[19]=o[8],d[3]=h,d[7]=l;let g=20;n&&(d[g]=$.parentMatrixA,d[g+1]=$.parentMatrixB,d[g+2]=$.parentMatrixC,d[g+4]=$.parentMatrixD,d[g+5]=$.parentMatrixE,d[g+6]=$.parentMatrixF,d[g+8]=$.parentMatrixG,d[g+9]=$.parentMatrixH,d[g+10]=$.parentMatrixI,d[g+12]=$.ancestorMatrixA,d[g+13]=$.ancestorMatrixB,d[g+14]=$.ancestorMatrixC,d[g+16]=$.ancestorMatrixD,d[g+17]=$.ancestorMatrixE,d[g+18]=$.ancestorMatrixF,d[g+20]=$.ancestorMatrixG,d[g+21]=$.ancestorMatrixH,d[g+22]=$.ancestorMatrixI,d[g+11]=$.parentViewportX,d[g+15]=$.parentViewportY,d[g+19]=$.parentViewportW,d[g+23]=$.parentViewportH,d[g+24]=$.minXST,d[g+25]=$.minYST,d[g+26]=$.minXPQ,d[g+27]=$.minYPQ,d[g+28]=$.maxXST,d[g+29]=$.maxYST,d[g+30]=$.maxXPQ,d[g+31]=$.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=s,d[g+2]=r,g+=4),_?(d[g]=c[5],d[g+1]=u):(d[g]=c[0],d[g+1]=c[1],d[g+2]=c[2],d[g+3]=c[3])}}class Bt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Nt.TEMPLATE(this._$keyword,s,r,!1,!1,e):Dt.TEMPLATE(this._$keyword,s,!1,!1,e),this._$collection.set(i,new te(this._$gl,this._$context,n,At.SOLID_COLOR(this._$keyword)))}return this._$collection.get(i)}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(!this._$collection.has(s)){const r=(i?13:5)+(t?1:0),n=r;let a;a=t?Nt.TEMPLATE(this._$keyword,r,n,!0,!1,i):Dt.TEMPLATE(this._$keyword,r,!0,!1,i);const o=e?At.BITMAP_PATTERN(this._$keyword):At.BITMAP_CLIPPED(this._$keyword);this._$collection.set(s,new te(this._$gl,this._$context,a,o))}return this._$collection.get(s)}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Nt.TEMPLATE(this._$keyword,s,r,!1,!0,e):Dt.TEMPLATE(this._$keyword,s,!1,!0,e),this._$collection.set(i,new te(this._$gl,this._$context,n,At.MASK(this._$keyword)))}return this._$collection.get(i)}setSolidColorShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_){const c=t.highp;let u;n?(c[0]=l.parentMatrixA,c[1]=l.parentMatrixB,c[2]=l.parentMatrixC,c[4]=l.parentMatrixD,c[5]=l.parentMatrixE,c[6]=l.parentMatrixF,c[8]=l.parentMatrixG,c[9]=l.parentMatrixH,c[10]=l.parentMatrixI,c[12]=l.ancestorMatrixA,c[13]=l.ancestorMatrixB,c[14]=l.ancestorMatrixC,c[16]=l.ancestorMatrixD,c[17]=l.ancestorMatrixE,c[18]=l.ancestorMatrixF,c[20]=l.ancestorMatrixG,c[21]=l.ancestorMatrixH,c[22]=l.ancestorMatrixI,c[3]=o,c[7]=h,c[11]=l.parentViewportX,c[15]=l.parentViewportY,c[19]=l.parentViewportW,c[23]=l.parentViewportH,c[24]=l.minXST,c[25]=l.minYST,c[26]=l.minXPQ,c[27]=l.minYPQ,c[28]=l.maxXST,c[29]=l.maxYST,c[30]=l.maxXPQ,c[31]=l.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=o,c[7]=h,u=12),e&&(c[u]=i,c[u+1]=s,c[u+2]=r);const d=t.mediump;d[0]=$[0],d[1]=$[1],d[2]=$[2],d[3]=$[3]*_}setBitmapShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,f,p,m,x,b){const T=t.highp;let v;T[0]=a[0],T[1]=a[1],T[2]=a[2],T[4]=a[3],T[5]=a[4],T[6]=a[5],T[8]=a[6],T[9]=a[7],T[10]=a[8],T[12]=o[0],T[13]=o[1],T[14]=o[2],T[16]=o[3],T[17]=o[4],T[18]=o[5],T[11]=o[6],T[15]=o[7],T[19]=o[8],T[3]=h,T[7]=l,v=20,n&&(T[v]=$.parentMatrixA,T[v+1]=$.parentMatrixB,T[v+2]=$.parentMatrixC,T[v+4]=$.parentMatrixD,T[v+5]=$.parentMatrixE,T[v+6]=$.parentMatrixF,T[v+8]=$.parentMatrixG,T[v+9]=$.parentMatrixH,T[v+10]=$.parentMatrixI,T[v+12]=$.ancestorMatrixA,T[v+13]=$.ancestorMatrixB,T[v+14]=$.ancestorMatrixC,T[v+16]=$.ancestorMatrixD,T[v+17]=$.ancestorMatrixE,T[v+18]=$.ancestorMatrixF,T[v+20]=$.ancestorMatrixG,T[v+21]=$.ancestorMatrixH,T[v+22]=$.ancestorMatrixI,T[v+11]=$.parentViewportX,T[v+15]=$.parentViewportY,T[v+19]=$.parentViewportW,T[v+23]=$.parentViewportH,T[v+24]=$.minXST,T[v+25]=$.minYST,T[v+26]=$.minXPQ,T[v+27]=$.minYPQ,T[v+28]=$.maxXST,T[v+29]=$.maxYST,T[v+30]=$.maxXPQ,T[v+31]=$.maxYPQ,v=52),e&&(T[v]=i,T[v+1]=s,T[v+2]=r);const y=t.mediump;y[0]=_,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=f,y[8]=p,y[9]=m,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.highp;e?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=_,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=o,d[8]=h,d[9]=l,d[10]=$,d[3]=_,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class Ft{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class Lt{static TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static BLEND(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static BLEND_CLIP(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}}class Pt{static POSITION_ONLY(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_DST_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_dst_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_ALPHA_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[7];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_alpha_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(u_highp[3].xyz, u_highp[4].xyz, u_highp[5].xyz);\n    mat3 alpha_tex_matrix = mat3(\n        u_highp[6].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w),\n        vec3(u_highp[3].w, u_highp[4].w, u_highp[5].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_alpha_tex_coord = (alpha_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static PIXEL_DISSOLVE_COLOR(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (u_src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (u_matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec4 a_color;\n\nuniform mat3 u_highp[3];\n\n${t.varyingOut()} vec2 v_dst_tex_coord;\n${t.varyingOut()} vec4 v_color;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    v_color = a_color;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}}class Dt{static TEMPLATE(t,e,i,s,r){const n=s?this.ATTRIBUTE_BEZIER_ON(t):"",a=s?this.VARYING_BEZIER_ON(t):i?this.VARYING_UV_ON(t):"",o=s?this.STATEMENT_BEZIER_ON():i?this.STATEMENT_UV_ON():"",h=r?Ft.FUNCTION_GRID_ON(i?5:0):Ft.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${n}\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${o}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(t){return`\n${t.attribute(1)} vec2 a_bezier;\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static VARYING_BEZIER_ON(t){return`\n${t.varyingOut()} vec2 v_bezier;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class Nt{static TEMPLATE(t,e,i,s,r){const n=i-1,a=s?this.VARYING_UV_ON(t):"",o=s?this.STATEMENT_UV_ON():"",h=r?Ft.FUNCTION_GRID_ON(s?5:0):Ft.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec2 a_option1;\n${t.attribute(2)} vec2 a_option2;\n${t.attribute(3)} float a_type;\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${n}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${n}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${n}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // \n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // \n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // B\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // A\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // A\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // B\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // \n        float face = u_highp[${n}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${o}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class Ut{constructor(){this._$rgb=U.RGB,this._$mode=Y.PAD,this._$focalPointRatio=0,this._$points=h.$getFloat32Array6(),this._$stops=h.$getArray(),this._$type=null}linear(t,e,i,s,r=U.RGB,n=Y.PAD){return this._$type=L.LINEAR,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,r,n,a=U.RGB,o=Y.PAD,l=0){return this._$type=L.RADIAL,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=r,this._$points[5]=n,this._$rgb=a,this._$mode=o,this._$focalPointRatio=h.$clamp(l,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push([t,e]),this._$stops.sort((function(t,e){switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}}))}}class kt{constructor(t=null,e=null,i=null){this._$initialization(t,e,i)}_$initialization(t=null,e=null,i=null){return this._$texture=t,this._$repeat=e,this._$color_transform=i,this}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$color_transform}}class Gt{constructor(t,e){this._$gl=t;const i=e?s.min(h.$currentPlayer().getSamples(),t.getParameter(t.MAX_SAMPLES)):0;this._$isWebGL2Context=e,this._$maxTextureSize=s.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new zt,this._$style=this._$contextStyle,this._$fillBuffer=null,this._$strokeBuffer=null,this._$cacheCurrentBounds={x:0,y:0,w:0,h:0},this._$cacheCurrentBuffer=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation=I.NORMAL,this._$matrix=h.$getFloat32Array9(1,0,0,0,1,0,0,0,1),this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new qt(t,e,i),this._$path=new jt,this._$grid=new Ht,this._$offsetX=0,this._$offsetY=0,this._$blends=[],this._$positions=[],this._$isLayer=!1,this._$shaderList=new ee(this,t),this._$gradientLUT=new ie(this,t),this._$vao=new Zt(t,e),this._$pbo=new Kt(t,e),this._$mask=new Yt(this,t),this._$blend=new Xt(this,t),this._$canvasPatternToWebGL=new kt,this._$canvasGradientToWebGL=new Ut}get canvas(){return this._$gl.canvas}get fillStyle(){return this._$style._$fillStyle}set fillStyle(t){this._$style._$fillStyle.constructor===Float32Array&&h.$poolFloat32Array4(this._$style._$fillStyle),this._$style._$fillStyle=t}get strokeStyle(){return this._$style._$strokeStyle}set strokeStyle(t){this._$style._$strokeStyle.constructor===Float32Array&&h.$poolFloat32Array4(this._$style._$strokeStyle),this._$style._$strokeStyle=t}get lineWidth(){return this._$style._$lineWidth}set lineWidth(t){this._$style._$lineWidth=t}get lineCap(){return this._$style._$lineCap}set lineCap(t){switch(t){case B.NONE:case B.SQUARE:this._$style._$lineCap=t;break;default:this._$style._$lineCap=B.ROUND}}get lineJoin(){return this._$style._$lineJoin}set lineJoin(t){switch(t){case k.BEVEL:case k.MITER:this._$style._$lineJoin=t;break;default:this._$style._$lineJoin=k.ROUND}}get miterLimit(){return this._$style._$miterLimit}set miterLimit(t){this._$style._$miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=h.$clamp(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=h.$toBoolean(t)}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get pbo(){return this._$pbo}get blend(){return this._$blend}_$bind(t){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e.dirty||i&&i.dirty)&&(e.dirty=!1,i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}fillRect(t,e,i,s){if(!i||!s)return;this._$viewportWidth=i,this._$viewportHeight=s;let r=!1;if(!this._$fillBuffer){r=!0;const n=this._$path.createRectVertices(t,e,i,s);this._$fillBuffer=this._$vao.createFill(n),h.$poolArray(n.pop()),h.$poolArray(n)}const n=this._$grid.enabled,a=this._$shaderList.shapeShaderVariants,o=a.getSolidColorShapeShader(!1,n),l=o.uniform;a.setSolidColorShapeUniform(l,!1,0,0,0,n,this._$matrix,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha),o._$fill(this._$fillBuffer),r&&(this._$vao.release(this._$fillBuffer),h.$poolArray(this._$fillBuffer.indexRanges)),this.beginPath()}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}transform(t,e,i,s,r,n){const a=this._$matrix[0],o=this._$matrix[1],h=this._$matrix[3],l=this._$matrix[4],$=this._$matrix[6],_=this._$matrix[7];this._$matrix[0]=t*a+e*h,this._$matrix[1]=t*o+e*l,this._$matrix[3]=i*a+s*h,this._$matrix[4]=i*o+s*l,this._$matrix[6]=r*a+n*h+$,this._$matrix[7]=r*o+n*l+_}drawImage(t,e,i,s,r,n=null){let a=1,o=1,h=1,l=this._$globalAlpha,$=0,_=0,c=0;n&&(a=n[0],o=n[1],h=n[2],$=n[4]/255,_=n[5]/255,c=n[6]/255),this._$blend.drawImage(t,e,i,s,r,a,o,h,l,$,_,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$startClip(t,e){return this._$mask._$startClip(t,e)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin(),this._$isGraphics&&(this._$fillBuffer&&(this.vao.release(this._$fillBuffer),this.vao.release(this._$fillBuffer.boundObject),h.$poolArray(this._$fillBuffer.indexRanges),h.$poolArray(this._$fillBuffer.boundObject.indexRanges)),this._$strokeBuffer&&this.vao.release(this._$strokeBuffer)),this._$isGraphics=!1,this._$fillBuffer=null,this._$strokeBuffer=null}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}_$getVertices(){return this._$path.vertices}fill(){let t,e,i,s=this._$matrix;switch(!0){case this.fillStyle.constructor===Ut:if(this.fillStyle._$type===L.LINEAR);else s=this._$stack[this._$stack.length-1];break;case this.fillStyle.constructor===kt:s=this._$stack[this._$stack.length-1]}const r=this._$grid.enabled;switch(!0){case this.fillStyle.constructor===Ut:{const n=this.fillStyle,a=n._$stops,o="linearRGB"===n._$rgb;if(t=this._$gradientLUT.generateForShape(a,o),this._$frameBufferManager._$textureManager.bind0(t,!0),e=this._$shaderList.gradientShapeShaderVariants,n._$type===L.LINEAR)i=e.getGradientShapeShader(!1,r,!1,!1,n._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,r,s,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,n._$points,0);else{const t=0!==n._$focalPointRatio;i=e.getGradientShapeShader(!1,r,!0,t,n._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,r,s,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,n._$points,n._$focalPointRatio)}}break;case this.fillStyle.constructor===kt:{const n=this.fillStyle,a=n.colorTransform;t=n.texture,this._$frameBufferManager._$textureManager.bind0(t,this._$imageSmoothingEnabled),e=this._$shaderList.shapeShaderVariants,i=e.getBitmapShapeShader(!1,""!==n.repeat,r),a?e.setBitmapShapeUniform(i.uniform,!1,0,0,0,r,s,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,a[0],a[1],a[2],this._$globalAlpha,a[4]/255,a[5]/255,a[6]/255,0):e.setBitmapShapeUniform(i.uniform,!1,0,0,0,r,s,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:e=this._$shaderList.shapeShaderVariants,i=e.getSolidColorShapeShader(!1,this._$grid.enabled),e.setSolidColorShapeUniform(i.uniform,!1,0,0,0,r,s,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha)}const n=this._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,r);if(n.setMaskShapeUniform(a.uniform,r,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],this._$viewportWidth,this._$viewportHeight,this._$grid),!this._$fillBuffer){const t=this._$getVertices();if(!t.length)return;const e=h.$getArray();for(let i=0;i<t.length;++i){const s=t[i];9>s.length||e.push(s)}if(!e.length)return;this._$isGraphics=!0,this._$fillBuffer=this._$vao.createFill(e);const i=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(i),h.$poolArray(i.pop()),h.$poolArray(i)}this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),a._$fill(this._$fillBuffer),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),i._$fill(this._$fillBuffer.boundObject),this._$gl.disable(this._$gl.STENCIL_TEST)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}_$unionStencilMask(t,e,i){this._$mask._$unionStencilMask(t,e,i)}closePath(){this._$path.close()}stroke(){if(!this._$strokeBuffer){const t=this._$getVertices();if(!t.length)return;const e=h.$getArray();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return;this._$isGraphics=!0,this._$strokeBuffer=this._$vao.createStroke(t,this.lineCap,this.lineJoin)}let t=this._$matrix;switch(!0){case this.strokeStyle.constructor===Ut:if(this.strokeStyle._$type===L.LINEAR);else t=this._$stack[this._$stack.length-1];break;case this.strokeStyle.constructor===kt:t=this._$stack[this._$stack.length-1]}let e=s.sign(t[0]*t[4]);e>0&&0!==t[1]&&0!==t[3]&&(e=-s.sign(t[1]*t[3]));let i,r,n=.5*this.lineWidth;this._$grid.enabled?(n*=h.$getSameScaleBase(),i=s.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),r=s.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(i=s.abs(t[0]+t[3]),r=s.abs(t[1]+t[4]));const a=s.min(i,r),o=s.max(i,r);let l,$,_;n*=o*(1-.3*s.cos(.5*s.PI*(a/o))),n=s.max(1,n);const c=this._$grid.enabled;switch(!0){case this.strokeStyle.constructor===Ut:{const i=this.strokeStyle,s=i._$stops,r="linearRGB"===i._$rgb;if(l=this._$gradientLUT.generateForShape(s,r),this._$frameBufferManager._$textureManager.bind0(l,!0),$=this._$shaderList.gradientShapeShaderVariants,i._$type===L.LINEAR)_=$.getGradientShapeShader(!0,c,!1,!1,i._$mode),$.setGradientShapeUniform(_.uniform,!0,n,e,this.miterLimit,c,t,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,i._$points,0);else{const s=0!==i._$focalPointRatio;_=$.getGradientShapeShader(!0,c,!0,s,i._$mode),$.setGradientShapeUniform(_.uniform,!0,n,e,this.miterLimit,c,t,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,i._$points,i._$focalPointRatio)}}break;case this.strokeStyle.constructor===kt:{const i=this.strokeStyle,s=i.colorTransform;l=i.texture,this._$frameBufferManager._$textureManager.bind0(l),$=this._$shaderList.shapeShaderVariants,_=$.getBitmapShapeShader(!0,""!==i.repeat,this._$grid.enabled),s?$.setBitmapShapeUniform(_.uniform,!0,n,e,this.miterLimit,c,t,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,l.width,l.height,s[0],s[1],s[2],this._$globalAlpha,s[4]/255,s[5]/255,s[6]/255,0):$.setBitmapShapeUniform(_.uniform,!0,n,e,this.miterLimit,c,t,h.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,l.width,l.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:$=this._$shaderList.shapeShaderVariants,_=$.getSolidColorShapeShader(!0,this._$grid.enabled),$.setSolidColorShapeUniform(_.uniform,!0,n,e,this.miterLimit,c,t,this._$viewportWidth,this._$viewportHeight,this._$grid,this.strokeStyle,this._$globalAlpha)}_._$stroke(this._$strokeBuffer)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(t=!1){const e=this._$shaderList.shapeShaderVariants,i=e.getMaskShapeShader(!1,!1),s=i.uniform;if(e.setMaskShapeUniform(s,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),!this._$fillBuffer){this._$fillBuffer=this._$vao.createFill(this._$getVertices());const t=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(t),h.$poolArray(t.pop()),h.$poolArray(t)}this._$mask._$onClip(this._$matrix,this._$viewportWidth,this._$viewportHeight)||(i._$fill(this._$fillBuffer),t&&(this._$vao.release(this._$fillBuffer),this._$vao.release(this._$fillBuffer.boundObject),h.$poolArray(this._$fillBuffer.indexRanges),h.$poolArray(this._$fillBuffer.boundObject.indexRanges),this._$fillBuffer=null),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(h.$getFloat32Array9(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){this._$stack.length&&(h.$poolFloat32Array9(this._$matrix),this._$matrix=this._$stack.pop()),this._$mask._$onRestore()}createPattern(t,e,i){return this._$canvasPatternToWebGL._$initialization(t,e,i)}createLinearGradient(t,e,i,s,r=U.RGB,n=Y.PAD){return this._$canvasGradientToWebGL.linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a=U.RGB,o=Y.PAD,h=0){return this._$canvasGradientToWebGL.radial(t,e,i,s,r,n,a,o,h)}_$applyBlurFilter(t,e,i){const r=this._$frameBufferManager.currentAttachment,n=r.width,a=r.height;this._$frameBufferManager._$textureManager.bind0(t,!0);const o=s.ceil(.5*i),h=1-(o-.5*i),l=1+i,$=this._$shaderList.filterShaderVariants,_=$.getBlurFilterShader(o);$.setBlurFilterUniform(_.uniform,n,a,e,h,l),_._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,o,h,l,$,_,c,u,d,g,f,p,m,x,b,T,v,y,E,A){const M=c===W.INNER,C=this._$frameBufferManager.currentAttachment,S=this._$frameBufferManager.getTextureFromCurrentAttachment();let R;const w=null!==g;let O;w&&(R=this._$gradientLUT.generateForFilter(g,f,p)),M?w?this._$frameBufferManager._$textureManager.bind02(t,R,!0):this._$frameBufferManager._$textureManager.bind0(t):(O=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(O),w?this._$frameBufferManager._$textureManager.bind012(t,S,R,!0):this._$frameBufferManager._$textureManager.bind01(t,S));const I=!(M||c===W.FULL&&u),B=!(e===o&&i===h&&0===l&&0===$),F=!(1===d),L=this._$shaderList.filterShaderVariants,P=L.getBitmapFilterShader(I,B,_,c,u,F,w);L.setBitmapFilterUniform(P.uniform,e,i,s,r,n,a,o,h,l,$,_,d,m,x,b,T,v,y,E,A,I,B,F,w),M?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),P._$drawImage(),M||this._$frameBufferManager.releaseAttachment(C,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager._$textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,o,h,l,$,_){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager._$textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,o);g.setConvolutionFilterUniform(f.uniform,c,u,s,r,n,o,h,l,$,_),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,o,h,l,$,_,c,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),r||(r={x:0,y:0}),this._$frameBufferManager._$textureManager.bind01(t,e);const p=this._$shaderList.filterShaderVariants,m=p.getDisplacementMapFilterShader(n,a,l);p.setDisplacementMapFilterUniform(m.uniform,e.width,e.height,i,s,r.x,r.y,o,h,l,$,_,c,u),this.blend.reset(),m._$drawImage()}getImageData(t,e,i,r){const n=i*r*4,a=h.$getUint8Array(n);this._$gl.readPixels(t,r-(r-e),i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,a);for(let t=0;t<n;t+=4){const e=a[t+3];e&&(a[t]=255&s.min(255*a[t]/e,255),a[t+1]=255&s.min(255*a[t+1]/e,255),a[t+2]=255&s.min(255*a[t+2]/e,255))}return a}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){h.$poolBoundsObject(this._$positions.pop()),this._$isLayer=h.$toBoolean(this._$blends.pop())}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$textureScale(t,e){const i=s.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}changeSamples(t=4){if(this._$isWebGL2Context){t=s.min(t,this._$gl.getParameter(this._$gl.MAX_SAMPLES));const e=this._$frameBufferManager;e._$objectPool=[],e._$colorBufferPool._$objectPool=[],e._$stencilBufferPool._$objectPool=[],e._$colorBufferPool._$samples=t}}}class Xt{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case I.ADD:this.toAdd();break;case I.SCREEN:this.toScreen();break;case I.ALPHA:this.toAlpha();break;case I.ERASE:this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,i,n,a,o,l,$,_,c,u,d,g,f,p,m,x,b){const T=this._$context._$frameBufferManager.currentAttachment,v=1!==o||1!==l||1!==$||1!==_||0!==c||0!==u||0!==d||0!==g,y=this._$context._$shaderList.blendShaderVariants;switch(f){case I.NORMAL:case I.LAYER:case I.ADD:case I.SCREEN:case I.ALPHA:case I.ERASE:case"copy":{this._$context._$frameBufferManager._$textureManager.bind0(t,b);const h=y.getNormalBlendShader(v);y.setNormalBlendUniform(h.uniform,e,i,n,a,x,p,m,v,o,l,$,_,c,u,d,g);const T=x[0],E=x[1],A=x[3],M=x[4],C=x[6],S=x[7];if(1!==T||0!==E||0!==A||1!==M){const t=e+n,o=i+a,h=+(t*T+o*A+C),l=+(t*T+i*A+C),$=+(e*T+o*A+C),_=+(e*T+i*A+C),c=+(t*E+o*M+S),u=+(t*E+i*M+S),d=+(e*E+o*M+S),g=+(e*E+i*M+S),f=r.MAX_VALUE,x=+s.min(s.min(s.min(s.min(f,h),l),$),_),b=+s.max(s.max(s.max(s.max(-f,h),l),$),_),v=+s.min(s.min(s.min(s.min(f,c),u),d),g),y=+s.max(s.max(s.max(s.max(-f,c),u),d),g),R=s.max(0,0|x),w=s.max(0,0|v),O=s.min(s.max(0,p-R),s.ceil(s.abs(b-x))),I=s.min(s.max(0,m-w),s.ceil(s.abs(y-v)));if(!O||!I)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(R,s.max(0,m-(w+I)),O+1,I+1)}else{const t=s.max(0,e+C|0),r=s.max(0,i+S|0),o=s.min(s.max(0,p-t),n),h=s.min(s.max(0,m-r),a);if(!o||!h)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,s.max(0,m-(r+h)),o+1,h+1)}this.toOperation(f),h._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const r=s.max(0,e+x[6]|0),E=s.max(0,i+x[7]|0),A=s.min(s.max(0,p-r),n),M=s.min(s.max(0,m-E),a);if(!A||!M)return;const C=this._$context._$frameBufferManager.getTextureFromCurrentAttachment(),S=this._$context._$frameBufferManager.createTextureAttachment(n,a);this._$context._$bind(S),this._$context._$frameBufferManager._$textureManager.bind0(C);const R=y.getClipShader(),w=R.uniform;y.setClipUniform(w,e,i,n,a,h.$inverseMatrix(x),p,m),this.reset(),R._$drawImage();const O=this._$context._$frameBufferManager.getTextureFromCurrentAttachment();this._$context._$bind(T),this._$context._$frameBufferManager._$textureManager.bind01(O,t,b);const I=y.getBlendShader(f,v);y.setBlendUniform(I.uniform,e,i,n,a,x,p,m,v,o,l,$,_,c,u,d,g),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(r,s.max(0,m-(E+M)),A,M),this.toOneZero(),I._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),this._$context._$frameBufferManager.releaseAttachment(S,!0)}}}}class Ht{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,i,r,n,a,o,l,$,_,c,u,d,g,f,p,m,x){const b=n.xMax-n.xMin,T=n.yMax-n.yMin,v=a._$width,y=a._$height,E=h.$currentPlayer(),A=E._$scale*E._$ratio,M=s.abs(s.ceil(b*A)),C=s.abs(s.ceil(T*A)),S=v>0?(a._$x-n.xMin)/b:1e-5,R=y>0?(a._$y-n.yMin)/T:1e-5,w=v>0?(a._$x+a._$width-n.xMin)/b:.99999,O=y>0?(a._$y+a._$height-n.yMin)/T:.99999;let I=M*S/i,B=C*R/r,F=(i-M*(1-w))/i,L=(r-C*(1-O))/r;if(I>=F){const t=S/(S+(1-w));I=s.max(t-1e-5,0),F=s.min(t+1e-5,1)}if(B>=L){const t=R/(R+(1-O));B=s.max(t-1e-5,0),L=s.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=o,this.parentMatrixB=l,this.parentMatrixD=$,this.parentMatrixE=_,this.parentMatrixG=c,this.parentMatrixH=u,this.ancestorMatrixA=d,this.ancestorMatrixB=g,this.ancestorMatrixD=f,this.ancestorMatrixE=p,this.ancestorMatrixG=m,this.ancestorMatrixH=x,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=i,this.parentViewportH=r,this.minXST=S,this.minYST=R,this.minXPQ=I,this.minYPQ=B,this.maxXST=w,this.maxYST=O,this.maxXPQ=F,this.maxYPQ=L}disable(){this.enabled=!1}}class Yt{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$clipStatus=!1,this._$containerClip=!1,this._$poolClip=[],this._$currentClip=!1}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context._$frameBufferManager,e=t.getTextureFromCurrentAttachment(),i=t.currentAttachment;this._$context._$bind(this._$context._$cacheCurrentBuffer),this._$context._$cacheCurrentBuffer=null,this._$context._$blend.disable();const s=this._$context._$cacheCurrentBounds.x,r=this._$context._$cacheCurrentBounds.y,n=this._$context._$cacheCurrentBounds.w,a=this._$context._$cacheCurrentBounds.h;h.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(e,s,r,n,a),this._$context._$blend.enable(),t.releaseAttachment(i,!0)}_$startClip(t,e){const i=h.$multiplicationMatrix(e,t._$transform._$rawMatrix()),r=t._$getBounds(null),n=h.$boundsMatrix(r,i);h.$poolFloat32Array9(i),h.$poolBoundsObject(r);let a=n.xMin,o=n.yMin,l=s.abs(n.xMax-n.xMin),$=s.abs(n.yMax-n.yMin);h.$poolBoundsObject(n);const _=this._$context._$frameBufferManager,c=_.currentAttachment;if(l+a>c.texture.width&&(l-=l-c.texture.width+a),$+o>c.texture.height&&($-=$-c.texture.height+o),0>a&&(l+=a,a=0),0>o&&($+=o,o=0),0>=l||0>=$)return null;l=s.ceil(l),$=s.ceil($),this._$context._$cacheCurrentBounds.x=a,this._$context._$cacheCurrentBounds.y=o,this._$context._$cacheCurrentBounds.w=l,this._$context._$cacheCurrentBounds.h=$;const u=_.getTextureFromCurrentAttachment();this._$context._$cacheCurrentBuffer=c;const d=h.$currentPlayer(),g=!this._$context._$isWebGL2Context||d._$quality!==z.LOW&&d._$quality!==z.MIDDLE?0:s.min(h.$HIGH_SAMPLES,this._$gl.getParameter(this._$gl.MAX_SAMPLES)),f=_.createCacheAttachment(l,$,!0,g);return this._$context._$bind(f),h.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(u,-a,-o,u.width,u.height),h.$getFloat32Array9(e[0],e[1],e[2],e[3],e[4]-a,e[5]-o)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context._$frameBufferManager.currentAttachment;t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context._$frameBufferManager.currentAttachment;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context._$frameBufferManager.currentAttachment.clipLevel;let e=0;for(let i=0;i<t;++i)e|=(1<<t-i)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&e,e),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context._$frameBufferManager.currentAttachment;if(--t.clipLevel,t.mask=h.$toBoolean(t.clipLevel),!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context._$cacheCurrentBuffer&&this._$endClip());const e=t.width,i=t.height,s=this._$context._$path.createRectVertices(0,0,e,i),r=this._$context._$vao.createFill(s);h.$poolArray(s.pop()),h.$poolArray(s);const n=this._$context._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),o=a.uniform;n.setMaskShapeUniformIdentity(o,e,i);const l=r.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(r,l.first,l.count),this._$context._$vao.release(r),h.$poolArray(r.indexRanges),this._$context._$endClipDef()}_$drawContainerClip(){const t=this._$context._$frameBufferManager.currentAttachment,e=t.clipLevel,i=this._$poolClip.length,s=this._$context._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;let a=e;const o=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);for(let t=0;t<i;++t){const t=this._$poolClip.shift();s.setMaskShapeUniform(n,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const i=t.fillBuffer.indexRanges.length;for(let e=0;e<i;++e){const i=t.fillBuffer.indexRanges[e];this._$gl.stencilMask(1<<a-1),r._$containerClip(t.fillBuffer,i.first,i.count)}++a,a>7&&(this._$context._$unionStencilMask(e,o,h),a=e)}a>e+1&&this._$context._$unionStencilMask(e,o,h)}_$unionStencilMask(t,e,i){const s=this._$context._$path.createRectVertices(0,0,e,i),r=this._$context._$vao.createFill(s);h.$poolArray(s.pop()),h.$poolArray(s);const n=this._$context._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),o=a.uniform;n.setMaskShapeUniformIdentity(o,e,i);const l=r.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(r,l.first,l.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT)),this._$context._$vao.release(r),h.$poolArray(r.indexRanges)}_$onClip(t,e,i){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip[this._$poolClip.length]={fillBuffer:this._$context._$fillBuffer,matrixA:t[0],matrixB:t[1],matrixC:t[2],matrixD:t[3],matrixE:t[4],matrixF:t[5],matrixG:t[6],matrixH:t[7],matrixI:t[8],viewportWidth:e,viewportHeight:i},!0)}_$onSave(){this._$clips[this._$clips.length]=this._$clipStatus}_$onRestore(){this._$clips.length&&(this._$clipStatus=h.$toBoolean(this._$clips.pop()))}}class jt{constructor(){this._$currentPath=[],this._$vertices=[],this._$bounds={xMin:0,xMax:0,yMin:0,yMax:0},this._$resetBounds()}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)h.$poolArray(this._$vertices.pop());this._$resetBounds()}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,r,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(r,n))return;const a=this._$currentPath[this._$currentPath.length-3],o=this._$currentPath[this._$currentPath.length-2];(class{static cubicToQuad(t,e,i,s,r,n,a,o){this._$split2Cubic(t,e,i,s,r,n,a,o,0,16),this._$split2Cubic(h.$bezierConverterBuffer[0],h.$bezierConverterBuffer[1],h.$bezierConverterBuffer[2],h.$bezierConverterBuffer[3],h.$bezierConverterBuffer[4],h.$bezierConverterBuffer[5],h.$bezierConverterBuffer[6],h.$bezierConverterBuffer[7],0,8),this._$split2Cubic(h.$bezierConverterBuffer[16],h.$bezierConverterBuffer[17],h.$bezierConverterBuffer[18],h.$bezierConverterBuffer[19],h.$bezierConverterBuffer[20],h.$bezierConverterBuffer[21],h.$bezierConverterBuffer[22],h.$bezierConverterBuffer[23],16,24),this._$split2Quad(h.$bezierConverterBuffer[0],h.$bezierConverterBuffer[1],h.$bezierConverterBuffer[2],h.$bezierConverterBuffer[3],h.$bezierConverterBuffer[4],h.$bezierConverterBuffer[5],h.$bezierConverterBuffer[6],h.$bezierConverterBuffer[7],0),this._$split2Quad(h.$bezierConverterBuffer[8],h.$bezierConverterBuffer[9],h.$bezierConverterBuffer[10],h.$bezierConverterBuffer[11],h.$bezierConverterBuffer[12],h.$bezierConverterBuffer[13],h.$bezierConverterBuffer[14],h.$bezierConverterBuffer[15],8),this._$split2Quad(h.$bezierConverterBuffer[16],h.$bezierConverterBuffer[17],h.$bezierConverterBuffer[18],h.$bezierConverterBuffer[19],h.$bezierConverterBuffer[20],h.$bezierConverterBuffer[21],h.$bezierConverterBuffer[22],h.$bezierConverterBuffer[23],16),this._$split2Quad(h.$bezierConverterBuffer[24],h.$bezierConverterBuffer[25],h.$bezierConverterBuffer[26],h.$bezierConverterBuffer[27],h.$bezierConverterBuffer[28],h.$bezierConverterBuffer[29],h.$bezierConverterBuffer[30],h.$bezierConverterBuffer[31],24)}static _$split2Cubic(t,e,i,s,r,n,a,o,l,$){const _=.125*(t+3*(i+r)+a),c=.125*(e+3*(s+n)+o),u=.125*(a+r-i-t),d=.125*(o+n-s-e);h.$bezierConverterBuffer[l]=t,h.$bezierConverterBuffer[l+1]=e,h.$bezierConverterBuffer[l+2]=.5*(t+i),h.$bezierConverterBuffer[l+3]=.5*(e+s),h.$bezierConverterBuffer[l+4]=_-u,h.$bezierConverterBuffer[l+5]=c-d,h.$bezierConverterBuffer[l+6]=_,h.$bezierConverterBuffer[l+7]=c,h.$bezierConverterBuffer[$]=_,h.$bezierConverterBuffer[$+1]=c,h.$bezierConverterBuffer[$+2]=_+u,h.$bezierConverterBuffer[$+3]=c+d,h.$bezierConverterBuffer[$+4]=.5*(r+a),h.$bezierConverterBuffer[$+5]=.5*(n+o),h.$bezierConverterBuffer[$+6]=a,h.$bezierConverterBuffer[$+7]=o}static _$split2Quad(t,e,i,s,r,n,a,o,l){const $=.125*(t+3*(i+r)+a),_=.125*(e+3*(s+n)+o);h.$bezierConverterBuffer[l]=.25*t+.75*i,h.$bezierConverterBuffer[l+1]=.25*e+.75*s,h.$bezierConverterBuffer[l+2]=$,h.$bezierConverterBuffer[l+3]=_,h.$bezierConverterBuffer[l+4]=.75*r+.25*a,h.$bezierConverterBuffer[l+5]=.75*n+.25*o,h.$bezierConverterBuffer[l+6]=a,h.$bezierConverterBuffer[l+7]=o}}).cubicToQuad(a,o,t,e,i,s,r,n);const l=h.$bezierConverterBuffer.length;for(let t=0;t<l;)this.quadTo(h.$bezierConverterBuffer[t++],h.$bezierConverterBuffer[t++],h.$bezierConverterBuffer[t++],h.$bezierConverterBuffer[t++])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=this._$currentPath[0],e=this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=this._$currentPath[this._$currentPath.length-3],s=this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t),this._$currentPath.push(e),this._$currentPath.push(i),this._$bounds.xMin=s.min(t,this._$bounds.xMin),this._$bounds.xMax=s.max(t,this._$bounds.xMax),this._$bounds.yMin=s.min(e,this._$bounds.yMin),this._$bounds.yMax=s.max(e,this._$bounds.yMax)}_$pushCurrentPathToVertices(){this._$currentPath.length<=3?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=h.$getArray())}_$resetBounds(){const t=r.MAX_VALUE;this._$bounds.xMin=t,this._$bounds.xMax=-t,this._$bounds.yMin=t,this._$bounds.yMax=-t}getBoundsVertices(){return h.$getArray(h.$getArray(this._$bounds.xMin,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMax,!1,this._$bounds.xMin,this._$bounds.yMax,!1))}createRectVertices(t,e,i,s){return h.$getArray(h.$getArray(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class zt{constructor(){this._$fillStyle=new a([1,1,1,1]),this._$strokeStyle=new a([1,1,1,1]),this._$lineWidth=1,this._$lineCap=0,this._$lineJoin=0,this._$miterLimit=5}}class Vt{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=[]}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();return t.stencil=this._$gl.createRenderbuffer(),t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}return this._$objectPool.shift()}create(t,e,i=0){t=s.max(256,h.$upperPowerOfTwo(t)),e=s.max(256,h.$upperPowerOfTwo(e));const r=this._$getColorBuffer(t*e);return(r.width<t||r.height<e||i&&r.samples!==i)&&(t=s.max(t,r.width),e=s.max(e,r.height),r.samples=i||this._$samples,r.width=t,r.height=e,r.area=t*e,r.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.STENCIL_INDEX8,t,e)),r}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;s.abs(i-e)>1;){const r=s.floor((i+e)/2);t<=this._$objectPool[r].area?i=r:e=r}return i}}const Wt={vertices:null};Wt.subhulls=new Array(512),Wt.subhullsIndex=0,Wt.extremePoints=new Array(32),Wt.extremePointsIndex=0,Wt.t=0,Wt.hulls=[new Array(16),new Array(64),new Array(256)],Wt.hullsIndex=0;class qt{constructor(t,e,i){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),this._$frameBufferTexture=null,this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new Jt(t,e),this._$colorBufferPool=null,this._$stencilBufferPool=new Qt(t),e&&(this._$frameBufferTexture=t.createFramebuffer(),this._$colorBufferPool=new Vt(t,i),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer))}get currentAttachment(){return this._$currentAttachment}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.length?this._$objectPool.pop():{},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,this._$isWebGL2Context&&i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(n.width,n.height)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}createTextureAttachment(t,e){const i=this._$objectPool.length?this._$objectPool.pop():{},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.length?this._$objectPool.pop():{};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t,e=!1){t.isActive&&(t.msaa?this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):(this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment.msaa)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t){return this._$textureManager.createFromImage(t)}createAlphaTextureFromPixels(t,e,i){return this._$textureManager.createAlpha(t,e,i)}createTextureFromVideo(t,e=!1,i=null){return this._$textureManager.createFromVideo(t,e,i)}createTextureFromCurrentAttachment(){const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class Kt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$maxWidth=0,this._$maxHeight=0,this._$cacheSize=0}_$getPixelBufferObject(t){if(!this._$objectPool.length){const t=this._$gl.createBuffer();return t.size=0,t}for(let e=0;e<this._$objectPool.length;e++){const i=this._$objectPool[e];if(i.size===t)return this._$objectPool.splice(e,1),this._$cacheSize-=i.size/4,i}const e=this._$objectPool.shift();return this._$cacheSize-=e.size/4,e}readPixelsAsync(t,e,i,s){if(!this._$isWebGL2Context)return null;const r=i*s*4,n=this._$getPixelBufferObject(r);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,n),n.size!==r&&(n.size=r,this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER,r,this._$gl.DYNAMIC_COPY)),this._$gl.readPixels(t,e,i,s,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,0),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),n}getBufferSubDataAsync(t){const e=new Uint8Array(t.size);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,t),this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER,0,e),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),this.release(t),e}release(t){if(t.size>this._$maxWidth*this._$maxHeight*4)this._$gl.deleteBuffer(t);else if(this._$objectPool.push(t),this._$cacheSize+=t.size/4,this._$cacheSize>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$cacheSize-=t.size/4,this._$gl.deleteBuffer(t)}}}class Qt{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;s++){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t)}}}class Jt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(e,i){const s=this._$gl.createTexture();return s.width=0,s.height=0,s.area=0,s.dirty=!0,s.smoothing=!0,s._$offsetX=0,s._$offsetY=0,this.bind0(s,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$isWebGL2Context&&(s.width=e,s.height=i,s.area=e*i,s.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,e,i),t.glstats&&glstats.ontex(s.area)),s}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}createAlpha(t,e,i){return this._$alphaTexture?this.bind0(this._$alphaTexture):(this._$alphaTexture=this._$gl.createTexture(),this.bind0(this._$alphaTexture),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST)),this._$alphaTexture.width=t,this._$alphaTexture.height=e,this._$alphaTexture.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.ALPHA,t,e,0,this._$gl.ALPHA,this._$gl.UNSIGNED_BYTE,i),this._$alphaTexture}create(e,i,s=null,r=!1,n=!0){const a=this._$getTexture(e,i);return r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,a.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,e,i,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),t.glstats&&glstats.ontex(a.area)):s&&(a.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,e,i,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s)),r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),a}createFromImage(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromVideo(t,e=!1,i=null){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e,i)}_$createFromElement(e,i,s,r=!1,n=null){const a=n||this._$getTexture(e,i);return a.dirty=!1,this.bind0(a,r),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),t.glstats&&glstats.ontex(a.area)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),a}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i,s){const r=i!==this._$boundTextures[t],n=null!==s&&s!==i.smoothing;if((r||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),r&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i.smoothing=s;const t=s&&h.$currentPlayer()._$quality!==z.LOW?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class Zt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$extension=e?null:t.getExtension("OES_vertex_array_object"),this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new a([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$createVertexArray(){return this._$isWebGL2Context?this._$gl.createVertexArray():this._$extension.createVertexArrayOES()}_$getVertexArray(t,e){const i=this._$createVertexArray();this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length)return this._$fillVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length)return this._$strokeVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=class{static generate(t){let e=0;for(let i=0;i<t.length;i++)e+=12*(t[i].length/3-2);this._$vertexBufferData=new a(e),this._$indexRanges=h.$getArray(),this._$currentIndex=0;for(let e=0;e<t.length;e++){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i;this._$indexRanges.push({first:i,count:s})}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=h.$upperPowerOfTwo(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const r=class{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new a(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new o(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new a(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new o(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){const a=11;let o=t,h=e;for(let l=1;l<a;l++){const $=l/a,_=1-$,c=(t*_+i*$)*_+(i*_+r*$)*$,u=(e*_+s*$)*_+(s*_+n*$)*$;this._$addLineSegmentMesh(o,h,c,u,2),o=c,h=u}this._$addLineSegmentMesh(o,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,o=n+2,h=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let $=this._$indexBufferPos;l[$++]=n,l[$++]=a,l[$++]=h,l[$++]=h,l[$++]=o,l[$++]=n,this._$indexBufferPos=$,this._$expandVertexBufferIfNeeded(28);const _=this._$vertexBufferData;let c=this._$vertexBufferPos;_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=1,_[c++]=1,_[c++]=1,_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=-1,_[c++]=-1,_[c++]=1,_[c++]=i,_[c++]=s,_[c++]=t,_[c++]=e,_[c++]=-1,_[c++]=-1,_[c++]=r,_[c++]=i,_[c++]=s,_[c++]=t,_[c++]=e,_[c++]=1,_[c++]=1,_[c++]=r,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,r,n,a,o,l,$,_,c){const u=i-t,d=r-e,g=a-i,f=o-r,p=h.$cross(u,d,g,f);if(!(s.abs(p)<1e-4))if(2!==n)switch(this._$lineJoin){case k.ROUND:this._$addRoundJoinMesh(i,r);break;case k.MITER:this._$addMiterJoinMesh(i,r,t,e,a,o,_,l,$,c);break;default:this._$addBevelJoinMesh(i,r,_,l,$,c)}else this._$addBevelJoinMesh(i,r,_,l,$,c)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,o,h,l){const $=this._$vertexBufferPos/7,_=$+1,c=$+2,u=$+3,d=$+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=$,g[f++]=a,g[f++]=_,g[f++]=$,g[f++]=_,g[f++]=c,g[f++]=$,g[f++]=c,g[f++]=o,g[f++]=$,g[f++]=h,g[f++]=u,g[f++]=$,g[f++]=u,g[f++]=d,g[f++]=$,g[f++]=d,g[f++]=l,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const p=this._$vertexBufferData;let m=this._$vertexBufferPos;p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=0,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=21,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=22,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=23,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=24,this._$vertexBufferPos=m}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let h=this._$indexBufferPos;o[h++]=a,o[h++]=i,o[h++]=s,o[h++]=a,o[h++]=r,o[h++]=n,this._$indexBufferPos=h,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let $=this._$vertexBufferPos;l[$++]=t,l[$++]=e,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,this._$vertexBufferPos=$}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],o=i[e-7],h=i[e-6],l=i[e-5],$=i[e-4],_=t/7,c=e/7;s!==o||r!==h?(this._$addLineCapMesh(s,r,n,a,_,_+1),this._$addLineCapMesh(o,h,l,$,c-1,c-2)):this._$addLineJoinMesh(l,$,s,r,n,a,c-2,c-1,_,_+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case B.ROUND:this._$addRoundJoinMesh(t,e);break;case B.SQUARE:this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,o=a+1;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let l=this._$indexBufferPos;h[l++]=r,h[l++]=a,h[l++]=o,h[l++]=o,h[l++]=n,h[l++]=r,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const $=this._$vertexBufferData;let _=this._$vertexBufferPos;$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=s,$[_++]=-1,$[_++]=-1,$[_++]=10,$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=s,$[_++]=1,$[_++]=1,$[_++]=10,this._$vertexBufferPos=_}}.generate(t,e,i),n=r.vertexBufferData,l=r.indexBufferData,$=this._$getStrokeVertexArray();return $.indexCount=l.length,this.bind($),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,$.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,$.indexBuffer),$.vertexLength<n.length&&($.vertexLength=h.$upperPowerOfTwo(n.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*$.vertexLength,this._$gl.DYNAMIC_DRAW)),$.indexLength<l.length&&($.indexLength=h.$upperPowerOfTwo(l.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*$.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,n),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,l),$}release(t){t.indexBuffer?this._$strokeVertexArrayPool.push(t):this._$fillVertexArrayPool.push(t)}bind(t){if(t){if(t===this._$boundVertexArray)return;this._$boundVertexArray=t}else this._$boundVertexArray=null;this._$isWebGL2Context?this._$gl.bindVertexArray(t):this._$extension.bindVertexArrayOES(t)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class te{constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new ne(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(t,e){const s=this._$gl.createProgram();s.id=i++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);if(this._$gl.shaderSource(r,t),this._$gl.compileShader(r),!this._$gl.getShaderParameter(r,this._$gl.COMPILE_STATUS)){const e=this._$gl.getShaderInfoLog(r);throw new Error("vertex shader compilation failed: "+e+"\n"+t)}const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);if(this._$gl.shaderSource(n,e),this._$gl.compileShader(n),!this._$gl.getShaderParameter(n,this._$gl.COMPILE_STATUS)){const t=this._$gl.getShaderInfoLog(n);throw new Error("fragment shader compilation failed: "+t+"\n"+e)}if(this._$context._$isWebGL2Context||(this._$gl.bindAttribLocation(s,0,"a_vertex"),this._$gl.bindAttribLocation(s,1,"a_bezier"),this._$gl.bindAttribLocation(s,1,"a_option1"),this._$gl.bindAttribLocation(s,2,"a_option2"),this._$gl.bindAttribLocation(s,3,"a_type")),this._$gl.attachShader(s,r),this._$gl.attachShader(s,n),this._$gl.linkProgram(s),!this._$gl.getProgramParameter(s,this._$gl.LINK_STATUS)){const i=this._$gl.getProgramInfoLog(s);throw new Error("link program failed: "+i+"\n"+t+"\n========\n"+e)}return this._$gl.detachShader(s,r),this._$gl.detachShader(s,n),this._$gl.deleteShader(r),this._$gl.deleteShader(n),s}_$attachProgram(){this._$context._$shaderList._$currentProgramId!==this._$program.id&&(this._$context._$shaderList._$currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(e,i){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(e,i),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawElements(this._$gl.TRIANGLES,e.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e);const i=e.indexRanges[e.indexRanges.length-1],s=i.first+i.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,s)}_$containerClip(e,i,s){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.TRIANGLES,i,s)}_$drawPoints(e,i,s){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.POINTS,i,s)}}class ee{constructor(t,e){const i=new se(e,t._$isWebGL2Context);this._$currentProgramId=-1,this._$shapeShaderVariants=new Bt(t,e,i),this._$bitmapShaderVariants=new St(t,e,i),this._$gradientShapeShaderVariants=new It(t,e,i),this._$gradientLUTShaderVariants=new Ot(t,e,i),this._$filterShaderVariants=new wt(t,e,i),this._$blendShaderVariants=new Rt(t,e,i);const s={opaque:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.COLOR_TRANSFORM.bind(null,!1)),transparent:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.COLOR_TRANSFORM.bind(null,!0))},r={opaque:new re(t,e,i,Pt.SRC_AND_DST_TEX_COORD,Mt.COPY_CHANNEL.bind(null,!1)),transparent:new re(t,e,i,Pt.SRC_AND_DST_TEX_COORD,Mt.COPY_CHANNEL.bind(null,!0))},n={opaque:new re(t,e,i,Pt.SRC_AND_DST_TEX_COORD,Mt.MERGE.bind(null,!1)),transparent:new re(t,e,i,Pt.SRC_AND_DST_TEX_COORD,Mt.MERGE.bind(null,!0))},a={opaque:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.PALETTE_MAP.bind(null,!1)),transparent:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.PALETTE_MAP.bind(null,!0))},o={color:new re(t,e,i,Pt.POSITION_ONLY,Mt.FILL_COLOR),texture:{opaque:new re(t,e,i,Pt.PIXEL_DISSOLVE_TEXTURE,Mt.PIXEL_DISSOLVE_TEXTURE.bind(null,!1)),transparent:new re(t,e,i,Pt.PIXEL_DISSOLVE_TEXTURE,Mt.PIXEL_DISSOLVE_TEXTURE.bind(null,!0))}},h=new re(t,e,i,Pt.SRC_TEX_COORD,Mt.COPY_SRC_TEX),l={withAlphaBitmapData:new re(t,e,i,Pt.SRC_AND_ALPHA_TEX_COORD,Mt.COPY_PIXELS_WITH_ALPHA_BITMAP_DATA),noAlphaBitmapData:h},$=new re(t,e,i,Pt.POSITION_ONLY,Mt.FILL_COLOR),_=new re(t,e,i,Pt.POSITION_ONLY,Mt.NOISE),c=function(s){return{discardSource:{opaque:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.THRESHOLD.bind(null,s,!1,!1)),transparent:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.THRESHOLD.bind(null,s,!1,!0))},copySource:{opaque:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.THRESHOLD.bind(null,s,!0,!1)),transparent:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.THRESHOLD.bind(null,s,!0,!0))}}},u={less:c("less"),lessEqual:c("lessEqual"),greater:c("greater"),greaterEqual:c("greaterEqual"),equal:c("thresholdEqual"),notEqual:c("thresholdNotEqual"),subtotal:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.THRESHOLD_SUBTOTAL)},d={findColor:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.GET_COLOR_BOUNDS_RECT.bind(null,!0)),findNotColor:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.GET_COLOR_BOUNDS_RECT.bind(null,!1))},g={RGBA:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.GET_PIXELS.bind(null,"RGBA")),BGRA:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.GET_PIXELS.bind(null,"BGRA")),ARGB:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.GET_PIXELS.bind(null,"ARGB"))},f={RGBA:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.SET_PIXELS.bind(null,"RGBA")),BGRA:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.SET_PIXELS.bind(null,"BGRA")),ARGB:new re(t,e,i,Pt.SRC_TEX_COORD,Mt.SET_PIXELS.bind(null,"ARGB"))},p=new re(t,e,i,Pt.SET_PIXEL_QUEUE,Mt.SET_PIXEL_QUEUE);this._$bitmapData={colorTransform:s,copyChannel:r,merge:n,paletteMap:a,pixelDissolve:o,copyPixels:l,scroll:h,fillRect:$,noise:_,threshold:u,getColorBoundsRect:d,getPixels:g,setPixels:f,setPixelQueue:p}}get shapeShaderVariants(){return this._$shapeShaderVariants}get bitmapShaderVariants(){return this._$bitmapShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class ie{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=s.floor(.75*this._$gl.getParameter(this._$gl.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new a(256),this._$rgbIdentityTable=new a(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=s.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,n=this._$context._$shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<r;i+=this._$maxLength-1){const o=s.min(i+this._$maxLength,r),h=n.getGradientLUTShader(o-i,e),l=h.uniform;n.setGradientLUTUniformForShape(l,t,i,o,a),h._$drawGradient(0===i?0:t[i][0],o===r?1:t[o-1][0])}return this._$context._$bind(i),this._$attachment.texture}generateForFilter(t,e,i){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context._$shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<n;r+=this._$maxLength-1){const o=s.min(r+this._$maxLength,n),h=a.getGradientLUTShader(o-r,!1),l=h.uniform;a.setGradientLUTUniformForFilter(l,t,e,i,r,o),h._$drawGradient(0===r?0:t[r],o===n?1:t[o-1])}return this._$context._$bind(r),this._$attachment.texture}}class se{constructor(t,e){this._$isWebGL2Context=e,e||t.getExtension("OES_standard_derivatives")}version(){return this._$isWebGL2Context?"#version 300 es":""}attribute(t){return this._$isWebGL2Context?`layout (location = ${t}) in`:"attribute"}varyingOut(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"out":"varying"}varyingIn(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"in":"varying"}outColor(){return this._$isWebGL2Context?"out vec4 o_color;":""}fragColor(){return this._$isWebGL2Context?"o_color":"gl_FragColor"}texture2D(){return this._$isWebGL2Context?"texture":"texture2D"}extensionDerivatives(){return this._$isWebGL2Context?"":"#extension GL_OES_standard_derivatives : enable"}}class re{constructor(t,e,i,s,r){this._$context=t,this._$gl=e,this._$keyword=i,this._$vertexSource=s,this._$fragmentSource=r,this._$instance=null}get instance(){return this._$instance||(this._$instance=new te(this._$gl,this._$context,this._$vertexSource(this._$keyword),this._$fragmentSource(this._$keyword))),this._$instance}}class ne{constructor(t,e){this._$gl=t,this._$array=[],this._$map=new Map;const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r={},n=this._$gl.getUniformLocation(e,s);if(i.type!==this._$gl.SAMPLER_2D||1!==i.size){switch(i.type){case this._$gl.FLOAT_VEC4:r.method=this._$gl.uniform4fv.bind(this._$gl,n),r.array=new Float32Array(4*i.size),r.assign=-1;break;case this._$gl.INT_VEC4:r.method=this._$gl.uniform4iv.bind(this._$gl,n),r.array=new Int32Array(4*i.size),r.assign=-1;break;case this._$gl.SAMPLER_2D:r.method=this._$gl.uniform1iv.bind(this._$gl,n),r.array=new Int32Array(i.size),r.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(r),this._$map.set(s,r)}}}getArray(t){return this._$map.get(t).array}get textures(){return this._$map.get("u_textures").array}get highp(){return this._$map.get("u_highp").array}get mediump(){return this._$map.get("u_mediump").array}get integer(){return this._$map.get("u_integer").array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array))}}}class ae{constructor(){this._$stage=new j,this._$stage._$player=this,this._$cacheStore=new yt,this._$mode="loader",this._$actionOffset=0,this._$actions=h.$getArray(),this._$loaders=h.$getArray(),this._$sounds=h.$getMap(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$mouseWheelEvent=null,this._$ratio=h.$devicePixelRatio,this._$stopFlag=!0,this._$startTime=0,this._$fps=60,this._$isLoad=!1,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=new a([1,0,0,1,0,0]),this._$tx=0,this._$ty=0,this._$backgroundColor=null,this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$broadcastEvents=h.$getMap(),this._$context=null,this._$canvas=null,this._$buffer=null,this._$optionWidth=0,this._$optionHeight=0,this._$tagId=null,this._$bgColor=null,this._$base="",this._$fullScreen=!1,this._$quality=z.HIGH,this._$sources=h.$getArray(),this._$videos=h.$getArray(),this._$textField=null,this._$bindRun=this._$run.bind(this),this._$timerId=-1,this._$loadId=-1}static get LOAD_START(){return 1}static get LOAD_END(){return 2}get broadcastEvents(){return this._$broadcastEvents}get base(){return this._$base}set base(t){if("string"==typeof t)if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${h.$location.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else if(-1===t.indexOf("?"))this._$base="/"===t.slice(-1)?t:`${t}/`;else{const e=t.split("?")[0];this._$base="/"===e.slice(-1)?e:`${e}/`}}get stage(){return this._$stage}get x(){return this._$tx}get y(){return this._$ty}get scaleX(){return this._$matrix[0]}get scaleY(){return this._$matrix[3]}get contentElementId(){return`${h.$PREFIX}`}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}play(){if(this._$stopFlag){if(this._$stopFlag=!1,this._$timerId>-1){(0,h.$cancelAnimationFrame)(this._$timerId)}this._$startTime=h.$performance.now(),this._$fps=1e3/this._$stage._$frameRate;const t=h.$requestAnimationFrame;this._$timerId=t(this._$bindRun)}}stop(){(0,h.$cancelAnimationFrame)(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,ut.stopAll(),h.$cacheStore().reset()}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this.base=t.base||this._$base,this._$fullScreen=!!t.fullScreen,"bgColor"in t&&(this._$bgColor=t.bgColor)),this._$initialize()}_$updateLoadStatus(){if(this._$loadStatus===ae.LOAD_END)return void this._$loaded();const t=h.$requestAnimationFrame;this._$loadId=t(this._$updateLoadStatus.bind(this))}_$loaded(){const t=h.$document.getElementById(this.contentElementId);if(t){null!==this._$bgColor&&(this._$backgroundColor=this._$bgColor),this._$context&&(this._$backgroundColor&&"transparent"!==this._$backgroundColor?this._$context._$setColor(this._$backgroundColor[0],this._$backgroundColor[1],this._$backgroundColor[2],this._$backgroundColor[3]):this._$context._$setColor(0,0,0,0)),this._$deleteNode(),t.appendChild(this._$canvas),this.play(),this._$stage._$prepareActions(),this._$broadcastEvents.has(_.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new _(_.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(_.EXIT_FRAME)&&this._$dispatchEvent(new _(_.EXIT_FRAME));const e=0|this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t instanceof X&&(t._$lock=!1),t.hasEventListener(_.INIT)&&t.dispatchEvent(new _(_.INIT)),t.hasEventListener(_.COMPLETE)&&t.dispatchEvent(new _(_.COMPLETE)),t._$player=null}this._$broadcastEvents.has(_.ACTIVATE)&&this._$dispatchEvent(new _(_.ACTIVATE)),this._$doAction(),this._$draw()}}_$initialize(){const t=h.$document;if("loading"===t.readyState){const t=function(e){e.target.removeEventListener("DOMContentLoaded",t),this._$initialize()}.bind(this);return void h.$window.addEventListener("DOMContentLoaded",t)}const e=this.contentElementId;if(null===this._$tagId)t.body.insertAdjacentHTML("beforeend",`<div id="${e}"></div>`);else{const i=t.getElementById(this._$tagId);if(!i)return void alert("Not Found Tag ID:"+this._$tagId);if(t.getElementById(e))this._$deleteNode();else{const s=t.createElement("div");s.id=e,s.tabIndex=-1,i.appendChild(s)}}this._$canvas||this._$initializeCanvas();const i=t.getElementById(e),s=i.parentNode;if(s){this._$initStyle(i),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===s.tagName?h.$window.innerWidth:s.offsetWidth,e=this._$optionHeight?this._$optionHeight:"BODY"===s.tagName?h.$window.innerHeight:s.offsetHeight;"loader"===this._$mode&&t&&e&&(this._$baseWidth=t,this._$baseHeight=e,this._$resize())}"loader"===this._$mode?(this._$loadStatus=ae.LOAD_START,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(e){const i=e.style;i.position="relative",i.top="0",i.left="0",i.backgroundColor="transparent",i.overflow="hidden",i.padding="0",i.margin="0",i.userSelect="none",i.outline="none";const s=this._$optionWidth,r=this._$optionHeight,n=e.parentNode;if("BODY"===n.tagName)return i.width=s?`${s}px`:`${t.innerWidth}px`,void(i.height=r?`${r}px`:`${t.innerHeight}px`);i.width=s?`${s}px`:`${n.offsetWidth}px`,i.height=r?`${r}px`:`${n.offsetHeight}px`}_$buildWait(){const t=h.$document.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=h.$document.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=h.$document.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){const e=h.$document.createElement("canvas");e.width=1,e.height=1,this._$canvas=e;const i={stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0};let s=!0,r=e.getContext("webgl2",i);if(r||(r=e.getContext("webgl",i)||e.getContext("experimental-webgl",i),s=!1),r?this._$context=new Gt(r,s):alert("WebGL setting is off. Please turn the setting on."),t.glstats&&glstats.init(r,s,h.$isChrome,h.$isFireFox),h.$isTouch){const t=function(e){e.target.removeEventListener(h.$TOUCH_END,t),h.$loadAudioData()};e.addEventListener(h.$TOUCH_END,t),e.addEventListener(h.$TOUCH_START,function(t){h.$event=t,h.$eventType=h.$TOUCH_START,this._$hitTest()}.bind(this)),e.addEventListener(h.$TOUCH_MOVE,function(t){h.$event=t,h.$eventType=h.$TOUCH_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(h.$TOUCH_END,function(t){h.$event=t,h.$eventType=h.$TOUCH_END,this._$hitTest()}.bind(this))}else{const t=function(e){e.target.removeEventListener(h.$MOUSE_DOWN,t),h.$loadAudioData()};e.addEventListener(h.$MOUSE_DOWN,t),e.addEventListener(h.$MOUSE_DOWN,function(t){h.$event=t,h.$eventType=h.$MOUSE_DOWN,t.button||this._$hitTest()}.bind(this)),e.addEventListener(h.$DOUBLE_CLICK,function(t){h.$event=t,h.$eventType=h.$DOUBLE_CLICK,t.button||this._$hitTest()}.bind(this)),e.addEventListener(h.$MOUSE_LEAVE,function(t){h.$event=t,h.$eventType=h.$MOUSE_LEAVE,this._$hitTest(),h.$event=null,this._$stageX=-1,this._$stageY=-1}.bind(this)),e.addEventListener(h.$MOUSE_UP,function(t){h.$event=t,h.$eventType=h.$MOUSE_UP,t.button||this._$hitTest()}.bind(this)),e.addEventListener(h.$MOUSE_MOVE,function(t){h.$event=t,h.$eventType=h.$MOUSE_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(h.$MOUSE_WHEEL,function(t){this._$mouseWheelEvent=t}.bind(this))}const n=e.style;n.position="absolute",n.top="0",n.left="0",n.webkitTapHighlightColor="rgba(0,0,0,0)",n.backfaceVisibility="hidden",n.transformOrigin="0 0",1!==h.$devicePixelRatio&&(n.transform=`scale(${1/h.$devicePixelRatio})`)}_$resize(){const t=h.$document.getElementById(this.contentElementId);if(t){const e=t.parentNode,i=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?h.$window.innerWidth:e.offsetWidth?e.offsetWidth:h.$parseFloat(e.style.width),r=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?h.$window.innerHeight:e.offsetHeight?e.offsetHeight:h.$parseFloat(e.style.height),n="BODY"===e.tagName?h.$window.innerWidth:e.offsetWidth,a=s.min(i/this._$baseWidth,r/this._$baseHeight);let o=this._$fullScreen?i:this._$baseWidth*a|0,l=this._$fullScreen?r:this._$baseHeight*a|0;const $=t.style;if($.width=`${o}px`,$.height=`${l}px`,$.top="0",$.left=this._$fullScreen?"0":n/2-o/2+"px",o*=h.$devicePixelRatio,l*=h.$devicePixelRatio,this._$scale=a,this._$width=o,this._$height=l,this._$canvas.width=o,this._$canvas.height=l,this._$canvas.style.transform=1===this._$ratio&&1===h.$devicePixelRatio?"":`scale(${1/this._$ratio})`,this._$context){this._$context._$gl.viewport(0,0,o,l);const t=this._$context._$frameBufferManager;this._$buffer&&(t.unbind(),t.releaseAttachment(this._$buffer,!0)),this._$buffer=t.createCacheAttachment(o,l,!1),t._$stencilBufferPool._$maxWidth=o,t._$stencilBufferPool._$maxHeight=l,t._$textureManager._$maxWidth=o,t._$textureManager._$maxHeight=l,this._$context._$pbo._$maxWidth=o,this._$context._$pbo._$maxHeight=l}const _=this._$scale*this._$ratio;this._$matrix[0]=_,this._$matrix[3]=_,this._$fullScreen&&(this._$tx=(o-this._$baseWidth*a*h.$devicePixelRatio)/2,this._$ty=(l-this._$baseHeight*a*h.$devicePixelRatio)/2,this._$matrix[4]=this._$tx,this._$matrix[5]=this._$ty),t.children.length>1&&t.children[1].dispatchEvent(new h.$window.Event(`${h.$PREFIX}_blur`)),this._$stage._$doChanged(),this._$cacheStore.reset()}}getSamples(){switch(this._$quality){case z.HIGH:return h.$HIGH_SAMPLES;case z.MEDIUM:return h.$MEDIUM_SAMPLES;default:return h.$LOW_SAMPLES}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t._$eventPhase=u.AT_TARGET;const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(t._$currentTarget=i.target,t._$listener=i.listener,i.listener.call(h.$window,t),t._$stopImmediatePropagation)break}return h.$poolArray(e),!0}}_$wheelEvent(){const t=this._$mouseWheelEvent;t&&(t.defaultPrevented||(h.$event=t,h.$eventType=h.$MOUSE_WHEEL,this._$hitTest()),this._$mouseWheelEvent=null)}_$run(e=0){if(this._$stopFlag)return;t.stats&&stats.begin(),t.glstats&&glstats.begin(),this._$wheelEvent(),this._$doAction();let i=e-this._$startTime;i>this._$fps&&(this._$startTime=e-i%this._$fps,this._$action(),this._$draw(0),!this._$hitTestStart&&"up"===this._$state&&h.$event&&this._$stageX>-1&&this._$stageY>-1&&this._$pointerCheck()),t.stats&&stats.end(),t.glstats&&glstats.end();const s=h.$requestAnimationFrame;this._$timerId=s(this._$bindRun)}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,h.$hitContext.setTransform(1,0,0,1,0,0),h.$hitContext.beginPath(),h.$MATRIX_HIT_ARRAY_IDENTITY[4]=this._$tx/this._$scale/h.$devicePixelRatio,h.$MATRIX_HIT_ARRAY_IDENTITY[5]=this._$ty/this._$scale/h.$devicePixelRatio,this._$stage._$mouseHit(h.$hitContext,h.$MATRIX_HIT_ARRAY_IDENTITY,this._$hitObject,!0);let i=null,s=null,r=!1,n=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(p.MOUSE_OUT)&&t.dispatchEvent(new p(p.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==i){let r=null;if(this._$rollOverObject)for(s=this._$rollOverObject,s.willTrigger(p.ROLL_OUT)&&s.dispatchEvent(new p(p.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),r=s._$parent;r&&r._$root!==r&&r!==i;){if(r._$mouseEnabled&&r._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===r){t=!0;break}e=e._$parent}if(!t&&r._$parent===i._$parent&&r._$index>i._$index&&(t=!0),t)break}r.willTrigger(p.ROLL_OUT)&&r.dispatchEvent(new p(p.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),r=r._$parent}for(s=i;s.willTrigger(p.ROLL_OVER)&&s.dispatchEvent(new p(p.ROLL_OVER,!1,!1,s.mouseX,s.mouseY)),s=s._$parent,s&&s!==r&&s.stage!==s;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i.willTrigger(p.MOUSE_OVER)&&i.dispatchEvent(new p(p.MOUSE_OVER,!0,!1,i.mouseX,i.mouseY)),this._$mouseOverTarget=i}if("up"===this._$state&&(this._$clickTarget=null),!h.$isTouch&&"up"===this._$state)for(s=i;s&&s.root!==s;){switch(!0){case s instanceof ht:s._$type===lt.INPUT&&(r=!0);break;case s.buttonMode:n=!0}if(r||n)break;s=s._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(p.MOUSE_OUT)&&i.dispatchEvent(new p(p.MOUSE_OUT,!0,!1,i.mouseX,i.mouseY))),this._$rollOverObject)for(s=this._$rollOverObject;s&&s.root!==s;)s.willTrigger(p.ROLL_OUT)&&s.dispatchEvent(new p(p.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),s=s._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case r:this._$canvas.style.cursor="text";break;case n:this._$canvas.style.cursor="pointer";break;case!h.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has(_.ENTER_FRAME)&&this._$dispatchEvent(new _(_.ENTER_FRAME)),this._$broadcastEvents.has(_.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new _(_.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(_.EXIT_FRAME)&&this._$dispatchEvent(new _(_.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new _(_.RENDER))),e){for(let i=0;i<e;++i){const e=t[i];e.hasEventListener(_.INIT)&&e.dispatchEvent(new _(_.INIT)),e.hasEventListener(_.COMPLETE)&&e.dispatchEvent(new _(_.COMPLETE))}h.$poolArray(t)}this._$doAction()}_$draw(){const t=this._$canvas,e=t.width,i=t.height,s=this._$context;if(this._$buffer&&this._$stage._$updated&&s&&e>0&&i>0){if(s._$bind(this._$buffer),h.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,e,i),s.beginPath(),this._$stage._$draw(s,this._$matrix,h.$COLOR_ARRAY_IDENTITY),this._$stage._$updated=!1,this._$sounds.size){const t=this._$sounds.values();for(let e of t)e._$soundPlay();this._$sounds.clear()}const t=s.frameBuffer.getTextureFromCurrentAttachment();s.frameBuffer.unbind(),h.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,e,i),s.drawImage(t,0,0,e,i),s._$bind(this._$buffer)}}_$doAction(){for(;this._$actions.length;){h.$actionProcess=!0;const t=this._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;t._$actionProcess=!0;const i=t._$actions.get(e),s=i.length;for(let e=0;e<s;++e)h.$currentLoaderInfo=t._$loaderInfo,i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}h.$currentLoaderInfo=null,h.$actionProcess=!1}_$hitTest(){if(this._$stopFlag)return;this._$hitTestStart=!0,h.$isUpdated=!1;const t=h.$event;let e=null,i=null,s=h.$window.pageXOffset,r=h.$window.pageYOffset;const n=h.$document.getElementById(this.contentElementId);if(n){const t=n.getBoundingClientRect();s+=t.left,r+=t.top}let a=0,o=0;if(h.$isTouch){const e=t.changedTouches[0];a=e.pageX,o=e.pageY}else a=t.pageX,o=t.pageY;a=(a-s)/this._$scale,o=(o-r)/this._$scale,t._$stageX=a,t._$stageY=o,this._$stageX=a,this._$stageY=o,this._$hitObject.x=a,this._$hitObject.y=o,this._$hitObject.pointer="",this._$hitObject.hit=null,h.$hitContext.setTransform(1,0,0,1,0,0),h.$hitContext.beginPath(),h.$MATRIX_HIT_ARRAY_IDENTITY[4]=this._$tx/this._$scale/h.$devicePixelRatio,h.$MATRIX_HIT_ARRAY_IDENTITY[5]=this._$ty/this._$scale/h.$devicePixelRatio,this._$stage._$mouseHit(h.$hitContext,h.$MATRIX_HIT_ARRAY_IDENTITY,this._$hitObject,!0),this._$hitObject.hit&&t.preventDefault();let l=!1,$=!1,_=!1;switch(h.$eventType){case h.$TOUCH_MOVE:case h.$MOUSE_MOVE:if(h.$dropTarget){const t=h.$dropTarget._$dragMousePoint();let e=t.x,i=t.y;h.$dragRules.lock||(e+=h.$dragRules.position.x,i+=h.$dragRules.position.y);const s=h.$dragRules.bounds;s&&(e=h.$clamp(e,s.left,s.right),i=h.$clamp(i,s.top,s.bottom)),h.$dropTarget.x=e,h.$dropTarget.y=i}break;case h.$TOUCH_START:case h.$MOUSE_DOWN:this._$state="down",_="pointer"===this._$canvas.style.cursor,$=!0;break;case h.$TOUCH_END:case h.$MOUSE_UP:case h.$DOUBLE_CLICK:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case h.$eventType===h.$MOUSE_LEAVE:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(p.MOUSE_OUT)&&e.dispatchEvent(new p(p.MOUSE_OUT,!0,!1,e.mouseX,e.mouseY))),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(p.ROLL_OUT)&&i.dispatchEvent(new p(p.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,h.$eventType){case h.$MOUSE_WHEEL:this._$stage.hasEventListener(p.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new p(p.MOUSE_WHEEL,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case h.$TOUCH_START:case h.$MOUSE_DOWN:this._$stage.hasEventListener(p.MOUSE_DOWN)&&this._$stage.dispatchEvent(new p(p.MOUSE_DOWN,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$textField&&this._$textField instanceof ht&&(this._$textField.focus=!1,this._$textField=null);break;case h.$TOUCH_END:case h.$MOUSE_UP:this._$textField&&this._$textField instanceof ht&&(this._$textField.focus=!1,this._$textField=null),this._$stage.hasEventListener(p.CLICK)&&this._$stage.dispatchEvent(new p(p.CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$stage.hasEventListener(p.MOUSE_UP)&&this._$stage.dispatchEvent(new p(p.MOUSE_UP,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case h.$TOUCH_MOVE:case h.$MOUSE_MOVE:this._$stage.hasEventListener(p.MOUSE_MOVE)&&this._$stage.dispatchEvent(new p(p.MOUSE_MOVE,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case h.$DOUBLE_CLICK:this._$stage.hasEventListener(p.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new p(p.DOUBLE_CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY))}break;default:switch(e=this._$hitObject.hit,h.$eventType){case h.$TOUCH_MOVE:case h.$MOUSE_MOVE:if(e.willTrigger(p.MOUSE_MOVE)&&e.dispatchEvent(new p(p.MOUSE_MOVE,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(p.MOUSE_OUT)&&t.dispatchEvent(new p(p.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(p.ROLL_OUT)&&i.dispatchEvent(new p(p.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(a,o)){let i=!1,s=e;for(;s&&s._$root!==s;){if(s===t){i=!0;break}s=s._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(p.ROLL_OUT)&&t.dispatchEvent(new p(p.ROLL_OUT,!1,!1,t.mouseX,t.mouseY)),t=t._$parent}for(i=e;i.willTrigger(p.ROLL_OVER)&&i.dispatchEvent(new p(p.ROLL_OVER,!1,!1,i.mouseX,i.mouseY)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(p.MOUSE_OVER)&&e.dispatchEvent(new p(p.MOUSE_OVER,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget=e}"up"===this._$state&&(this._$clickTarget=null);break;case h.$TOUCH_START:case h.$MOUSE_DOWN:e!==this._$textField&&this._$textField instanceof ht&&(this._$textField.focus=!1,this._$textField=null),e instanceof ht&&(e.focus=!0,this._$textField=e),e.willTrigger(p.MOUSE_DOWN)&&e.dispatchEvent(new p(p.MOUSE_DOWN,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=e;break;case h.$TOUCH_END:case h.$MOUSE_UP:e!==this._$textField&&this._$textField instanceof ht&&(this._$textField.focus=!1,this._$textField=null),e.willTrigger(p.MOUSE_UP)&&e.dispatchEvent(new p(p.MOUSE_UP,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget===e&&e.willTrigger(p.CLICK)&&e.dispatchEvent(new p(p.CLICK,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=null;break;case h.$MOUSE_WHEEL:e.willTrigger(p.MOUSE_WHEEL)&&e.dispatchEvent(new p(p.MOUSE_WHEEL)),e instanceof ht&&(e.scrollV+=t.deltaY);break;case h.$DOUBLE_CLICK:e.willTrigger(p.DOUBLE_CLICK)&&e.dispatchEvent(new p(p.DOUBLE_CLICK))}if(!$&&!h.$isTouch&&"up"===this._$state)for(i=e;i&&i.root!==i;){if(i instanceof ht){if(i._$type===lt.INPUT){l=!0;break}}else if(i._$buttonMode){_=!0;break}i=i._$parent}}switch(!0){case l:this._$canvas.style.cursor="text";break;case _:this._$canvas.style.cursor="pointer";break;case!h.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}!h.$actionProcess&&this._$actions.length>1&&this._$doAction(),h.$isUpdated&&(this._$stage._$prepareActions(),h.$actionProcess||this._$doAction()),this._$hitTestStart=!1}}h.$window.next2d=new class{constructor(){this._$player=new ae}load(t,e=null){if("develop"===t){const e=h.$location.search.substr(1).split("&")[0];if(!e)return;t=`${h.$location.origin}/${e}`}if(!t)return;"/"===t.charAt(1)&&(t=t.slice(1)),e&&"base"in e||!(t.indexOf("//")>-1)||(this._$player.base=t),this._$player.setOptions(e);const i=new G,s=i.contentLoaderInfo;s.addEventListener(f.IO_ERROR,(t=>{t.target.removeEventListener(f.IO_ERROR,t.listener),alert("Error: "+t.message)})),s.addEventListener(_.COMPLETE,(t=>{const e=t.target;e.removeEventListener(_.COMPLETE,t.listener);const i=h.$currentPlayer(),s=i.stage,r=e._$data.stage;if(i.width=r.width,i.height=r.height,i.stage.frameRate=r.fps,null===i._$bgColor){const t=h.$intToRGBA(0|`0x${r.bgColor.substr(1)}`);i._$context._$setColor(t.R/255,t.G/255,t.B/255,1),i._$backgroundColor=[t.R/255,t.G/255,t.B/255,1]}s.addChild(e.content),i._$resize()})),i.load(new pt(t))}createRootMovieClip(t=240,e=240,i=24,s=null){const r=this._$player;return r._$loadStatus=ae.LOAD_END,r._$mode="create",r._$stage.frameRate=0|i,r.width=0|t,r.height=0|e,r.setOptions(s),r._$stage.addChild(new S)}},h.$packages(h.$window.next2d),console.log("%c Next2D Player %c 1.7.0 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729","")})(window);