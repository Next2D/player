(()=>{"use strict";let t=0;const e=()=>t++;let i=0,s=null;const r=(t=null)=>{s=t};let n="";const a=t=>{n=t};let h=null;const o=()=>h,l=(t=null)=>{h=t};let _=1;const c=()=>_,$=window,u=$.document,d=RegExp;class g{constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}get value(){return this._$value}}let f=1,m=0,p=!1;const x=(t=!0)=>{p=t},b=1/0,T=Math,v=Array,E=Map,y=Number,A=Float32Array,M=Int32Array,C=Int16Array,w=OffscreenCanvas,S=isNaN,F=requestAnimationFrame,R=cancelAnimationFrame,B=performance,I=setTimeout,L=clearTimeout,P=new A([1,0,0,1,0,0]),O=new A([1,1,1,1,0,0,0,0]),k=-32768,N=32767,D=T.PI/180,U=180/T.PI,V=[],Y=[],X=[],z=[],G=[],H=[],W=[],j=[],q=new w(1,1).getContext("2d"),K=(t=0,e=0,i=0,s=0)=>{const r=j.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return r.xMin=t,r.xMax=e,r.yMin=i,r.yMax=s,r},Q=t=>{j.push(t)},J=(t=0,e=0,i=0,s=0)=>{const r=Y.pop()||new A(4);return r[0]=t,r[1]=e,r[2]=i,r[3]=s,r},Z=t=>{Y.push(t)},tt=(t=0,e=0,i=0,s=0,r=0,n=0)=>{const a=X.pop()||new A(6);return a[0]=t,a[1]=e,a[2]=i,a[3]=s,a[4]=r,a[5]=n,a},et=t=>{X.push(t)},it=(t=1,e=1,i=1,s=1,r=0,n=0,a=0,h=0)=>{const o=z.pop()||new A(8);return o[0]=t,o[1]=e,o[2]=i,o[3]=s,o[4]=r,o[5]=n,o[6]=a,o[7]=h,o},st=t=>{z.push(t)},rt=(t=0,e=0,i=0,s=0,r=0,n=0,a=0,h=0,o=0)=>{const l=G.pop()||new A(9);return l[0]=t,l[1]=e,l[2]=i,l[3]=s,l[4]=r,l[5]=n,l[6]=a,l[7]=h,l[8]=o,l},nt=(...t)=>{const e=H.pop()||[];return t.length&&e.push(...t),e},at=(t=null)=>{t&&(t.length&&(t.length=0),H.push(t))},ht=t=>{t.size&&t.clear(),W.push(t)},ot=()=>W.pop()||new E,lt=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),_t=t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],s=-819.2*t[0]+819.2*t[2]+t[4],r=-819.2*t[1]-819.2*t[3]+t[5],n=819.2*t[1]-819.2*t[3]+t[5];let a=s-e,h=-819.2*t[1]+819.2*t[3]+t[5]-r;const o=T.sqrt(a*a+h*h);o?(a/=o,h/=o):(a=0,h=0);const l=(i-e)*a+(n-r)*h;return J(e+l*a,r+l*h,i,n)},ct=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return rt(t[4]*e,0-t[1]*e,0,0-t[3]*e,t[0]*e,0,i*e,s*e,1)},$t=(t,e,i,s=null)=>{const r=+t;return S(r)&&null!==s?s:T.min(T.max(e,S(r)?0:r),i)},ut=(t,e)=>tt(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),dt=(t,e)=>it(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),gt=(t,e)=>{const i=t.xMax*e[0]+t.yMax*e[2]+e[4],s=t.xMax*e[0]+t.yMin*e[2]+e[4],r=t.xMin*e[0]+t.yMax*e[2]+e[4],n=t.xMin*e[0]+t.yMin*e[2]+e[4],a=t.xMax*e[1]+t.yMax*e[3]+e[5],h=t.xMax*e[1]+t.yMin*e[3]+e[5],o=t.xMin*e[1]+t.yMax*e[3]+e[5],l=t.xMin*e[1]+t.yMin*e[3]+e[5],_=T.min(y.MAX_VALUE,i,s,r,n),c=T.max(0-y.MAX_VALUE,i,s,r,n),$=T.min(y.MAX_VALUE,a,h,o,l),u=T.max(0-y.MAX_VALUE,a,h,o,l);return K(_,c,$,u)},ft=t=>{if(!q)return 0;q.fillStyle=t;const e=+`0x${q.fillStyle.slice(1)}`;return q.fillStyle="rgba(0, 0, 0, 1)",e},mt=t=>S(+t)?ft(`${t}`):+t,pt=t=>({A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}),xt=(t,e,i)=>(t>>16)*(i?e:1)/255,bt=(t,e,i)=>(t>>8&255)*(i?e:1)/255,Tt=(t,e,i)=>(255&t)*(i?e:1)/255,vt=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),Et=(t,e,i=!1,s=!1)=>{let r="";return i&&(r="italic "),s&&(r+="bold "),`${r}${e}px '${t}','sans-serif'`},yt=t=>{t.color&&st(t.color),t.isLayer=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.filters=null,t.blendMode="normal",t.sw=0,t.sh=0,V.push(t)},At=new class{constructor(){this._$pool=[],this._$store=new Map,this._$timerMap=new Map,this._$context=null}set context(t){this._$context=t}reset(){for(const t of this._$store.values()){for(const e of t.values())this.destroy(e);ht(t)}this._$store.clear(),this._$context&&this._$context.frameBuffer.clearCache()}destroy(t=null){if(t&&"object"==typeof t)if(t instanceof WebGLTexture)F((()=>{this._$context&&this._$context.frameBuffer.releaseTexture(t)}));else{if("canvas"in t&&t instanceof CanvasRenderingContext2D){const e=t.canvas,i=e.width,s=e.height;t.clearRect(0,0,i+1,s+1),e.width=e.height=1,this._$pool.push(e)}this._$context&&"index"in t&&this._$context.frameBuffer.textureManager.releasePosition(t)}}getCanvas(){return this._$pool.pop()||document.createElement("canvas")}remove(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t);i.has(e)&&(i.delete(e),i.size||(ht(i),this._$store.delete(t)))}stopTimer(t){t=`${t}`,this._$timerMap.has(t)&&(L(this._$timerMap.get(t)),this._$timerMap.delete(t))}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const t of e.values())this.destroy(t);e.clear(),ht(e),this._$store.delete(t)}this._$timerMap.delete(t)}setRemoveTimer(t){if(t=`${t}`,this.stopTimer(t),this._$store.has(t)){const e=I((()=>{this.removeCache(t)}),5e3);this._$timerMap.set(t,e)}}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){this.stopTimer(e);const t=this._$store.get(e);if(t.has(i))return t.get(i)}return null}set(t,e=null){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,ot());const r=this._$store.get(i);if(null===e){if(!r.has(s))return;return this.destroy(r.get(s)),r.delete(s),void(r.size||(ht(r),this._$store.delete(i)))}r.set(s,e)}has(t){const e=`${t[0]}`;return!!this._$store.has(e)&&this._$store.get(e).has(`${t[1]}`)}generateKeys(t,e=null,i=null){let s="";e&&e.length&&(s+=`${e[0]}_${e[1]}`),i&&i.length&&(s+=0===i[7]?"":`_${i[7]}`);const r=nt();if(s){let t=0;const e=s.length;for(let i=0;i<e;i++)t=(t<<5)-t+s.charCodeAt(i),t|=0;r[1]=`_${t}`}else r[1]="_0";return r[0]=`${t}`,r}};class Mt{constructor(t=""){this._$url=`${t}`,this._$contentType="application/json",this._$data="",this._$method="GET",this._$requestHeaders=nt(),this._$responseDataFormat="json",this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){this._$method=`${t}`}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){this._$requestHeaders.length=0,this._$requestHeaders.push(...t)}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=Zi();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get responseDataFormat(){return this._$responseDataFormat}set responseDataFormat(t){this._$responseDataFormat=`${t}`}get withCredentials(){return this._$withCredentials}set withCredentials(t){this._$withCredentials=t}get headers(){const t=nt();return t.push(new g("Content-Type",`${this._$contentType}`)),this._$requestHeaders.length&&t.push(...this._$requestHeaders),t}}class Ct{static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class wt{constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=e,this._$cancelable=i,this._$target=null,this._$currentTarget=null,this._$eventPhase=Ct.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get LOAD(){return"load"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get RESIZE(){return"resize"}static get SCROLL(){return"scroll"}static get OPEN(){return"open"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}set currentTarget(t){this._$currentTarget=t}get eventPhase(){return this._$eventPhase}set eventPhase(t){this._$eventPhase=t}get listener(){return this._$listener}set listener(t){this._$listener=t}get target(){return this._$target?this._$target:this._$currentTarget}set target(t){this._$target=t}get type(){return this._$type}formatToString(...t){let e=`[${t[0]}`;for(let i=1;i<t.length;++i){const s=t[i];e+=` ${s}=`;const r=this[s];e+="string"==typeof r?`"${r}"`:`${r}`}return`${e}]`}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}class St{constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,s=0){const r=Zi();let n,a=!1;switch(t=`${t}`){case wt.ENTER_FRAME:case wt.EXIT_FRAME:case wt.FRAME_CONSTRUCTED:case wt.RENDER:case wt.ACTIVATE:case wt.DEACTIVATE:case"keyDown":case"keyUp":r.broadcastEvents.size&&r.broadcastEvents.has(t)||r.broadcastEvents.set(t,nt()),n=r.broadcastEvents.get(t)||nt(),a=!0;break;default:this._$events||(this._$events=ot()),this._$events.size&&this._$events.has(t)||this._$events.set(t,nt()),n=this._$events.get(t)||nt()}let h=n.length;for(let t=0;t<h;++t){const s=n[t];i===s.useCapture&&s.target===this&&s.listener===e&&(h=t)}n[h]={listener:e,priority:s,useCapture:i,target:this},n.length>1&&n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),a?r.broadcastEvents.set(t,n):(this._$events||(this._$events=ot()),this._$events.set(t,n))}dispatchEvent(t){switch(t.type){case wt.ENTER_FRAME:case wt.EXIT_FRAME:case wt.FRAME_CONSTRUCTED:case wt.RENDER:case wt.ACTIVATE:case wt.DEACTIVATE:case"keyDown":case"keyUp":{const e=Zi();if(e&&e.broadcastEvents.size&&e.broadcastEvents.has(t.type)){const i=e.broadcastEvents.get(t.type);for(let e=0;e<i.length;++e){const s=i[e];if(s.target===this){t.eventPhase=Ct.AT_TARGET,t.currentTarget=s.target;try{t.listener=s.listener,s.listener.call(null,t)}catch(t){return console.error(t),!1}}}return!0}}break;default:{let e=null;this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type),e&&(e=e.slice(0))),e||(e=nt());const i=nt();if("parent"in this){let e=this.parent;for(;e;){if(e.hasEventListener(t.type)){const s=e._$events?e._$events.get(t.type):void 0;s&&i.push(s)}e=e.parent}}if(t.target=this,e.length||i.length){if(t.eventPhase=Ct.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(i.useCapture){t.currentTarget=i.target,r(i.target.loaderInfo);try{t.listener=i.listener,i.listener.call(null,t)}catch(t){return console.error(t),!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}if(t.eventPhase=Ct.AT_TARGET,!t._$stopImmediatePropagation&&!t._$stopPropagation){const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(!i.useCapture){t.currentTarget=i.target,r(i.target.loaderInfo);try{t.listener=i.listener,i.listener.call(null,t)}catch(t){return console.error(t),!1}if(t._$stopImmediatePropagation)break}}}switch(t.eventPhase=Ct.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(!i.useCapture){t.currentTarget=i.target,r(i.target.loaderInfo);try{t.listener=i.listener,i.listener.call(null,t)}catch(t){return console.error(t),!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return at(e),at(i),!0}at(e),at(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case wt.ENTER_FRAME:case wt.EXIT_FRAME:case wt.FRAME_CONSTRUCTED:case wt.RENDER:case wt.ACTIVATE:case wt.DEACTIVATE:case"keyDown":case"keyUp":{const e=Zi();if(e&&e.broadcastEvents.size&&e.broadcastEvents.has(t)){const i=e.broadcastEvents.get(t)||nt();for(let t=0;t<i.length;t++)if(i[t].target===this)return!0}return!1}default:return!!(this._$events&&this._$events.size&&this._$events.has(t))}}removeEventListener(t,e,i=!1){if(!e)return;if(t=`${t}`,!this.hasEventListener(t))return;const s=Zi();let r=null,n=!1;switch(t){case wt.ENTER_FRAME:case wt.EXIT_FRAME:case wt.FRAME_CONSTRUCTED:case wt.RENDER:case wt.ACTIVATE:case wt.DEACTIVATE:case"keyDown":case"keyUp":n=!0,s&&(r=s.broadcastEvents.get(t)||nt());break;default:this._$events&&this._$events.size&&this._$events.has(t)&&(r=this._$events.get(t)||nt())}if(r){for(let t=0;t<r.length;++t){const s=r[t];if(i===s.useCapture&&s.listener===e){r.splice(t,1);break}}if(r.length)r.length>1&&r.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),n?s.broadcastEvents.set(t,r):(this._$events||(this._$events=ot()),this._$events.set(t,r));else if(n)s.broadcastEvents.delete(t);else{if(!this._$events)return;this._$events.delete(t),this._$events.size||(ht(this._$events),this._$events=null)}}}removeAllEventListener(t,e=!1){if(t=`${t}`,!this.hasEventListener(t))return;const i=Zi();let s=null,r=!1;switch(t){case wt.ENTER_FRAME:case wt.EXIT_FRAME:case wt.FRAME_CONSTRUCTED:case wt.RENDER:case wt.ACTIVATE:case wt.DEACTIVATE:case"keyDown":case"keyUp":r=!0,i&&(s=i.broadcastEvents.get(t)||nt());break;default:this._$events&&this._$events.size&&this._$events.has(t)&&(s=this._$events.get(t)||nt())}if(!s)return;const n=nt();for(let t=0;t<s.length;++t){const i=s[t];e!==i.useCapture&&n.push(i)}if(n.length)n.length>1&&n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),r?i.broadcastEvents.set(t,n):(this._$events||(this._$events=ot()),this._$events.set(t,n));else if(r)i.broadcastEvents.delete(t);else{if(!this._$events)return;this._$events.delete(t),this._$events.size||(ht(this._$events),this._$events=null)}}willTrigger(t){if(this.hasEventListener(t))return!0;if("parent"in this){let e=this.parent;for(;e;){if(e.hasEventListener(t))return!0;e=e.parent}}return!1}}class Ft extends wt{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class Rt extends wt{constructor(t,e=!1,i=!1,s=0,r="",n=[]){super(t,e,i),this._$status=0|s,this._$responseHeaders=n,this._$responseURL=r}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","eventPhase","status","responseURL")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}get responseURL(){return this._$responseURL}get status(){return this._$status}}class Bt extends wt{constructor(t,e=!1,i=!1,s=""){super(t,e,i),this._$text=`${s}`}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}get text(){return this._$text}}class It extends wt{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:(t,e)=>{if(e in t)return t[e];const i=o();return i&&e in i?i[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class Lt extends wt{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class Pt extends wt{constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class Ot{constructor(t=1,e=1,i=1,s=1,r=0,n=0,a=0,h=0){this._$colorTransform=it(),this.redMultiplier=t,this.greenMultiplier=e,this.blueMultiplier=i,this.alphaMultiplier=s,this.redOffset=r,this.greenOffset=n,this.blueOffset=a,this.alphaOffset=h}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=$t(+t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=$t(0|t,-255,255,0)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=$t(+t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=$t(0|t,-255,255,0)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=$t(+t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=$t(0|t,-255,255,0)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=$t(+t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=$t(0|t,-255,255,0)}concat(t){const e=dt(this._$colorTransform,t._$colorTransform);this.redMultiplier=e[0],this.greenMultiplier=e[1],this.blueMultiplier=e[2],this.alphaMultiplier=e[3],this.redOffset=e[4],this.greenOffset=e[5],this.blueOffset=e[6],this.alphaOffset=e[7],st(e)}_$clone(){return ss(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class kt{constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return T.sqrt(T.pow(this.x,2)+T.pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=$t(+t,k,N,0)}get y(){return this._$y}set y(t){this._$y=$t(+t,k,N,0)}add(t){return new kt(this.x+t.x,this.y+t.y)}clone(){return new kt(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return T.sqrt(T.pow(t._$x-e._$x,2)+T.pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new kt(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new kt(t*T.cos(e),t*T.sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new kt(this.x-t.x,this.y-t.y)}}class Nt{constructor(t=1,e=0,i=0,s=1,r=0,n=0){this._$matrix=tt(1,0,0,1,0,0),this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=$t(+t,k,N,0)}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=$t(+t,k,N,0)}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=$t(+t,k,N,0)}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=$t(+t,k,N,0)}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=$t(+t,k,N,0)}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=$t(+t,k,N,0)}_$clone(){return this.clone()}clone(){return es(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let s=e[0]*i[0],r=0,n=0,a=e[3]*i[3],h=e[4]*i[0]+i[4],o=e[5]*i[3]+i[5];(e[1]||e[2]||i[1]||i[2])&&(s+=e[1]*i[2],a+=e[2]*i[1],r+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],h+=e[5]*i[2],o+=e[4]*i[1]),this.a=s,this.b=r,this.c=n,this.d=a,this.tx=h,this.ty=o}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,s=0,r=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(s,r)}createGradientBox(t,e,i=0,s=0,r=0){this.createBox(t/1638.4,e/1638.4,i,s+t/2,r+e/2)}deltaTransformPoint(t){return new kt(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){const t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],s=this._$matrix[3],r=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/s,this.tx=-this.a*r,this.ty=-this.d*n;else{const a=t*s-e*i;if(a){const h=1/a;this.a=s*h,this.b=-e*h,this.c=-i*h,this.d=t*h,this.tx=-(this.a*r+this.c*n),this.ty=-(this.b*r+this.d*n)}}}rotate(t){const e=this._$matrix[0],i=this._$matrix[1],s=this._$matrix[2],r=this._$matrix[3],n=this._$matrix[4],a=this._$matrix[5];this.a=e*T.cos(t)-i*T.sin(t),this.b=e*T.sin(t)+i*T.cos(t),this.c=s*T.cos(t)-r*T.sin(t),this.d=s*T.sin(t)+r*T.cos(t),this.tx=n*T.cos(t)-a*T.sin(t),this.ty=n*T.sin(t)+a*T.cos(t)}scale(t,e){this.a*=t,this.c*=t,this.tx*=t,this.b*=e,this.d*=e,this.ty*=e}setTo(t,e,i,s,r,n){this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}transformPoint(t){return new kt(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class Dt{constructor(t=0,e=0,i=0,s=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,s)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new kt(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=$t(+t,k,N,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new kt(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new kt(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=$t(+t,k,N,0)}get x(){return this._$x}set x(t){this._$x=$t(+t,k,N,0)}get y(){return this._$y}set y(t){this._$y=$t(+t,k,N,0)}clone(){return new Dt(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=T.max(this.x,t.x),i=T.max(this.y,t.y),s=T.min(this.right,t.right)-e,r=T.min(this.bottom,t.bottom)-i;return s>0&&r>0?new Dt(e,i,s,r):new Dt(0,0,0,0)}intersects(t){const e=T.max(this.x,t.x),i=T.max(this.y,t.y),s=T.min(this.right,t.right),r=T.min(this.bottom,t.bottom);return s-e>0&&r-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new Dt(T.min(this.x,t.x),T.min(this.y,t.y),T.max(this.right-t.left,t.right-this.left),T.max(this.bottom-t.top,t.bottom-this.top))}}class Ut{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,x()}}class Vt extends Ut{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=$t(+t,0,255,0))!==this._$blurX&&(this._$blurX=t,this._$doChanged())}get blurY(){return this._$blurY}set blurY(t){(t=$t(+t,0,255,0))!==this._$blurY&&(this._$blurY=t,this._$doChanged())}get quality(){return this._$quality}set quality(t){(t=$t(0|t,0,15,1))!==this._$quality&&(this._$quality=t,this._$doChanged())}clone(){return new Vt(this._$blurX,this._$blurY,this._$quality)}_$toArray(){return nt(1,this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=0,i=0){const s=K(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$quality)return s;const r=Vt.STEP[this._$quality-1];let n=0>=this._$blurX?1:this._$blurX*r,a=0>=this._$blurY?1:this._$blurY*r;return e?n*=e:n=T.round(n),i?a*=i:a=T.round(a),s.xMin-=n,s.xMax+=2*n,s.yMin-=a,s.yMax+=2*a,s}_$canApply(){return 0!==this._$blurX&&0!==this._$blurY}_$applyFilter(t,e,i=!0){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment,n=s.getTextureFromCurrentAttachment();if(!this._$canApply())return i?n:s.createTextureFromCurrentAttachment();let a=T.sqrt(e[0]*e[0]+e[1]*e[1]),h=T.sqrt(e[2]*e[2]+e[3]*e[3]);a/=f,h/=f,a*=2,h*=2;const o=K(0,n.width,0,n.height),l=this._$generateFilterRect(o,a,h);Q(o);const _=0|T.ceil(l.xMax),c=0|T.ceil(l.yMax),$=T.ceil(T.abs(l.xMin)+.5*T.abs(_-l.xMax)),u=T.ceil(T.abs(l.yMin)+.5*T.abs(c-l.yMax));t._$offsetX=$+t._$offsetX,t._$offsetY=u+t._$offsetY;const d=this._$blurX*a,g=this._$blurY*h;let m=1,p=1;d>128?m=.0625:d>64?m=.125:d>32?m=.25:d>16&&(m=.5),g>128?p=.0625:g>64?p=.125:g>32?p=.25:g>16&&(p=.5);const x=d*m,b=g*p,v=T.ceil(_*m),E=T.ceil(c*p),y=s.createTextureAttachment(v,E),A=[y,s.createTextureAttachment(v,E)];let M=0;t._$bind(y),t.reset(),t.setTransform(m,0,0,p,0,0),t.drawImage(n,$,u,n.width,n.height),t.blend.toOneZero();let C=s.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(C,!0,x),C=s.getTextureFromCurrentAttachment()}if(this._$blurY>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(C,!1,b),C=s.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==m||1!==p){const e=s.createTextureAttachment(_,c);t._$bind(e),t.reset(),t.imageSmoothingEnabled=!0,t.setTransform(1/m,0,0,1/p,0,0),t.drawImage(C,0,0,v,E),C=s.getTextureFromCurrentAttachment(),t.reset(),t.setTransform(1,0,0,1,0,0),s.releaseAttachment(A[0],!0),s.releaseAttachment(A[1],!0),i?s.releaseAttachment(r,!0):s.releaseAttachment(e,!1)}else s.releaseAttachment(A[(M+1)%2],!0),i?s.releaseAttachment(r,!0):s.releaseAttachment(A[M],!1);return C}}class Yt extends Ut{constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,h=4,o=1,l=1,_="inner",c=!1){super(),this._$blurFilter=new Vt(a,h,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=s,this.shadowColor=r,this.shadowAlpha=n,this.strength=o,this.type=_,this.knockout=c}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=$t(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=$t(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=$t(+t,0,1,0))!==this._$highlightAlpha&&(this._$highlightAlpha=t,this._$doChanged())}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=$t(mt(t),0,16777215,16777215))!==this._$highlightColor&&(this._$highlightColor=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=$t(+t,0,1,0))!==this._$shadowAlpha&&(this._$shadowAlpha=t,this._$doChanged())}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=$t(mt(t),0,16777215,0))!==this._$shadowColor&&(this._$shadowColor=t,this._$doChanged())}get strength(){return this._$strength}set strength(t){(t=$t(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){(t=`${t}`)!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new Yt(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return nt(0,this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=K(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const r=this._$angle*D;let n=T.abs(T.cos(r)*this._$distance),a=T.abs(T.sin(r)*this._$distance);return e&&(n*=e),i&&(a*=i),s.xMin=T.min(s.xMin,n),n>0&&(s.xMax+=n),s.yMin=T.min(s.yMin,a),a>0&&(s.yMax+=a),s}_$canApply(){return this._$strength>0&&0!==this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer,s=i.currentAttachment;if(!s)throw new Error("the current attachment is null.");t.setTransform(1,0,0,1,0,0);const r=i.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const n=s.width,a=s.height,h=t._$offsetX,o=t._$offsetY;let l=T.sqrt(e[0]*e[0]+e[1]*e[1]),_=T.sqrt(e[2]*e[2]+e[3]*e[3]);l/=f,_/=f,l*=2,_*=2;const c=this._$angle*D,$=T.cos(c)*this._$distance*l,u=T.sin(c)*this._$distance*_,d=i.createTextureAttachment(n,a);t._$bind(d),t.reset(),t.drawImage(r,0,0,n,a),t.globalCompositeOperation="erase",t.drawImage(r,2*$,2*u,n,a);const g=this._$blurFilter._$applyFilter(t,e,!1),m=g.width,p=g.height,x=T.ceil(m+2*T.abs($)),b=T.ceil(p+2*T.abs(u)),v="inner"===this._$type,E=v?n:x,y=v?a:b,A=T.abs($),M=T.abs(u),C=(m-n)/2,w=(p-a)/2,S=v?0:A+C,F=v?0:M+w,R=v?-C-$:A-$,B=v?-w-u:M-u;return t._$bind(s),i.releaseAttachment(d,!0),t._$applyBitmapFilter(g,E,y,n,a,S,F,m,p,R,B,!1,this._$type,this._$knockout,this._$strength,null,null,null,xt(this._$highlightColor,this._$highlightAlpha,!0),bt(this._$highlightColor,this._$highlightAlpha,!0),Tt(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,xt(this._$shadowColor,this._$shadowAlpha,!0),bt(this._$shadowColor,this._$shadowAlpha,!0),Tt(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=h+S,t._$offsetY=o+F,i.releaseTexture(g),i.getTextureFromCurrentAttachment()}}class Xt extends Ut{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(t&&v.isArray(t)&&20===t.length){for(let e=0;e<20;++e)if(t[e]!==this._$matrix[e]){this._$doChanged();break}this._$matrix=t}}clone(){return new Xt(this._$matrix)}_$toArray(){return nt(2,this._$matrix)}_$generateFilterRect(t){return t}_$canApply(){return!0}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment(),r=s.width,n=s.height,a=e.createTextureAttachment(r,n);return t._$bind(a),t.reset(),t._$applyColorMatrixFilter(s,this._$matrix),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()}}class zt extends Ut{constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,h=0,o=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=s,this.bias=r,this.preserveAlpha=n,this.clamp=a,this.color=h,this.alpha=o}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=$t(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get bias(){return this._$bias}set bias(t){t!==this._$bias&&(this._$bias=0|t,this._$doChanged())}get clamp(){return this._$clamp}set clamp(t){t!==this._$clamp&&(this._$clamp=!!t,this._$doChanged())}get color(){return this._$color}set color(t){(t=$t(mt(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get divisor(){return this._$divisor}set divisor(t){t!==this._$divisor&&(this._$divisor=0|t,this._$doChanged())}get matrix(){return this._$matrix}set matrix(t){v.isArray(this._$matrix)&&at(this._$matrix),this._$matrix=v.isArray(t)?t:null,this._$doChanged()}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|$t(0|t,0,15,0))!==this._$matrixX&&(this._$matrixX=t,this._$doChanged())}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|$t(0|t,0,15,0))!==this._$matrixY&&(this._$matrixY=t,this._$doChanged())}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){t!==this._$preserveAlpha&&(this._$preserveAlpha=!!t,this._$doChanged())}clone(){return new zt(this._$matrixX,this._$matrixY,this._$matrix?this._$matrix.slice():null,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$toArray(){return nt(3,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$matrix&&this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment();return this._$canApply()&&this._$matrix?(t._$applyConvolutionFilter(s,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,xt(this._$color,this._$alpha,!1),bt(this._$color,this._$alpha,!1),Tt(this._$color,this._$alpha,!1),this._$alpha),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()):s}}class Gt extends Ut{constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",h=0,o=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode="wrap",this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=s,this.scaleX=r,this.scaleY=n,this.mode=a,this.color=h,this.alpha=o}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=$t(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get color(){return this._$color}set color(t){(t=$t(mt(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get componentX(){return this._$componentX}set componentX(t){t!==this._$componentX&&(this._$componentX=t,this._$doChanged())}get componentY(){return this._$componentY}set componentY(t){t!==this._$componentY&&(this._$componentY=t,this._$doChanged())}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&(this._$mapBitmap=t,this._$doChanged())}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&(this._$mapPoint=t,this._$doChanged())}get mode(){return this._$mode}set mode(t){t!==this._$mode&&(this._$mode=t,this._$doChanged())}get scaleX(){return this._$scaleX}set scaleX(t){(t=$t(+t,-65535,65535,0))!==this._$scaleX&&(this._$scaleX=t,this._$doChanged())}get scaleY(){return this._$scaleY}set scaleY(t){(t=$t(+t,-65535,65535,0))!==this._$scaleY&&(this._$scaleY=t,this._$doChanged())}clone(){return new Gt(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$toArray(){return nt(4,this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$mapBitmap&&this._$componentX>0&&this._$componentY>0&&0!==this._$scaleX&&0!==this._$scaleY}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer,s=i.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=i.getTextureFromCurrentAttachment();if(!this._$canApply()||!s||!this._$mapBitmap)return r;const n=T.sqrt(e[0]*e[0]+e[1]*e[1]),a=T.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(r,this._$mapBitmap,r.width/n,r.height/a,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,xt(this._$color,this._$alpha,!0),bt(this._$color,this._$alpha,!0),Tt(this._$color,this._$alpha,!0),this._$alpha),i.releaseAttachment(s,!0),i.getTextureFromCurrentAttachment()}}class Ht extends Ut{constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,h=1,o=!1,l=!1,_=!1){super(),this._$blurFilter=new Vt(r,n,h),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=s,this.strength=a,this.inner=o,this.knockout=l,this.hideObject=_}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=$t(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=$t(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=$t(mt(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get distance(){return this._$distance}set distance(t){(t=$t(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get hideObject(){return this._$hideObject}set hideObject(t){t!==this._$hideObject&&(this._$hideObject=!!t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=$t(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new Ht(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$toArray(){return nt(5,this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=K(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const r=this._$angle*D;let n=T.cos(r)*this._$distance,a=T.sin(r)*this._$distance;return e&&(n*=e),i&&(a*=i),s.xMin=T.min(s.xMin,n),n>0&&(s.xMax+=n),s.yMin=T.min(s.yMin,a),a>0&&(s.yMax+=a),s}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t.frameBuffer,s=i.currentAttachment;if(!s)throw new Error("the current attachment is null.");if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const r=s.width,n=s.height,a=t._$offsetX,h=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),l=o.width,_=o.height,c=t._$offsetX,$=t._$offsetY,u=c-a,d=$-h;let g=T.sqrt(e[0]*e[0]+e[1]*e[1]),m=T.sqrt(e[2]*e[2]+e[3]*e[3]);g/=f,m/=f,g*=2,m*=2;const p=this._$angle*D,x=T.cos(p)*this._$distance*g,b=T.sin(p)*this._$distance*m,v=this._$inner?r:l+T.max(0,T.abs(x)-u),E=this._$inner?n:_+T.max(0,T.abs(b)-d),y=T.ceil(v),A=T.ceil(E),M=(y-v)/2,C=(A-E)/2,w=this._$inner?0:T.max(0,u-x)+M,S=this._$inner?0:T.max(0,d-b)+C,F=this._$inner?x-c:(x>0?T.max(0,x-u):0)+M,R=this._$inner?b-$:(b>0?T.max(0,b-d):0)+C;let B,I;return this._$inner?(B="inner",I=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(B="full",I=!0):(B="outer",I=this._$knockout),t._$bind(s),t._$applyBitmapFilter(o,y,A,r,n,w,S,l,_,F,R,!0,B,I,this._$strength,null,null,null,xt(this._$color,this._$alpha,!0),bt(this._$color,this._$alpha,!0),Tt(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+w,t._$offsetY=h+S,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class Wt extends Ut{constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,h=!1){super(),this._$blurFilter=new Vt(i,s,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=r,this.inner=a,this.knockout=h}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=$t(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=$t(mt(t),0,16777215,4))!==this._$color&&(this._$color=t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=$t(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new Wt(this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$toArray(){return nt(6,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){const s=K(t.xMin,t.xMax,t.yMin,t.yMax);return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t.frameBuffer,s=i.currentAttachment;if(!s)throw new Error("the current attachment is null.");if(this._$updated=!1,t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const r=s.width,n=s.height,a=t._$offsetX,h=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),l=o.width,_=o.height,c=t._$offsetX,$=t._$offsetY,u=this._$inner?r:l,d=this._$inner?n:_,g=this._$inner?0:c-a,f=this._$inner?0:$-h,m=this._$inner?-c:0,p=this._$inner?-$:0,x=this._$inner?"inner":"outer";return t._$bind(s),t._$applyBitmapFilter(o,u,d,r,n,g,f,l,_,m,p,!0,x,this._$knockout,this._$strength,null,null,null,xt(this._$color,this._$alpha,!0),bt(this._$color,this._$alpha,!0),Tt(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=h+f,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class jt extends Ut{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,l="inner",_=!1){super(),this._$blurFilter=new Vt(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=l,this.knockout=_}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,v.isArray(t)){for(let e=0;e<t.length;++e){const i=t[e];t[e]=$t(+i,0,1,0)}this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=$t(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,v.isArray(t)){for(let e=0;e<t.length;++e)t[e]=$t(mt(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=$t(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,v.isArray(t)){for(let e=0;e<t.length;++e)t[e]=$t(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=$t(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new jt(this._$distance,this._$angle,this._$colors?this._$colors.slice():null,this._$alphas?this._$alphas.slice():null,this._$ratios?this._$ratios.slice():null,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return nt(7,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=K(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const r=this._$angle*D;let n=T.abs(T.cos(r)*this._$distance),a=T.abs(T.sin(r)*this._$distance);return e&&(n*=e),i&&(a*=i),s.xMin=T.min(s.xMin,n),n>0&&(s.xMax+=n),s.yMin=T.min(s.yMin,a),a>0&&(s.yMax+=a),s}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer,s=i.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=i.getTextureFromCurrentAttachment();if(!this._$canApply()||!s)return r;const n=s.width,a=s.height,h=t._$offsetX,o=t._$offsetY;let l=T.sqrt(e[0]*e[0]+e[1]*e[1]),_=T.sqrt(e[2]*e[2]+e[3]*e[3]);l/=f,_/=f,l*=2,_*=2;const c=+this._$angle*D,$=+T.cos(c)*this._$distance*l,u=+T.sin(c)*this._$distance*_,d=i.createTextureAttachment(n,a);t._$bind(d),t.reset(),t.drawImage(r,0,0,n,a),t.globalCompositeOperation="erase",t.drawImage(r,2*$,2*u,n,a);const g=this._$blurFilter._$applyFilter(t,e,!1),m=g.width,p=g.height,x=T.ceil(m+2*T.abs($)),b=T.ceil(p+2*T.abs(u)),v="inner"===this._$type,E=v?n:x,y=v?a:b,A=T.abs($),M=T.abs(u),C=(m-n)/2,w=(p-a)/2,S=v?0:A+C,F=v?0:M+w,R=v?-C-$:A-$,B=v?-w-u:M-u;return t._$bind(s),t._$applyBitmapFilter(g,E,y,n,a,S,F,m,p,R,B,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=h+S,t._$offsetY=o+F,i.releaseAttachment(d,!0),i.getTextureFromCurrentAttachment()}}class qt extends Ut{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,l="inner",_=!1){super(),this._$blurFilter=new Vt(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=l,this.knockout=_}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,v.isArray(t)){for(let e=0;e<t.length;++e)t[e]=$t(+t[e],0,1,0);this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=$t(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,v.isArray(t)){for(let e=0;e<t.length;++e)t[e]=$t(mt(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=$t(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,v.isArray(t)){for(let e=0;e<t.length;++e)t[e]=$t(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=$t(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new qt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return nt(8,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=K(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const r=this._$angle*D;let n=T.abs(T.cos(r)*this._$distance),a=T.abs(T.sin(r)*this._$distance);return e&&(n*=e),i&&(a*=i),s.xMin=T.min(s.xMin,n),n>0&&(s.xMax+=n),s.yMin=T.min(s.yMin,a),a>0&&(s.yMax+=a),s}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer,s=i.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply()||!s)return i.getTextureFromCurrentAttachment();const r=s.width,n=s.height,a=t._$offsetX,h=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),l=o.width,_=o.height,c=t._$offsetX,$=t._$offsetY,u=c-a,d=$-h;let g=T.sqrt(e[0]*e[0]+e[1]*e[1]),m=T.sqrt(e[2]*e[2]+e[3]*e[3]);g/=f,m/=f,g*=2,m*=2;const p=+this._$angle*D,x=+T.cos(p)*this._$distance*g,b=+T.sin(p)*this._$distance*m,v="inner"===this.type,E=v?r:l+T.max(0,T.abs(x)-u),y=v?n:_+T.max(0,T.abs(b)-d),A=T.ceil(E),M=T.ceil(y),C=(A-E)/2,w=(M-y)/2,S=v?0:T.max(0,u-x)+C,F=v?0:T.max(0,d-b)+w,R=v?x-c:(x>0?T.max(0,x-u):0)+C,B=v?b-$:(b>0?T.max(0,b-d):0)+w;return t._$bind(s),t._$applyBitmapFilter(o,A,M,r,n,S,F,l,_,R,B,!0,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=a+S,t._$offsetY=h+F,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class Kt{constructor(t){this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject,e=t._$placeObject||t._$getPlaceObject();if(e&&e.colorTransform){const t=e.colorTransform;return ss(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}return this._$transform(),this._$colorTransform||(this._$colorTransform=ss()),this._$colorTransform._$clone()}set colorTransform(t){this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=dt(e._$transform._$rawColorTransform(),t),e=e._$parent;return ss(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject,e=t._$placeObject||t._$getPlaceObject();if(e&&e.matrix){const t=e.matrix;return es(t[0],t[1],t[2],t[3],t[4],t[5])}return this._$transform(),this._$matrix||(this._$matrix=es()),this._$matrix._$clone()}set matrix(t){this._$transform(t._$matrix,null)}get concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=ut(e._$transform._$rawMatrix(),t),e=e._$parent;return es(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){if(!this._$displayObject)return new Dt(0,0,0,0);const t=this._$displayObject._$getBounds(null),e=new Dt(t.xMin,t.yMin,+T.abs(t.xMax-t.xMin),+T.abs(t.yMax-t.yMin));return Q(t),e}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject,e=t._$placeObject||t._$getPlaceObject();if(e&&e.matrix){if(v.isArray(e.matrix)){const t=e.matrix;e.matrix=tt(t[0],t[1],t[2],t[3],t[4],t[5]),at(t)}return e.matrix}return P}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject,e=t._$placeObject||t._$getPlaceObject();if(e&&e.colorTransform){if(v.isArray(e.colorTransform)){const t=e.colorTransform;e.colorTransform=it(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7]),at(t)}return e.colorTransform}return O}_$transform(t=null,e=null,i=null,s=""){const r=this._$displayObject,n=r._$placeObject||r._$getPlaceObject();this._$setMatrix(t,n),this._$setColorTransform(e,n),this._$setFilters(i,n),this._$setBlendMode(s,n)}_$setMatrix(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),x()),this._$matrix||(this._$matrix=es(1,0,0,1,0,0),!t&&e&&e.matrix&&(t=e.matrix)),t){const e=this._$matrix._$matrix;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5]}}_$setColorTransform(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),x()),this._$colorTransform||(this._$colorTransform=ss(1,1,1,1,0,0,0,0),!t&&e&&e.colorTransform&&(t=e.colorTransform)),t){const e=this._$colorTransform._$colorTransform;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7]}}_$setFilters(t=null,e=null){if(v.isArray(t))return this._$filters&&at(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void x();if(!this._$filters)if(e){if(e.filters){this._$filters=e.filters.slice(0);for(let t=0;t<this._$filters.length;++t)this._$filters[t]=this._$filters[t].clone()}else if(e.surfaceFilterList){e.filters=this._$buildFilter(e.surfaceFilterList),this._$filters=e.filters.slice(0);for(let t=0;t<this._$filters.length;++t)this._$filters[t]=this._$filters[t].clone()}}else this._$filters=nt()}_$buildFilter(t){const e=nt(),i=t.length;for(let s=0;s<i;++s){const i=t[s];switch(null===i.params[0]&&i.params.shift(),i.class){case"BevelFilter":e.push(new Yt(...i.params));break;case"BlurFilter":e.push(new Vt(...i.params));break;case"ColorMatrixFilter":e.push(new Xt(...i.params));break;case"ConvolutionFilter":e.push(new zt(...i.params));break;case"DisplacementMapFilter":e.push(new Gt(...i.params));break;case"DropShadowFilter":e.push(new Ht(...i.params));break;case"GlowFilter":e.push(new Wt(...i.params));break;case"GradientBevelFilter":e.push(new jt(...i.params));break;case"GradientGlowFilter":e.push(new qt(...i.params))}}return e}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void x();this._$blendMode||(e&&e.blendMode?this._$blendMode=e.blendMode:this._$blendMode="normal")}}class Qt extends St{constructor(){super(),this._$id=-1,this._$instanceId=e(),this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$created=!1,this._$posted=!1,this._$postArray=null,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=-1,this._$startFrame=1,this._$endFrame=0,this._$transform=new Kt(this),this._$variables=null,this._$placeObject=null,this._$currentPlaceId=-1,this._$changePlace=!1,this._$scaleX=null,this._$scaleY=null,this._$rotation=null}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=$t(t,0,1,0);const e=this._$transform;if(e._$colorTransform){const i=e._$colorTransform;i._$colorTransform[3]=t,i._$colorTransform[7]=0,this._$doChanged(),x()}else{const i=e.colorTransform;i._$colorTransform[3]=t,i._$colorTransform[7]=0,e.colorTransform=i,rs(i)}}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,t._$blendMode;const e=this._$placeObject||this._$getPlaceObject();return e&&e.blendMode?(this._$blendMode=e.blendMode,e.blendMode):(this._$blendMode="normal","normal")}set blendMode(t){const e=this._$transform;e._$blendMode?(e._$blendMode=t,this._$doChanged(),x()):e._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters){const t=nt();for(let e=0;e<this._$filters.length;++e)t[e]=this._$filters[e].clone();return t}const t=this._$transform;if(t._$filters){const e=nt(),i=nt();for(let s=0;s<t._$filters.length;++s){const r=t._$filters[s];e[s]=r.clone(),i[s]=r.clone()}return this._$filters=e,i}const e=this._$placeObject||this._$getPlaceObject();if(e&&e.surfaceFilterList){e.filters||(e.filters=t._$buildFilter(e.surfaceFilterList));const i=nt(),s=nt();for(let t=0;t<e.filters.length;++t){const r=e.filters[t];i[t]=r.clone(),s[t]=r.clone()}return this._$filters=i,s}const i=nt();return this._$filters=i,i}set filters(t){t||(t=nt()),this._$transform._$transform(null,null,t),this._$filters=t}get height(){const t="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),e=gt(t,this._$transform._$rawMatrix());Q(t);const i=T.abs(e.yMax-e.yMin);switch(Q(e),i){case 0:case b:case-1/0:return 0;default:return+i.toFixed(2)}}set height(t){if(!S(t=+t)&&t>-1){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),i=this.rotation,s=i?gt(e,this._$transform._$rawMatrix()):e;i&&Q(e);const r=T.abs(s.yMax-s.yMin);switch(Q(s),r){case 0:case b:case-1/0:this.scaleY=0;break;default:this.scaleY=t/r}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(us&&this._$mask.stage&&this._$mask._$removeWorkerInstance(),this._$mask._$isMask=!1,this._$mask=null),t&&(us&&"_$createWorkerInstance"in t&&"function"==typeof t._$createWorkerInstance&&t._$createWorkerInstance(),t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return o()?this.globalToLocal(ts()).x:0}get mouseY(){return o()?this.globalToLocal(ts()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren();for(let i=0;i<t.length;++i){const s=t[i];s._$name&&e._$names.set(s.name,s)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){if(null!==this._$rotation)return this._$rotation;const t=this._$transform._$rawMatrix();return T.atan2(t[1],t[0])*U}set rotation(t){if(t=$t(t%360,-360,360,0),this._$rotation===t)return;const e=this._$transform,i=null!==e._$matrix,s=i?e._$matrix:e.matrix,r=T.sqrt(s.a*s.a+s.b*s.b),n=T.sqrt(s.c*s.c+s.d*s.d);if(0===t)s.a=r,s.b=0,s.c=0,s.d=n;else{let e=T.atan2(s.b,s.a),i=T.atan2(0-s.c,s.d);const a=t*D;i=i+a-e,e=a,s.b=r*T.sin(e),1===s.b||-1===s.b?s.a=0:s.a=r*T.cos(e),s.c=-n*T.sin(i),1===s.c||-1===s.c?s.d=0:s.d=n*T.cos(i)}i?(this._$doChanged(),x()):(e.matrix=s,is(s)),this._$rotation=t}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid!==t&&(this._$scale9Grid=t,this._$doChanged(),x())}get scaleX(){if(null!==this._$scaleX)return this._$scaleX;const t=this._$transform._$rawMatrix();let e=T.sqrt(t[0]*t[0]+t[1]*t[1]);if(!y.isInteger(e)){const t=e.toString(),i=t.indexOf("e");-1!==i&&(e=+t.slice(0,i)),e=+e.toFixed(4)}return 0>t[0]?-1*e:e}set scaleX(t){if(t=$t(+t,k,N),!y.isInteger(t)){const e=t.toString(),i=e.indexOf("e");-1!==i&&(t=+e.slice(0,i)),t=+t.toFixed(4)}if(this._$scaleX===t)return;const e=this._$transform,i=null!==e._$matrix,s=i?e._$matrix:e.matrix;if(0===s.b||S(s.b))s.a=t;else{let e=T.atan2(s.b,s.a);e===-T.PI&&(e=0),s.b=t*T.sin(e),s.a=t*T.cos(e)}i?(this._$doChanged(),x()):(e.matrix=s,is(s)),this._$scaleX=t}get scaleY(){if(null!==this._$scaleY)return this._$scaleY;const t=this._$transform._$rawMatrix();let e=T.sqrt(t[2]*t[2]+t[3]*t[3]);if(!y.isInteger(e)){const t=e.toString(),i=t.indexOf("e");-1!==i&&(e=+t.slice(0,i)),e=+e.toFixed(4)}return 0>t[3]?-1*e:e}set scaleY(t){if(t=$t(+t,k,N),!y.isInteger(t)){const e=t.toString(),i=e.indexOf("e");-1!==i&&(t=+e.slice(0,i)),t=+t.toFixed(4)}if(this._$scaleY===t)return;const e=this._$transform,i=null!==e._$matrix,s=i?e._$matrix:e.matrix;if(0===s.c||S(s.c))s.d=t;else{let e=T.atan2(-s.c,s.d);e===-T.PI&&(e=0),s.c=-t*T.sin(e),s.d=t*T.cos(e)}i?(this._$doChanged(),x()):(e.matrix=s,is(s)),this._$scaleY=t}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t._$stage:null}get transform(){return this._$transform}set transform(t){this._$transform=t}get visible(){return this._$visible}set visible(t){this._$visible!==t&&(this._$visible=!!t,this._$doChanged(),x())}get width(){const t="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),e=gt(t,this._$transform._$rawMatrix());Q(t);const i=T.abs(e.xMax-e.xMin);switch(Q(e),!0){case 0===i:case i===b:case i===-1/0:return 0;default:return+i.toFixed(2)}}set width(t){if(!S(t=+t)&&t>-1){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),i=this.rotation,s=i?gt(e,this._$transform._$rawMatrix()):e;i&&Q(e);const r=T.abs(s.xMax-s.xMin);switch(Q(s),!0){case 0===r:case r===b:case r===-1/0:this.scaleX=0;break;default:this.scaleX=t/r}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform;if(e._$matrix)e._$matrix.tx=t,this._$doChanged(),x();else{const i=e.matrix;i.tx=t,e.matrix=i,is(i)}}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform;if(e._$matrix)e._$matrix.ty=t,this._$doChanged(),x();else{const i=e.matrix;i.ty=t,e.matrix=i,is(i)}}getBounds(t=null){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),i=this._$transform.concatenatedMatrix,s=gt(e,i._$matrix);is(i),Q(e);const r=K(s.xMin,s.xMax,s.yMin,s.yMax);Q(s),t||(t=this);const n=t._$transform.concatenatedMatrix;n.invert();const a=gt(r,n._$matrix);Q(r),is(n);const h=a.xMin,o=a.yMin,l=a.xMax,_=a.yMax;return Q(a),new Dt(h,o,T.abs(l-h),T.abs(_-o))}globalToLocal(t){const e=this._$transform.concatenatedMatrix;e.invert();const i=new kt(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return is(e),i}hitTestObject(t){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),i=this._$transform.concatenatedMatrix,s=gt(e,i._$matrix);is(i),Q(e);const r=t._$getBounds(null),n=t._$transform.concatenatedMatrix,a=gt(r,n._$matrix);is(n),Q(r);const h=T.max(s.xMin,a.xMin),o=T.max(s.yMin,a.yMin),l=T.min(s.xMax,a.xMax),_=T.min(s.yMax,a.yMax);return Q(s),Q(a),l-h>=0&&_-o>=0}hitTestPoint(t,e,i=!1){if(i){let i=P,s=this._$parent;for(;s;)i=ut(s._$transform._$rawMatrix(),i),s=s._$parent;Ji.setTransform(1,0,0,1,0,0),Ji.beginPath();let r=!1;return"_$hit"in this&&"function"==typeof this._$hit&&(r=this._$hit(Ji,i,{x:t,y:e},!0)),i!==P&&et(i),r}const s="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),r=gt(s,this._$transform._$rawMatrix());Q(s);const n=new Dt(r.xMin,r.yMin,r.xMax-r.xMin,r.yMax-r.yMin);Q(r);const a=this._$parent?this._$parent.globalToLocal(new kt(t,e)):new kt(t,e);return n.containsPoint(a)}localToGlobal(t){const e=this._$transform.concatenatedMatrix,i=new kt(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return is(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=ot()),this._$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(ht(this._$variables),this._$variables=null))}getGlobalVariable(t){return Bi.has(t)?Bi.get(t):null}setGlobalVariable(t,e){Bi.set(t,e)}hasGlobalVariable(t){return Bi.has(t)}deleteGlobalVariable(t){Bi.has(t)&&Bi.delete(t)}clearGlobalVariable(){return Bi.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(-1===t)return null;const e=this._$parent;if(!e||!e._$placeObjects)return null;const i=e._$placeMap;if(!i||!i.length)return null;const s=i["currentFrame"in e?e.currentFrame:1];if(!s)return null;const r=0|s[t],n=e._$placeObjects[r];return n?(this._$changePlace=r!==this._$currentPlaceId,this._$currentPlaceId=r,this._$placeObject=n,n):null}return this._$placeObject}_$baseBuild(t,e){const i=e._$loaderInfo;if(!i||!i._$data)throw new Error("the loaderInfo or data is nul.");return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;const t=this._$parent;t&&t._$updateState()}_$doChanged(){this._$posted=!1,this._$isNext=!0,this._$updated=!0;const t=this._$parent;t&&(t._$updated||t._$doChanged())}_$drawFilter(t,e,i,s,r,n=null){const a=nt(this._$instanceId,"f");let h=At.get(a);const o=this._$isFilterUpdated(e,i,!0);if(h&&!o)return t.cachePosition=h,h;h&&At.set(a,null);const l=t.frameBuffer,_=n||t.getTextureFromRect(t.cachePosition),c=this._$applyFilter(t,i,_,e,s,r);l.textureManager.release(_);const $=this._$getLayerBounds(e);return h=l.createCachePosition(T.ceil(T.abs($.xMax-$.xMin)),T.ceil(T.abs($.yMax-$.yMin))),Q($),h.filterState=!0,h.matrix=`${e[0]}_${e[1]}_${e[2]}_${e[3]}_0_0`,h.offsetX=c.offsetX,h.offsetY=c.offsetY,t.drawTextureFromRect(c,h),At.set(a,h),at(a),h}_$getLayerBounds(t){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():K(),i=gt(e,t);Q(e);const s=this._$filters||this.filters;if(!s.length)return i;let r=K(0,T.abs(i.xMax-i.xMin),0,T.abs(i.yMax-i.yMin));Q(i);let n=+T.sqrt(t[0]*t[0]+t[1]*t[1]),a=+T.sqrt(t[2]*t[2]+t[3]*t[3]);n/=f,a/=f,n*=2,a*=2;for(let t=0;t<s.length;++t)r=s[t]._$generateFilterRect(r,n,a);return r}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger(wt.ADDED)&&this.dispatchEvent(new wt(wt.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger(wt.ADDED_TO_STAGE)&&this.dispatchEvent(new wt(wt.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!this._$posted&&us&&this._$postProperty(),!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e=null,i=!1){if(this._$isUpdated())return!0;if(i&&e)for(let t=0;t<e.length;++t)if(e[t]._$isUpdated())return!0;const s=At.get([this._$instanceId,"f"]);return!s||s.filterState!==i||s.matrix!==`${t[0]}_${t[1]}_${t[2]}_${t[3]}`}_$applyFilter(t,e,i,s,r,n){const a=+T.sqrt(s[0]*s[0]+s[1]*s[1]),h=+T.sqrt(s[2]*s[2]+s[3]*s[3]),o=T.atan2(s[1],s[0]),l=T.atan2(-s[2],s[3]),_=tt(T.cos(o),T.sin(o),-T.sin(l),T.cos(l),r/2,n/2),c=tt(1,0,0,1,-i.width/2,-i.height/2),$=ut(_,c);et(_),et(c);const u=t.frameBuffer,d=u.currentAttachment,g=u.createCacheAttachment(r,n);t._$bind(g),t.reset(),t.setTransform($[0],$[1],$[2],$[3],$[4],$[5]),et($),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;const f=tt(a,0,0,h,0,0);let m=null;for(let i=0;i<e.length;++i)m=e[i]._$applyFilter(t,f);if(et(f),!m)return i;const p=t._$offsetX,x=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,m.offsetX=p,m.offsetY=x,t._$bind(d),u.releaseAttachment(g,!1),m}_$shouldClip(t){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds(t):K(),i=T.abs(e.xMax-e.xMin),s=T.abs(e.yMax-e.yMin);return Q(e),!(!i||!s)}_$startClip(t,e){t.drawInstacedArray();const i="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds(e):K(),s=t._$startClip(i);if(Q(i),!s)return!1;t._$enterClip(),t._$beginClipDef();let r=!1;return"_$children"in this&&(r=!0,t._$updateContainerClipFlag(!0)),this._$clip(t,e),this._$updated=!1,r&&(t._$updateContainerClipFlag(!1),t._$drawContainerClip()),t._$endClipDef(),!0}_$removeWorkerInstance(){us&&us.postMessage({command:"remove",instanceId:this._$instanceId})}_$createMessage(){const t={command:"setProperty",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,visible:this._$visible};this._$placeId>-1&&(t.depth=this._$placeId),this._$clipDepth&&(t.clipDepth=this._$clipDepth),this._$isMask&&(t.isMask=this._$isMask);const e=this._$mask;if(e){t.maskId=e._$instanceId;let i=P,s=e._$parent;for(;s;)i=ut(s._$transform._$rawMatrix(),i),s=s._$parent;t.maskMatrix=i}if(this._$visible){const e=this._$transform,i=e._$rawMatrix();1!==i[0]&&(t.a=i[0]),0!==i[1]&&(t.b=i[1]),0!==i[2]&&(t.c=i[2]),1!==i[3]&&(t.d=i[3]),0!==i[4]&&(t.tx=i[4]),0!==i[5]&&(t.ty=i[5]);const s=e._$rawColorTransform();1!==s[0]&&(t.f0=s[0]),1!==s[1]&&(t.f1=s[1]),1!==s[2]&&(t.f2=s[2]),1!==s[3]&&(t.f3=s[3]),0!==s[4]&&(t.f4=s[4]),0!==s[5]&&(t.f5=s[5]),0!==s[6]&&(t.f6=s[6]),0!==s[7]&&(t.f7=s[7]);const r=this._$filters||this.filters;if(r&&r.length){const e=nt();for(let t=0;t<r.length;++t)e.push(r[t]._$toArray());t.filters=e}const n=this._$blendMode||this.blendMode;"normal"!==n&&(t.blendMode=n);const a=this._$scale9Grid;if(a&&this._$isUpdated()){const e=this._$parent._$transform.concatenatedMatrix;t.matrixBase=e._$matrix.slice(),is(e),t.grid={x:a.x,y:a.y,w:a.width,h:a.height}}}return t}}class Jt extends Qt{constructor(){super(),this._$mouseEnabled=!0}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=!!t}}class Zt extends Jt{constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=nt(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=ot(),new Proxy(this,{get:(t,e)=>t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]})}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=!!t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){return t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId)),this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),s=i.length;if(0>e||e>s)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(s&&s>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren();for(let i=0;i<e.length;++i){const s=e[i];if(s._$instanceId===t._$instanceId)return!0;if(s instanceof Zt&&s.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren();if(0>t||t>e.length)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren();for(let i=0;i<e.length;++i){const s=e[i];if(s.name===t)return s}return null}getChildIndex(t){if(t._$parent!==this)throw new Error("ArgumentError: getChildIndex: not child");const e=this._$getChildren().indexOf(t);if(-1===e)throw new Error("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(t._$parent!==this)throw new Error("ArgumentError: removeChild: not child");return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const i=this._$getChildren();if(i.length){t=$t(t,0,2147483646,0)-1,e=$t(e,1,134217727,134217727);for(let s=T.min(e,i.length-1);s>t;--s)this._$remove(i[s])}}setChildIndex(t,e){const i=this.getChildIndex(t);if(i===e)return;const s=this._$getChildren();s.splice(i,1),s.splice(e,0,t),us&&this._$postChildrenIds(),this._$doChanged()}swapChildren(t,e){const i=this._$getChildren(),s=this.getChildIndex(t),r=this.getChildIndex(e);i[s]=e,i[r]=t,us&&this._$postChildrenIds(),this._$doChanged()}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=P;if(t){e=t;const i=this._$transform._$rawMatrix();1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=ut(t,i))}const i="_$graphics"in this?this._$graphics:null,s=this._$needsChildren?this._$getChildren():this._$children;if(!s.length&&!i){const i=K(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&et(e),i}const r=y.MAX_VALUE;let n=r,a=-r,h=r,o=-r;if(i){const t=i._$getBounds(),s=gt(t,e);Q(t),n=s.xMin,a=s.xMax,h=s.yMin,o=s.yMax,Q(s)}for(let t=0;t<s.length;++t){const i=s[t]._$getBounds(e);n=T.min(n,i.xMin),a=T.max(a,i.xMax),h=T.min(h,i.yMin),o=T.max(o,i.yMax),Q(i)}return t&&e!==t&&et(e),K(n,a,h,o)}_$getLayerBounds(t){const e="_$graphics"in this?this._$graphics:null,i=this._$needsChildren?this._$getChildren():this._$children;if(!i.length&&!e)return K(0,0,0,0);const s=y.MAX_VALUE;let r=s,n=-s,a=s,h=-s;if(e){const i=e._$getBounds(),s=gt(i,t);Q(i),r=+s.xMin,n=+s.xMax,a=+s.yMin,h=+s.yMax,Q(s)}for(let e=0;e<i.length;++e){const s=i[e];let o=t;const l=s._$transform._$rawMatrix();1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(o=ut(t,l));const _=s._$getLayerBounds(o);r=T.min(r,_.xMin),n=T.max(n,_.xMax),a=T.min(a,_.yMin),h=T.max(h,_.yMax),Q(_),o!==t&&et(o)}const o=this._$filters||this.filters;if(!o.length)return K(r,n,a,h);let l=K(0,n-r,0,h-a),_=+T.sqrt(t[0]*t[0]+t[1]*t[1]),c=+T.sqrt(t[2]*t[2]+t[3]*t[3]);_/=f,c/=f,_*=2,c*=2;for(let t=0;t<o.length;++t)l=o[t]._$generateFilterRect(l,_,c);return n+=l.xMax-(n-r),h+=l.yMax-(h-a),r+=l.xMin,a+=l.yMin,Q(l),K(r,n,a,h)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=this._$children;if(!this._$controller)return t;const e="_$currentFrame"in this?this._$currentFrame:1,i=this._$controller[e];if(!t.length){if(i)for(let e=0;e<i.length;++e){const s=this._$createInstance(i[e]);s._$placeId=e;const r=s.loopConfig;r&&(s._$currentFrame=s._$getLoopFrame(r)),t.push(s),s._$name&&this._$names.set(s._$name,s)}return t}const s=!!us&&!!this._$stage,r=ot(),n=ot();let a=0;const h=nt();for(let o=0;o<t.length;++o){const l=t[o],_=l._$parent;if(!_||_._$instanceId!==this._$instanceId)continue;const c=l._$instanceId,$=l._$startFrame,u=l._$endFrame;if(1===$&&0===u||$<=e&&u>e){if(l._$isNext=!0,l._$placeObject=null,l._$filters=null,l._$blendMode=null,-1===l._$id){h.push(l),l._$name&&this._$names.set(l._$name,l);continue}const t=i[a];if(l._$id===t){l._$placeId=a,h.push(l),l._$name&&this._$names.set(l._$name,l),n.has(t)&&n.delete(t),r.set(t,!0),a++,s&&l._$postProperty();continue}n.set(l._$id,l)}else s&&l._$removeWorkerInstance(),At.setRemoveTimer(c),l._$loaderInfo&&l._$characterId&&At.setRemoveTimer(`${l._$loaderInfo._$id}@${l._$characterId}`),l._$graphics&&At.setRemoveTimer(l._$graphics._$cacheKey),l.willTrigger(wt.REMOVED)&&l.dispatchEvent(new wt(wt.REMOVED,!0)),l.willTrigger(wt.REMOVED_FROM_STAGE)&&l.dispatchEvent(new wt(wt.REMOVED_FROM_STAGE,!0)),l._$added=!1,l._$addedStage=!1,l._$active=!1,l._$updated=!0,l._$filters=null,l._$blendMode=null,l._$isNext=!0,l._$placeObject=null,l._$created=!1,l._$posted=!1,l instanceof Zt&&(l._$executeRemovedFromStage(),l._$removeParentAndStage())}if(i)for(let t=0;t<i.length;++t){const e=i[t];if(r.has(e))continue;const s=n.has(e)?n.get(e):this._$createInstance(e);s._$placeId=t;const a=s.loopConfig;a&&(s._$currentFrame=s._$getLoopFrame(a)),h.push(s),s._$name&&this._$names.set(s._$name,s)}ht(r),ht(n),t.length=0,t.push(...h),at(h)}return this._$children}_$clearChildren(){this._$doChanged(),x(),this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$parent=this,t._$stage&&t._$root||(t._$stage=this._$stage,t._$root=this._$root),t instanceof Zt&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger(wt.ADDED)&&t.dispatchEvent(new wt(wt.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(t.willTrigger(wt.ADDED_TO_STAGE)&&t.dispatchEvent(new wt(wt.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof Zt&&t._$executeAddedToStage(),us&&(t._$createWorkerInstance(),t._$postProperty(),this._$postChildrenIds())),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=0;e<t.length;++e){const i=t[e];i._$root=this._$root,i._$stage=this._$stage,i instanceof Zt&&(i._$setParentAndStage(),i._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=nt();for(let i=0;i<t.length;++i){const s=t[i];s&&(e.push(s._$instanceId),s._$addedStage||(us&&(s._$createWorkerInstance(),s._$postProperty()),s.willTrigger(wt.ADDED_TO_STAGE)&&s.dispatchEvent(new wt(wt.ADDED_TO_STAGE)),s._$addedStage=!0),s instanceof Zt&&s._$executeAddedToStage())}us&&this._$postChildrenIds(e),at(e)}_$remove(t,e=!0){t._$transform._$transform(),t.hasEventListener(wt.ENTER_FRAME)&&t.removeAllEventListener(wt.ENTER_FRAME),t.hasEventListener(wt.EXIT_FRAME)&&t.removeAllEventListener(wt.EXIT_FRAME),t.hasEventListener(wt.FRAME_CONSTRUCTED)&&t.removeAllEventListener(wt.FRAME_CONSTRUCTED),t.hasEventListener(wt.RENDER)&&t.removeAllEventListener(wt.RENDER),t.hasEventListener(wt.ACTIVATE)&&t.removeAllEventListener(wt.ACTIVATE),t.hasEventListener(wt.DEACTIVATE)&&t.removeAllEventListener(wt.DEACTIVATE),t.hasEventListener("keyDown")&&t.removeAllEventListener("keyDown"),t.hasEventListener("keyUp")&&t.removeAllEventListener("keyUp");const i=this._$needsChildren?this._$getChildren():this._$children,s=this.getChildIndex(t);return i.splice(s,1),this._$names.delete(t.name),e&&(t.willTrigger(wt.REMOVED)&&t.dispatchEvent(new wt(wt.REMOVED,!0)),null!==this._$stage&&(us&&(t._$removeWorkerInstance(),this._$postChildrenIds()),t.willTrigger(wt.REMOVED_FROM_STAGE)&&t.dispatchEvent(new wt(wt.REMOVED_FROM_STAGE)),t instanceof Zt&&t._$executeRemovedFromStage()),At.setRemoveTimer(t._$instanceId),t._$loaderInfo&&t._$characterId&&At.setRemoveTimer(`${t._$loaderInfo._$id}@${t._$characterId}`),t._$graphics&&At.setRemoveTimer(t._$graphics._$cacheKey),t instanceof Zt&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,t._$created=!1,t._$posted=!1,this._$doChanged()),t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0);for(let e=0;e<t.length;++e){const i=t[e];i&&(i._$addedStage&&(us&&i._$removeWorkerInstance(),i.willTrigger(wt.REMOVED_FROM_STAGE)&&i.dispatchEvent(new wt(wt.REMOVED_FROM_STAGE)),i._$created=!1,i._$posted=!1,i._$addedStage=!1),i instanceof Zt&&i._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=0;e<t.length;++e){const i=t[e];At.setRemoveTimer(i._$instanceId),i._$loaderInfo&&i._$characterId&&At.setRemoveTimer(`${i._$loaderInfo._$id}@${i._$characterId}`),i._$graphics&&At.setRemoveTimer(i._$graphics._$cacheKey),i instanceof Zt&&i._$removeParentAndStage(),i._$stage=null,i._$root=null,i._$addedStage=!1}if("_$sounds"in this){const t=this._$sounds;if(t.size)for(const e of t.values())for(let t=0;t<e.length;++t)e[t].stop()}this._$needsChildren=!0}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$getChildren();for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,!this._$posted&&us&&this._$postProperty(),this._$isNext}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=ut(e,s));const r="_$graphics"in this?this._$graphics:null;r&&r._$canDraw&&r._$clip(t,i);const n=this._$getChildren();for(let e=0;e<n.length;++e){const s=n[e];s._$isMask||(s._$clip(t,i),s._$updated=!1)}i!==e&&et(i)}_$preDraw(t,e){let i=e;const s=this._$transform._$rawMatrix();if((s!==ki&&1!==s[0]||0!==s[1]||0!==s[2]||1!==s[3]||0!==s[4]||0!==s[5])&&(i=ut(e,s)),!i[0]&&!i[1]||!i[2]&&!i[3])return i!==e&&et(i),null;const r=V.pop()||{isLayer:!1,isUpdated:null,canApply:null,matrix:null,color:null,blendMode:"normal",filters:null,sw:0,sh:0};r.matrix=i;const n=this._$filters||this.filters,a=this._$blendMode||this.blendMode;if(n.length>0||"normal"!==a){const s=this._$getBounds(null),h=gt(s,i);Q(s);const o=+h.xMax,l=+h.xMin,_=+h.yMax,c=+h.yMin;Q(h);const $=T.ceil(T.abs(o-l)),u=T.ceil(T.abs(_-c));if(0>=$||0>=u)return yt(r),i!==e&&et(i),null;let d=+T.sqrt(i[0]*i[0]+i[1]*i[1]);if(!y.isInteger(d)){const t=d.toString(),e=t.indexOf("e");-1!==e&&(d=+t.slice(0,e)),d=+d.toFixed(4)}let g=+T.sqrt(i[2]*i[2]+i[3]*i[3]);if(!y.isInteger(g)){const t=g.toString(),e=t.indexOf("e");-1!==e&&(g=+t.slice(0,e)),g=+g.toFixed(4)}r.canApply=this._$canApply(n);let f=K(0,$,0,u);if(r.canApply&&n)for(let t=0;t<n.length;++t)f=n[t]._$generateFilterRect(f,d,g);const m=t.frameBuffer.currentAttachment;if(!m||!m.texture||l-f.xMin>m.width||c-f.yMin>m.height)return Q(f),yt(r),i!==e&&et(i),null;if(0>l+f.xMax||0>c+f.yMax)return Q(f),yt(r),i!==e&&et(i),null;let p=i[4]-l,x=i[5]-c;t._$startLayer(K(l,o,c,_));const b=this._$isFilterUpdated(i,n,r.canApply),v=this._$getLayerBounds(i),E=T.ceil(T.abs(v.xMax-v.xMin)),A=T.ceil(T.abs(v.yMax-v.yMin));Q(v);const M=E-f.xMax+f.xMin,C=A-f.yMax+f.yMin;p+=M,x+=C,r.sw=M,r.sh=C,b&&t._$saveAttachment(T.ceil($+M),T.ceil(u+C),!0),r.isLayer=!0,r.isUpdated=b,r.filters=n,r.blendMode=a,r.color=it(),r.matrix=tt(i[0],i[1],i[2],i[3],p,x),i!==e&&et(i),Q(f)}return r}_$postDraw(t,e,i,s){t.drawInstacedArray();const r=nt(this._$instanceId,"f"),n=t.frameBuffer,a=s.matrix;let h=0,o=0,l=At.get(r);if(!l||s.isUpdated){l&&At.set(r,null),l=n.getTextureFromCurrentAttachment();const i=s.filters;let _=!1;if(i&&i.length){for(let s=0;s<i.length;++s)l=i[s]._$applyFilter(t,e);_=!0,h=t._$offsetX,o=t._$offsetY,t._$offsetX=0,t._$offsetY=0}l.filterState=_,l.matrix=`${a[0]}_${a[1]}_${a[2]}_${a[3]}`,l.offsetX=h,l.offsetY=o,At.set(r,l),t._$restoreAttachment()}l.offsetX&&(h=l.offsetX),l.offsetY&&(o=l.offsetY),t.reset(),t.globalAlpha=$t(i[3]+i[7]/255,0,1),t.globalCompositeOperation=s.blendMode;const _=t.getCurrentPosition();t.setTransform(1,0,0,1,_.xMin-h-s.sw,_.yMin-o-s.sh),t.drawImage(l,0,0,l.width,l.height,i),t._$endLayer(),et(s.matrix),yt(s),t.cachePosition=null}_$draw(t,e,i){if(!this._$visible)return;let s=i;const r=this._$transform._$rawColorTransform();if((r!==O&&1!==r[0]||1!==r[1]||1!==r[2]||1!==r[3]||0!==r[4]||0!==r[5]||0!==r[6]||0!==r[7])&&(s=dt(i,r)),!$t(s[3]+s[7]/255,0,1,0))return;const n=this._$getChildren(),a=n.length,h="_$graphics"in this?this._$graphics:null;if(!(a||h&&h._$canDraw))return;const o=this._$preDraw(t,e);if(!o)return;if(o.isLayer&&!o.isUpdated)return void this._$postDraw(t,e,s,o);const l=o.matrix,_=o.isLayer&&o.color?o.color:s;h&&h._$canDraw&&h._$draw(t,l,_);let c=!0,$=0;const u=Zi(),d=t.isLayer,g=this._$isUpdated();for(let e=0;e<a;++e){const i=n[e];if(g&&(i._$placeObject=null),i._$isMask)continue;const s=i._$blendMode||i.blendMode;if(("alpha"===s||"erase"===s)&&!d)continue;if($&&(i._$placeId>$||i._$clipDepth>0)&&(t.restore(),c&&t._$leaveClip(),$=0,c=!0),!c)continue;if(i._$clipDepth>0){$=i._$clipDepth,c=i._$shouldClip(l),c&&(t.save(),c=i._$startClip(t,l));continue}const r=i._$mask;if(r){let e;if(r._$updated=!1,this===r._$parent)e=l;else{e=P;let i=r._$parent;for(;i;)e=ut(i._$transform._$rawMatrix(),e),i=i._$parent;const s=u.scaleX,n=tt(s,0,0,s,0,0);if(e=ut(n,e),et(n),t.isLayer){const i=t.getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}}if(!r._$shouldClip(e))continue;const i=r._$startClip(t,e);if(t.save(),!i){t.restore();continue}}i._$draw(t,l,_),i._$updated=!1,r&&(t.restore(),t._$leaveClip())}if($&&(t.restore(),c&&t._$leaveClip()),o.isLayer)return this._$postDraw(t,e,s,o);o.matrix!==e&&et(o.matrix),s!==i&&st(s),yt(o)}_$mouseHit(t,e,i,s=!0){let r=e;const n=this._$transform._$rawMatrix();n!==P&&(r=ut(e,n));const a=this._$getChildren(),h=nt(),o=nt(),l=ot();let _=0,c=0;for(let t=0;t<a.length;++t){const e=a[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?(c=h.length,_=e._$clipDepth,h.push(e)):(_&&e._$placeId>_&&(c=0,_=0),c&&l.set(e._$instanceId,c),o.push(e)))}const $=this._$mouseChildren&&s;let u=!1;const d=this._$root===this;for(;o.length;){const e=o.pop();if(e._$isMask)continue;if(d&&!(e instanceof Jt))continue;if(l.has(e._$instanceId)){const s=l.get(e._$instanceId);if(!s)continue;if(!h[s]._$hit(t,r,i,!0))continue}const s=e._$mask;if(s)if(this===s._$parent){if(!s._$hit(t,r,i,!0))continue}else{let e=P,r=s._$parent;for(;r;)e=ut(r._$transform._$rawMatrix(),e),r=r._$parent;if(!s._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,r,i,$)||e._$hitArea&&e._$hitArea._$mouseHit(t,r,i,$)){if(e._$root===e)return!0;if(!$)return!0;if(u=!0,e instanceof Jt){if(!e.mouseEnabled&&!e._$hitObject)continue;return Wi||i.pointer||("_$text"in e&&"type"in e&&"input"===e.type&&(i.pointer="text"),"buttonMode"in e&&"useHandCursor"in e&&e.buttonMode&&e.useHandCursor&&(i.pointer="pointer")),i.hit||(i.hit=!e.mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}if(at(h),at(o),ht(l),!u){const e="_$graphics"in this?this._$graphics:null;e&&(u=e._$hit(t,r,i))}return r!==e&&et(r),u}_$hit(t,e,i,s=!1){let r=e;const n=this._$transform._$rawMatrix();n!==P&&(r=ut(e,n));const a=this._$getChildren();for(let e=a.length;e>-1;--e){const n=a[e];if(!n._$isMask&&n._$hit(t,r,i,s))return!0}let h=!1;const o="_$graphics"in this?this._$graphics:null;return o&&(h=o._$hit(t,r,i)),r!==e&&et(r),h}_$createInstance(t){if(!this._$dictionary)throw new Error("the dictionary is null.");const e=this._$dictionary[t],i=this._$loaderInfo;if(!i||!i._$data)throw new Error("the loaderInfo or data is null.");const s=i._$data.characters[e.characterId],r=$s(s.extends);return r._$build(e,this),r._$id=t,r}_$outCheck(t,e){let i=P,s=this._$parent;for(;s;)i=ut(s._$transform._$rawMatrix(),i),s=s._$parent;Ji.setTransform(1,0,0,1,0,0),Ji.beginPath();const r={x:t,y:e,pointer:"",hit:null};return this._$mouseHit(Ji,i,r)}_$createWorkerInstance(){if(this._$created||!us)return;this._$created=!0;const t=nt(),e={command:"createDisplayObjectContainer",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1},i="_$graphics"in this?this._$graphics:null;if(i){const s=i._$getRecodes();t.push(s.buffer),e.recodes=s,e.maxAlpha=i._$maxAlpha,e.canDraw=i._$canDraw,e.xMin=i._$xMin,e.yMin=i._$yMin,e.xMax=i._$xMax,e.yMax=i._$yMax}us.postMessage(e,t)}_$postProperty(){if(!us)return;this._$postChildrenIds();const t=nt(),e=this._$createMessage(),i="_$graphics"in this?this._$graphics:null;if(i&&!i._$buffer){e.maxAlpha=i._$maxAlpha,e.canDraw=i._$canDraw;const s=i._$getRecodes();e.recodes=s,t.push(s.buffer);const r=this._$getBounds();e.xMin=r.xMin,e.yMin=r.yMin,e.xMax=r.xMax,e.yMax=r.yMax}us.postMessage(e,t),at(t),this._$posted=!0,this._$updated=!1}_$postChildrenIds(t=null){if(us)if(t)us.postMessage({command:"setChildren",instanceId:this._$instanceId,children:t});else{const e=this._$getChildren();t=nt();for(let i=0;i<e.length;++i)t.push(e[i]._$instanceId);us.postMessage({command:"setChildren",instanceId:this._$instanceId,children:t}),at(t)}}}class te{constructor(t=0,i=0){this._$instanceId=e(),this._$width=0|t,this._$height=0|i,this._$buffer=null,this._$image=null,this._$canvas=null,this._$texture=null}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get instanceId(){return this._$instanceId}get height(){return this._$height}get buffer(){return this._$buffer}set buffer(t){if(this._$canvas=null,this._$image=null,this._$buffer=t,this._$texture){const t=Zi().context;t&&t.frameBuffer.releaseTexture(this._$texture),this._$texture=null}}get image(){return this._$image}set image(t){if(this._$canvas=null,this._$buffer=null,this._$image=t,this._$texture){const t=Zi().context;t&&t.frameBuffer.releaseTexture(this._$texture),this._$texture=null}t&&(this._$width=t.width,this._$height=t.height)}get canvas(){return this._$canvas}set canvas(t){if(this._$image=null,this._$buffer=null,this._$canvas=t,this._$texture){const t=Zi().context;t&&t.frameBuffer.releaseTexture(this._$texture),this._$texture=null}t&&(this._$width=t.width,this._$height=t.height)}get width(){return this._$width}clone(){const t=new te(this.width,this.height);if(null!==this._$image||null!==this._$canvas){const e=At.getCanvas();e.width=this.width,e.height=this.height;const i=e.getContext("2d");if(!i)throw new Error("the context is null.");this._$image&&i.drawImage(this._$image,0,0),this._$canvas&&i.drawImage(this._$canvas,0,0),t.canvas=e}else null!==this._$buffer&&(t._$buffer=this._$buffer.slice());return t}getTexture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=Zi().context;if(!i)throw new Error("the context is null.");return null!==this._$texture||(null!==this._$image&&(this._$texture=i.frameBuffer.createTextureFromImage(this._$image)),null!==this._$canvas&&(this._$texture=i.frameBuffer.createTextureFromCanvas(this._$canvas)),null!==this._$buffer&&(this._$texture=i.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0))),this._$texture}draw(t,e=null,i=null,s=null,r=null){const{width:n,height:a}=this;if(!n||!a)return;const h=Zi(),o=h._$width,l=h._$height;(n>o||a>l)&&(h._$width=n,h._$height=a,h._$resizeCanvas(n,a,h.scaleX));const _=i?i._$colorTransform:O;let c=e?e._$matrix:P;if(e){const e=t._$transform.matrix;e.invert(),c=ut(c,e._$matrix),is(e)}if(s||(s=At.getCanvas()),us){t._$stage||(t instanceof Zt?gs&&gs(t):(t._$createWorkerInstance(),t._$postProperty())),s.width=n,s.height=a;const e=s.getContext("2d");if(!e)throw new Error("the context is null.");e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,n,a);const i=t._$instanceId;Vi.set(i,{source:t,context:e,callback:r});const h=nt(),o={command:"bitmapDraw",sourceId:i,width:n,height:a};1===c[0]&&0===c[1]&&0===c[2]&&1===c[3]&&0===c[4]&&0===c[5]||(o.matrix=c.slice(),h.push(o.matrix.buffer)),1===_[0]&&1===_[1]&&1===_[2]&&1===_[3]&&0===_[4]&&0===_[5]&&0===_[6]&&0===_[7]||(o.colorTransform=_.slice(),h.push(o.colorTransform.buffer)),us.postMessage(o,h),at(h)}else{const e=h.context;if(!e)throw new Error("the context is null.");e.reset(),e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,h._$width,h._$height),e.beginPath(),t._$draw(e,c,_),e.drawInstacedArray(),e.frameBuffer.transferToMainTexture(),s.width=n,s.height=a;const i=s.getContext("2d");if(!i)return;i.setTransform(1,0,0,1,0,0),i.clearRect(0,0,n,a),i.drawImage(h.canvas,0,0),r&&r(s)}e&&is(e),i&&rs(i)}}class ee extends St{constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class ie{constructor(t,e=null,i=!0,s=!1){this._$bitmapData=t,this._$matrix=e,this._$repeat=i,this._$smooth=s}clone(){return new ie(this._$bitmapData.clone(),this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){return nt(this._$bitmapData,this._$matrix,this._$repeat,this._$smooth)}}class se{constructor(t,e,i,s,r=null,n="pad",a="rgb",h=0){this._$type=t,this._$colors=e,this._$alphas=i,this._$ratios=s,this._$matrix=r,this._$spreadMethod=n,this._$interpolationMethod=a,this._$focalPointRatio=h,this._$colorStops=nt()}get colorStops(){if(!this._$colorStops.length){const t=T.min(T.min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=this._$colors[e],i="string"==typeof t?ft(t):t,s=vt(i,this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:s.R,G:s.G,B:s.B,A:s.A}}}return this._$colorStops}toArray(){return nt(this._$type,this.colorStops,this._$matrix?this._$matrix._$matrix:P,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}clone(){return new se(this._$type,this._$colors.slice(),this._$alphas.slice(),this._$ratios.slice(),this._$matrix?this._$matrix.clone():null,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class re{constructor(t=null){this._$displayObject=t,this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=null,this._$caps="none",this._$joints="round",this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=y.MAX_VALUE,this._$xMax=-y.MAX_VALUE,this._$yMin=y.MAX_VALUE,this._$yMax=-y.MAX_VALUE,this._$buffer=null,this._$recode=null,this._$fills=null,this._$lines=null,this._$uniqueKey="",this._$cacheKeys=nt(),this._$cacheParams=nt(0,0,0),this._$bitmapId=0,this._$mode="shape"}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}static get BITMAP_STROKE(){return 14}beginBitmapFill(t,e=null,i=!0,s=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=nt()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$fills.push(re.BEGIN_PATH),this._$fillType=re.BITMAP_FILL,this._$fillBitmap=new ie(t,e,i,s),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=nt()),t=$t(mt(t),0,16777215,0),e=$t(e,0,1,1),this._$maxAlpha=T.max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$fills.push(re.BEGIN_PATH);const i=vt(t,e);return this._$fillType=re.FILL_STYLE,this._$fillStyleR=i.R,this._$fillStyleG=i.G,this._$fillStyleB=i.B,this._$fillStyleA=i.A,this}beginGradientFill(t,e,i,s,r=null,n="pad",a="rgb",h=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=nt());for(let t=0;t<i.length;++t)this._$maxAlpha=T.max(this._$maxAlpha,i[t]);return this._$doFill=!0,this._$canDraw=!0,this._$fills.push(re.BEGIN_PATH),this._$fillType=re.GRADIENT_FILL,this._$fillGradient=new se(t,e,i,s,r,n,a,h),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$bitmapId=0,this._$mode="shape",this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=null,this._$caps="none",this._$joints="round",this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=y.MAX_VALUE,this._$xMax=-y.MAX_VALUE,this._$yMin=y.MAX_VALUE,this._$yMax=-y.MAX_VALUE,this._$recode&&at(this._$recode),this._$fills&&at(this._$fills),this._$lines&&at(this._$lines),this._$buffer=null,this._$recode=null,this._$fills=null,this._$lines=null,this._$cacheKeys.length=0,this._$uniqueKey="",this._$cacheParams.fill(0),this._$restart(),this}clone(){const t=new re;return t.copyFrom(this),t}copyFrom(t){t._$fillGradient&&(this._$fillGradient=t._$fillGradient.clone()),t._$fillBitmap&&(this._$fillBitmap=t._$fillBitmap.clone()),this._$doFill=t._$doFill,this._$fillType=t._$fillType,this._$fillStyleR=t._$fillStyleR,this._$fillStyleG=t._$fillStyleG,this._$fillStyleB=t._$fillStyleB,this._$fillStyleA=t._$fillStyleA,t._$lineGradient&&(this._$lineGradient=t._$lineGradient.clone()),this._$doLine=t._$doLine,this._$lineType=t._$lineType,this._$caps=t._$caps,this._$joints=t._$joints,this._$miterLimit=t._$miterLimit,this._$lineWidth=t._$lineWidth,this._$lineStyleR=t._$lineStyleR,this._$lineStyleG=t._$lineStyleG,this._$lineStyleB=t._$lineStyleB,this._$lineStyleA=t._$lineStyleA,this._$xMin=t._$xMin,this._$xMax=t._$xMax,this._$yMin=t._$yMin,this._$yMax=t._$yMax,this._$maxAlpha=t._$maxAlpha,this._$pointerX=t._$pointerX,this._$pointerY=t._$pointerY,this._$canDraw=t._$canDraw,t._$fills&&(this._$fills=t._$fills.slice(0)),t._$lines&&(this._$lines=t._$lines.slice(0)),t._$recode&&(this._$recode=t._$recode.slice(0))}cubicCurveTo(t,e,i,s,r,n){return r=+r||0,n=+n||0,this._$pointerX===r&&this._$pointerY===n||(t=+t||0,e=+e||0,i=+i||0,s=+s||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$setBounds(r,n),this._$margePath(nt(re.CUBIC,t,e,i,s,r,n)),this._$pointerX=r,this._$pointerY=n,this._$restart()),this}curveTo(t,e,i,s){return i=+i||0,s=+s||0,this._$pointerX===i&&this._$pointerY===s||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$margePath(nt(re.CURVE_TO,t,e,i,s)),this._$pointerX=i,this._$pointerY=s,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(nt(re.MOVE_TO,t+i,e,re.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,i,s){const r=(i=+i||0)/2,n=(s=+s||0)/2,a=(t=+t||0)+r,h=(e=+e||0)+n,o=t+i,l=e+s,_=4/3*(T.SQRT2-1),c=_*r,$=_*n;return this.moveTo(a,e).cubicCurveTo(a+c,e,o,h-$,o,h).cubicCurveTo(o,h+$,a+c,l,a,l).cubicCurveTo(a-c,l,t,h+$,t,h).cubicCurveTo(t,h-$,a-c,e,a,e)}drawRect(t,e,i,s){t=+t||0,e=+e||0,i=+i||0,s=+s||0;const r=T.round(t+i),n=T.round(e+s);return this.moveTo(t,e).lineTo(t,n).lineTo(r,n).lineTo(r,e).lineTo(t,e)}drawRoundRect(t,e,i,s,r,n=NaN){t=+t||0,e=+e||0,i=+i||0,s=+s||0;const a=(r=+r||0)/2,h=(n=+n||r)/2,o=4/3*(T.SQRT2-1),l=o*a,_=o*h,c=t+a,$=t+i,u=$-a,d=e+h,g=e+s,f=g-h;return this.moveTo(c,e).lineTo(u,e).cubicCurveTo(u+l,e,$,d-_,$,d).lineTo($,f).cubicCurveTo($,f+_,u+l,g,u,g).lineTo(c,g).cubicCurveTo(c-l,g,t,f+_,t,f).lineTo(t,d).cubicCurveTo(t,d-_,c-l,e,c,e)}endFill(){if(this._$doFill&&this._$fills&&this._$fills.length>7)switch(this._$recode||(this._$recode=nt()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(re.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push(...this._$fills),this._$fillType){case re.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,re.END_FILL);break;case re.GRADIENT_FILL:this._$fillGradient&&this._$recode.push(this._$fillType,...this._$fillGradient.toArray());break;case re.BITMAP_FILL:this._$fillBitmap&&this._$recode.push(this._$fillType,...this._$fillBitmap.toArray())}return this._$fills&&(at(this._$fills),this._$fills=null),this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine&&this._$lines)switch(this._$recode||(this._$recode=nt()),this._$recode.push(...this._$lines),at(this._$lines),this._$lines=null,this._$lineType){case re.STROKE_STYLE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,re.END_STROKE);break;case re.GRADIENT_STROKE:this._$lineGradient&&this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,...this._$lineGradient.toArray());break;case re.BITMAP_STROKE:this._$fillBitmap&&this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,...this._$fillBitmap.toArray())}return this._$lineType=0,this._$lineWidth=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps="none",this._$joints="round",this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineBitmapStyle(t,e=null,i=!0,s=!1){return this._$doLine&&this.endLine(),this._$lines||(this._$lines=nt()),this._$maxAlpha=1,this._$doLine=!0,this._$canDraw=!0,this._$lines.push(re.BEGIN_PATH),this._$lineType=re.BITMAP_STROKE,this._$fillBitmap=new ie(t,e,i,s),this}lineGradientStyle(t,e,i,s,r=null,n="pad",a="rgb",h=0){if(!this._$doLine)return this;this._$lines||(this._$lines=nt());for(let t=0;t<i.length;++t)this._$maxAlpha=T.max(this._$maxAlpha,i[t]);return this._$lines.push(re.BEGIN_PATH),this._$lineType=re.GRADIENT_STROKE,this._$lineGradient=new se(t,e,i,s,r,n,a,h),this}lineStyle(t=1,e=0,i=1,s="round",r="round",n=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=nt()),e=$t(mt(e),0,16777215,0),i=$t(+i,0,1,1),this._$maxAlpha=T.max(this._$maxAlpha,i),this._$doLine=!0,this._$canDraw=!0,this._$pointerX||this._$pointerY?this._$lines.push(re.BEGIN_PATH,re.MOVE_TO,this._$pointerX,this._$pointerY):this._$lines.push(re.BEGIN_PATH);const a=vt(e,i);return this._$lineType=re.STROKE_STYLE,this._$lineStyleR=a.R,this._$lineStyleG=a.G,this._$lineStyleB=a.B,this._$lineStyleA=a.A,this._$lineWidth=t,this._$caps=`${s}`,this._$joints=`${r}`,"miter"===this._$joints&&(this._$miterLimit=n),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(nt(re.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e);let i=!1;return this._$doFill&&this._$fills&&this._$fills[this._$fills.length-3]===re.MOVE_TO&&(i=!0,this._$fills[this._$fills.length-2]=t,this._$fills[this._$fills.length-1]=e),this._$doLine&&this._$lines&&this._$lines[this._$lines.length-3]===re.MOVE_TO&&(i=!0,this._$lines[this._$lines.length-2]=t,this._$lines[this._$lines.length-1]=e),i||this._$margePath(nt(re.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,e){const i=this._$getBounds(),s=gt(i,e);Q(i);const r=T.ceil(T.abs(s.xMax-s.xMin)),n=T.ceil(T.abs(s.yMax-s.yMin));switch(Q(s),!0){case 0===r:case 0===n:case r===-1/0:case n===-1/0:case r===b:case n===b:return}t.reset(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$doDraw(t,null,!0),t.clip()}_$draw(t,e,i,s="normal",r=null){if(!this._$maxAlpha)return;const n=$t(i[3]+i[7]/255,0,1),a=this._$displayObject;let h=null!==a._$scale9Grid;const o=a._$transform._$rawMatrix();h&&(h=h&&T.abs(o[1])<.001&&T.abs(o[2])<1e-4);const l=this._$getBounds(),_=gt(l,e),c=_.xMax,$=_.xMin,u=_.yMax,d=_.yMin;Q(_);const g=T.ceil(T.abs(c-$)),f=T.ceil(T.abs(u-d));switch(!0){case 0===g:case 0===f:case g===-1/0:case f===-1/0:case g===b:case f===b:return}let m=+T.sqrt(e[0]*e[0]+e[1]*e[1]);if(!y.isInteger(m)){const t=m.toString(),e=t.indexOf("e");-1!==e&&(m=+t.slice(0,e)),m=+m.toFixed(4)}let p=+T.sqrt(e[2]*e[2]+e[3]*e[3]);if(!y.isInteger(p)){const t=p.toString(),e=t.indexOf("e");-1!==e&&(p=+t.slice(0,e)),p=+p.toFixed(4)}const x=null!==r&&r.length>0&&a._$canApply(r);let v=K(0,g,0,f);if(x&&r)for(let t=0;t<r.length;++t)v=r[t]._$generateFilterRect(v,m,p);const E=t.frameBuffer,A=E.currentAttachment;if(!A||$-v.xMin>A.width||d-v.yMin>A.height)return void Q(v);if(0>$+v.xMax||0>d+v.yMax)return void Q(v);Q(v),""===this._$uniqueKey&&(!h&&a._$loaderInfo&&a._$characterId?this._$uniqueKey=`${a._$loaderInfo._$id}@${this._$bitmapId||a._$characterId}`:this._$uniqueKey=this._$createCacheKey());const M=Zi();if("bitmap"===this._$mode)this._$cacheKeys.length||(this._$cacheKeys=At.generateKeys(this._$uniqueKey));else if(!this._$cacheKeys.length||this._$cacheParams[0]!==m||this._$cacheParams[1]!==p||this._$cacheParams[2]!==i[7]){const t=nt();t[0]=m,t[1]=p,this._$cacheKeys=At.generateKeys(this._$uniqueKey,t,i),at(t),this._$cacheParams[0]=m,this._$cacheParams[1]=p,this._$cacheParams[2]=i[7]}if(t.cachePosition=At.get(this._$cacheKeys),!t.cachePosition){const s=E.currentAttachment;s&&s.mask&&t.stopStencil();let r=0,n=0;if("shape"===this._$mode){r=T.ceil(T.abs(l.xMax-l.xMin)*m),n=T.ceil(T.abs(l.yMax-l.yMin)*p);const e=t._$getTextureScale(r,n);e<1&&(r*=e,n*=e)}else r=T.ceil(T.abs(l.xMax-l.xMin)),n=T.ceil(T.abs(l.yMax-l.yMin));if(t.cachePosition=E.createCachePosition(r,n),t.bindRenderBuffer(t.cachePosition),t.reset(),"shape"===this._$mode?t.setTransform(m,0,0,p,-l.xMin*m,-l.yMin*p):t.setTransform(1,0,0,1,-l.xMin,-l.yMin),h){const i=M.scaleX,s=tt(i,0,0,i,0,0),r=ut(s,o);et(s);const n=a._$parent._$transform.concatenatedMatrix._$matrix;et(n);const h=tt(n[0],n[1],n[2],n[3],n[4]*i-$,n[5]*i-d),_=ut(h,r),c=_[4]-(e[4]-$),u=_[5]-(e[5]-d);et(_);const g=gt(l,r),f=+g.xMax,m=+g.xMin,p=+g.yMax,x=+g.yMin,b=T.ceil(T.abs(f-m)),v=T.ceil(T.abs(p-x));Q(g),t.grid.enable(m,x,b,v,l,a._$scale9Grid,i,r[0],r[1],r[2],r[3],r[4],r[5],h[0],h[1],h[2],h[3],h[4]-c,h[5]-u),et(r),et(h)}this._$doDraw(t,i,!1),h&&t.grid.disable(),E.transferTexture(t.cachePosition),At.set(this._$cacheKeys,t.cachePosition),t._$bind(s)}let C=0,w=0;if(x){const i=this._$createBitmapTexture(t,t.cachePosition,m,p,g,f),s=a._$drawFilter(t,e,r,g,f,i);s.offsetX&&(C=s.offsetX),s.offsetY&&(w=s.offsetY),t.cachePosition=s}if(x||"bitmap"!==this._$mode){const i=T.atan2(e[1],e[0]),s=T.atan2(-e[2],e[3]);if(x||!i&&!s)t.setTransform(1,0,0,1,$-C,d-w);else{const r=l.xMin*m,n=l.yMin*p,a=T.cos(i),h=T.sin(i),o=T.cos(s),_=T.sin(s);t.setTransform(a,h,-_,o,r*a-n*_+e[4],r*h+n*o+e[5])}}else t.setTransform(e[0],e[1],e[2],e[3],l.xMin*e[0]+l.yMin*e[2]+e[4],l.xMin*e[1]+l.yMin*e[3]+e[5]);t.cachePosition&&(t.globalAlpha=n,t.imageSmoothingEnabled="shape"===this._$mode,t.globalCompositeOperation=s,t.drawInstance($-C,d-w,c,u,i),t.cachePosition=null),Q(l)}_$createBitmapTexture(t,e,i,s,r,n){if("bitmap"!==this._$mode)return null;t.drawInstacedArray();const a=t.frameBuffer,h=a.currentAttachment,o=a.createCacheAttachment(r,n);t._$bind(o),t.reset();const l=tt(i,0,0,s,r/2,n/2),_=t.getTextureFromRect(e),c=tt(1,0,0,1,-_.width/2,-_.height/2),$=ut(l,c);et(l),et(c),t.setTransform($[0],$[1],$[2],$[3],$[4],$[5]),t.drawImage(_,0,0,_.width,_.height);const u=a.getTextureFromCurrentAttachment();return t._$bind(h),a.releaseAttachment(o),a.textureManager.release(_),u}_$doDraw(t,e=null,i=!1){t.reset(),t.beginPath(),this._$runCommand(t,e,i)}_$hit(t,e,i,s=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,s,i)}_$getBounds(){const t=this._$displayObject;return t&&t._$bounds?K(t._$bounds.xMin,t._$bounds.xMax,t._$bounds.yMin,t._$bounds.yMax):K(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){this._$displayObject&&(this._$displayObject._$posted=!1,this._$displayObject._$isUpdated()||(this._$displayObject._$doChanged(),x(),At.removeCache(this._$displayObject._$instanceId),this._$displayObject._$characterId&&At.removeCache(this._$displayObject._$characterId)))}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t=0,e=0){this._$xMin=T.min(this._$xMin,t),this._$xMax=T.max(this._$xMax,t),this._$yMin=T.min(this._$yMin,e),this._$yMax=T.max(this._$yMax,e)}_$setLineBounds(t=0,e=0){this._$xMin=T.min(this._$xMin,T.min(t,this._$pointerX)),this._$xMax=T.max(this._$xMax,T.max(t,this._$pointerX)),this._$yMin=T.min(this._$yMin,T.min(e,this._$pointerY)),this._$yMax=T.max(this._$yMax,T.max(e,this._$pointerY));const i=this._$lineWidth/2,s=.5*T.PI,r=T.atan2(e-this._$pointerY,t-this._$pointerX),n=T.atan2(this._$pointerY-e,this._$pointerX-t),a=r+s,h=r-s,o=n+s,l=n-s;let _=t+i,c=-i+t,$=this._$pointerX+i,u=-i+this._$pointerX,d=e+i,g=-i+e,f=this._$pointerY+i,m=-i+this._$pointerY;switch(this._$xMin=T.min(this._$xMin,T.min(_,T.min(c,T.min($,u)))),this._$xMax=T.max(this._$xMax,T.max(_,T.max(c,T.max($,u)))),this._$yMin=T.min(this._$yMin,T.min(d,T.min(g,T.min(f,m)))),this._$yMax=T.max(this._$yMax,T.max(d,T.max(g,T.max(f,m)))),T.abs(a)%s!=0&&(_=t+T.cos(a)*i),T.abs(h)%s!=0&&(c=t+T.cos(h)*i),T.abs(o)%s!=0&&($=this._$pointerX+T.cos(o)*i),T.abs(l)%s!=0&&(u=this._$pointerX+T.cos(l)*i),a&&T.abs(a)%T.PI!=0&&(d=e+T.sin(a)*i),h&&T.abs(h)%T.PI!=0&&(g=e+T.sin(h)*i),o&&T.abs(o)%T.PI!=0&&(f=this._$pointerY+T.sin(o)*i),l&&T.abs(l)%T.PI!=0&&(m=this._$pointerY+T.sin(l)*i),this._$xMin=T.min(this._$xMin,T.min(_,T.min(c,T.min($,u)))),this._$xMax=T.max(this._$xMax,T.max(_,T.max(c,T.max($,u)))),this._$yMin=T.min(this._$yMin,T.min(d,T.min(g,T.min(f,m)))),this._$yMax=T.max(this._$yMax,T.max(d,T.max(g,T.max(f,m)))),this._$caps){case"round":if(T.abs(r)%s!=0){const e=t+T.cos(r)*i;this._$xMin=T.min(this._$xMin,e),this._$xMax=T.max(this._$xMax,e)}if(r&&T.abs(r)%T.PI!=0){const t=e+T.sin(r)*i;this._$yMin=T.min(this._$yMin,t),this._$yMax=T.max(this._$yMax,t)}if(T.abs(n)%s!=0){const t=this._$pointerX+T.cos(n)*i;this._$xMin=T.min(this._$xMin,t),this._$xMax=T.max(this._$xMax,t)}if(n&&T.abs(n)%T.PI!=0){const t=this._$pointerY+T.sin(n)*i;this._$yMin=T.min(this._$yMin,t),this._$yMax=T.max(this._$yMax,t)}break;case"square":if(T.abs(r)%s!=0){const t=T.cos(r)*i,e=_+t,s=c+t;this._$xMin=T.min(this._$xMin,T.min(e,s)),this._$xMax=T.max(this._$xMax,T.max(e,s))}if(T.abs(n)%s!=0){const t=T.cos(n)*i,e=$+t,s=u+t;this._$xMin=T.min(this._$xMin,T.min(e,s)),this._$xMax=T.max(this._$xMax,T.max(e,s))}if(r&&T.abs(r)%T.PI!=0){const t=T.sin(r)*i,e=d+t,s=g+t;this._$yMin=T.min(this._$yMin,T.min(e,s)),this._$yMax=T.max(this._$yMax,T.max(e,s))}if(n&&T.abs(n)%T.PI!=0){const t=T.sin(n)*i,e=f+t,s=m+t;this._$yMin=T.min(this._$yMin,T.min(e,s)),this._$yMax=T.max(this._$yMax,T.max(e,s))}}}_$margePath(t){this._$doFill&&this._$fills&&this._$fills.push(...t),this._$doLine&&this._$lines&&this._$lines.push(...t),at(t)}_$createCacheKey(){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return"";const t=this._$getRecodes();let e=0;for(let i=0;i<t.length;i++)e=(e<<5)-e+t[i],e|=0;return`${e}`}_$getRecodes(){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),this._$recode||(this._$recode=nt()),!this._$buffer){const t=nt(),e=this._$recode;for(let i=0;i<e.length;){const s=e[i++];switch(t.push(s),s){case re.BEGIN_PATH:case re.END_FILL:case re.END_STROKE:case re.CLOSE_PATH:break;case re.MOVE_TO:case re.LINE_TO:t.push(e[i++],e[i++]);break;case re.CURVE_TO:case re.FILL_STYLE:t.push(e[i++],e[i++],e[i++],e[i++]);break;case re.CUBIC:t.push(e[i++],e[i++],e[i++],e[i++],e[i++],e[i++]);break;case re.STROKE_STYLE:switch(t.push(e[i++]),e[i++]){case"none":t.push(0);break;case"round":t.push(1);break;case"square":t.push(2)}switch(e[i++]){case"bevel":t.push(0);break;case"miter":t.push(1);break;case"round":t.push(2)}t.push(e[i++],e[i++],e[i++],e[i++],e[i++]);break;case re.ARC:t.push(e[i++],e[i++],e[i++]);break;case re.GRADIENT_FILL:{const s=e[i++],r=e[i++],n=e[i++],a=e[i++],h=e[i++],o=e[i++];t.push("linear"===s?0:1),t.push(r.length);for(let e=0;e<r.length;++e){const i=r[e];t.push(i.ratio,i.R,i.G,i.B,i.A)}switch(t.push(n[0],n[1],n[2],n[3],n[4],n[5]),a){case"reflect":t.push(0);break;case"repeat":t.push(1);break;default:t.push(2)}t.push("linearRGB"===h?0:1),t.push(o)}break;case re.GRADIENT_STROKE:{switch(t.push(e[i++]),e[i++]){case"none":t.push(0);break;case"round":t.push(1);break;case"square":t.push(2)}switch(e[i++]){case"bevel":t.push(0);break;case"miter":t.push(1);break;case"round":t.push(2)}t.push(e[i++]);const s=e[i++],r=e[i++],n=e[i++],a=e[i++],h=e[i++],o=e[i++];t.push("linear"===s?0:1),t.push(r.length);for(let e=0;e<r.length;++e){const i=r[e];t.push(i.ratio,i.R,i.G,i.B,i.A)}switch(t.push(n[0],n[1],n[2],n[3],n[4],n[5]),a){case"reflect":t.push(0);break;case"repeat":t.push(1);break;default:t.push(2)}t.push("linearRGB"===h?0:1),t.push(o)}break;case re.BITMAP_FILL:{const s=e[i++];let r;if(null!==s.image||null!==s.canvas){const t=At.getCanvas(),e=s.width,i=s.height;t.width=e,t.height=i;const n=t.getContext("2d");if(!n)throw new Error("the context is null.");n.drawImage(s.image||s.canvas,0,0),r=new Uint8Array(n.getImageData(0,0,e,i).data),At.destroy(n)}else{if(null===s._$buffer)break;r=s._$buffer}t.push(s.width,s.height,this._$xMax-this._$xMin,this._$yMax-this._$yMin,r.length);for(let e=0;e<r.length;++e)t.push(r[e]);const n=e[i++];n?t.push(n[0],n[1],n[2],n[3],n[4],n[5]):t.push(1,0,0,1,0,0);const a=e[i++];t.push(a?1:0);const h=e[i++];t.push(h?1:0)}break;case re.BITMAP_STROKE:{switch(t.push(e[i++]),e[i++]){case"none":t.push(0);break;case"round":t.push(1);break;case"square":t.push(2)}switch(e[i++]){case"bevel":t.push(0);break;case"miter":t.push(1);break;case"round":t.push(2)}t.push(e[i++]);const s=e[i++];let r;if(null!==s.image||null!==s.canvas){const t=At.getCanvas(),e=s.width,i=s.height;t.width=e,t.height=i;const n=t.getContext("2d");if(!n)throw new Error("the context is null.");n.drawImage(s.image||s.canvas,0,0),r=new Uint8Array(n.getImageData(0,0,e,i).data),At.destroy(n)}else{if(null===s._$buffer)break;r=s._$buffer}t.push(s.width,s.height,this._$xMax-this._$xMin,this._$yMax-this._$yMin,r.length);for(let e=0;e<r.length;++e)t.push(r[e]);const n=e[i++];n?t.push(n[0],n[1],n[2],n[3],n[4],n[5]):t.push(1,0,0,1,0,0);const a=e[i++];t.push(a?1:0);const h=e[i++];t.push(h?1:0)}}}this._$buffer=new A(t)}return this._$buffer.slice()}_$runCommand(t,e=null,i=!1,s=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;const r=this._$recode,n=r.length;for(let a=0;a<n;)switch(r[a++]){case re.BEGIN_PATH:t.beginPath();break;case re.MOVE_TO:t.moveTo(r[a++],r[a++]);break;case re.LINE_TO:t.lineTo(r[a++],r[a++]);break;case re.CURVE_TO:t.quadraticCurveTo(r[a++],r[a++],r[a++],r[a++]);break;case re.FILL_STYLE:{if(i||s){a+=4;continue}const n=J();n[0]=r[a++]/255,n[1]=r[a++]/255,n[2]=r[a++]/255,n[3]=r[a++]/255,null!==e&&0!==e[7]&&(n[3]=T.max(0,T.min(n[3]*e[7],255))/255),t.fillStyle=n}break;case re.END_FILL:if(s&&"isPointInPath"in t&&t.isPointInPath(s.x,s.y))return!0;i||s||t.fill();break;case re.STROKE_STYLE:{if(i||s){a+=8;continue}t.lineWidth=r[a++],t.lineCap=r[a++],t.lineJoin=r[a++],t.miterLimit=r[a++];const n=J();n[0]=r[a++]/255,n[1]=r[a++]/255,n[2]=r[a++]/255,n[3]=r[a++]/255,null!==e&&0!==e[7]&&(n[3]=T.max(0,T.min(n[3]+e[7],255))/255),t.strokeStyle=n}break;case re.END_STROKE:if(s&&"isPointInStroke"in t&&t.isPointInStroke(s.x,s.y))return!0;i||s||t.stroke();break;case re.CLOSE_PATH:t.closePath();break;case re.CUBIC:t.bezierCurveTo(r[a++],r[a++],r[a++],r[a++],r[a++],r[a++]);break;case re.ARC:t.arc(r[a++],r[a++],r[a++],0,2*T.PI);break;case re.GRADIENT_FILL:{if(s&&"isPointInPath"in t&&t.isPointInPath(s.x,s.y))return!0;if(i||s||t instanceof CanvasRenderingContext2D){a+=6;continue}const n=r[a++],h=r[a++],o=r[a++],l=r[a++],_=r[a++],c=r[a++];let $;if("linear"===n){const e=_t(o);$=t.createLinearGradient(e[0],e[1],e[2],e[3],_,l)}else t.save(),t.transform(o[0],o[1],o[2],o[3],o[4],o[5]),$=t.createRadialGradient(0,0,0,0,0,819.2,_,l,c);for(let t=0;t<h.length;++t){const i=h[t];let s=i.A;e&&0!==e[7]&&(s=0|T.max(0,T.min(i.A+e[7],255))),$.addColorStop(i.ratio,J(i.R,i.G,i.B,s))}t.fillStyle=$,t.fill(),"radial"===n&&t.restore()}break;case re.GRADIENT_STROKE:{if(s&&"isPointInStroke"in t&&t.isPointInStroke(s.x,s.y))return!0;if(i||s||t instanceof CanvasRenderingContext2D){a+=12;continue}t.lineWidth=r[a++],t.lineCap=r[a++],t.lineJoin=r[a++],t.miterLimit=r[a++];const n=r[a++],h=r[a++],o=r[a++],l=r[a++],_=r[a++],c=r[a++];let $;if("linear"===n){const e=_t(o);$=t.createLinearGradient(e[0],e[1],e[2],e[3],_,l)}else t.save(),t.transform(o[0],o[1],o[2],o[3],o[4],o[5]),$=t.createRadialGradient(0,0,0,0,0,819.2,_,l,c);for(let t=0;t<h.length;++t){const i=h[t];let s=i.A;e&&0!==e[7]&&(s=0|T.max(0,T.min(i.A+e[7],255))),$.addColorStop(i.ratio,J(i.R,i.G,i.B,s))}t.strokeStyle=$,t.stroke(),"radial"===n&&t.restore()}break;case re.BITMAP_FILL:{if(s&&"isPointInPath"in t&&t.isPointInPath(s.x,s.y))return!0;if(i||s||t instanceof CanvasRenderingContext2D){a+=6;continue}t.save();const n=r[a++],h=r[a++],o=r[a++],l=r[a++];h&&t.transform(h[0],h[1],h[2],h[3],h[4],h[5]);const _=n.getTexture();if(!_||!e)break;t.imageSmoothingEnabled=l,this._$bitmapId||n.width===this._$xMax-this._$xMin&&n.height===this._$yMax-this._$yMin?t.drawBitmap(_):(t.fillStyle=t.createPattern(_,o,e),t.fill()),t.restore(),t.imageSmoothingEnabled=!1}break;case re.BITMAP_STROKE:{if(s&&"isPointInStroke"in t&&t.isPointInStroke(s.x,s.y))return!0;if(i||s||t instanceof CanvasRenderingContext2D){a+=9;continue}t.save(),t.lineWidth=r[a++],t.lineCap=r[a++],t.lineJoin=r[a++],t.miterLimit=r[a++];const n=r[a++],h=r[a++],o=r[a++],l=r[a++];h&&t.transform(h[0],h[1],h[2],h[3],h[4],h[5]);const _=n.getTexture();if(!_||!e)break;t.strokeStyle=t.createPattern(_,o,e),t.imageSmoothingEnabled=l,t.stroke(),t.restore(),t.imageSmoothingEnabled=!1}}return!1}}class ne extends St{constructor(){super(),this._$id=i++,this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format="json"}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}set bytesLoaded(t){this._$bytesLoaded=0|t}get bytesTotal(){return this._$bytesTotal}set bytesTotal(t){this._$bytesTotal=0|t}get content(){return this._$content}set content(t){this._$content=t}get url(){return this._$url}set url(t){this._$url=t}get format(){return this._$format}set format(t){this._$format=t}}class ae{static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static get volume(){return c()}static set volume(t){(t=>{_=t})($t(t,0,1,1));const e=c(),i=Zi(),s=i._$sources;for(let t=0;t<s.length;++t){const i=s[t];for(let t=0;t<i._$sources.length;++t){const s=i._$sources[t];s._$gainNode&&(s._$gainNode.gain.value=T.min(e,s._$volume))}}const r=i._$videos;for(let t=0;t<r.length;++t){const i=r[t];i._$video&&(i._$video.volume=T.min(e,i.volume))}}static stopAll(){const t=Zi(),e=t._$sources;for(let t=0;t<e.length;++t)e[t].stop();const i=t._$videos;for(let t=0;t<i.length;++t)i[t].pause();t._$sources.length=0,t._$videos.length=0}}class he extends St{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$arrayBuffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=nt(),this._$volume=1,this._$currentCount=0,this._$loopCount=0,this._$stopFlag=!0,this._$src=""}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loopCount(){return this._$loopCount}set loopCount(t){this._$loopCount=t}get src(){return this._$src}set src(t){this.load(new Mt(t))}get volume(){return this._$volume}set volume(t){this._$volume=T.min(ae.volume,$t(t,0,1,1));const e=this._$sources.length;if(e&&Ri)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode&&(e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume)}}clone(){const t=new he;return t.volume=this.volume,t._$loopCount=this._$loopCount,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){this._$src=t.url,_s({format:"arraybuffer",url:t.url,method:t.method,data:t.data,headers:t.headers,withCredentials:t.withCredentials,event:{loadstart:t=>{this._$loadStart(t)},progress:t=>{this._$progress(t)},loadend:t=>{this._$loadEnd(t)}}})}_$loadStart(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(wt.OPEN)&&this.dispatchEvent(new wt(wt.OPEN)),this.willTrigger(Lt.PROGRESS)&&this.dispatchEvent(new Lt(Lt.PROGRESS,!1,!1,t.loaded,t.total))}_$progress(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(Lt.PROGRESS)&&this.dispatchEvent(new Lt(Lt.PROGRESS,!1,!1,t.loaded,t.total))}_$loadEnd(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(Lt.PROGRESS)&&this.dispatchEvent(new Lt(Lt.PROGRESS,!1,!1,t.loaded,t.total));const e=t.target;if(!e)throw new Error("the Sound target is null.");199<e.status&&400>e.status?(this._$arrayBuffer=e.response,Ri?as(this).then((t=>{(t.hasEventListener(wt.INIT)||t.hasEventListener(wt.COMPLETE))&&Zi()._$loaders.push(t)})):Ni.push(this)):this.willTrigger(Bt.IO_ERROR)&&this.dispatchEvent(new Bt(Bt.IO_ERROR,!1,!1,e.statusText))}play(t=0){const e=this._$character?this._$character.audioBuffer:this._$audioBuffer;if(Ri&&e)this._$createBufferSource(t);else{const e=B.now(),i=()=>{if(null===(this._$character?this._$character.audioBuffer:this._$audioBuffer)||null===Ri)F(i);else{const i=(B.now()-e)/1e3;this._$createBufferSource(t,i)}};F(i)}}stop(){this._$stopFlag=!0;const t=this._$sources.length;if(t){const e=Zi();if(Ri)for(let e=0;e<t;++e){const t=this._$sources[e];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect()}e._$sources.splice(e._$sources.indexOf(this),1),this._$currentCount=0,this._$sources.length=0}}_$build(t,e){const i=e.loaderInfo;if(!i||!i._$data)throw new Error("the loaderInfo or data is null.");if(this._$character=i._$data.characters[t.characterId],!this._$character)throw new Error("character is null.");this._$character.audioBuffer||(Ri?as(this).then((t=>{(t.hasEventListener(wt.INIT)||t.hasEventListener(wt.COMPLETE))&&Zi()._$loaders.push(t)})):Ni.push(this)),this._$loopCount=0|t.loopCount,this._$volume=T.min(ae.volume,t.volume)}_$createBufferSource(t=0,e=0){if(!Ri)throw new Error("the Audio Context is null.");const i=Ri.createBufferSource();i.onended=t=>this._$endEventHandler(t),i.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,i._$gainNode=Ri.createGain(),i._$gainNode.connect(Ri.destination);const s=T.min(ae.volume,this._$volume);i._$gainNode.gain.value=s,i._$volume=s,i.connect(i._$gainNode),i.start(0|t,e);const r=Zi();-1===r._$sources.indexOf(this)&&r._$sources.push(this),this._$sources.push(i),this._$stopFlag=!1}_$endEventHandler(t){const e=t.target;if(this._$sources.splice(this._$sources.indexOf(e),1),!this._$stopFlag&&this._$loopCount>this._$currentCount)this._$createBufferSource(),this._$currentCount++;else{if(this._$currentCount=0,Ri&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),!this._$sources.length){const t=Zi();t._$sources.splice(t._$sources.indexOf(this),1)}this.willTrigger(wt.SOUND_COMPLETE)&&this.dispatchEvent(new wt(wt.SOUND_COMPLETE))}}}class oe{constructor(t=1,e=!1){this._$volume=1,this._$loop=!1,this.volume=t,this.loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=$t(+t,0,1,0)}}class le extends Qt{constructor(t=0,e=0){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=K(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$video=null,this._$stop=!0,this._$ready=!1,this._$volume=1,this._$context=null,this._$cacheKeys=nt(),this._$cacheParams=nt(0,0,0)}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=!!t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=!!t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=!!t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video||(this._$video=this._$initializeVideo()),this._$video.src=t,this._$video.load()}get videoHeight(){return this._$video?this._$video.videoHeight:this._$bounds.yMax}get videoWidth(){return this._$video?this._$video.videoWidth:this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=$t(T.min(ae.volume,t),0,1,1),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$video&&this._$video.pause(),this._$video=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause(),R(this._$timerId),this._$timerId=-1,this.hasEventListener(Pt.PAUSE)&&this.dispatchEvent(new Pt(Pt.PAUSE,!1,!1,this._$bytesLoaded,this._$bytesTotal));const t=Zi();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){this._$video&&this._$stop&&(this._$stop=!1,this._$video.volume=T.min(this._$volume,ae.volume),this._$video.play().then((()=>{this._$timerId=F((()=>{this._$update()})),this.hasEventListener(Pt.PLAY)&&this.dispatchEvent(new Pt(Pt.PLAY,!1,!1,this._$bytesLoaded,this._$bytesTotal));const t=Zi();-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$ready=!0})))}seek(t){this._$video&&(this._$video.currentTime=t,this.hasEventListener(Pt.SEEK)&&this.dispatchEvent(new Pt(Pt.SEEK,!1,!1,this._$bytesLoaded,this._$bytesTotal)))}_$update(){const t=Zi();if(!this.stage||!this._$video)return this._$video&&this._$video.pause(),R(this._$timerId),this._$timerId=-1,void t._$videos.splice(t._$videos.indexOf(this),1);us&&this._$postProperty(),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this.hasEventListener(Pt.PROGRESS)&&this.dispatchEvent(new Pt(Pt.PROGRESS,!1,!1,this._$bytesLoaded,this._$bytesTotal)),this._$doChanged()),this._$timerId=F((()=>{this._$update()}))}_$start(){if(!this._$video)return;this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration;const t=Zi();this._$autoPlay&&(this._$stop=!1,this._$video.play().then((()=>{-1===t._$videos.indexOf(this)&&t._$videos.push(this),this.hasEventListener(Pt.PLAY_START)&&this.dispatchEvent(new Pt(Pt.PLAY_START,!1,!1,this._$bytesLoaded,this._$bytesTotal)),this._$timerId=F((()=>{this._$update()})),this._$ready=!0,this._$doChanged()}))),this._$createContext()}_$initializeVideo(){this._$cacheKeys.length=0;const t=u.createElement("video");return t.autoplay=!1,t.crossOrigin="anonymous",Ri||(t.muted=!0),Wi&&t.setAttribute("playsinline",""),t.addEventListener("canplaythrough",(()=>{this._$start()})),t.addEventListener("ended",(()=>{this._$loop?t.currentTime=0:(this.hasEventListener(Pt.PLAY_END)&&this.dispatchEvent(new Pt(Pt.PLAY_END,!1,!1,this._$bytesLoaded,this._$bytesTotal)),R(this._$timerId),this._$timerId=-1)})),t}_$createContext(){if(us){const t=new w(this._$bounds.xMax,this._$bounds.yMax);this._$context=t.getContext("2d")}}_$buildCharacter(t){t.buffer&&!t._$buffer&&(t._$buffer=new Uint8Array(t.buffer),t.buffer=null),this._$loop=t.loop,this._$autoPlay=t.autoPlay,this._$bounds.xMin=t.bounds.xMin,this._$bounds.yMin=t.bounds.yMin,this._$bounds.xMax=t.bounds.xMax,this._$bounds.yMax=t.bounds.yMax,this._$video||(this._$video=this._$initializeVideo()),this._$video.src=URL.createObjectURL(new Blob([t._$buffer],{type:"video/mp4"})),this._$video.volume=T.min(t.volume,ae.volume),this._$video.load(),us&&this._$stage&&this._$createWorkerInstance()}_$sync(t){this._$buildCharacter(t)}_$build(t,e){const i=this._$baseBuild(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const i=this._$bounds.xMax,s=this._$bounds.yMax;if(!i||!s)return;let r=e;const n=this._$transform._$rawMatrix();1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(r=ut(e,n)),t.reset(),t.setTransform(r[0],r[1],r[2],r[3],r[4],r[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(),r!==e&&et(r)}_$draw(t,e,i){if(!this._$visible||!this._$video||!this._$ready)return;let s=i;const r=this._$transform._$rawColorTransform();1===r[0]&&1===r[1]&&1===r[2]&&1===r[3]&&0===r[4]&&0===r[5]&&0===r[6]&&0===r[7]||(s=dt(i,r));const n=$t(s[3]+s[7]/255,0,1,0);if(!n)return void(s!==i&&st(s));let a=e;const h=this._$transform._$rawMatrix();1===h[0]&&0===h[1]&&0===h[2]&&1===h[3]&&0===h[4]&&0===h[5]||(a=ut(e,h));const o=gt(this._$bounds,a),l=+o.xMax,_=+o.xMin,c=+o.yMax,$=+o.yMin;Q(o);const u=T.ceil(T.abs(l-_)),d=T.ceil(T.abs(c-$));switch(!0){case 0===u:case 0===d:case u===-1/0:case d===-1/0:case u===b:case d===b:return}let g=+T.sqrt(a[0]*a[0]+a[1]*a[1]);if(!y.isInteger(g)){const t=g.toString(),e=t.indexOf("e");-1!==e&&(g=+t.slice(0,e)),g=+g.toFixed(4)}let f=+T.sqrt(a[2]*a[2]+a[3]*a[3]);if(!y.isInteger(f)){const t=f.toString(),e=t.indexOf("e");-1!==e&&(f=+t.slice(0,e)),f=+f.toFixed(4)}const m=this._$filters||this.filters,p=m&&m.length>0&&this._$canApply(m);let x=K(0,u,0,d);if(p)for(let t=0;t<m.length;++t)x=m[t]._$generateFilterRect(x,g,f);const v=t.frameBuffer,E=v.currentAttachment;if(!E||_-x.xMin>E.width||$-x.yMin>E.height)return void Q(x);if(0>_+x.xMax||0>$+x.yMax)return void Q(x);if(Q(x),!this._$cacheKeys.length||this._$cacheParams[0]!==g||this._$cacheParams[1]!==f||this._$cacheParams[2]!==i[7]){const t=nt();t[0]=g,t[1]=f,this._$cacheKeys=At.generateKeys(this._$instanceId,t,i),at(t),this._$cacheParams[0]=g,this._$cacheParams[1]=f,this._$cacheParams[2]=i[7]}const A=this._$blendMode||this.blendMode;if(t.cachePosition=At.get(this._$cacheKeys),!t.cachePosition){const e=T.ceil(T.abs(this._$bounds.xMax-this._$bounds.xMin)),i=T.ceil(T.abs(this._$bounds.yMax-this._$bounds.yMin)),s=v.createCachePosition(e,i);t.cachePosition=s,At.set(this._$cacheKeys,s)}const M=v.createTextureFromVideo(this._$video,this._$smoothing);let C=0,w=0;if(p){const e=v.currentAttachment,i=v.createCacheAttachment(u,d);t._$bind(i),t.reset();const s=tt(g,0,0,f,u/2,d/2),r=tt(1,0,0,1,-M.width/2,-M.height/2),n=ut(s,r);et(s),et(r),t.setTransform(n[0],n[1],n[2],n[3],n[4],n[5]),t.drawImage(M,0,0,M.width,M.height);const h=v.getTextureFromCurrentAttachment();t._$bind(e),v.releaseAttachment(i),t.drawTextureFromRect(M,t.cachePosition);const o=this._$drawFilter(t,a,m,u,d,h);o.offsetX&&(C=o.offsetX),o.offsetY&&(w=o.offsetY),t.cachePosition=o,t.setTransform(1,0,0,1,_-C,$-w)}else t.drawTextureFromRect(M,t.cachePosition),t.setTransform(a[0],a[1],a[2],a[3],a[4],a[5]);t.cachePosition&&(t.globalAlpha=n,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=A,t.drawInstance(_-C,$-w,l,c,i),t.cachePosition=null),a!==e&&et(a),s!==i&&st(s)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let s=e;const r=this._$transform._$rawMatrix();r!==P&&(s=ut(e,r));const n=this._$getBounds(null),a=gt(n,s),h=+a.xMax,o=+a.xMin,l=+a.yMax,_=+a.yMin;Q(a),Q(n);const c=T.ceil(T.abs(h-o)),$=T.ceil(T.abs(l-_));return t.setTransform(1,0,0,1,o,_),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,$),t.lineTo(0,$),t.lineTo(0,0),s!==e&&et(s),t.isPointInPath(i.x,i.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=ut(t,i));const s=gt(this._$bounds,e);return e!==t&&et(e),s}return K(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}_$createWorkerInstance(){if(!us||this._$created)return;this._$created=!0;const t={command:"createVideo",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,smoothing:this._$smoothing,xMin:this._$bounds.xMin,yMin:this._$bounds.yMin,xMax:this._$bounds.xMax,yMax:this._$bounds.yMax};this._$characterId>-1&&(t.characterId=this._$characterId),this._$loaderInfo&&(t.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(t.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),us.postMessage(t)}_$postProperty(){if(!us)return;const t=this._$createMessage();t.smoothing=this._$smoothing;const e=nt(),i=this._$context;if(i&&this._$video){t.xMin=this._$bounds.xMin,t.yMin=this._$bounds.yMin,t.xMax=this._$bounds.xMax,t.yMax=this._$bounds.yMax,i.drawImage(this._$video,0,0);const s=i.canvas.transferToImageBitmap();t.imageBitmap=s,e.push(s)}us.postMessage(t,e),at(e),this._$posted=!0,this._$updated=!1}}class _e extends Zt{constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=!!t}get dropTarget(){return Ii}get graphics(){return this._$graphics||(this._$graphics=new re(this)),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=t,t&&(t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new oe),this._$soundTransform}set soundTransform(t){this._$soundTransform=t}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=t}startDrag(t=!1,e=null){let i=0,s=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,s=this.y-t.y}Li(this),Pi.lock=t,Pi.position.x=i,Pi.position.y=s,Pi.bounds=e}stopDrag(){Li(null),Pi.lock=!1,Pi.position.x=0,Pi.position.y=0,Pi.bounds=null}_$sync(t){us&&this._$stage&&this._$createWorkerInstance(),this._$controller=t.controller,this._$dictionary=t.dictionary,this._$placeMap=t.placeMap,this._$placeObjects=t.placeObjects}_$build(t,e){const i=this._$baseBuild(t,e);return us&&this._$stage&&this._$createWorkerInstance(),this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(ts()):this.globalToLocal(ts())}}class ce extends _e{constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=ot(),this._$frameCache=ot(),this._$labels=null,this._$sounds=ot(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1,this._$loopConfig=null,this._$tweenFrame=0}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)&&this._$labels.get(t)||null}get currentLabels(){return this._$labels&&this._$labels.size?v.from(this._$labels.values()):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}get loopConfig(){if(this._$loopConfig)return this._$loopConfig;const t=this._$placeObject||this._$getPlaceObject();return t&&t.loop?(this._$tweenFrame&&(this._$changePlace=this._$tweenFrame!==this._$parent._$currentFrame,this._$tweenFrame=0),t.loop.tweenFrame&&(this._$tweenFrame=t.loop.tweenFrame),t.loop):null}set loopConfig(t){this._$loopConfig=t,t&&(t.frame=this._$startFrame,this._$loopConfig=t,this._$currentFrame=this._$getLoopFrame(t))}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=ot()),this._$labels.set(t.frame,t)}addFrameScript(...t){for(let e=0;e<t.length;e+=2){const i=t[e];let s=+i;S(s)&&(s=this._$getFrameForLabel(`${i}`));const r=t[e+1];if(r&&s&&this._$totalFrames>=s&&this._$addAction(s,r),s===this._$currentFrame){const t=Zi();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push(...t._$actions,...e),t._$actionOffset=0}}}}_$getFrameForLabel(t){if(!this._$labels)return 0;for(const[e,i]of this._$labels)if(i.name===t)return e;return 0}_$addAction(t,e){if(t){this._$actions.has(t)||this._$actions.set(t,nt());const i=this._$actions.get(t);i&&i.push(e)}}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e&&e.willTrigger(wt.FRAME_LABEL)&&e.dispatchEvent(new wt(wt.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=Zi();-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}_$goToFrame(t){let e=+t;if(S(e)&&(e=this._$getFrameForLabel(`${t}`)),e<1&&(e=1),e>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const i=Zi();switch(!0){case e!==this._$currentFrame:{this._$wait=!1;const t=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",e),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=e,this._$clearChildren(),i._$actionOffset=i._$actions.length;const s=i._$actionOffset?i._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),i._$actionOffset&&i._$actionOffset!==i._$actions.length){const t=i._$actions.splice(0,i._$actionOffset);i._$actions.push(...i._$actions,...t),i._$actionOffset=0}if(!this._$actionProcess&&(s>-1||!i._$actionOffset))for(;i._$actions.length&&i._$actions.length!==s;){const t=i._$actions.pop();if(!t)continue;t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const e=t._$currentFrame;if(!t._$actions.has(e))continue;const s=t._$actions.get(e);if(s)for(let e=0;e<s.length;++e)try{r(t._$loaderInfo),s[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=t,this._$clearChildren())}break;case!this._$actionProcess&&i._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=i._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();if(!e)continue;e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const s=e._$actions.get(i);if(s)for(let t=0;t<s.length;++t)try{r(e._$loaderInfo),s[t].apply(e)}catch(t){e.stop()}}}}r(null),this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!i._$sounds.has(this._$instanceId)&&i._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:{t=!0,this._$canAction=!0,this._$canSound=!0;const e=this.loopConfig;if(e){const i=e.end?e.end:this._$totalFrames;switch(e.type){case 0:this._$changePlace?this._$currentFrame=e.start:(++this._$currentFrame,this._$currentFrame>i&&(this._$currentFrame=e.start));break;case 1:this._$changePlace?this._$currentFrame=e.start:(++this._$currentFrame,this._$currentFrame>i&&(this._$currentFrame=i,t=!1,this._$canAction=!1,this._$canSound=!1));break;case 2:this._$changePlace?this._$currentFrame=e.start:(t=!1,this._$canAction=!1,this._$canSound=!1);break;case 3:this._$changePlace?this._$currentFrame=i:(--this._$currentFrame,e.start>this._$currentFrame&&(this._$currentFrame=e.start,t=!1,this._$canAction=!1,this._$canSound=!1));break;case 4:this._$changePlace?this._$currentFrame=i:(--this._$currentFrame,e.start>this._$currentFrame&&(this._$currentFrame=i))}}else++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1);if(t&&this._$clearChildren(),this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)){const t=Zi();t._$sounds.has(this._$instanceId)||t._$sounds.set(this._$instanceId,this)}}}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$setAction(),this._$isNext=t,!this._$posted&&us&&this._$postProperty(),this._$isNext}_$getLoopFrame(t){const e=this._$parent._$currentFrame-t.frame;let i=1;switch(t.type){case 0:{const s=t.end?t.end:this._$totalFrames;i=t.start;for(let r=0;r<e;++r)++i,i>s&&(i=t.start)}break;case 1:{const s=t.end?t.end:this._$totalFrames;i=T.min(s,t.start+e)}break;case 2:i=t.start;break;case 3:i=t.end?t.end:this._$totalFrames,i=T.max(t.start,i-e);break;case 4:{const s=t.end?t.end:this._$totalFrames;i=s;for(let r=0;r<e;++r)--i,t.start>i&&(i=s)}}return i}_$buildCharacter(t){if(t.sounds)for(let e=0;e<t.sounds.length;++e){const i=t.sounds[e],s=nt();for(let t=0;t<i.sound.length;++t){const e=new he;e._$build(i.sound[t],this),s.push(e)}this._$sounds.set(i.frame,s)}if(t.actions)for(let e=0;e<t.actions.length;++e){const i=t.actions[e];i.script||(i.script=Function(i.action)),this._$addAction(i.frame,i.script)}if(t.labels)for(let e=0;e<t.labels.length;++e){const i=t.labels[e];this.addFrameLabel(new ee(i.name,i.frame))}this._$totalFrames=t.totalFrame||1}_$sync(t){super._$sync(t),this._$buildCharacter(t)}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$soundPlay(){if(!this._$sounds.has(this._$currentFrame))return;const t=this._$sounds.get(this._$currentFrame);if(t.length){let e=this._$soundTransform,i=this._$parent;for(;i;)i._$soundTransform&&(e=i._$soundTransform),i=i._$parent;for(let i=0;i<t.length;++i){const s=t[i];e&&(s.loopCount=e.loop?16777215:0,s.volume=e.volume),s.play()}}this._$canSound=!1}}class $e extends Zt{constructor(){super(),this._$loaderInfo=new ne}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo?this._$loaderInfo.content:null}get contentLoaderInfo(){return this._$loaderInfo}load(t){const e=this._$loaderInfo;e&&(e.url=t.url,e.format=t.responseDataFormat,_s({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,withCredentials:t.withCredentials,event:{loadstart:t=>{this._$loadstart(t)},progress:t=>{this._$progress(t)},loadend:t=>{this._$loadend(t)}}}))}_$loadend(t){const e=this._$loaderInfo;if(!e)return;e.bytesLoaded=t.loaded,e.bytesTotal=t.total,e.willTrigger(Lt.PROGRESS)&&e.dispatchEvent(new Lt(Lt.PROGRESS,!1,!1,t.loaded,t.total));const i=t.target;if(e.willTrigger(Rt.HTTP_STATUS)){const t=cs(i.getAllResponseHeaders());e.dispatchEvent(new Rt(Rt.HTTP_STATUS,!1,!1,i.status,i.responseURL,t))}if(199<i.status&&400>i.status)if("json"===e.format){const t=i.response;if("zlib"===t.type){if(vs())return void ms.push(t);Ts(!0);const e=xs(),i=new Uint8Array(t.buffer);e.onmessage=t=>{this._$unzipHandler(t)},e.postMessage(i,[i.buffer])}else this._$build(t)}else e.willTrigger(Bt.IO_ERROR)&&e.dispatchEvent(new Bt(Bt.IO_ERROR,!1,!1,"LoaderInfo format is `json`"));else e.willTrigger(Bt.IO_ERROR)&&e.dispatchEvent(new Bt(Bt.IO_ERROR,!1,!1,i.statusText))}_$unzipHandler(t){if(this._$build(t.data),ms.length){const t=ms.pop();if(!t)return;const e=new Uint8Array(t.buffer),i=xs();i.onmessage=t=>{this._$unzipHandler(t)},i.postMessage(e,[e.buffer])}else Ts(!1)}_$loadstart(t){const e=this._$loaderInfo;e&&(e.bytesLoaded=t.loaded,e.bytesTotal=t.total,e.willTrigger(wt.OPEN)&&e.dispatchEvent(new wt(wt.OPEN)),e.willTrigger(Lt.PROGRESS)&&e.dispatchEvent(new Lt(Lt.PROGRESS,!1,!1,t.loaded,t.total)))}_$progress(t){const e=this._$loaderInfo;e&&(e.bytesLoaded=t.loaded,e.bytesTotal=t.total,e.willTrigger(Lt.PROGRESS)&&e.dispatchEvent(new Lt(Lt.PROGRESS,!1,!1,t.loaded,t.total)))}_$build(t){const e=this._$loaderInfo;if(!e)return;const i=ot();if(t.symbols.length)for(let e=0;e<t.symbols.length;++e){const s=t.symbols[e];i.set(s[0],s[1])}e._$data={stage:t.stage,characters:t.characters,symbols:i},e._$content=new ce;const s=t.characters[0];e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:s.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const r=Zi();r._$loaders.push(e),1===r._$loadStatus&&(r._$loadStatus=2)}}class ue extends Qt{constructor(){super(),this._$graphics=null,this._$src=""}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new re(this)),this._$graphics}get src(){return this._$src}set src(t){if(!t)return;const e=new Image;e.addEventListener("load",(()=>{const t=e.width,i=e.height,s=new te(t,i);s.image=e,this.graphics.beginBitmapFill(s).drawRect(0,0,t,i),this.hasEventListener(wt.LOAD)&&this.dispatchEvent(new wt(wt.LOAD))})),this._$src=e.src=t,this.graphics._$mode="bitmap"}_$buildCharacter(t,e){const i=this.graphics;if(!e._$data)throw new Error("the loaderInfo data is null.");if(t.recodes)switch(!0){case t.bitmapId>0:{const s=e._$data.characters[t.bitmapId];if(!s.buffer)throw new Error("the bitmap buffer is null.");const r=T.abs(s.bounds.xMax-s.bounds.xMin),n=T.abs(s.bounds.yMax-s.bounds.yMin),a=new te(r,n);s._$buffer||(s._$buffer=new Uint8Array(s.buffer),at(s.buffer),s.buffer=null),a.buffer=s._$buffer.slice(),i._$recode=nt(),r===t.bounds.xMax-t.bounds.xMin&&n===t.bounds.yMax-t.bounds.yMin&&(i._$bitmapId=t.bitmapId,i._$mode="bitmap");const h=t.recodes;if(h[h.length-1]===re.END_FILL){const t=h.length-6;for(let e=0;e<t;++e)i._$recode.push(h[e]);i._$recode.push(re.BITMAP_FILL,a,null,"repeat",!1)}else{const e=h[h.length-9],s=h[h.length-8],r=h[h.length-7],n=h[h.length-6],o=h.length-10;for(let t=0;t<o;++t)i._$recode.push(h[t]);i._$recode.push(re.BITMAP_STROKE,e,s,r,n,a,tt(1,0,0,1,t.bounds.xMin,t.bounds.yMin),"repeat",!1)}}break;case t.inBitmap:{i._$recode=nt();const e=t.recodes;for(let s=0;s<e.length;++s){const r=e[s];if(i._$recode[s]=r,"object"!=typeof r)continue;if(!r.buffer)continue;const n=new te(r.width,r.height);n.buffer=new Uint8Array(r.buffer),i._$recode[s++]=n;const a=e[s];i._$recode[s]=tt(a[0],a[1],a[2],a[3],a[4],a[5]),r.width===t.bounds.xMax-t.bounds.xMin&&r.height===t.bounds.yMax-t.bounds.yMin&&(i._$bitmapId=t.bitmapId,i._$mode="bitmap")}}break;default:i._$recode=t.recodes.slice(0)}else{i._$mode="bitmap";const e=T.abs(t.bounds.xMax-t.bounds.xMin),s=T.abs(t.bounds.yMax-t.bounds.yMin),r=new te(e,s);if(!t._$buffer){if(!t.buffer)throw new Error("the bitmap buffer is null.");t._$buffer=new Uint8Array(t.buffer),at(t.buffer),t.buffer=null}r.buffer=t._$buffer.slice(0),i.beginBitmapFill(r,null,!1).drawRect(0,0,e,s)}i._$maxAlpha=1,i._$canDraw=!0,i._$xMin=t.bounds.xMin,i._$xMax=t.bounds.xMax,i._$yMin=t.bounds.yMin,i._$yMax=t.bounds.yMax,t.grid&&(this._$scale9Grid=new Dt(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),us&&this._$stage&&this._$createWorkerInstance()}_$createWorkerInstance(){if(this._$created||!us)return;this._$created=!0;const t=nt(),e=this._$getBounds(),i={command:"createShape",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,maxAlpha:0,canDraw:!1,xMin:e.xMin,yMin:e.yMin,xMax:e.xMax,yMax:e.yMax},s=this._$graphics;if(s){const e=s._$getRecodes();e.length&&s._$maxAlpha>0&&s._$canDraw&&(i.maxAlpha=s._$maxAlpha,i.canDraw=s._$canDraw,i.recodes=e,t.push(e.buffer))}this._$characterId>-1&&(i.characterId=this._$characterId),this._$loaderInfo&&(i.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(i.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),us.postMessage(i,t)}_$sync(t){this._$loaderInfo&&this._$buildCharacter(t,this._$loaderInfo)}_$build(t,e){const i=this._$baseBuild(t,e);return this._$buildCharacter(i,e._$loaderInfo),i}_$getBounds(t=null){if(!this._$graphics)return K(0,0,0,0);const e=this._$graphics._$getBounds();if(!t)return e;let i=t;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=ut(t,s));const r=gt(e,i);return Q(e),i!==t&&et(i),r}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let s=i;const r=this._$transform._$rawColorTransform();if((r!==O&&1!==r[0]||1!==r[1]||1!==r[2]||1!==r[3]||0!==r[4]||0!==r[5]||0!==r[6]||0!==r[7])&&(s=dt(i,r)),!$t(s[3]+s[7]/255,0,1,0))return void(s!==i&&st(s));const n=this._$filters||this.filters,a=this._$blendMode||this.blendMode;let h=e;const o=this._$transform._$rawMatrix();(o!==ki&&1!==o[0]||0!==o[1]||0!==o[2]||1!==o[3]||0!==o[4]||0!==o[5])&&(h=ut(e,o)),this._$graphics._$draw(t,h,s,a,n),h!==e&&et(h),s!==i&&st(s)}_$clip(t,e){if(!this._$graphics)return;let i=e;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=ut(e,s)),this._$graphics._$clip(t,i),i!==e&&et(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,s=!1){let r=!1;const n=this._$graphics;if(n&&n._$canDraw&&n._$getBounds()){let a=e;const h=this._$transform._$rawMatrix();1===h[0]&&0===h[1]&&0===h[2]&&1===h[3]&&0===h[4]&&0===h[5]||(a=ut(e,h)),r=n._$hit(t,a,i,s),a!==e&&et(a)}return r}_$postProperty(){if(!us)return;const t=this._$createMessage(),e=this._$graphics;if(e&&!e._$buffer){t.maxAlpha=e._$maxAlpha,t.canDraw=e._$canDraw;const i=e._$getRecodes();t.recodes=i;const s=nt(i.buffer),r=this._$getBounds();t.xMin=r.xMin,t.yMin=r.yMin,t.xMax=r.xMax,t.yMax=r.yMax,us.postMessage(t,s),at(s)}else us.postMessage(t);this._$posted=!0,this._$updated=!1}}class de extends Zt{constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=$t(mt(t),0,16777215,16777215);const e=this._$player;if(e&&e.context){const t=pt(this._$color);e.context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=$t(+t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get player(){return this._$player}get canvasHeight(){return this._$player?this._$player._$height/f:0}get canvasWidth(){return this._$player?this._$player._$width/f:0}get currentStageHeight(){return this._$player?this._$player.height*this._$player._$scale:0}get currentStageWidth(){return this._$player?this._$player.width*this._$player._$scale:0}get stageHeight(){return this._$player?this._$player.height:0}get stageWidth(){return this._$player?this._$player.width:0}invalidate(){this._$invalidate=!0}_$addChild(t){return t._$stage=this,t._$root=t,super._$addChild(t)}}class ge{constructor(){this._$rgb="rgb",this._$mode="pad",this._$type="linear",this._$focalPointRatio=0,this._$points=tt(),this._$stops=nt()}dispose(){const t=this._$stops;for(let e=0;e<t.length;++e)Z(t[e][1]);et(this._$points)}get mode(){return this._$mode}get type(){return this._$type}get rgb(){return this._$rgb}get points(){return this._$points}get focalPointRatio(){return this._$focalPointRatio}get stops(){return this._$stops.sort(((t,e)=>{switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}})),this._$stops}linear(t,e,i,s,r="rgb",n="pad"){return this._$type="linear",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,r,n,a="rgb",h="pad",o=0){return this._$type="radial",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=r,this._$points[5]=n,this._$rgb=a,this._$mode=h,this._$focalPointRatio=$t(o,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push(nt(t,e))}}class fe{constructor(t,e,i,s){this._$context=t,this._$texture=e,this._$repeat=i,this._$colorTransform=s}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$colorTransform}}class me{constructor(){this._$fillStyle=J(1,1,1,1),this._$strokeStyle=J(1,1,1,1),this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5}get miterLimit(){return this._$miterLimit}set miterLimit(t){this._$miterLimit=t}get lineWidth(){return this._$lineWidth}set lineWidth(t){this._$lineWidth=t}get lineCap(){return this._$lineCap}set lineCap(t){this._$lineCap=t}get lineJoin(){return this._$lineJoin}set lineJoin(t){this._$lineJoin=t}get fillStyle(){return this._$fillStyle}set fillStyle(t){this._$fillStyle instanceof A&&Z(this._$fillStyle),this._$fillStyle=t}get strokeStyle(){return this._$strokeStyle}set strokeStyle(t){this._$strokeStyle instanceof A&&Z(this._$strokeStyle),this._$strokeStyle=t}clear(){this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5,this._$clearFill(),this._$clearStroke()}_$clearFill(){if(this._$fillStyle instanceof ge)return this._$fillStyle.dispose(),void(this._$fillStyle=J(1,1,1,1));this._$fillStyle instanceof fe?this._$fillStyle=J(1,1,1,1):this._$fillStyle.fill(1)}_$clearStroke(){if(this._$strokeStyle instanceof ge)return this._$strokeStyle.dispose(),void(this._$strokeStyle=J(1,1,1,1));this._$strokeStyle instanceof fe?this._$strokeStyle=J(1,1,1,1):this._$strokeStyle.fill(1)}}const pe=4096;class xe{constructor(t,e){t.pixelStorei(t.UNPACK_ALIGNMENT,1),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),this._$gl=t,this._$context=e,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$atlasTextures=[],this._$atlasCacheMap=new Map,this._$positionObjectArray=[],this._$nodeObjectArray=[],this._$atlasNodes=new Map}createTextureAtlas(){const t=this._$gl.createTexture();t.width=pe,t.height=pe,this._$gl.activeTexture(this._$gl.TEXTURE3),this._$gl.bindTexture(this._$gl.TEXTURE_2D,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST),this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,pe,pe),this._$gl.bindTexture(this._$gl.TEXTURE_2D,null),this._$activeTexture>-1&&this._$gl.activeTexture(this._$activeTexture);const e=this._$atlasTextures.length;this._$atlasNodes.set(e,[]),this._$atlasCacheMap.set(e,[]),this._$atlasTextures.push(t)}getAtlasTexture(t){return this._$atlasTextures[t]}getNode(t,e,i,s){const r=this._$nodeObjectArray.length?this._$nodeObjectArray.pop():{x:0,y:0,w:0,h:0};return r.x=t,r.y=e,r.w=i,r.h=s,r}createCachePosition(t,e){const i=this._$positionObjectArray.length?this._$positionObjectArray.pop():{index:0,x:0,y:0,w:0,h:0};i.x=i.y=0,i.w=t,i.h=e;for(const[s,r]of this._$atlasNodes){if(!r.length)return t>e?(pe-t-1>0&&r.push(this.getNode(t+1,0,pe-t-1,e)),pe-e-1>0&&r.push(this.getNode(0,e+1,pe,pe-e-1))):(pe-e-1>0&&r.push(this.getNode(0,e+1,t,pe-e-1)),pe-t-1>0&&r.push(this.getNode(t+1,0,pe-t-1,pe))),i.index=s,this._$atlasCacheMap.get(i.index).push(i),i;const n=r.length;for(let a=0;a<n;++a){const n=r[a];if(!(t>n.w||e>n.h))return i.index=s,i.x=n.x,i.y=n.y,this._$atlasCacheMap.get(i.index).push(i),n.w!==t||n.h!==e?t>e?(n.h-e-1>0&&r.push(this.getNode(n.x,n.y+e+1,n.w,n.h-e-1)),n.w-t-1>0?(n.x=n.x+t+1,n.w=n.w-t-1,n.h=e):(r.splice(a,1),this._$nodeObjectArray.push(n))):(n.w-t-1>0&&r.push(this.getNode(n.x+t+1,n.y,n.w-t-1,n.h)),n.h-e-1>0?(n.y=n.y+e+1,n.w=t,n.h=n.h-e-1):(r.splice(a,1),this._$nodeObjectArray.push(n))):(r.splice(a,1),this._$nodeObjectArray.push(n)),i}}const s=this._$atlasTextures.length;if(s)return this._$context.drawInstacedArray(),At.reset(),this.createCachePosition(t,e);this.createTextureAtlas();const r=this._$atlasNodes.get(s);return t>e?(pe-t-1>0&&r.push(this.getNode(t+1,0,pe-t-1,e)),pe-e-1>0&&r.push(this.getNode(0,e+1,pe,pe-e-1))):(pe-e-1>0&&r.push(this.getNode(0,e+1,t,pe-e-1)),pe-t-1>0&&r.push(this.getNode(t+1,0,pe-t-1,pe))),i.index=s,this._$atlasCacheMap.get(i.index).push(i),i}releasePosition(t){var e;this._$atlasNodes.has(t.index)&&(null===(e=this._$atlasNodes.get(t.index))||void 0===e||e.unshift(this.getNode(t.x,t.y,t.w,t.h)),this._$positionObjectArray.push(t))}clearCache(){for(const t of this._$atlasCacheMap.values())t.length=0;for(const t of this._$atlasNodes.values())t.length=0}_$createTexture(t,e){const i=this._$gl.createTexture();return i.width=0,i.height=0,i.area=0,i.dirty=!0,i.smoothing=!0,this.bind0(i,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,t,e),i}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}create(t,e,i=null,s=!1,r=!0){const n=this._$getTexture(t,e);return s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,t,e,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):i&&(n.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,t,e,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)),s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),n}createFromImage(t,e=!1){return this._$createFromElement(t.width,t.height,t,e)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1)}createFromVideo(t,e=!1){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e)}_$createFromElement(t,e,i,s=!1){const r=this._$getTexture(t,e);return r.dirty=!1,this.bind0(r,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r.width!==t||r.height!==e?(r.width=t,r.height=e,r.area=t*e,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPool.length&&this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i=null,s=null){const r=i!==this._$boundTextures[t],n=null!==s&&null!==i&&s!==i.smoothing;if((r||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),r&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i&&(i.smoothing=!!s);const t=s?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class be{constructor(t){this._$gl=t,this._$objectPool=nt(),this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}set maxWidth(t){this._$maxWidth=t}set maxHeight(t){this._$maxHeight=t}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the stencil buffer is null.");return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;++s){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();if(t)return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();t&&(this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t))}}}class Te{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=nt()}set samples(t){this._$samples=t}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the color buffer is null.");const e=this._$gl.createRenderbuffer();if(!e)throw new Error("the stencil buffer is null.");return t.stencil=e,t.samples=0,t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}const i=this._$objectPool.shift();if(!i)throw new Error("the color buffer is void.");return i}create(t,e,i=0){t=T.max(256,lt(t)),e=T.max(256,lt(e));const s=this._$getColorBuffer(t*e);return i||(i=this._$samples),(s.width<t||s.height<e||s.samples!==i)&&(t=T.max(t,s.width),e=T.max(e,s.height),s.samples=i,s.width=t,s.height=e,s.area=t*e,s.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,s),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,s.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i,this._$gl.STENCIL_INDEX8,t,e)),s}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;T.abs(i-e)>1;){const s=T.floor((i+e)/2);t<=this._$objectPool[s].area?i=s:e=s}return i}}class ve{constructor(t,e,i){this._$gl=t,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer),this._$frameBufferTexture=t.createFramebuffer(),this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new xe(t,e),this._$stencilBufferPool=new be(t),this._$colorBufferPool=new Te(t,i),this._$isRenderBinding=!1,this._$colorBuffer=this._$gl.createRenderbuffer(),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$colorBuffer),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i,this._$gl.RGBA8,pe,pe),this._$stencilBuffer=this._$gl.createRenderbuffer(),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$stencilBuffer),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i,this._$gl.STENCIL_INDEX8,pe,pe)}bindRenderBuffer(){this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),this._$isRenderBinding||(this._$isRenderBinding=!0,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$colorBuffer),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,this._$colorBuffer),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$stencilBuffer),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,this._$stencilBuffer))}get currentAttachment(){return this._$currentAttachment}get textureManager(){return this._$textureManager}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(t,e)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}clearCache(){this._$textureManager.clearCache()}setMaxSize(t,e){this._$stencilBufferPool._$maxWidth=t,this._$stencilBufferPool._$maxHeight=e,this._$textureManager._$maxWidth=t,this._$textureManager._$maxHeight=e}createTextureAttachment(t,e){const i=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!0};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t=null,e=!1){t&&t.isActive&&(t.msaa?t.color instanceof WebGLRenderbuffer&&this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&t.texture&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?t.color instanceof WebGLRenderbuffer&&(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):t.color instanceof WebGLTexture&&(t.color&&this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil),this._$isRenderBinding=!1}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}transferToMainTexture(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;if(!i)throw new Error("the texture is null.");this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,null),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBuffer)}createCachePosition(t,e){return this._$textureManager.createCachePosition(t,e)}transferTexture(t){this._$gl.disable(this._$gl.SCISSOR_TEST),this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture);const e=this._$textureManager.getAtlasTexture(t.index);this._$textureManager.bind0(e),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,e,0);const i=T.max(0,t.x-1),s=T.max(0,t.y-1),r=T.min(pe,t.x+t.w+1),n=T.min(pe,t.y+t.h+1);this._$gl.blitFramebuffer(i,s,r,n,i,s,r,n,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)}getTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");if(!this._$currentAttachment.msaa&&this._$currentAttachment.texture)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;if(!i)throw new Error("the texture is null.");return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t,e=!1){return this._$textureManager.createFromImage(t,e)}createTextureFromVideo(t,e=!1){return this._$textureManager.createFromVideo(t,e)}createTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class Ee{constructor(){this._$bezierConverterBuffer=new A(32)}cubicToQuad(t,e,i,s,r,n,a,h){this._$split2Cubic(t,e,i,s,r,n,a,h,0,16),this._$split2Cubic(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0,8),this._$split2Cubic(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16,24),this._$split2Quad(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0),this._$split2Quad(this._$bezierConverterBuffer[8],this._$bezierConverterBuffer[9],this._$bezierConverterBuffer[10],this._$bezierConverterBuffer[11],this._$bezierConverterBuffer[12],this._$bezierConverterBuffer[13],this._$bezierConverterBuffer[14],this._$bezierConverterBuffer[15],8),this._$split2Quad(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16),this._$split2Quad(this._$bezierConverterBuffer[24],this._$bezierConverterBuffer[25],this._$bezierConverterBuffer[26],this._$bezierConverterBuffer[27],this._$bezierConverterBuffer[28],this._$bezierConverterBuffer[29],this._$bezierConverterBuffer[30],this._$bezierConverterBuffer[31],24)}_$split2Cubic(t,e,i,s,r,n,a,h,o,l){const _=.125*(t+3*(i+r)+a),c=.125*(e+3*(s+n)+h),$=.125*(a+r-i-t),u=.125*(h+n-s-e);this._$bezierConverterBuffer[o]=t,this._$bezierConverterBuffer[o+1]=e,this._$bezierConverterBuffer[o+2]=.5*(t+i),this._$bezierConverterBuffer[o+3]=.5*(e+s),this._$bezierConverterBuffer[o+4]=_-$,this._$bezierConverterBuffer[o+5]=c-u,this._$bezierConverterBuffer[o+6]=_,this._$bezierConverterBuffer[o+7]=c,this._$bezierConverterBuffer[l]=_,this._$bezierConverterBuffer[l+1]=c,this._$bezierConverterBuffer[l+2]=_+$,this._$bezierConverterBuffer[l+3]=c+u,this._$bezierConverterBuffer[l+4]=.5*(r+a),this._$bezierConverterBuffer[l+5]=.5*(n+h),this._$bezierConverterBuffer[l+6]=a,this._$bezierConverterBuffer[l+7]=h}_$split2Quad(t,e,i,s,r,n,a,h,o){const l=.125*(t+3*(i+r)+a),_=.125*(e+3*(s+n)+h);this._$bezierConverterBuffer[o]=.25*t+.75*i,this._$bezierConverterBuffer[o+1]=.25*e+.75*s,this._$bezierConverterBuffer[o+2]=l,this._$bezierConverterBuffer[o+3]=_,this._$bezierConverterBuffer[o+4]=.75*r+.25*a,this._$bezierConverterBuffer[o+5]=.75*n+.25*h,this._$bezierConverterBuffer[o+6]=a,this._$bezierConverterBuffer[o+7]=h}}class ye{constructor(){this._$currentPath=nt(),this._$vertices=nt(),this._$bezierConverter=new Ee}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)at(this._$vertices.pop())}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,r,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(r,n))return;const a=+this._$currentPath[this._$currentPath.length-3],h=+this._$currentPath[this._$currentPath.length-2];this._$bezierConverter.cubicToQuad(a,h,t,e,i,s,r,n);const o=this._$bezierConverter._$bezierConverterBuffer;for(let t=0;t<32;)this.quadTo(o[t++],o[t++],o[t++],o[t++])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=+this._$currentPath[0],e=+this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=+this._$currentPath[this._$currentPath.length-3],s=+this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t,e,i)}_$pushCurrentPathToVertices(){this._$currentPath.length<4?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=nt())}createRectVertices(t,e,i,s){return nt(nt(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class Ae{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,m,p){const x=r.xMax-r.xMin,b=r.yMax-r.yMin,v=n.w,E=n.h,y=T.abs(T.ceil(x*a)),A=T.abs(T.ceil(b*a)),M=v>0?(n.x-r.xMin)/x:1e-5,C=E>0?(n.y-r.yMin)/b:1e-5,w=v>0?(n.x+n.w-r.xMin)/x:.99999,S=E>0?(n.y+n.h-r.yMin)/b:.99999;let F=y*M/i,R=A*C/s,B=(i-y*(1-w))/i,I=(s-A*(1-S))/s;if(F>=B){const t=M/(M+(1-w));F=T.max(t-1e-5,0),B=T.min(t+1e-5,1)}if(R>=I){const t=C/(C+(1-S));R=T.max(t-1e-5,0),I=T.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=h,this.parentMatrixB=o,this.parentMatrixD=l,this.parentMatrixE=_,this.parentMatrixG=c,this.parentMatrixH=$,this.ancestorMatrixA=u,this.ancestorMatrixB=d,this.ancestorMatrixD=g,this.ancestorMatrixE=f,this.ancestorMatrixG=m,this.ancestorMatrixH=p,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=i,this.parentViewportH=s,this.minXST=M,this.minYST=C,this.minXPQ=F,this.minYPQ=R,this.maxXST=w,this.maxYST=S,this.maxXPQ=B,this.maxYPQ=I}disable(){this.enabled=!1}}class Me{constructor(t,e){this._$gl=t,this._$array=[],this._$map=ot();const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r=this._$gl.getUniformLocation(e,s);if(i.type===this._$gl.SAMPLER_2D&&1===i.size)continue;const n={};switch(i.type){case this._$gl.FLOAT_VEC4:n.method=this._$gl.uniform4fv.bind(this._$gl,r),n.array=new A(4*i.size),n.assign=-1;break;case this._$gl.INT_VEC4:n.method=this._$gl.uniform4iv.bind(this._$gl,r),n.array=new M(4*i.size),n.assign=-1;break;case this._$gl.SAMPLER_2D:n.method=this._$gl.uniform1iv.bind(this._$gl,r),n.array=new M(i.size),n.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(n),this._$map.set(s,n)}}getArray(t){const e=this._$map.get(t);if(!e||!e.array)throw new Error("the UniformData is null.");return e.array}get textures(){const t=this._$map.get("u_textures");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get highp(){const t=this._$map.get("u_highp");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get mediump(){const t=this._$map.get("u_mediump");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get integer(){const t=this._$map.get("u_integer");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];void 0!==t.method&&void 0!==t.assign&&(t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array)))}}}class Ce{constructor(){this._$attributes=[],this._$count=0}get attributes(){return this._$attributes}get count(){return this._$count}set count(t){this._$count=t}clear(){this._$attributes.length=0,this._$count=0}}class we{constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new Me(t,this._$program),this._$instance=null}get instance(){return this._$instance||(this._$instance=new Ce),this._$instance}get uniform(){return this._$uniform}_$createProgram(t,e){const i=this._$gl.createProgram();i.id=m++;const s=this._$gl.createShader(this._$gl.VERTEX_SHADER);this._$gl.shaderSource(s,t),this._$gl.compileShader(s);const r=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);return this._$gl.shaderSource(r,e),this._$gl.compileShader(r),this._$gl.attachShader(i,s),this._$gl.attachShader(i,r),this._$gl.linkProgram(i),this._$gl.detachShader(i,s),this._$gl.detachShader(i,r),this._$gl.deleteShader(s),this._$gl.deleteShader(r),i}_$attachProgram(){const t=this._$context.shaderList;t.currentProgramId!==this._$program.id&&(t.currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}drawArraysInstanced(t){this._$attachProgram(),this._$context.vao.bindInstnceArray(t),this._$gl.drawArraysInstanced(this._$gl.TRIANGLE_STRIP,0,4,t.count)}_$drawImage(){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(t,e){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(t,e),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawElements(this._$gl.TRIANGLES,t.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t);const e=t.indexRanges,i=e[e.length-1];this._$gl.drawArrays(this._$gl.TRIANGLES,0,i.first+i.count)}_$containerClip(t,e,i){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.TRIANGLES,e,i)}_$drawPoints(t,e,i){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.POINTS,e,i)}}class Se{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class Fe{static TEMPLATE(t,e,i,s){const r=e-1,n=i?this.VARYING_UV_ON():"",a=i?this.STATEMENT_UV_ON():"";return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\nlayout (location = 1) in vec2 a_option1;\nlayout (location = 2) in vec2 a_option2;\nlayout (location = 3) in float a_type;\n\nuniform vec4 u_highp[${t}];\n\n${n}\n\n${s?Se.FUNCTION_GRID_ON(i?5:0):Se.FUNCTION_GRID_OFF()}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${r}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${r}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${r}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // \n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // \n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // B\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // A\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // A\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // B\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // \n        float face = u_highp[${r}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${a}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(){return"\nout vec2 v_uv;\n"}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class Re{static TEMPLATE(t,e,i,s){const r=i?this.ATTRIBUTE_BEZIER_ON():"",n=i?this.VARYING_BEZIER_ON():e?this.VARYING_UV_ON():"",a=i?this.STATEMENT_BEZIER_ON():e?this.STATEMENT_UV_ON():"";return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n${r}\n\nuniform vec4 u_highp[${t}];\n\n${n}\n\n${s?Se.FUNCTION_GRID_ON(e?5:0):Se.FUNCTION_GRID_OFF()}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${a}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(){return"\nlayout (location = 1) in vec2 a_bezier;\n"}static VARYING_UV_ON(){return"\nout vec2 v_uv;\n"}static VARYING_BEZIER_ON(){return"\nout vec2 v_bezier;\n"}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class Be{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_INSTANCED_COLOR_TRANSFORM_ON(){return"\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n${Be.STATEMENT_INSTANCED_COLOR_TRANSFORM_ON()}\n`}}class Ie{static SOLID_COLOR(){return"#version 300 es\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\nout vec4 o_color;\n\nvoid main() {\n    o_color = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n"}static BITMAP_CLIPPED(){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = texture(u_texture, uv);\n    ${Be.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    o_color = src;\n}`}static BITMAP_PATTERN(){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = texture(u_texture, uv);\n    ${Be.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    o_color = src;\n}`}static MASK(){return"#version 300 es\nprecision mediump float;\n\nin vec2 v_bezier;\nout vec4 o_color;\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        o_color = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n"}}class Le{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=ot()}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Fe.TEMPLATE(s,r,!1,e):Re.TEMPLATE(s,!1,!1,e);const a=new we(this._$gl,this._$context,n,Ie.SOLID_COLOR());return this._$collection.set(i,a),a}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r=(i?13:5)+(t?1:0),n=r;let a;a=t?Fe.TEMPLATE(r,n,!0,i):Re.TEMPLATE(r,!0,!1,i);const h=e?Ie.BITMAP_PATTERN():Ie.BITMAP_CLIPPED(),o=new we(this._$gl,this._$context,a,h);return this._$collection.set(s,o),o}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Fe.TEMPLATE(s,r,!1,e):Re.TEMPLATE(s,!1,!0,e);const a=new we(this._$gl,this._$context,n,Ie.MASK());return this._$collection.set(i,a),a}setSolidColorShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c){const $=t.highp;let u;n?($[0]=l.parentMatrixA,$[1]=l.parentMatrixB,$[2]=l.parentMatrixC,$[4]=l.parentMatrixD,$[5]=l.parentMatrixE,$[6]=l.parentMatrixF,$[8]=l.parentMatrixG,$[9]=l.parentMatrixH,$[10]=l.parentMatrixI,$[12]=l.ancestorMatrixA,$[13]=l.ancestorMatrixB,$[14]=l.ancestorMatrixC,$[16]=l.ancestorMatrixD,$[17]=l.ancestorMatrixE,$[18]=l.ancestorMatrixF,$[20]=l.ancestorMatrixG,$[21]=l.ancestorMatrixH,$[22]=l.ancestorMatrixI,$[3]=h,$[7]=o,$[11]=l.parentViewportX,$[15]=l.parentViewportY,$[19]=l.parentViewportW,$[23]=l.parentViewportH,$[24]=l.minXST,$[25]=l.minYST,$[26]=l.minXPQ,$[27]=l.minYPQ,$[28]=l.maxXST,$[29]=l.maxYST,$[30]=l.maxXPQ,$[31]=l.maxYPQ,u=32):($[0]=a[0],$[1]=a[1],$[2]=a[2],$[4]=a[3],$[5]=a[4],$[6]=a[5],$[8]=a[6],$[9]=a[7],$[10]=a[8],$[3]=h,$[7]=o,u=12),e&&($[u]=i,$[u+1]=s,$[u+2]=r);const d=t.mediump;d[0]=_[0],d[1]=_[1],d[2]=_[2],d[3]=_[3]*c}setBitmapShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,m,p,x,b){const T=t.highp;let v;T[0]=a[0],T[1]=a[1],T[2]=a[2],T[4]=a[3],T[5]=a[4],T[6]=a[5],T[8]=a[6],T[9]=a[7],T[10]=a[8],T[12]=h[0],T[13]=h[1],T[14]=h[2],T[16]=h[3],T[17]=h[4],T[18]=h[5],T[11]=h[6],T[15]=h[7],T[19]=h[8],T[3]=o,T[7]=l,v=20,n&&(T[v]=_.parentMatrixA,T[v+1]=_.parentMatrixB,T[v+2]=_.parentMatrixC,T[v+4]=_.parentMatrixD,T[v+5]=_.parentMatrixE,T[v+6]=_.parentMatrixF,T[v+8]=_.parentMatrixG,T[v+9]=_.parentMatrixH,T[v+10]=_.parentMatrixI,T[v+12]=_.ancestorMatrixA,T[v+13]=_.ancestorMatrixB,T[v+14]=_.ancestorMatrixC,T[v+16]=_.ancestorMatrixD,T[v+17]=_.ancestorMatrixE,T[v+18]=_.ancestorMatrixF,T[v+20]=_.ancestorMatrixG,T[v+21]=_.ancestorMatrixH,T[v+22]=_.ancestorMatrixI,T[v+11]=_.parentViewportX,T[v+15]=_.parentViewportY,T[v+19]=_.parentViewportW,T[v+23]=_.parentViewportH,T[v+24]=_.minXST,T[v+25]=_.minYST,T[v+26]=_.minXPQ,T[v+27]=_.minYPQ,T[v+28]=_.maxXST,T[v+29]=_.maxYST,T[v+30]=_.maxXPQ,T[v+31]=_.maxYPQ,v=52),e&&(T[v]=i,T[v+1]=s,T[v+2]=r);const E=t.mediump;E[0]=c,E[1]=$,E[4]=u,E[5]=d,E[6]=g,E[7]=f,E[8]=m,E[9]=p,E[10]=x,E[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u=null){const d=t.highp;e&&u?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=c,d[7]=$,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=h,d[8]=o,d[9]=l,d[10]=_,d[3]=c,d[7]=$)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class Pe{static TEMPLATE(t,e,i,s,r){const n=i?this.STATEMENT_GRADIENT_TYPE_RADIAL(e,s):this.STATEMENT_GRADIENT_TYPE_LINEAR(e);let a;switch(r){case"reflect":a="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":a="fract(t)";break;default:a="clamp(t, 0.0, 1.0)"}return`#version 300 es\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${t}];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 p = v_uv;\n    ${n}\n    t = ${a};\n    o_color = texture(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}class Oe{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=ot()}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(e?13:5)+(t?1:0)+1,h=a-1;let o;o=t?Fe.TEMPLATE(a,h,!0,e):Re.TEMPLATE(a,!0,!1,e);const l=new we(this._$gl,this._$context,o,Pe.TEMPLATE(a,h,i,s,r));return this._$collection.set(n,l),l}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",h=i?"y":"n",o=i&&s?"y":"n";let l=0;switch(r){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${h}${o}${l}`}setGradientShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=h[0],d[13]=h[1],d[14]=h[2],d[16]=h[3],d[17]=h[4],d[18]=h[5],d[11]=h[6],d[15]=h[7],d[19]=h[8],d[3]=o,d[7]=l;let g=20;n&&(d[g]=_.parentMatrixA,d[g+1]=_.parentMatrixB,d[g+2]=_.parentMatrixC,d[g+4]=_.parentMatrixD,d[g+5]=_.parentMatrixE,d[g+6]=_.parentMatrixF,d[g+8]=_.parentMatrixG,d[g+9]=_.parentMatrixH,d[g+10]=_.parentMatrixI,d[g+12]=_.ancestorMatrixA,d[g+13]=_.ancestorMatrixB,d[g+14]=_.ancestorMatrixC,d[g+16]=_.ancestorMatrixD,d[g+17]=_.ancestorMatrixE,d[g+18]=_.ancestorMatrixF,d[g+20]=_.ancestorMatrixG,d[g+21]=_.ancestorMatrixH,d[g+22]=_.ancestorMatrixI,d[g+11]=_.parentViewportX,d[g+15]=_.parentViewportY,d[g+19]=_.parentViewportW,d[g+23]=_.parentViewportH,d[g+24]=_.minXST,d[g+25]=_.minYST,d[g+26]=_.minXPQ,d[g+27]=_.minYPQ,d[g+28]=_.maxXST,d[g+29]=_.maxYST,d[g+30]=_.maxXPQ,d[g+31]=_.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=s,d[g+2]=r,g+=4),c?(d[g]=$[5],d[g+1]=u):(d[g]=$[0],d[g+1]=$[1],d[g+2]=$[2],d[g+3]=$[3])}}class ke{static TEXTURE(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n"}static BLEND(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}static INSTANCE_BLEND(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\nout vec2 v_src_coord;\nout vec2 v_dst_coord;\n\nvoid main() {\n    vec4 rect     = vec4(u_highp[0].x, u_highp[0].y, u_highp[0].z, u_highp[0].w);\n    vec2 size     = vec2(u_highp[4].x, u_highp[4].y);\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    v_src_coord = a_vertex * rect.zw + rect.xy;\n    v_dst_coord = a_vertex;\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}static INSTANCE(t=!1){return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\nlayout (location = 1) in vec4 a_rect;\nlayout (location = 2) in vec4 a_size;\nlayout (location = 3) in vec2 a_offset;\nlayout (location = 4) in vec4 a_matrix;\n${t?"\nlayout (location = 5) in vec4 a_mul;\nlayout (location = 6) in vec4 a_add;":""}\n\nout vec2 v_coord;\n${t?"\nout vec4 mul;\nout vec4 add;":""}\n\nvoid main() {\n    v_coord = a_vertex * a_rect.zw + a_rect.xy;\n    ${t?"\n    mul = a_mul;\n    add = a_add;":""}\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * a_size.xy;\n    mat3 matrix = mat3(a_matrix.x, a_matrix.y, 0.0, a_matrix.z, a_matrix.w, 0.0, a_offset.x, a_offset.y, 1.0);\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= a_size.zw;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static BLEND_CLIP(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}}class Ne{static TEMPLATE(t,e,i){let s="";for(let t=1;t<e;t++){const i=t-1,r=t,n=`u_mediump[${e+T.floor(i/4)}][${i%4}]`,a=`u_mediump[${e+T.floor(r/4)}][${r%4}]`;s+=`\n    if (t <= ${a}) {\n        return mix(u_mediump[${i}], u_mediump[${r}], (t - ${n}) / (${a} - ${n}));\n    }\n`}return`#version 300 es\nprecision mediump float;\n\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${e}][0]) {\n        return u_mediump[0];\n    }\n    ${s}\n    return u_mediump[${e-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${i?"color = pow(color, vec4(0.45454545));":""}\n    color.rgb *= color.a;\n\n    o_color = color;\n}\n\n`}}class De{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=ot()}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=T.ceil(5*t/4),r=new we(this._$gl,this._$context,ke.TEXTURE(),Ne.TEMPLATE(s,t,e));return this._$collection.set(i,r),r}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n++]=r[i[0]],a[n++]=r[i[1]],a[n++]=r[i[2]],a[n++]=r[i[3]]}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const h=t.mediump;for(let t=r;t<n;t++){const e=i[t];h[a++]=(e>>16)/255,h[a++]=(e>>8&255)/255,h[a++]=(255&e)/255,h[a++]=s[t]}for(let t=r;t<n;t++)h[a++]=e[t]}}class Ue{static TEMPLATE(t,e,i,s,r,n,a,h,o){let l=0;const _=i?this.STATEMENT_BASE_TEXTURE_TRANSFORM(l++):"",c=s?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(l++):this.STATEMENT_BLUR_TEXTURE(),$="inner"===n,u=l;let d,g,f=4*l;switch(o?d=r?this.STATEMENT_GLOW(!1,i,h,o,u,f):this.STATEMENT_BEVEL(i,s,h,o,u,f):r?(f+=4,d=this.STATEMENT_GLOW($,i,h,o,u,f)):(f+=8,d=this.STATEMENT_BEVEL(i,s,h,o,u,f)),n){case"outer":g=a?"blur - blur * base.a":"base + blur - blur * base.a";break;case"full":g=a?"blur":"base - base * blur.a + blur";break;default:g="blur"}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[${t}];\nuniform vec4 u_mediump[${e}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${Be.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${_}\n    ${c}\n    ${d}\n    o_color = ${g};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t){return`\n    vec2 base_scale  = u_mediump[${t}].xy;\n    vec2 base_offset = u_mediump[${t}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), texture(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(){return"\n    vec4 blur = texture(u_textures[0], v_coord);\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t){return`\n    vec2 blur_scale  = u_mediump[${t}].xy;\n    vec2 blur_offset = u_mediump[${t}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), texture(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,s,r,n){return`\n    ${t?"blur.a = 1.0 - blur.a;":""}\n    ${i?this.STATEMENT_GLOW_STRENGTH(n):""}\n    ${s?this.STATEMENT_GLOW_GRADIENT_COLOR(e):this.STATEMENT_GLOW_SOLID_COLOR(r)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${T.floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t){return`\n    blur = texture(u_textures[${t?2:1}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,s,r,n){return`\n    ${e?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2():this.STATEMENT_BLUR_TEXTURE_2()}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${i?this.STATEMENT_BEVEL_STRENGTH(n):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${s?this.STATEMENT_BEVEL_GRADIENT_COLOR(t):this.STATEMENT_BEVEL_SOLID_COLOR(r)}\n`}static STATEMENT_BLUR_TEXTURE_2(){return"\n    vec4 blur2 = texture(u_textures[0], 1.0 - v_coord);\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(){return"\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), texture(u_textures[0], pq), isInside(pq));\n"}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${T.floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t){return`\n    blur = texture(u_textures[${t?2:1}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}class Ve{static TEMPLATE(t){const e=t.toFixed(1);return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = texture(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${e}; i += 1.0) {\n        color += texture(u_texture, v_coord + offset * i);\n        color += texture(u_texture, v_coord - offset * i);\n    }\n    color += texture(u_texture, v_coord + offset * ${e}) * fraction;\n    color += texture(u_texture, v_coord - offset * ${e}) * fraction;\n    color /= samples;\n\n    o_color = color;\n}\n\n`}}class Ye{static TEMPLATE(){return"#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = texture(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    o_color = color;\n}\n\n"}}class Xe{static TEMPLATE(t,e,i,s,r){const n=T.floor(.5*e),a=T.floor(.5*i),h=e*i;let o="";const l=r?1:2;for(let t=0;t<h;++t)o+=`\n    result += getWeightedColor(${t}, u_mediump[${l+T.floor(t/4)}][${t%4}]);\n`;const _=s?"result.a = texture(u_texture, v_coord).a;":"",c=r?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${Be.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${e};\n    int i_mod_x = i - ${e} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${n}, ${a} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = texture(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${c}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${o}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${_}\n\n    result.rgb *= result.a;\n    o_color = result;\n}\n\n`}}class ze{static TEMPLATE(t,e,i,s){let r,n,a;switch(e){case 1:r="map_color.r";break;case 2:r="map_color.g";break;case 4:r="map_color.b";break;case 8:r="map_color.a";break;default:r="0.5"}switch(i){case 1:n="map_color.r";break;case 2:n="map_color.g";break;case 4:n="map_color.b";break;case 8:n="map_color.a";break;default:n="0.5"}switch(s){case"clamp":a="\n    vec4 source_color = texture(u_textures[0], uv);\n";break;case"ignore":a="\n    vec4 source_color =texture(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n";break;case"color":a="\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, texture(u_textures[0], uv), isInside(uv));\n";break;default:a="\n    vec4 source_color = texture(u_textures[0], fract(uv));\n"}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${Be.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = texture(u_textures[1], st);\n\n    vec2 offset = vec2(${r}, ${n}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${a}\n\n    o_color = mix(texture(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}class Ge{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=ot()}getBlurFilterShader(t){const e=`b${t}`;if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new we(this._$gl,this._$context,ke.TEXTURE(),Ve.TEMPLATE(t));return this._$collection.set(e,i),i}getBitmapFilterShader(t,e,i,s,r,n,a){const h=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${s}${r?"y":"n"}${n?"y":"n"}`;if(this._$collection.has(h)){const t=this._$collection.get(h);if(t)return t}let o=1;t&&o++,a&&o++;let l=(t?4:0)+(e?4:0)+(n?1:0);a||(l+=i?4:8),l=T.ceil(l/4);const _=new we(this._$gl,this._$context,ke.TEXTURE(),Ue.TEMPLATE(o,l,t,e,i,s,r,n,a));return this._$collection.set(h,_),_}getColorMatrixFilterShader(){if(this._$collection.has("m")){const t=this._$collection.get("m");if(t)return t}const t=new we(this._$gl,this._$context,ke.TEXTURE(),Ye.TEMPLATE());return this._$collection.set("m",t),t}getConvolutionFilterShader(t,e,i,s){const r=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${s?"y":"n"}`;if(this._$collection.has(r)){const t=this._$collection.get(r);if(t)return t}const n=(s?1:2)+T.ceil(t*e/4),a=new we(this._$gl,this._$context,ke.TEXTURE(),Xe.TEMPLATE(n,t,e,i,s));return this._$collection.set(r,a),a}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r="color"===i?3:2,n=new we(this._$gl,this._$context,ke.TEXTURE(),ze.TEMPLATE(r,t,e,i));return this._$collection.set(s,n),n}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,m,p,x,b,T,v,E,y){let A;T?(A=t.textures,A[0]=0,A[1]=1,y&&(A[2]=2)):y&&(A=t.textures,A[0]=0,A[1]=2);const M=t.mediump;let C=0;T&&(M[C]=e/s,M[C+1]=i/r,M[C+2]=n/s,M[C+3]=(i-r-a)/r,C+=4),v&&(M[C]=e/h,M[C+1]=i/o,M[C+2]=l/h,M[C+3]=(i-o-_)/o,C+=4),y||(c?(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,C+=4):(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,M[C+4]=m,M[C+5]=p,M[C+6]=x,M[C+7]=b,C+=8)),E&&(M[C]=$)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,h,o,l,_){const c=t.mediump;c[0]=1/e,c[1]=1/i,c[2]=1/r,c[3]=n/255;let $=4;a||(c[$]=h,c[$+1]=o,c[$+2]=l,c[$+3]=_,$+=4);const u=s.length;for(let t=0;t<u;t++)c[$++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=h/s,g[5]=-o/r,"color"===l&&(g[8]=_,g[9]=c,g[10]=$,g[11]=u)}}class He{static TEMPLATE(t){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${t?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec4 src = texture(u_texture, v_coord);\n    ${t?Be.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = src;\n}\n\n`}static INSTANCE_TEMPLATE(t){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${t?"\nin vec4 mul;\nin vec4 add;":""}\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec4 src = texture(u_texture, v_coord);\n    ${t?Be.STATEMENT_INSTANCED_COLOR_TRANSFORM_ON():""}\n    o_color = src;\n}\n\n`}}class We{static TEMPLATE(t,e){let i;switch(t){case"subtract":i=this.FUNCTION_SUBTRACT();break;case"multiply":i=this.FUNCTION_MULTIPLY();break;case"lighten":i=this.FUNCTION_LIGHTEN();break;case"darken":i=this.FUNCTION_DARKEN();break;case"overlay":i=this.FUNCTION_OVERLAY();break;case"hardlight":i=this.FUNCTION_HARDLIGHT();break;case"difference":i=this.FUNCTION_DIFFERENCE();break;case"invert":i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${e?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${i}\n\nvoid main() {\n    vec4 dst = texture(u_textures[0], v_coord);\n    vec4 src = texture(u_textures[1], v_coord);\n    ${e?Be.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = blend(src, dst);\n}\n\n`}static INSTANCE_TEMPLATE(t,e){let i;switch(t){case"subtract":i=this.FUNCTION_SUBTRACT();break;case"multiply":i=this.FUNCTION_MULTIPLY();break;case"lighten":i=this.FUNCTION_LIGHTEN();break;case"darken":i=this.FUNCTION_DARKEN();break;case"overlay":i=this.FUNCTION_OVERLAY();break;case"hardlight":i=this.FUNCTION_HARDLIGHT();break;case"difference":i=this.FUNCTION_DIFFERENCE();break;case"invert":i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${e?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_src_coord;\nin vec2 v_dst_coord;\nout vec4 o_color;\n\n${i}\n\nvoid main() {\n    vec4 dst = texture(u_textures[0], v_dst_coord);\n    vec4 src = texture(u_textures[1], v_src_coord);\n    ${e?Be.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}class je{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=ot()}getInstanceShader(t){const e="i"+(t?"y":"n");if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new we(this._$gl,this._$context,ke.INSTANCE(t),He.INSTANCE_TEMPLATE(t));return this._$collection.set(e,i),i}getNormalBlendShader(t){const e="n"+(t?"y":"n");if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new we(this._$gl,this._$context,ke.BLEND(),He.TEMPLATE(t));return this._$collection.set(e,i),i}getClipShader(){if(this._$collection.has("c")){const t=this._$collection.get("c");if(t)return t}const t=new we(this._$gl,this._$context,ke.BLEND_CLIP(),He.TEMPLATE(!1));return this._$collection.set("c",t),t}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=new we(this._$gl,this._$context,ke.BLEND(),We.TEMPLATE(t,e));return this._$collection.set(i,s),s}getInstanceBlendShader(t,e){const i=`i${t}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=new we(this._$gl,this._$context,ke.INSTANCE_BLEND(),We.INSTANCE_TEMPLATE(t,e));return this._$collection.set(i,s),s}setNormalBlendUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f){const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=h,o){const e=t.mediump;e[0]=l,e[1]=_,e[2]=c,e[3]=$,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}pushNormalBlend(t,e,i,s,r,n,a,h,o=1,l=1,_=1,c=1,$=0,u=0,d=0,g=0){t.attributes.push(e/pe,i/pe,s/pe,r/pe,s,r,a,h,n[6],n[7],n[0],n[1],n[3],n[4],o,l,_,c,$,u,d,g),t.count++}setClipUniform(t,e,i,s,r,n,a,h){const o=t.highp;o[0]=e,o[1]=i,o[2]=s,o[3]=r,o[4]=n[0],o[5]=n[1],o[6]=n[2],o[8]=n[3],o[9]=n[4],o[10]=n[5],o[12]=n[6],o[13]=n[7],o[14]=n[8],o[7]=a,o[11]=h}setInstanceBlendUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,m,p){const x=t.textures;x[0]=0,x[1]=1;const b=t.highp;if(b[0]=e,b[1]=i,b[2]=s,b[3]=r,b[4]=h[0],b[5]=h[1],b[6]=h[2],b[8]=h[3],b[9]=h[4],b[10]=h[5],b[12]=h[6],b[13]=h[7],b[14]=h[8],b[7]=o,b[11]=l,b[16]=n,b[17]=a,_){const e=t.mediump;e[0]=c,e[1]=$,e[2]=u,e[3]=d,e[4]=g,e[5]=f,e[6]=m,e[7]=p}}setBlendUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f){const m=t.textures;m[0]=0,m[1]=1;const p=t.highp;if(p[0]=e,p[1]=i,p[2]=s,p[3]=r,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=h,o){const e=t.mediump;e[0]=l,e[1]=_,e[2]=c,e[3]=$,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class qe{constructor(t,e){this._$currentProgramId=-1,this._$shapeShaderVariants=new Le(t,e),this._$gradientShapeShaderVariants=new Oe(t,e),this._$gradientLUTShaderVariants=new De(t,e),this._$filterShaderVariants=new Ge(t,e),this._$blendShaderVariants=new je(t,e)}get currentProgramId(){return this._$currentProgramId}set currentProgramId(t){this._$currentProgramId=t}get shapeShaderVariants(){return this._$shapeShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Ke{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=T.floor(.75*e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new Float32Array(256),this._$rgbIdentityTable=new Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=T.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment,s=this._$context.cachePosition;s&&this._$gl.disable(this._$gl.SCISSOR_TEST),this._$context._$bind(this._$attachment);const r=t.length,n=this._$context.shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<r;i+=this._$maxLength-1){const s=T.min(i+this._$maxLength,r),h=n.getGradientLUTShader(s-i,e),o=h.uniform;n.setGradientLUTUniformForShape(o,t,i,s,a),h._$drawGradient(0===i?0:t[i][0],s===r?1:t[s-1][0])}if(this._$context._$bind(i),!this._$attachment.texture)throw new Error("the texture is null.");return s&&this._$context.bindRenderBuffer(s),this._$attachment.texture}generateForFilter(t,e,i){const s=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,n=this._$context.shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let s=0;s<r;s+=this._$maxLength-1){const a=T.min(s+this._$maxLength,r),h=n.getGradientLUTShader(a-s,!1),o=h.uniform;n.setGradientLUTUniformForFilter(o,t,e,i,s,a),h._$drawGradient(0===s?0:t[s],a===r?1:t[a-1])}if(this._$context._$bind(s),!this._$attachment.texture)throw new Error("the texture is null.");return this._$attachment.texture}}class Qe{static get indexRangePool(){return this._$indexRangePool}static generate(t){let e=0;for(let i=0;i<t.length;++i)e+=12*(t[i].length/3-2);this._$vertexBufferData=new A(e),this._$indexRanges=nt(),this._$currentIndex=0;for(let e=0;e<t.length;++e){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i,r=this._$indexRangePool.pop()||{first:0,count:0};r.first=i,r.count=s,this._$indexRanges.push(r)}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}Qe._$indexRangePool=nt();class Je{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new A(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new A(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new C(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){let a=t,h=e;for(let o=1;o<11;o++){const l=o/11,_=1-l,c=(t*_+i*l)*_+(i*_+r*l)*l,$=(e*_+s*l)*_+(s*_+n*l)*l;this._$addLineSegmentMesh(a,h,c,$,2),a=c,h=$}this._$addLineSegmentMesh(a,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,h=n+2,o=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let _=this._$indexBufferPos;l[_++]=n,l[_++]=a,l[_++]=o,l[_++]=o,l[_++]=h,l[_++]=n,this._$indexBufferPos=_,this._$expandVertexBufferIfNeeded(28);const c=this._$vertexBufferData;let $=this._$vertexBufferPos;c[$++]=t,c[$++]=e,c[$++]=i,c[$++]=s,c[$++]=1,c[$++]=1,c[$++]=1,c[$++]=t,c[$++]=e,c[$++]=i,c[$++]=s,c[$++]=-1,c[$++]=-1,c[$++]=1,c[$++]=i,c[$++]=s,c[$++]=t,c[$++]=e,c[$++]=-1,c[$++]=-1,c[$++]=r,c[$++]=i,c[$++]=s,c[$++]=t,c[$++]=e,c[$++]=1,c[$++]=1,c[$++]=r,this._$vertexBufferPos=$}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,s,r,n,a,h,o,l=0,_=0){const c=i-t,$=s-e,u=n-i,d=a-s,g=this._$cross(c,$,u,d);if(!(T.abs(g)<1e-4))if(2!==r)switch(this._$lineJoin){case"round":this._$addRoundJoinMesh(i,s);break;case"miter":this._$addMiterJoinMesh(i,s,t,e,n,a,l,h,o,_);break;default:this._$addBevelJoinMesh(i,s,l,h,o,_)}else this._$addBevelJoinMesh(i,s,l,h,o,_)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,h,o,l){const _=this._$vertexBufferPos/7,c=_+1,$=_+2,u=_+3,d=_+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=_,g[f++]=a,g[f++]=c,g[f++]=_,g[f++]=c,g[f++]=$,g[f++]=_,g[f++]=$,g[f++]=h,g[f++]=_,g[f++]=o,g[f++]=u,g[f++]=_,g[f++]=u,g[f++]=d,g[f++]=_,g[f++]=d,g[f++]=l,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const m=this._$vertexBufferData;let p=this._$vertexBufferPos;m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=0,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=21,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=22,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=23,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=24,this._$vertexBufferPos=p}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let o=this._$indexBufferPos;h[o++]=a,h[o++]=i,h[o++]=s,h[o++]=a,h[o++]=r,h[o++]=n,this._$indexBufferPos=o,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let _=this._$vertexBufferPos;l[_++]=t,l[_++]=e,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,this._$vertexBufferPos=_}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],h=i[e-7],o=i[e-6],l=i[e-5],_=i[e-4],c=t/7,$=e/7;s!==h||r!==o?(this._$addLineCapMesh(s,r,n,a,c,c+1),this._$addLineCapMesh(h,o,l,_,$-1,$-2)):this._$addLineJoinMesh(l,_,s,r,n,a,$-2,$-1,c,c+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case"round":this._$addRoundJoinMesh(t,e);break;case"square":this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,h=a+1;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let l=this._$indexBufferPos;o[l++]=r,o[l++]=a,o[l++]=h,o[l++]=h,o[l++]=n,o[l++]=r,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const _=this._$vertexBufferData;let c=this._$vertexBufferPos;_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=-1,_[c++]=-1,_[c++]=10,_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=1,_[c++]=1,_[c++]=10,this._$vertexBufferPos=c}}Je._$cross=(t,e,i,s)=>t*s-i*e;class Ze{constructor(t){this._$gl=t,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new Float32Array([0,0,0,1,1,0,1,1]),this._$attributeVertexBuffer=t.createBuffer(),this._$attributeBuffer=new Float32Array(22),this._$instanceVertexArray=this._$getCommonVertexArray(),this._$commonVertexArray=this._$getVertexArray(0,1)}_$getCommonVertexArray(){const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,0,1,1]),this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,this._$attributeVertexBuffer),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$attributeBuffer.byteLength,this._$gl.DYNAMIC_DRAW),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(1,4,this._$gl.FLOAT,!1,88,0),this._$gl.vertexAttribDivisor(1,1),this._$gl.enableVertexAttribArray(2),this._$gl.vertexAttribPointer(2,4,this._$gl.FLOAT,!1,88,16),this._$gl.vertexAttribDivisor(2,1),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(3,2,this._$gl.FLOAT,!1,88,32),this._$gl.vertexAttribDivisor(3,1),this._$gl.enableVertexAttribArray(4),this._$gl.vertexAttribPointer(4,4,this._$gl.FLOAT,!1,88,40),this._$gl.vertexAttribDivisor(4,1),this._$gl.enableVertexAttribArray(5),this._$gl.vertexAttribPointer(5,4,this._$gl.FLOAT,!1,88,56),this._$gl.vertexAttribDivisor(5,1),this._$gl.enableVertexAttribArray(6),this._$gl.vertexAttribPointer(6,4,this._$gl.FLOAT,!1,88,72),this._$gl.vertexAttribDivisor(6,1),t}_$getVertexArray(t,e){const i=this._$gl.createVertexArray();this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length){const t=this._$fillVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length){const t=this._$strokeVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=Qe.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=lt(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const s=Je.generate(t,e,i),r=s.vertexBufferData,n=s.indexBufferData,a=this._$getStrokeVertexArray();return a.indexCount=n.length,this.bind(a),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,a.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,a.indexBuffer),a.vertexLength<r.length&&(a.vertexLength=lt(r.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*a.vertexLength,this._$gl.DYNAMIC_DRAW)),a.indexLength<n.length&&(a.indexLength=lt(n.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*a.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,r),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,n),a}releaseFill(t){this._$fillVertexArrayPool.push(t)}releaseStroke(t){this._$strokeVertexArrayPool.push(t)}bind(t=null){t!==this._$boundVertexArray&&(this._$boundVertexArray=t,this._$gl.bindVertexArray(t))}bindInstnceArray(t){this.bind(this._$instanceVertexArray),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,this._$attributeVertexBuffer),t.attributes.length>this._$attributeBuffer.length&&(this._$attributeBuffer=new Float32Array(t.attributes.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$attributeBuffer.byteLength,this._$gl.DYNAMIC_DRAW)),this._$attributeBuffer.set(t.attributes),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,this._$attributeBuffer)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class ti{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$poolClip=[],this._$clipStatus=!1,this._$containerClip=!1,this._$currentClip=!1}get containerClip(){return this._$containerClip}set containerClip(t){this._$containerClip=t}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel;let i=0;for(let t=0;t<e;++t)i|=(1<<e-t)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&i,i),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");if(--t.clipLevel,t.mask=!!t.clipLevel,!t.clipLevel)return void this._$context._$clearRectStencil();const e=t.width,i=t.height,s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);at(s.pop()),at(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(r,o.first,o.count);const l=r.indexRanges;for(let t=0;t<l.length;++t)Qe.indexRangePool.push(l[t]);at(r.indexRanges),this._$context.vao.releaseFill(r),this._$endClipDef()}_$drawContainerClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel,i=this._$context.shaderList.shapeShaderVariants,s=i.getMaskShapeShader(!1,!1),r=s.uniform;let n=e;const a=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);const o=this._$poolClip.length;for(let t=0;t<o;++t){const t=this._$poolClip.shift();if(!t)continue;i.setMaskShapeUniform(r,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const o=t.vertexArrayObject.indexRanges;for(let e=0;e<o.length;++e){const i=o[e];this._$gl.stencilMask(1<<n-1),s._$containerClip(t.vertexArrayObject,i.first,i.count),Qe.indexRangePool.push(i)}at(o),this._$context.vao.releaseFill(t.vertexArrayObject),++n,n>7&&(this._$unionStencilMask(e,a,h),n=e)}n>e+1&&this._$unionStencilMask(e,a,h)}_$unionStencilMask(t,e,i){const s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);at(s.pop()),at(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(r,o.first,o.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT));const l=r.indexRanges;for(let t=0;t<l.length;++t)Qe.indexRangePool.push(l[t]);at(r.indexRanges),this._$context.vao.releaseFill(r)}_$onClip(t,e,i,s){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip.push({vertexArrayObject:t,matrixA:e[0],matrixB:e[1],matrixC:e[2],matrixD:e[3],matrixE:e[4],matrixF:e[5],matrixG:e[6],matrixH:e[7],matrixI:e[8],viewportWidth:i,viewportHeight:s}),!0)}_$onSave(){this._$clips.push(this._$clipStatus)}_$onRestore(){this._$clips.length&&(this._$clipStatus=!!this._$clips.pop())}}class ei{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this._$currentShader=null,this._$currentOperation="normal",this._$currentIndex=-1,this._$currentSmoothing=null,this.enable()}get currentShader(){return this._$currentShader}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case"add":this.toAdd();break;case"screen":this.toScreen();break;case"alpha":this.toAlpha();break;case"erase":this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}clearInstacedArray(){if(!this._$currentShader)return;const t=this._$currentShader.instance;t.count&&t.clear()}drawInstacedArray(){if(!this._$currentShader)return;const t=this._$currentShader.instance;if(!t.count)return;const e=this._$context.frameBuffer,i=e.textureManager.getAtlasTexture(this._$currentIndex);e.textureManager.bind0(i,this._$currentSmoothing),this.toOperation(this._$currentOperation),this._$currentShader.drawArraysInstanced(t),t.clear()}drawInstance(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=1!==e||1!==i||1!==s||1!==r||0!==n||0!==a||0!==h||0!==o,g=this._$context.shaderList.blendShaderVariants;this._$currentOperation||(this._$currentOperation=l);const f=g.getInstanceShader(d);this._$currentShader||(this._$currentShader=f),-1===this._$currentIndex&&(this._$currentIndex=t.index),null===this._$currentSmoothing&&(this._$currentSmoothing=u),this._$currentShader===f&&this._$currentOperation===l&&this._$currentIndex===t.index&&this._$currentSmoothing===u||(this.drawInstacedArray(),this._$currentShader=f,this._$currentOperation=l,this._$currentIndex=t.index,this._$currentSmoothing=u),g.pushNormalBlend(f.instance,t.x,t.y,t.w,t.h,$,_,c,e,i,s,r,n,a,h,o)}drawInstanceBlend(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,m,p){this.drawInstacedArray();const x=this._$context.frameBuffer,b=x.currentAttachment,v=1!==n||1!==a||1!==h||1!==o||0!==l||0!==_||0!==c||0!==$,E=this._$context.shaderList.blendShaderVariants,y=x.getTextureFromCurrentAttachment(),A=this._$context.frameBuffer.createTextureAttachment(u.w,u.h);this._$context._$bind(A),x.textureManager.bind0(y);const M=E.getClipShader(),C=M.uniform;E.setClipUniform(C,0,0,u.w,u.h,ct(m),g,f),this.reset(),M._$drawImage();const w=x.getTextureFromCurrentAttachment();this._$context._$bind(b),x.textureManager.bind01(w,t,p);const S=E.getInstanceBlendShader(d,v);E.setInstanceBlendUniform(S.uniform,u.x/t.width,u.y/t.height,u.w/t.width,u.h/t.height,u.w,u.h,m,g,f,v,n,a,h,o,l,_,c,$);const F=T.abs(s-e),R=T.abs(r-i);this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(e,f-(i+R),F,R),this.toOneZero(),S._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),x.releaseAttachment(A,!0)}drawImage(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,m){const p=this._$context.frameBuffer,x=p.currentAttachment,b=1!==n||1!==a||1!==h||1!==o||0!==l||0!==_||0!==c||0!==$,v=this._$context.shaderList.blendShaderVariants;switch(u){case"normal":case"layer":case"add":case"screen":case"alpha":case"erase":case"copy":{p.textureManager.bind0(t,m);const x=v.getNormalBlendShader(b);v.setNormalBlendUniform(x.uniform,e,i,s,r,f,d,g,b,n,a,h,o,l,_,c,$);const E=f[0],A=f[1],M=f[3],C=f[4],w=f[6],S=f[7];if(1!==E||0!==A||0!==M||1!==C){const t=e+s,n=i+r,a=+(t*E+n*M+w),h=+(t*E+i*M+w),o=+(e*E+n*M+w),l=+(e*E+i*M+w),_=+(t*A+n*C+S),c=+(t*A+i*C+S),$=+(e*A+n*C+S),u=+(e*A+i*C+S),f=y.MAX_VALUE,m=+T.min(T.min(T.min(T.min(f,a),h),o),l),p=+T.max(T.max(T.max(T.max(-f,a),h),o),l),x=+T.min(T.min(T.min(T.min(f,_),c),$),u),b=+T.max(T.max(T.max(T.max(-f,_),c),$),u),v=T.max(0,m),F=T.max(0,x),R=T.min(T.max(0,d-v),T.ceil(T.abs(p-m))),B=T.min(T.max(0,g-F),T.ceil(T.abs(b-x)));if(!R||!B)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(v,T.max(0,g-(F+B)),R+1,B+1)}else{const t=T.max(0,e+w),n=T.max(0,i+S),a=T.min(T.max(0,d-t),s),h=T.min(T.max(0,g-n),r);if(!a||!h)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,T.max(0,g-(n+h)),a+1,h+1)}this.toOperation(u),x._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const E=T.max(0,e+f[6]),y=T.max(0,i+f[7]),A=T.min(T.max(0,d-E),s),M=T.min(T.max(0,g-y),r);if(!A||!M)return;const C=p.getTextureFromCurrentAttachment(),w=this._$context.frameBuffer.createTextureAttachment(s,r);this._$context._$bind(w),p.textureManager.bind0(C);const S=v.getClipShader(),F=S.uniform;v.setClipUniform(F,e,i,s,r,ct(f),d,g),this.reset(),S._$drawImage();const R=p.getTextureFromCurrentAttachment();this._$context._$bind(x),p.textureManager.bind01(R,t,m);const B=v.getBlendShader(u,b);v.setBlendUniform(B.uniform,e,i,s,r,f,d,g,b,n,a,h,o,l,_,c,$),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(E,T.max(0,g-(y+M)),A,M),this.toOneZero(),B._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),p.releaseAttachment(w,!0)}}}}class ii{constructor(t,e){this._$gl=t;const i=T.min(e,t.getParameter(t.MAX_SAMPLES));this._$maxTextureSize=T.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new me,this._$cacheBounds=K(),this._$matrix=rt(1,0,0,0,1,0,0,0,1),this._$cacheAttachment=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation="normal",this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new ve(t,this,i),this._$path=new ye,this._$grid=new Ae,this._$offsetX=0,this._$offsetY=0,this._$blends=nt(),this._$positions=nt(),this._$isLayer=!1,this._$shaderList=new qe(this,t),this._$gradientLUT=new Ke(this,t),this._$vao=new Ze(t),this._$mask=new ti(this,t),this._$blend=new ei(this,t),this._$attachmentArray=[],this._$maskBounds=K(0,0,0,0),this._$cachePosition=null}get cachePosition(){return this._$cachePosition}set cachePosition(t){this._$cachePosition=t}reset(){this._$globalAlpha=1,this._$globalCompositeOperation="normal",this._$imageSmoothingEnabled=!1,this._$contextStyle.clear()}get isLayer(){return this._$isLayer}get canvas(){return this._$gl.canvas}get cacheAttachment(){return this._$cacheAttachment}set cacheAttachment(t){this._$cacheAttachment=t}get cacheBounds(){return this._$cacheBounds}get fillStyle(){return this._$contextStyle.fillStyle}set fillStyle(t){this._$contextStyle.fillStyle=t}get strokeStyle(){return this._$contextStyle.strokeStyle}set strokeStyle(t){this._$contextStyle.strokeStyle=t}get lineWidth(){return this._$contextStyle.lineWidth}set lineWidth(t){this._$contextStyle.lineWidth=t}get lineCap(){return this._$contextStyle.lineCap}set lineCap(t){this._$contextStyle.lineCap=t}get lineJoin(){return this._$contextStyle.lineJoin}set lineJoin(t){this._$contextStyle.lineJoin=t}get miterLimit(){return this._$contextStyle.miterLimit}set miterLimit(t){this._$contextStyle.miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=$t(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=t}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get shaderList(){return this._$shaderList}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get blend(){return this._$blend}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$getTextureScale(t,e){const i=T.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}drawInstacedArray(){this.blend.drawInstacedArray()}clearInstacedArray(){this.blend.clearInstacedArray()}bindRenderBuffer(t){this._$frameBufferManager.bindRenderBuffer(),this._$gl.clearColor(0,0,0,0),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$viewportWidth=t.w,this._$viewportHeight=t.h,this._$gl.viewport(t.x,t.y,t.w,t.h),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t.x,t.y,t.w,t.h)}getTextureFromRect(t){const e=this._$frameBufferManager,i=e.textureManager.getAtlasTexture(t.index),s=e.currentAttachment,r=e.createTextureAttachment(t.w,t.h);this._$bind(r),this.save(),this.setTransform(1,0,0,1,0,0),this.reset(),this.drawImage(i,-t.x,-i.height+t.h+t.y,i.width,i.height),this.restore();const n=r.texture;return e.releaseAttachment(r),this._$bind(s),n}drawBitmap(t){const e=this._$shaderList.blendShaderVariants,i=e.getNormalBlendShader(!1);e.setNormalBlendUniform(i.uniform,0,0,t.width,t.height,this._$matrix,this._$viewportWidth,this._$viewportHeight,!1,1,1,1,1,0,0,0,0),this._$frameBufferManager.textureManager.bind0(t,this._$imageSmoothingEnabled),this.blend.toOperation("normal"),i._$drawImage()}drawTextureFromRect(t,e){const i=this._$frameBufferManager,s=i.currentAttachment;this.bindRenderBuffer(e),i.transferTexture(e);const r=i.textureManager.getAtlasTexture(e.index),n=i.createTextureAttachmentFrom(r);this._$bind(n),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(e.x,e.y,e.w,e.h),this._$gl.clearColor(0,0,0,0),this._$gl.disable(this._$gl.SCISSOR_TEST),this.save(),this.setTransform(1,0,0,1,0,0),this.reset(),this.drawImage(t,e.x,r.height-e.h-e.y,t.width,t.height),this.restore(),i.releaseAttachment(n),this._$bind(s),i.textureManager.release(t)}stopStencil(){this._$mask._$onClearRect()}_$bind(t=null){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e&&e.dirty||i&&i.dirty)&&(e&&(e.dirty=!1),i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}setMaxSize(t,e){this._$frameBufferManager.setMaxSize(t,e)}transform(t,e,i,s,r,n){const a=this._$matrix[0],h=this._$matrix[1],o=this._$matrix[3],l=this._$matrix[4],_=this._$matrix[6],c=this._$matrix[7];this._$matrix[0]=t*a+e*o,this._$matrix[1]=t*h+e*l,this._$matrix[3]=i*a+s*o,this._$matrix[4]=i*h+s*l,this._$matrix[6]=r*a+n*o+_,this._$matrix[7]=r*h+n*l+c}debug(t=0){const e=this._$frameBufferManager,i=e.textureManager.getAtlasTexture(t),s=e.currentAttachment,r=e.createTextureAttachmentFrom(i);this._$bind(r);const n=new Uint8Array(i.width*i.height*4);this._$gl.readPixels(0,0,i.width,i.height,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,n);const a=document.createElement("canvas");a.width=i.width,a.height=i.height;const h=a.getContext("2d"),o=new ImageData(i.width,i.height);for(let t=0;t<n.length;++t)o.data[t]=n[t];null==h||h.putImageData(o,0,0),console.log(a.toDataURL()),this._$bind(s),e.releaseAttachment(r)}drawInstance(t,e,i,s,r){let n=1,a=1,h=1,o=0,l=0,_=0;const c=this._$globalAlpha;r&&(n=r[0],a=r[1],h=r[2],o=r[4]/255,l=r[5]/255,_=r[6]/255);const $=this._$cachePosition;if($)switch(this._$globalCompositeOperation){case"normal":case"layer":case"add":case"screen":case"alpha":case"erase":case"copy":this.blend.drawInstance($,n,a,h,c,o,l,_,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled);break;default:{const r=this._$frameBufferManager.textureManager.getAtlasTexture($.index);this.blend.drawInstanceBlend(r,t,e,i,s,n,a,h,c,o,l,_,0,$,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}}}drawImage(t,e,i,s,r,n=null){let a=1,h=1,o=1,l=0,_=0,c=0;const $=this._$globalAlpha;n&&(a=n[0],h=n[1],o=n[2],l=n[4]/255,_=n[5]/255,c=n[6]/255),this.blend.drawImage(t,e,i,s,r,a,h,o,$,l,_,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(this._$maskBounds.xMin,this._$maskBounds.yMin,this._$maskBounds.xMax,this._$maskBounds.yMax),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin()}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}fill(){const t=this._$path.vertices;if(!t.length)return;const e=nt();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void at(e);const i=this._$vao.createFill(e),s=this.fillStyle;let r,n,a,h=this._$matrix;const o=this._$grid.enabled;if(s instanceof ge){const t=s.stops,e="linearRGB"===s.rgb;if(r=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(r,!0),this._$frameBufferManager.bindRenderBuffer(),n=this._$shaderList.gradientShapeShaderVariants,"linear"===s.type)a=n.getGradientShapeShader(!1,o,!1,!1,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,s.points,0);else{h=this._$stack[this._$stack.length-1];const t=0!==s.focalPointRatio;a=n.getGradientShapeShader(!1,o,!0,t,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,s.points,s.focalPointRatio)}}else if(s instanceof fe){h=this._$stack[this._$stack.length-1];const t=s.colorTransform;r=s.texture,this._$frameBufferManager.textureManager.bind0(r,this._$imageSmoothingEnabled),n=this._$shaderList.shapeShaderVariants,a=n.getBitmapShapeShader(!1,s.repeat,o),t?n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,1,1,1,this._$globalAlpha,0,0,0,0)}else n=this._$shaderList.shapeShaderVariants,a=n.getSolidColorShapeShader(!1,this._$grid.enabled),n.setSolidColorShapeUniform(a.uniform,!1,0,0,0,o,h,this._$viewportWidth,this._$viewportHeight,this._$grid,s,this._$globalAlpha);const l=this._$shaderList.shapeShaderVariants,_=l.getMaskShapeShader(!1,o);l.setMaskShapeUniform(_.uniform,o,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],this._$viewportWidth,this._$viewportHeight,this._$grid),this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),_._$fill(i),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),a._$fill(i),this._$gl.disable(this._$gl.STENCIL_TEST),this.releaseFillVertexArray(i)}releaseFillVertexArray(t){this._$vao.releaseFill(t);const e=t.indexRanges;for(let t=0;t<e.length;++t)Qe.indexRangePool.push(e[t]);at(e)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$updateContainerClipFlag(t){this._$mask.containerClip=t}_$startClip(t){const e=t.xMin,i=t.yMin,s=Math.abs(t.xMax-t.xMin),r=Math.abs(t.yMax-t.yMin),n=this._$frameBufferManager.currentAttachment;if(!n)throw new Error("the current Attachment is null.");return!(e>n.width||i>n.height||0>e&&0>=s+e||0>i&&0>=r+i||(this._$maskBounds.xMin=T.max(0,T.min(this._$maskBounds.xMin,e)),this._$maskBounds.yMin=T.max(0,T.min(this._$maskBounds.yMin,i)),this._$maskBounds.xMax=T.min(n.width,T.min(this._$maskBounds.xMax,s)),this._$maskBounds.yMax=T.min(n.height,T.min(this._$maskBounds.yMax,r)),0))}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this.drawInstacedArray(),this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}closePath(){this._$path.close()}stroke(){const t=this._$path.vertices;if(!t.length)return;const e=nt();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return void at(e);const i=this._$vao.createStroke(t,this.lineCap,this.lineJoin);let s=this._$matrix;const r=this.strokeStyle;let n=T.sign(s[0]*s[4]);n>0&&0!==s[1]&&0!==s[3]&&(n=-T.sign(s[1]*s[3]));let a,h,o=.5*this.lineWidth;this._$grid.enabled?(a=T.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),h=T.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(a=T.abs(s[0]+s[3]),h=T.abs(s[1]+s[4]));const l=T.min(a,h),_=T.max(a,h);o*=_*(1-.3*T.cos(.5*T.PI*(l/_))),o=T.max(1,o);const c=this._$grid.enabled;let $,u,d;if(r instanceof ge){"radial"===r.type&&(s=this._$stack[this._$stack.length-1]);const t=r.stops,e="linearRGB"===r.rgb;if($=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0($,!0),u=this._$shaderList.gradientShapeShaderVariants,"linear"===r.type)d=u.getGradientShapeShader(!0,c,!1,!1,r.mode),u.setGradientShapeUniform(d.uniform,!0,o,n,this.miterLimit,c,s,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,r.points,0);else{s=this._$stack[this._$stack.length-1];const t=0!==r.focalPointRatio;d=u.getGradientShapeShader(!0,c,!0,t,r.mode),u.setGradientShapeUniform(d.uniform,!0,o,n,this.miterLimit,c,s,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,r.points,r.focalPointRatio)}}else if(r instanceof fe){s=this._$stack[this._$stack.length-1];const t=r.colorTransform;$=r.texture,this._$frameBufferManager.textureManager.bind0($),u=this._$shaderList.shapeShaderVariants,d=u.getBitmapShapeShader(!0,r.repeat,this._$grid.enabled),t?u.setBitmapShapeUniform(d.uniform,!0,o,n,this.miterLimit,c,s,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,$.width,$.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):u.setBitmapShapeUniform(d.uniform,!0,o,n,this.miterLimit,c,s,ct(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,$.width,$.height,1,1,1,this._$globalAlpha,0,0,0,0)}else u=this._$shaderList.shapeShaderVariants,d=u.getSolidColorShapeShader(!0,this._$grid.enabled),u.setSolidColorShapeUniform(d.uniform,!0,o,n,this.miterLimit,c,s,this._$viewportWidth,this._$viewportHeight,this._$grid,r,this._$globalAlpha);d._$stroke(i),this._$vao.releaseStroke(i)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(){const t=this._$path.vertices;if(!t.length)return;const e=nt();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void at(e);const i=this._$vao.createFill(e),s=this._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;s.setMaskShapeUniform(n,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),this._$mask._$onClip(i,this._$matrix,this._$viewportWidth,this._$viewportHeight)||(r._$fill(i),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(rt(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){var t;this._$stack.length&&(t=this._$matrix,G.push(t),this._$matrix=this._$stack.pop()||rt()),this._$mask._$onRestore()}createPattern(t,e,i){return new fe(this,t,e,i)}createLinearGradient(t,e,i,s,r="rgb",n="pad"){return(new ge).linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a="rgb",h="pad",o=0){return(new ge).radial(t,e,i,s,r,n,a,h,o)}_$applyBlurFilter(t,e,i){const s=this._$frameBufferManager,r=s.currentAttachment;if(!r)throw new Error("the current attachment is null.");const n=r.width,a=r.height;s.textureManager.bind0(t,!0);const h=T.ceil(.5*i),o=1-(h-.5*i),l=1+i,_=this._$shaderList.filterShaderVariants,c=_.getBlurFilterShader(h);_.setBlurFilterUniform(c.uniform,n,a,e,o,l),c._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g=null,f=null,m=null,p=0,x=0,b=0,T=0,v=0,E=0,y=0,A=0){const M=this._$frameBufferManager,C="inner"===$,w=M.currentAttachment,S=M.getTextureFromCurrentAttachment();let F=null;const R=null!==g&&null!==f&&null!==m;let B;null!==g&&null!==f&&null!==m&&(F=this._$gradientLUT.generateForFilter(g,f,m)),C?R&&F?M.textureManager.bind02(t,F,!0):M.textureManager.bind0(t):(B=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(B),R&&F?M.textureManager.bind012(t,S,F,!0):M.textureManager.bind01(t,S));const I=!(C||"full"===$&&u),L=!(e===h&&i===o&&0===l&&0===_),P=!(1===d),O=this._$shaderList.filterShaderVariants,k=O.getBitmapFilterShader(I,L,c,$,u,P,R);O.setBitmapFilterUniform(k.uniform,e,i,s,r,n,a,h,o,l,_,c,d,p,x,b,T,v,E,y,A,I,L,P,R),C?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),k._$drawImage(),C||M.releaseAttachment(w,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager.textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,h,o,l,_,c){const $=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment($,u);this._$bind(d),this._$frameBufferManager.textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,h);g.setConvolutionFilterUniform(f.uniform,$,u,s,r,n,h,o,l,_,c),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),r||(r={x:0,y:0});const m=this._$frameBufferManager.createTextureFromImage(e);this._$frameBufferManager.textureManager.bind01(t,m);const p=this._$shaderList.filterShaderVariants,x=p.getDisplacementMapFilterShader(n,a,l);p.setDisplacementMapFilterUniform(x.uniform,e.width,e.height,i,s,r.x,r.y,h,o,l,_,c,$,u),this.blend.reset(),x._$drawImage(),this._$frameBufferManager.releaseTexture(m)}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){const t=this._$positions.pop();t&&Q(t),this._$isLayer=!!this._$blends.pop()}_$saveAttachment(t,e,i=!1){this.drawInstacedArray();const s=this._$frameBufferManager;this._$attachmentArray.push(s.currentAttachment),this._$bind(s.createCacheAttachment(t,e,i))}_$restoreAttachment(t=!1){const e=this._$frameBufferManager;e.releaseAttachment(e.currentAttachment,t),this._$bind(this._$attachmentArray.pop())}getCurrentPosition(){return this._$positions[this._$positions.length-1]}textureScale(t,e){const i=T.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}}class si{constructor(){var t;t=window.devicePixelRatio,f=t,this._$stage=new de,this._$stage._$player=this,this._$mode="loader",this._$actionOffset=0,this._$actions=nt(),this._$loaders=nt(),this._$sounds=ot(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$ratio=f,this._$stopFlag=!0,this._$startTime=0,this._$fps=16,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=tt(1,0,0,1,0,0),this._$tx=0,this._$ty=0,this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$deltaX=0,this._$deltaY=0,this._$broadcastEvents=ot(),this._$optionWidth=0,this._$optionHeight=0,this._$tagId="",this._$bgColor="transparent",this._$base="",this._$fullScreen=!1,this._$quality="high",this._$sources=nt(),this._$videos=nt(),this._$textField=null,this._$touchY=0,this._$timerId=-1,this._$loadId=-1,this._$context=null,this._$attachment=null,this._$clickTarget=null,this._$actionProcess=!1,this._$canvas=u.createElement("canvas")}static get LOAD_START(){return 1}static get LOAD_END(){return 2}get cacheStore(){return At}get canvas(){return this._$canvas}get broadcastEvents(){return this._$broadcastEvents}get context(){return this._$context}set context(t){this._$context=t}get base(){return this._$base}set base(t){if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${location.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else if(-1===t.indexOf("?"))this._$base="/"===t.slice(-1)?t:`${t}/`;else{const e=t.split("?")[0];this._$base="/"===e.slice(-1)?e:`${e}/`}}get stage(){return this._$stage}get x(){return this._$tx}get y(){return this._$ty}get scaleX(){return this._$matrix[0]}get scaleY(){return this._$matrix[3]}get mode(){return this._$mode}set mode(t){this._$mode=t}get contentElementId(){return mi}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}get bgColor(){return this._$bgColor}set bgColor(t){this._$bgColor=`${t}`}play(){if(this._$stopFlag){this._$stopFlag=!1,this._$timerId>-1&&R(this._$timerId),this._$startTime=B.now();const t=this._$stage._$frameRate;this._$fps=1e3/t|0,this._$timerId=F((t=>{this._$run(t)}))}}stop(){this._$timerId>-1&&R(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,ae.stopAll(),At.reset(),us&&us.postMessage({command:"stop"})}removeCache(t){At.removeCache(t),us&&us.postMessage({command:"removeCache",id:t})}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this.base=t.base||this._$base,this._$bgColor=t.bgColor||this._$bgColor,this._$fullScreen=!!t.fullScreen)}_$loadWebAudio(t=null){t&&this._$canvas.removeEventListener(Ei,this._$loadWebAudio),Ri||hs()}_$updateLoadStatus(){if(this._$loadStatus===si.LOAD_END)return this._$loadId>-1&&R(this._$loadId),this._$loadId=-1,void this._$loaded();this._$loadId=F((()=>{this._$updateLoadStatus()}))}_$loaded(){const t=u.getElementById(this.contentElementId);if(t){this._$setBackgroundColor(this._$bgColor),this._$deleteNode(),t.appendChild(this._$canvas),this._$stage._$prepareActions(),this._$broadcastEvents.has(wt.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new wt(wt.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(wt.EXIT_FRAME)&&this._$dispatchEvent(new wt(wt.EXIT_FRAME));const e=this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t.hasEventListener(wt.INIT)&&t.dispatchEvent(new wt(wt.INIT)),t.hasEventListener(wt.COMPLETE)&&t.dispatchEvent(new wt(wt.COMPLETE))}this._$broadcastEvents.has(wt.ACTIVATE)&&this._$dispatchEvent(new wt(wt.ACTIVATE)),this._$doAction(),this._$draw(),this.play()}}_$initialize(){if("loading"===u.readyState)return void $.addEventListener("DOMContentLoaded",(()=>{this._$initialize()}));const t=this.contentElementId;if(this._$tagId){const e=u.getElementById(this._$tagId);if(!e)return void alert("Not Found Tag ID:"+this._$tagId);if(u.getElementById(t))this._$deleteNode();else{const i=u.createElement("div");i.id=t,i.tabIndex=-1,e.appendChild(i)}}else u.body.insertAdjacentHTML("beforeend",`<div id="${t}" tabindex="-1"></div>`);const e=u.getElementById(t);if(!e)throw new Error("the content element is null.");const i=e.parentElement;if(i){this._$initStyle(e),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===i.tagName?$.innerWidth:i.offsetWidth,s=this._$optionHeight?this._$optionHeight:"BODY"===i.tagName?$.innerHeight:i.offsetHeight;"loader"===this._$mode&&t&&s&&(this._$baseWidth=t,this._$baseHeight=s,this._$resize())}"loader"===this._$mode?(this._$loadStatus=si.LOAD_START,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(t){const e=t.style;e.position="relative",e.top="0",e.left="0",e.backgroundColor="transparent",e.overflow="hidden",e.padding="0",e.margin="0",e.userSelect="none",e.outline="none";const i=this._$optionWidth,s=this._$optionHeight,r=t.parentElement;if(!r)throw new Error("the parentElement is null.");if("BODY"===r.tagName)return e.width=i?`${i}px`:`${window.innerWidth}px`,void(e.height=s?`${s}px`:`${window.innerHeight}px`);e.width=i?`${i}px`:`${r.offsetWidth}px`,e.height=s?`${s}px`:`${r.offsetHeight}px`}_$buildWait(){const t=u.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=u.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=u.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){if(this._$canvas.width=1,this._$canvas.height=1,us){us.postMessage({command:"setStage",instanceId:this._$stage._$instanceId});const t=this._$canvas.transferControlToOffscreen();us.postMessage({command:"initialize",canvas:t,samples:this._$getSamples(),devicePixelRatio:f,isSafari:Xi},[t])}else{const t=this._$canvas.getContext("webgl2",{stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0});t?(this._$context=new ii(t,this._$getSamples()),At.context=this._$context):alert("WebGL setting is off. Please turn the setting on.")}const t=()=>{if(this._$canvas.removeEventListener(Ei,t),this._$canvas.removeEventListener(bi,t),!Ri){hs();for(let t=0;t<this._$videos.length;++t){const e=this._$videos[t];e._$video&&(e._$video.muted=!1)}}};this._$canvas.addEventListener(bi,t),this._$canvas.addEventListener(Ei,t),this._$canvas.addEventListener(pi,(t=>{l(t),a(pi),this._$touchY=t.changedTouches[0].pageY,this._$hitTest()})),this._$canvas.addEventListener(xi,(t=>{l(t),a(xi),this._$hitTest()})),this._$canvas.addEventListener(bi,(t=>{l(t),a(bi),this._$hitTest()})),this._$canvas.addEventListener(xi,(t=>{const e=t.changedTouches[0].pageY;this._$deltaY=this._$touchY-e,this._$touchY=e,l(t),a(xi),this._$hitTest()}),{passive:!1}),this._$canvas.addEventListener(Ti,(t=>{l(t),a(Ti),t.button||this._$hitTest()})),this._$canvas.addEventListener(Ai,(t=>{l(t),a(Ai),t.button||this._$hitTest()})),this._$canvas.addEventListener(Mi,(t=>{l(t),a(Mi),this._$hitTest(),l(null),this._$stageX=-1,this._$stageY=-1})),this._$canvas.addEventListener(Ei,(t=>{l(t),a(Ei),t.button||this._$hitTest()})),this._$canvas.addEventListener(vi,(t=>{l(t),a(vi),this._$hitTest()})),this._$canvas.addEventListener(yi,(t=>{t.defaultPrevented||(l(t),a(yi),this._$hitTest())}),{passive:!1});let e="";e+="position: absolute;",e+="top: 0;",e+="left: 0;",e+="-webkit-tap-highlight-color: rgba(0,0,0,0);",e+="backface-visibility: hidden;",e+="transform-origin: 0 0;",1!==f&&(e+=`transform: scale(${1/f});`),this._$canvas.setAttribute("style",e)}_$resize(){const t=u.getElementById(this.contentElementId);if(t){const e=t.parentElement;if(!e)throw new Error("the parentElement is null.");const i=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?$.innerWidth:e.offsetWidth?e.offsetWidth:parseFloat(e.style.width),s=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?$.innerHeight:e.offsetHeight?e.offsetHeight:parseFloat(e.style.height),r="BODY"===e.tagName?$.innerWidth:e.offsetWidth,n=T.min(i/this._$baseWidth,s/this._$baseHeight);let a=this._$fullScreen?i:this._$baseWidth*n|0,h=this._$fullScreen?s:this._$baseHeight*n|0;const o=t.style;if(o.width=`${a}px`,o.height=`${h}px`,o.top="0",o.left=this._$fullScreen?"0":r/2-a/2+"px",a*=f,h*=f,this._$width===a&&this._$height===h)return;this._$stage._$doChanged(),At.reset(),this._$scale=n,this._$width=a,this._$height=h;const l=this._$scale*this._$ratio;this._$matrix[0]=l,this._$matrix[3]=l,this._$fullScreen&&(this._$tx=(a-this._$baseWidth*n*f)/2,this._$ty=(h-this._$baseHeight*n*f)/2,this._$matrix[4]=this._$tx,this._$matrix[5]=this._$ty),this._$resizeCanvas(a,h,l,this._$tx,this._$ty),this._$ratio>1&&f>1&&(this._$canvas.style.transform=`scale(${1/this._$ratio})`),t.children.length>1&&t.children[1].dispatchEvent(new Event(`${mi}_blur`))}}_$setBackgroundColor(t="transparent"){if(us)us.postMessage({command:"setBackgroundColor",backgroundColor:t});else{const e=this._$context;if(!e)return;if("transparent"===t)e._$setColor(0,0,0,0);else{const i=pt(mt(t));e._$setColor(i.R/255,i.G/255,i.B/255,1)}}}_$resizeCanvas(t,e,i,s=0,r=0){if(us)us.postMessage({command:"resize",width:t,height:e,scale:i,tx:s,ty:r});else{const i=this._$context;if(!i)return;i.clearInstacedArray(),this._$canvas.width=t,this._$canvas.height=e,i._$gl.viewport(0,0,t,e);const s=i.frameBuffer;this._$attachment&&(s.unbind(),s.releaseAttachment(this._$attachment,!0)),this._$attachment=s.createCacheAttachment(t,e,!0),i.setMaxSize(t,e),i._$bind(this._$attachment)}}_$getSamples(){switch(this._$quality){case"high":return 4;case"medium":return 2;default:return 0}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t.eventPhase=Ct.AT_TARGET;for(let i=0;i<e.length;++i){const s=e[i];if(t.currentTarget=s.target,t.listener=s.listener,s.listener.call(null,t),t._$stopImmediatePropagation)break}return at(e),!0}return!1}_$run(t=0){if(this._$stopFlag)return;this._$doAction();const e=t-this._$startTime;if(e>this._$fps){if(this._$startTime=t-e%this._$fps,this._$action(),this._$sounds.size){for(const t of this._$sounds.values())t._$soundPlay();this._$sounds.clear()}this._$draw(),!Wi&&!this._$hitTestStart&&"up"===this._$state&&this._$stageX>-1&&this._$stageY>-1&&o()&&this._$pointerCheck()}else this._$videos.length&&!us&&this._$draw();this._$timerId=F((t=>{this._$run(t)}))}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,Ji.setTransform(1,0,0,1,0,0),Ji.beginPath(),ki[4]=this._$tx/this._$scale/f,ki[5]=this._$ty/this._$scale/f,this._$stage._$mouseHit(Ji,ki,this._$hitObject,!0);let i=null,s=null,r=!1,n=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(It.MOUSE_OUT)&&t.dispatchEvent(new It(It.MOUSE_OUT,!0,!1))}if(this._$rollOverObject!==i){let r=null;if(this._$rollOverObject)for(s=this._$rollOverObject,s.willTrigger(It.ROLL_OUT)&&s.dispatchEvent(new It(It.ROLL_OUT,!1,!1)),r=s._$parent;r&&r._$root!==r&&r!==i;){if(r._$mouseEnabled&&r._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===r){t=!0;break}e=e._$parent}if(!t&&r._$parent===i._$parent&&r._$index>i._$index&&(t=!0),t)break}r.willTrigger(It.ROLL_OUT)&&r.dispatchEvent(new It(It.ROLL_OUT,!1,!1)),r=r._$parent}for(s=i;s.willTrigger(It.ROLL_OVER)&&s.dispatchEvent(new It(It.ROLL_OVER,!1,!1)),s=s._$parent,s&&s!==r&&s.stage!==s;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i&&i.willTrigger(It.MOUSE_OVER)&&i.dispatchEvent(new It(It.MOUSE_OVER,!0,!1)),this._$mouseOverTarget=i}if("up"===this._$state&&(this._$clickTarget=null),!Wi&&"up"===this._$state)for(s=i;s&&s.root!==s;){if("_$text"in s&&"input"===s.type){r=!0;break}if("buttonMode"in s&&s.buttonMode){n=!0;break}s=s._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(It.MOUSE_OUT)&&i.dispatchEvent(new It(It.MOUSE_OUT,!0,!1))),this._$rollOverObject)for(s=this._$rollOverObject;s&&s.root!==s;)s.willTrigger(It.ROLL_OUT)&&s.dispatchEvent(new It(It.ROLL_OUT,!1,!1)),s=s._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case r:this._$canvas.style.cursor="text";break;case n:this._$canvas.style.cursor="pointer";break;case!Wi&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has(wt.ENTER_FRAME)&&this._$dispatchEvent(new wt(wt.ENTER_FRAME)),this._$broadcastEvents.has(wt.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new wt(wt.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(wt.EXIT_FRAME)&&this._$dispatchEvent(new wt(wt.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new wt(wt.RENDER))),t){for(let e=0;e<t.length;++e){const i=t[e];i.hasEventListener(wt.INIT)&&i.dispatchEvent(new wt(wt.INIT)),i.hasEventListener(wt.COMPLETE)&&i.dispatchEvent(new wt(wt.COMPLETE))}at(t)}this._$doAction()}_$draw(){if(!this._$width||!this._$height)return;if(us&&us.postMessage({command:"draw"}),!this._$stage._$isUpdated())return;const t=this._$context;t&&(t.reset(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.beginPath(),this._$stage._$draw(t,this._$matrix,O),this._$stage._$updated=!1,t.drawInstacedArray(),t.frameBuffer.transferToMainTexture())}_$doAction(){for(;this._$actions.length;){this._$actionProcess=!0;const t=this._$actions.pop();if(!t)continue;t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;const i=t._$actions.get(e);if(i){t._$actionProcess=!0;for(let e=0;e<i.length;++e)r(t._$loaderInfo),i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}}this._$actionProcess=!1,r(null)}_$hitTest(){if(this._$stopFlag)return;const t=o();if(!t)return;this._$hitTestStart=!0,x(!1);let e=null,i=null,s=$.scrollX,r=$.scrollY;const a=u.getElementById(this.contentElementId);if(a){const t=a.getBoundingClientRect();s+=t.left,r+=t.top}let h=0,l=0;if("changedTouches"in t){const e=t.changedTouches[0];h=e.pageX,l=e.pageY}else"pageX"in t&&(h=t.pageX,l=t.pageY);h=(h-s)/this._$scale,l=(l-r)/this._$scale,this._$stageX=h,this._$stageY=l,this._$hitObject.x=h,this._$hitObject.y=l,this._$hitObject.pointer="",this._$hitObject.hit=null,Ji.setTransform(1,0,0,1,0,0),Ji.beginPath(),ki[4]=this._$tx/this._$scale/f,ki[5]=this._$ty/this._$scale/f,this._$stage._$mouseHit(Ji,ki,this._$hitObject,!0),this._$hitObject.hit&&t.preventDefault();let _=!1,c=!1,d=!1;const g=n;switch(g){case xi:case vi:if(Ii){const t=Ii._$dragMousePoint();let e=t.x,i=t.y;Pi.lock||(e+=Pi.position.x,i+=Pi.position.y);const s=Pi.bounds;s&&(e=$t(e,s.left,s.right),i=$t(i,s.top,s.bottom)),Ii.x=e,Ii.y=i}break;case pi:case Ti:this._$state="down",d="pointer"===this._$canvas.style.cursor,c=!0;break;case bi:case Ei:case Ai:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case g===Mi:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(It.MOUSE_OUT)&&e.dispatchEvent(new It(It.MOUSE_OUT,!0,!1))),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(It.ROLL_OUT)&&i.dispatchEvent(new It(It.ROLL_OUT,!1,!1)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,g){case yi:this._$stage.hasEventListener(It.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new It(It.MOUSE_WHEEL,!0,!1));break;case pi:case Ti:this._$stage.hasEventListener(It.MOUSE_DOWN)&&this._$stage.dispatchEvent(new It(It.MOUSE_DOWN,!0,!1)),this._$textField&&(this._$textField.focus=!1,this._$textField=null);break;case bi:case Ei:this._$textField&&(this._$textField.focus=!1,this._$textField=null),this._$stage.hasEventListener(It.CLICK)&&this._$stage.dispatchEvent(new It(It.CLICK,!0,!1)),this._$stage.hasEventListener(It.MOUSE_UP)&&this._$stage.dispatchEvent(new It(It.MOUSE_UP,!0,!1));break;case xi:case vi:this._$stage.hasEventListener(It.MOUSE_MOVE)&&this._$stage.dispatchEvent(new It(It.MOUSE_MOVE,!0,!1));break;case Ai:this._$stage.hasEventListener(It.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new It(It.DOUBLE_CLICK,!0,!1))}break;default:switch(e=this._$hitObject.hit,g){case xi:case vi:if(e.willTrigger(It.MOUSE_MOVE)&&e.dispatchEvent(new It(It.MOUSE_MOVE,!0,!1)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(It.MOUSE_OUT)&&t.dispatchEvent(new It(It.MOUSE_OUT,!0,!1))}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(It.ROLL_OUT)&&i.dispatchEvent(new It(It.ROLL_OUT,!1,!1)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(h,l)){let i=!1,s=e;for(;s&&s._$root!==s;){if(s===t){i=!0;break}s=s._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(It.ROLL_OUT)&&t.dispatchEvent(new It(It.ROLL_OUT,!1,!1)),t=t._$parent}for(i=e;i.willTrigger(It.ROLL_OVER)&&i.dispatchEvent(new It(It.ROLL_OVER,!1,!1)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(It.MOUSE_OVER)&&e.dispatchEvent(new It(It.MOUSE_OVER,!0,!1)),this._$mouseOverTarget=e}"up"===this._$state&&(this._$clickTarget=null);break;case pi:case Ti:this._$textField&&e!==this._$textField&&"_$text"in this._$textField&&(this._$textField.focus=!1,this._$textField=null),"_$text"in e&&(e.focus=!0,this._$textField=e),e.willTrigger(It.MOUSE_DOWN)&&e.dispatchEvent(new It(It.MOUSE_DOWN,!0,!1)),this._$clickTarget=e;break;case bi:case Ei:this._$textField&&e!==this._$textField&&"_$text"in this._$textField&&(this._$textField.focus=!1,this._$textField=null),e.willTrigger(It.MOUSE_UP)&&e.dispatchEvent(new It(It.MOUSE_UP,!0,!1)),this._$clickTarget===e&&e.willTrigger(It.CLICK)&&e.dispatchEvent(new It(It.CLICK,!0,!1)),this._$clickTarget=null;break;case yi:e.willTrigger(It.MOUSE_WHEEL)&&e.dispatchEvent(new It(It.MOUSE_WHEEL)),"deltaY"in t&&e.scrollEnabled&&(e.scrollV+=$t(t.deltaY,-1,1,0));break;case Ai:e.willTrigger(It.DOUBLE_CLICK)&&e.dispatchEvent(new It(It.DOUBLE_CLICK))}if(!c&&!Wi&&"up"===this._$state)for(i=e;i&&i.root!==i;){if("_$text"in i){if("input"===i.type){_=!0;break}}else if(i._$buttonMode){d=!0;break}i=i._$parent}}switch(!0){case _:this._$canvas.style.cursor="text";break;case d:this._$canvas.style.cursor="pointer";break;case!Wi&&"up"===this._$state:this._$canvas.style.cursor="auto"}!this._$actionProcess&&this._$actions.length>1&&this._$doAction(),p&&(this._$stage._$prepareActions(),this._$actionProcess||this._$doAction()),this._$hitTestStart=!1}}const ri={Event:wt,EventDispatcher:St,EventPhase:Ct,FocusEvent:Ft,HTTPStatusEvent:Rt,IOErrorEvent:Bt,MouseEvent:It,ProgressEvent:Lt,VideoEvent:Pt};Object.entries(ri).forEach((([t,e])=>{Object.defineProperty(ri,t,{get:()=>e})}));const ni={DisplayObject:Qt,InteractiveObject:Jt,DisplayObjectContainer:Zt,Sprite:_e,MovieClip:ce,BitmapData:te,BlendMode:class{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}},FrameLabel:ee,Graphics:re,Loader:$e,LoaderInfo:ne,Shape:ue,Stage:de};Object.entries(ni).forEach((([t,e])=>{Object.defineProperty(ni,t,{get:()=>e})}));const ai={BevelFilter:Yt,BlurFilter:Vt,ColorMatrixFilter:Xt,ConvolutionFilter:zt,DisplacementMapFilter:Gt,DropShadowFilter:Ht,GlowFilter:Wt,GradientBevelFilter:jt,GradientGlowFilter:qt};Object.entries(ai).forEach((([t,e])=>{Object.defineProperty(ai,t,{get:()=>e})}));const hi={ColorTransform:Ot,Matrix:Nt,Point:kt,Rectangle:Dt,Transform:Kt};Object.entries(hi).forEach((([t,e])=>{Object.defineProperty(hi,t,{get:()=>e})}));const oi={Sound:he,SoundMixer:ae,SoundTransform:oe,Video:le};Object.entries(oi).forEach((([t,e])=>{Object.defineProperty(oi,t,{get:()=>e})}));const li={URLRequest:Mt,URLRequestHeader:g};Object.entries(li).forEach((([t,e])=>{Object.defineProperty(li,t,{get:()=>e})}));class _i{constructor(t=null,e=null,i=null,s=null,r=null,n=null,a=null,h=null,o=null,l=null,_=null,c=null){this._$font=t,this._$size=e,this._$color=null===i?null:$t(mt(i),0,16777215,0),this._$bold=s,this._$italic=r,this._$underline=n,this._$align=a,this._$leftMargin=h,this._$rightMargin=o,this._$indent=l,this._$leading=_,this._$blockIndent=c,this._$letterSpacing=0}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){this._$align=t}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t}get bold(){return this._$bold}set bold(t){this._$bold=null!==t?!!t:null}get color(){return this._$color}set color(t){this._$color=t,t&&(this._$color=$t(mt(t),0,16777215,0))}get font(){return this._$font}set font(t){this._$font=null!==t?`${t}`:null}get indent(){return this._$indent}set indent(t){this._$indent=t}get italic(){return this._$italic}set italic(t){this._$italic=null!==t?!!t:null}get leading(){return this._$leading}set leading(t){this._$leading=t}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t}get size(){return this._$size}set size(t){this._$size=t?0|t:null}get underline(){return this._$underline}set underline(t){this._$underline=null!==t?!!t:null}_$clone(){const t=new _i(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t}_$setDefault(){this._$align="left",this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="Times New Roman",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t._$color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){let t=0;return this._$indent&&(t+=this._$indent),this._$leftMargin&&(t+=this._$leftMargin),this._$rightMargin&&(t+=this._$rightMargin),t}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','sans-serif'`}}class ci{static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,s){return t/s*i+e}static inQuad(t,e,i,s){return(t/=s)*t*i+e}static outQuad(t,e,i,s){return-(t/=s)*(t-2)*i+e}static inOutQuad(t,e,i,s){return(t/=s/2)<1?t*t*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,s){return(t/=s)*t*t*i+e}static outCubic(t,e,i,s){return t/=s,(--t*t*t+1)*i+e}static inOutCubic(t,e,i,s){return(t/=s/2)<1?t*t*t*i/2+e:((t-=2)*t*t+2)*i/2+e}static inQuart(t,e,i,s){return(t/=s)*t*t*t*i+e}static outQuart(t,e,i,s){return t/=s,(--t*t*t*t-1)*-i+e}static inOutQuart(t,e,i,s){return(t/=s/2)<1?t*t*t*t*i/2+e:((t-=2)*t*t*t-2)*-i/2+e}static inQuint(t,e,i,s){return(t/=s)*t*t*t*t*i+e}static outQuint(t,e,i,s){return t/=s,(--t*t*t*t*t+1)*i+e}static inOutQuint(t,e,i,s){return(t/=s/2)<1?t*t*t*t*t*i/2+e:((t-=2)*t*t*t*t+2)*i/2+e}static inSine(t,e,i,s){return-i*T.cos(t/s*(T.PI/2))+i+e}static outSine(t,e,i,s){return i*T.sin(t/s*(T.PI/2))+e}static inOutSine(t,e,i,s){return-i/2*(T.cos(T.PI*t/s)-1)+e}static inExpo(t,e,i,s){return i*T.pow(2,10*(t/s-1))+e}static outExpo(t,e,i,s){return i*(1-T.pow(2,-10*t/s))+e}static inOutExpo(t,e,i,s){return(t/=s/2)<1?i/2*T.pow(2,10*(t-1))+e:i/2*(2-T.pow(2,-10*(t-1)))+e}static inCirc(t,e,i,s){return(1-T.sqrt(1-(t/=s)*t))*i+e}static outCirc(t,e,i,s){return t/=s,T.sqrt(1- --t*t)*i+e}static inOutCirc(t,e,i,s){return(t/=2*s)<1?(T.sqrt(1-t*t)-1)/-2*i+e:(T.sqrt(1-(t-=2)*t)+1)/2*i+e}static inBack(t,e,i,s){return(2.70158*(t/=s)*t*t-1.70158*t*t)*i+e}static outBack(t,e,i,s){return(1+2.70158*T.pow((t/=s)-1,3)+1.70158*T.pow(t-1,2))*i+e}static inOutBack(t,e,i,s){let r=1.70158;return(t/=s/2)<1?t*t*((1+(r*=1.525))*t-r)*i/2+e:((t-=2)*t*((1+(r*=1.525))*t+r)+2)*i/2+e}static inElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:-T.pow(2,(t*=10)-10)*T.sin((t-10.75)*(2*T.PI/3))*i+e}static outElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:(T.pow(2,-10*t)*T.sin((10*t-.75)*(2*T.PI/3))+1)*i+e}static inOutElastic(t,e,i,s){return 0==(t/=s)?e:1===t?i+e:t<.5?-T.pow(2,20*t-10)*T.sin((20*t-11.125)*(2*T.PI/4.5))/2*i+e:(T.pow(2,-20*t+10)*T.sin((20*t-11.125)*(2*T.PI/4.5))/2+1)*i+e}static outBounce(t,e,i,s){return(t/=s)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,s){return i-ci.outBounce(s-t,0,i,s)+e}static inOutBounce(t,e,i,s){return t<s/2?ci.inBounce(2*t,e,i/2,s):ci.outBounce(2*t-s,e+i/2,i/2,s)}}class $i extends St{constructor(t,e=null,i=null,s=0,r=1,n=null){super(),this._$target=t,this._$delay=s,this._$duration=r,this._$ease=n||ci.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$forceStop=!1,this._$to=i,this._$currentTime=0}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$forceStop||(this._$stopFlag=!1,this._$startTime=B.now(),this._$names=this.entries(this._$from),this.addEventListener(wt.ENTER_FRAME,(t=>{this._$update(t)})))}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],s=i[1];s&&"object"==typeof s&&(i[1]=this.entries(s))}return e}start(){return new Promise((t=>{this.hasEventListener(wt.COMPLETE)||this.addEventListener(wt.COMPLETE,(e=>{this.removeEventListener(wt.COMPLETE,e.listener),t()})),this._$delay?I((()=>{this.initialize()}),1e3*this._$delay):this.initialize()}))}stop(){this.hasEventListener(wt.STOP)&&this.dispatchEvent(new wt(wt.STOP)),this.hasEventListener(wt.ENTER_FRAME)&&this.removeAllEventListener(wt.ENTER_FRAME),this.hasEventListener(wt.UPDATE)&&this.removeAllEventListener(wt.UPDATE),this.hasEventListener(wt.COMPLETE)&&this.removeAllEventListener(wt.COMPLETE),this._$forceStop=!0,this._$stopFlag=!0}_$update(t){this._$stopFlag||(this._$currentTime=.001*(B.now()-this._$startTime),this._$names&&this._$updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener(wt.UPDATE)&&this.dispatchEvent(new wt(wt.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener(wt.ENTER_FRAME,t.listener),this.hasEventListener(wt.COMPLETE)&&this.dispatchEvent(new wt(wt.COMPLETE))))}_$updateProperty(t,e,i,s){for(let r=0;r<s.length;++r){const n=s[r],a=n[0];if("__proto__"===a||"constructor"===a||"prototype"===a)continue;const h=n[1];if(h&&"object"==typeof h){this._$updateProperty(t[a],e[a],i[a],h);continue}if(!t.hasOwnProperty(a))continue;const o=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,o,i[a]-o,this._$duration):t[a]=i[a]}}}class ui{static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,s=0,r=1,n=null){return new $i(t,e,i,s,r,n)}}class di extends Jt{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0;const t=new _i;t._$setDefault(),this._$defaultTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict="",this._$isHTML=!1,this._$createdTextData=!1,this._$textData=nt(),this._$textHeight=null,this._$textWidth=null,this._$widthTable=nt(),this._$textarea=null,this._$autoSize="none",this._$autoFontSize=!1,this._$heightTable=nt(),this._$textFormatTable=nt(),this._$textAreaActive=!1,this._$totalWidth=0,this._$objectTable=nt(),this._$imageData=nt(),this._$scrollEnabled=!0,this._$scrollSprite=null,this._$type="static",this._$textHeightTable=nt(),this._$focus=!1,this._$isComposing=!1,this._$thickness=0,this._$thicknessColor=0,this._$verticalAlign="top",this._$heightCache=ot(),this._$cacheKeys=nt(),this._$cacheParams=nt(0,0,0)}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}get autoFontSize(){return this._$autoFontSize}set autoFontSize(t){t!==this._$autoFontSize&&(this._$autoFontSize=t,this._$reload())}get autoSize(){return this._$autoSize}set autoSize(t){t!==this._$autoSize&&(this._$autoSize=t,this._$reload())}get background(){return this._$background}set background(t){t!==this._$background&&(this._$background=!!t,this._$reset())}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){(t=$t(mt(t),0,16777215,16777215))!==this._$backgroundColor&&(this._$backgroundColor=t,this._$reset())}get border(){return this._$border}set border(t){t!==this._$border&&(this._$border=!!t,this._$reset())}get borderColor(){return this._$borderColor}set borderColor(t){(t=$t(mt(t),0,16777215,0))!==this._$borderColor&&(this._$borderColor=t,this._$reset())}get defaultTextFormat(){return this._$defaultTextFormat._$clone()}set defaultTextFormat(t){t._$merge(this._$defaultTextFormat),this._$defaultTextFormat=t,this._$reset()}get focus(){return this._$focus}set focus(t){if(this._$focus!==t)if(this._$focus=t,this._$focus){if("input"===this._$type){const t=Zi(),e=u.getElementById(t.contentElementId);if(!e)return;this._$createTextAreaElement(t._$scale);const i=this._$textarea;if(!i)return;const s=this._$transform.concatenatedMatrix,r=this._$getBounds(null),n=vt(mt(this._$defaultTextFormat.color),100);i.style.color=`rgb(${n.R},${n.G},${n.B})`,i.style.left=(s.tx+r.xMin+t.x/t._$scale/f)*t._$scale+"px",i.style.top=(s.ty+r.yMin+t.y/t._$scale/f)*t._$scale+"px",i.style.width=`${T.ceil((this.width-1)*t._$scale)}px`,i.style.height=`${T.ceil((this.height-1)*t._$scale)}px`,i.value=this.text,e.appendChild(i),F((()=>{i.focus()})),this._$doChanged(),x(),this._$textAreaActive=!0,this.willTrigger(Ft.FOCUS_IN)&&this.dispatchEvent(new Ft(Ft.FOCUS_IN))}}else this._$textarea&&(this._$textarea.dispatchEvent(new Event(`${mi}_blur`)),this.willTrigger(Ft.FOCUS_OUT)&&this.dispatchEvent(new Ft(Ft.FOCUS_OUT)),this._$textarea.remove())}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=`${t}`,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable.length=0,this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){if(this._$maxScrollV=1,this._$getTextData(),!this._$textHeightTable.length)return this._$maxScrollV;const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=0,s=0;for(;t>s&&(i+=this._$textHeightTable[s++],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){t!==this._$multiline&&(this._$multiline=!!t,this._$reset())}get numLines(){return this._$createdTextData||this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=`${t}`}get scrollEnabled(){return this._$scrollEnabled}set scrollEnabled(t){this._$scrollEnabled=t}get scrollH(){return this._$scrollH}set scrollH(t){t=$t(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger(wt.SCROLL)&&this.dispatchEvent(new wt(wt.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){if(t=$t(0|t,1,this.maxScrollV),this._$scrollV!==t){if(this._$scrollV=T.max(1,t),this._$reset(),this._$scrollSprite&&this.textHeight>this.height){this._$scrollSprite.height=this.height*this.height/this.textHeight-1;const t=this._$parent;if(t){this._$scrollSprite.alpha=1,this._$scrollSprite.x=this.x+this.width-this._$scrollSprite.width-.5,this._$scrollSprite.y=this.y+.5+(this.height-1-this._$scrollSprite.height)/(this.maxScrollV-1)*(this._$scrollV-1),t.addChildAt(this._$scrollSprite,t.getChildIndex(this)+1),this._$scrollSprite.hasLocalVariable("job")&&this._$scrollSprite.getLocalVariable("job").stop();const e=ui.add(this._$scrollSprite,{alpha:1},{alpha:0},1);e.addEventListener(wt.COMPLETE,(t=>{const e=t.target.target;e.deleteLocalVariable("job"),e.parent&&e.parent.removeChild(e)})),e.start(),this._$scrollSprite.setLocalVariable("job",e)}}this.willTrigger(wt.SCROLL)&&this.dispatchEvent(new wt(wt.SCROLL,!0))}}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData();for(let i=1;i<e.length;++i){const s=e[i];switch(s.mode){case"text":t+=s.text;break;case"break":t+="\r"}}return this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$isHTML=!1,this._$textFormatTable.length=0,this._$reload())}get textColor(){return this._$defaultTextFormat.color||0}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(""===this.text)return 0;if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();const t=this._$textHeightTable.length;1===t&&(this._$textHeight+=this._$defaultTextFormat.leading||0);for(let e=0;e<t;++e)this._$textHeight+=this._$textHeightTable[e]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=T.max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get thickness(){return this._$thickness}set thickness(t){(t|=0)!==this._$thickness&&(this._$thickness=t,this._$reset())}get thicknessColor(){return this._$thicknessColor}set thicknessColor(t){(t=$t(mt(t),0,16777215,0))!==this._$thicknessColor&&(this._$thicknessColor=t,this._$reset())}get type(){return this._$type}set type(t){this._$type=t,"static"===t&&(this._$textarea=null)}get verticalAlign(){return this._$verticalAlign}set verticalAlign(t){t!==this._$verticalAlign&&(this._$verticalAlign=t,this._$reset())}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap!==t&&(this._$wordWrap=!!t,this._$reset())}get width(){return super.width}set width(t){if(!S(t=+t)&&t>-1){const e=this._$getBounds(null),i=T.abs(e.xMin);this._$originBounds.xMax=t+i,this._$originBounds.xMin=i,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}}get height(){return super.height}set height(t){if(!S(t=+t)&&t>-1){const e=this._$getBounds(null),i=T.abs(e.yMin);this._$originBounds.yMax=t+i,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this.text=e+`${t}`}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),s=e>-1?e:i.length;let r=!1,n=new _i,a=t>-1?t:0;for(;a<s;++a){if("break"===i[a].mode)continue;const t=i[a].textFormat;r?(n.align=n.align!==t.align?null:t.align,n.blockIndent=n.blockIndent!==t.blockIndent?null:t.blockIndent,n.bold=n.bold!==t.bold?null:t.bold,n.color=n.color!==t.color?null:t.color,n.font=n.font!==t.font?null:t.font,n.indent=n.indent!==t.indent?null:t.indent,n.italic=n.italic!==t.italic?null:t.italic,n.leading=n.leading!==t.leading?null:t.leading,n.leftMargin=n.leftMargin!==t.leftMargin?null:t.leftMargin,n.letterSpacing=n.letterSpacing!==t.letterSpacing?null:t.letterSpacing,n.rightMargin=n.rightMargin!==t.rightMargin?null:t.rightMargin,n.size=n.size!==t.size?null:t.size,n.underline=n.underline!==t.underline?null:t.underline):(r=!0,n=t._$clone())}return n}getLineText(t){if(!this._$text&&!this._$htmlText)return"";t|=0;let e="";const i=this._$getTextData();for(let s=0;s<i.length;s++){const r=i[s];if(r.yIndex>t)break;r.yIndex===t&&"text"===r.mode&&(e+=r.text)}return e}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const s=this.text;t>=s.length?e>=s.length&&e>=t&&(this.text=s+`${i}`):this.text=s.slice(0,t)+`${i}`+s.slice(e,s.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const s=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:for(let e=0;e<s.length;++e)this._$textFormatTable[e]=t._$clone();break;case e>-1&&-1===i:{let i=e+1,r=s[i];"wrap"===r.mode&&(r=s[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let r=0;for(let n=e;n<i;++n){const e=s[n];e&&("wrap"!==e.mode&&"break"!==e.mode?this._$textFormatTable[n+r]=t._$clone():(++i,--r))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(!this._$createdTextData){this._$createdTextData=!0,this._$textData.length=0,this._$imageData.length=0,this._$heightTable.length=0,this._$textHeightTable.length=0,this._$objectTable.length=0,this._$widthTable.length=0,this._$heightCache.clear();let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),wi.innerHTML!==e&&(wi.textContent="",wi.insertAdjacentHTML("afterbegin",e));let s=this._$defaultTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}this._$totalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=this._$getTextHeight(s),this._$widthTable[0]=0;const r={mode:"break",x:0,yIndex:0,textFormat:s._$clone()};this._$objectTable[0]=r,this._$textData[0]=r,this._$parseTag(wi,s._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")];for(let i=0;i<e.length;++i){this._$totalWidth=0;let s=this.defaultTextFormat;const r=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[r]=0,this._$textHeightTable[r]=this._$getTextHeight(s),this._$widthTable[r]=0,r&&(this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}const n={mode:"break",x:0,yIndex:r,textFormat:s._$clone()};s=this.defaultTextFormat,this._$objectTable[r]=n,this._$textData[this._$textData.length]=n;const a=e[i];a&&(t=this._$parseText(a,s,t))}}this._$heightCache.clear()}return this._$textData}_$parseTag(t,e,i){const s=t.childNodes,r=s.length;for(let t=0;t<r;++t){let r=e._$clone();const n=s[t];if(3!==n.nodeType)switch(n.nodeName){case"P":{if(n.hasAttribute("align")){const t=n.getAttribute("align");"center"!==t&&"left"!==t&&"right"!==t||(r.align=t,1===this._$textData.length&&(this._$textData[0].textFormat.align=r.align))}if(this._$parseTag(n,r,i),!this._$multiline)break;this._$totalWidth=this._$getImageOffsetX();const t=this._$heightTable.length;if(this._$heightTable[t]=0,this._$textHeightTable[t]=0,this._$widthTable[t]=0,t&&(this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(r),r=t}const e={mode:"break",x:0,yIndex:t,textFormat:r};this._$objectTable[t]=e,this._$textData.push(e)}break;case"B":r.bold=!0,this._$parseTag(n,r,i);break;case"I":r.italic=!0,this._$parseTag(n,r,i);break;case"U":r.underline=!0,this._$parseTag(n,r,i);break;case"FONT":if(n.hasAttribute("face")&&(r.font=n.getAttribute("face")),n.hasAttribute("size")){const t=n.getAttribute("size");t&&(r.size=+t)}if(n.hasAttribute("color")&&(r.color=mt(n.getAttribute("color"))),n.hasAttribute("letterSpacing")){const t=n.getAttribute("size");t&&(r.letterSpacing=+t)}this._$parseTag(n,r,i);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0,this._$totalWidth=this._$getImageOffsetX(),r.indent=0;const e={mode:"break",x:0,yIndex:t,textFormat:r};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"IMG":{if(!n.hasAttribute("src"))break;const t=n.getAttribute("src");if(!t)break;let e=0;if(n.hasAttribute("width")){const t=n.getAttribute("width");t&&(e=+t)}let i=0;if(n.hasAttribute("height")){const t=n.getAttribute("height");t&&(i=+t)}let s=8;if(n.hasAttribute("vspace")){const t=n.getAttribute("vspace");t&&(s=+t)}let a=8;if(n.hasAttribute("hspace")){const t=n.getAttribute("hspace");t&&(a=+t)}let h=0;for(let t=0;t<this._$textHeightTable.length;t++)h+=this._$textHeightTable[t];const o=new Image,l={mode:"image",image:o,src:t,loaded:!1,x:0,y:h,width:e,height:i,hspace:a,vspace:s,textFormat:r._$clone()};if(o.crossOrigin="anonymous",o.addEventListener("load",(()=>{l.width||(l.width=o.width),l.height||(l.height=o.height),l.loaded=!0,this._$reload()})),o.src=t,this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],e=t.y+t.height+2*t.vspace;l.y=T.max(h,e)}this._$textData[this._$textData.length]=l,this._$imageData[this._$imageData.length]=l}break;default:this._$parseTag(n,r,i)}else i=this._$parseText(n.nodeValue||"",r,i)}}_$parseText(t,e,i){let s=this._$heightTable.length-1,r=e._$clone();const n=this._$transform.concatenatedMatrix._$matrix,a=(this._$originBounds.xMax-this._$originBounds.xMin)*(n[0]/n[3]);et(n);const h=a-r._$widthMargin()-4;for(let n=0;n<t.length;++n){if(r=e._$clone(),this._$textData.length+i in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+i]._$clone();t._$merge(r),r=t}const a={mode:"text",text:t[n],x:0,width:0,height:0,yIndex:s,textFormat:r};let o=!1;this._$multiline&&(o="\n"===a.text||"\r"===a.text||"\n\r"===a.text);const l=s&&r.leading||0;let _,c=0,$=0,u=0;if(qi){if(qi.font=r._$generateFontStyle(),c=qi.measureText(a.text||"").width,c+=r.letterSpacing||0,$=this._$getTextHeight(r),u=$+l,a.height=$,o||this._$wordWrap&&this._$totalWidth+c>h){this._$widthTable[++s]=0,a.yIndex=s,this._$heightTable[s]=this._$heightTable[s-1],this._$textHeightTable[s]=this._$textHeightTable[s-1],this._$totalWidth=this._$getImageOffsetX(),r=r._$clone(),r.indent=0,_={mode:o?"break":"wrap",x:0,yIndex:s,textFormat:r},this._$objectTable[s]=_,o||--i;let t=a.text||"",e=0,n=!0;const h=/[0-9a-zA-Z?!;:.,]/g;for(;t.match(h);){++e;const i=this._$textData[this._$textData.length-e];if("text"!==i.mode){n=!1;break}t=i.text||""}if(e>1&&this._$textData&&(this._$textData[this._$textData.length-e+1].text||"").match(/[0-9a-zA-Z]/g)&&--e,e>0&&n){const t=this._$textData.length-e;this._$textData.splice(t,0,_);let i=1,r=this._$textData[t-i];for(this._$widthTable[s-1]=0,this._$heightTable[s-1]=0,this._$textHeightTable[s-1]=0;"text"===r.mode;)$=this._$getTextHeight(r.textFormat),u=$+l,this._$widthTable[s-1]+=r.width||0,this._$heightTable[s-1]=T.max(this._$heightTable[s-1],$),this._$textHeightTable[s-1]=T.max(this._$textHeightTable[s-1],u),++i,r=this._$textData[t-i];for(i=1;this._$textData.length>t+i;)r=this._$textData[t+i],++i,$=this._$getTextHeight(r.textFormat),u=$+l,this._$heightTable[s]=T.max(this._$heightTable[s],$),this._$textHeightTable[s]=T.max(this._$textHeightTable[s],u),r.x=this._$totalWidth,r.yIndex=s,this._$totalWidth+=r.width||0}else this._$textData[this._$textData.length]=_}o||(a.width=c,a.x=this._$totalWidth,this._$totalWidth+=c,this._$widthTable&&(this._$widthTable[s]=T.max(this._$widthTable[s],this._$totalWidth)),this._$heightTable[s]=T.max(this._$heightTable[s],$),this._$textHeightTable[s]=T.max(this._$textHeightTable[s],u),this._$textData[this._$textData.length]=a)}}return i}_$getTextHeight(t){const e=t.size||0,i=t.font||"",s=t.bold?"bold":"normal",r=`${e}_${i}_${s}`;if(this._$heightCache.has(r))return this._$heightCache.get(r)||0;const n=Fi.style,a=`${e}px`;n.fontSize!==a&&(n.fontSize=a),n.fontFamily!==i&&(n.fontFamily=i),n.fontWeight!==s&&(n.fontWeight=s);const h=10>e?Fi.clientHeight*e*.1:Fi.clientHeight;return this._$heightCache.set(r,h),h}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];if(this._$imageData)for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],s=i.height+2*i.vspace;if(i.y<=t&&t<i.y+s)return i.width+2*i.hspace}return 0}_$reset(){this._$createdTextData=!1,this._$textData.length=0,this._$imageData.length=0,this._$heightTable.length=0,this._$textHeightTable.length=0,this._$widthTable.length=0,this._$objectTable.length=0,this._$textHeight=null,this._$textWidth=null,this._$totalWidth=0,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),x(),At.removeCache(this._$instanceId)}_$reload(){if(this._$reset(),this._$getTextData(),"none"===this._$autoSize&&this._$autoFontSize){let t=this._$defaultTextFormat.size||0;const e=t;if(this.width&&this.textWidth&&this.textWidth>this.width)for(;this.textWidth>this.width;){if(this._$defaultTextFormat.size=t--,1>t){this._$defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}if(this.height&&this.textHeight&&this.textHeight>this.height)for(;this.textHeight>this.height;){if(this._$defaultTextFormat.size=t--,1>t){this._$defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}this._$defaultTextFormat.size=e}this._$resize()}_$resize(){if("none"!==this._$autoSize){const t=this._$defaultTextFormat,e=this.textWidth+4+t._$widthMargin();if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case"left":case"center":this._$bounds.xMax=e+this._$bounds.xMin;break;case"right":this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}else this._$scrollEnabled&&!this._$scrollSprite&&(this._$scrollSprite=new _e,this._$scrollSprite.graphics.beginFill("#000",.3).drawRoundRect(0,0,3,3,3),this._$scrollSprite.scale9Grid=new Dt(1.5,1.5,.1,.1))}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],s=t.textFormat;let r=0;r+=s.blockIndent||0,r+=s.leftMargin||0;const n=s.rightMargin||0;switch(!0){case!this._$wordWrap&&i>e:return T.max(0,r);case"center"===s.align:case"center"===this._$autoSize:return T.max(0,e/2-r-n-i/2);case"right"===s.align:case"right"===this._$autoSize:return T.max(0,e-r-i-n-2);default:return T.max(0,r+2)}}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();return 1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=ut(t,i)),gt(this._$bounds,e)}return K(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}_$buildCharacter(t){const e=this._$defaultTextFormat;switch(e.font=t.font,e.size=0|t.size,e.align=t.align,e.color=0|t.color,e.leading=t.leading,e.letterSpacing=t.letterSpacing,e.leftMargin=t.leftMargin,e.rightMargin=t.rightMargin,t.fontType){case 1:e.bold=!0;break;case 2:e.italic=!0;break;case 3:e.bold=!0,e.italic=!0}switch(this._$type=t.inputType,this._$multiline=!!t.multiline,this._$wordWrap=!!t.wordWrap,this._$border=!!t.border,this._$scrollEnabled=!!t.scroll,this._$thickness=0|t.thickness,this._$thicknessColor=0|t.thicknessColor,this._$bounds.xMin=t.originBounds.xMin,this._$bounds.xMax=t.originBounds.xMax,this._$bounds.yMin=t.originBounds.yMin,this._$bounds.yMax=t.originBounds.yMax,this._$originBounds.xMin=t.originBounds.xMin,this._$originBounds.xMax=t.originBounds.xMax,this._$originBounds.yMin=t.originBounds.yMin,this._$originBounds.yMax=t.originBounds.yMax,t.autoSize){case 1:this.autoSize=t.align;break;case 2:this.autoFontSize=!0}this.text=t.text,us&&this._$stage&&this._$createWorkerInstance()}_$sync(t){this._$buildCharacter(t)}_$build(t,e){const i=this._$baseBuild(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const i=this._$getBounds(),s=i.xMax,r=i.xMin,n=i.yMax,a=i.yMin;Q(i);const h=T.ceil(T.abs(s-r)),o=T.ceil(T.abs(n-a));if(!h||!o)return;let l=e;const _=this._$transform._$rawMatrix();1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||(l=ut(e,_)),t.reset(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(h,0),t.lineTo(h,o),t.lineTo(0,o),t.lineTo(0,0),t.clip(),l!==e&&et(l)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let s=i;const r=this._$transform._$rawColorTransform();1===r[0]&&1===r[1]&&1===r[2]&&1===r[3]&&0===r[4]&&0===r[5]&&0===r[6]&&0===r[7]||(s=dt(i,r));const n=$t(s[3]+s[7]/255,0,1);if(!n)return;let a=e;const h=this._$transform._$rawMatrix();1===h[0]&&0===h[1]&&0===h[2]&&1===h[3]&&0===h[4]&&0===h[5]||(a=ut(e,h));const o=this._$getBounds(null);o.xMin-=this._$thickness,o.xMax+=this._$thickness,o.yMin-=this._$thickness,o.yMax+=this._$thickness;const l=gt(o,a),_=+l.xMax,c=+l.xMin,$=+l.yMax,u=+l.yMin;Q(l);const d=T.ceil(T.abs(_-c)),g=T.ceil(T.abs($-u));switch(!0){case 0===d:case 0===g:case d===-1/0:case g===-1/0:case d===b:case g===b:return}let f=+T.sqrt(a[0]*a[0]+a[1]*a[1]);if(!y.isInteger(f)){const t=f.toString(),e=t.indexOf("e");-1!==e&&(f=+t.slice(0,e)),f=+f.toFixed(4)}let m=+T.sqrt(a[2]*a[2]+a[3]*a[3]);if(!y.isInteger(m)){const t=m.toString(),e=t.indexOf("e");-1!==e&&(m=+t.slice(0,e)),m=+m.toFixed(4)}const p=this._$filters||this.filters,x=null!==p&&p.length>0&&this._$canApply(p);let v=K(0,d,0,g);if(x&&p)for(let t=0;t<p.length;++t)v=p[t]._$generateFilterRect(v,f,m);const E=t.frameBuffer,A=E.currentAttachment;if(!A||c-v.xMin>A.width||u-v.yMin>A.height)return void Q(v);if(0>c+v.xMax||0>u+v.yMax)return void Q(v);if(Q(v),this._$isUpdated()&&(At.removeCache(this._$instanceId),t.cachePosition=null,this._$cacheKeys.length=0),!this._$cacheKeys.length||this._$cacheParams[0]!==f||this._$cacheParams[1]!==m||this._$cacheParams[2]!==i[7]){const t=nt(f,m);this._$cacheKeys=At.generateKeys(this._$instanceId,t),at(t),this._$cacheParams[0]=f,this._$cacheParams[1]=m,this._$cacheParams[2]=i[7]}const M=this._$blendMode||this.blendMode;if(t.cachePosition=At.get(this._$cacheKeys),!t.cachePosition){const i=T.min(1,T.max(f,m)),r=T.ceil(T.abs(o.xMax-o.xMin)*f),n=T.ceil(T.abs(o.yMax-o.yMin)*m),a=At.getCanvas();a.width=r+2*i,a.height=n+2*i;const h=a.getContext("2d");if(!h)throw new Error("the context is null.");if(this._$background||this._$border){if(h.beginPath(),h.moveTo(0,0),h.lineTo(r,0),h.lineTo(r,n),h.lineTo(0,n),h.lineTo(0,0),this._$background){const t=vt(this._$backgroundColor),e=T.max(0,T.min(255*t.A+s[7],255))/255;h.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,h.fill()}if(this._$border){const t=vt(this._$borderColor),e=T.max(0,T.min(255*t.A+s[7],255))/255;h.lineWidth=i,h.strokeStyle=`rgba(${t.R},${t.G},${t.B},${e})`,h.stroke()}}h.save(),h.beginPath(),h.moveTo(2,2),h.lineTo(r-2,2),h.lineTo(r-2,n-2),h.lineTo(2,n-2),h.lineTo(2,2),h.clip(),h.beginPath(),h.setTransform(f,0,0,m,0,0),this._$doDraw(h,e,s,r/f),h.restore();const l=E.createCachePosition(r,n),_=E.createTextureFromCanvas(h.canvas);t.drawTextureFromRect(_,l),t.cachePosition=l,At.set(this._$cacheKeys,l),At.destroy(h)}let C=!1,w=0,S=0;if(p&&p.length&&this._$canApply(p)){C=!0;const e=this._$drawFilter(t,a,p,d,g);e.offsetX&&(w=e.offsetX),e.offsetY&&(S=e.offsetY),t.cachePosition=e}const F=T.atan2(a[1],a[0]),R=T.atan2(-a[2],a[3]);if(C||!F&&!R)t.setTransform(1,0,0,1,c-w,u-S);else{const e=o.xMin*f,i=o.yMin*m,s=T.cos(F),r=T.sin(F),n=T.cos(R),h=T.sin(R);t.setTransform(s,r,-h,n,e*s-i*h+a[4],e*r+i*n+a[5])}t.cachePosition&&(t.globalAlpha=n,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=M,t.drawInstance(c-w,u-S,_,$,i),t.cachePosition=null),Q(o),a!==e&&et(a),s!==i&&st(s)}_$doDraw(t,e,i,s){const r=this._$getTextData(),n=this.width,a=this.height;let h=0,o=0,l=0,_=0;if("top"!==this._$verticalAlign&&this.height>this.textHeight)switch(this._$verticalAlign){case"middle":_=(this.height-this.textHeight+2)/2;break;case"bottom":_=this.height-this.textHeight+2}for(let c=0;c<r.length;++c){const $=r[c];if(0===$.width)continue;const u=h+$.x;if("none"===this._$autoSize&&(o>a||u>n))continue;const d=$.textFormat,g=vt(d.color||0),m=T.max(0,T.min(255*g.A+i[7],255))/255;if(t.fillStyle=`rgba(${g.R},${g.G},${g.B},${m})`,this._$thickness){const e=vt(this._$thicknessColor),s=T.max(0,T.min(255*e.A+i[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${s})`}const p=0|$.yIndex;switch($.mode){case"break":case"wrap":if(l++,this.scrollV>l)continue;if(o+=this._$textHeightTable[p],h=this._$getAlignOffset(this._$objectTable[p],s),d.underline){const s=d.size?d.size/12:0,r=vt(d.color||0),n=T.max(0,T.min(255*r.A+i[7],255))/255;t.lineWidth=T.max(1,1/T.min(e[0],e[3])),t.strokeStyle=`rgba(${r.R},${r.G},${r.B},${n})`,t.beginPath(),t.moveTo(h,_+o-s),t.lineTo(h+this._$widthTable[p],_+o-s),t.stroke()}break;case"text":{if(this.scrollV>l)continue;let e=o-this._$heightTable[0];!Xi&&d.size&&(e+=f*(d.size/12)),t.beginPath(),t.textBaseline="top",t.font=Et(d.font||"",d.size||0,!!d.italic,!!d.bold),this._$thickness&&t.strokeText($.text,u,_+e),t.fillText($.text,u,_+e)}break;case"image":if(!$.loaded)continue;t.beginPath(),t.drawImage($.image,$.hspace,_+$.y,$.width,$.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let s=e;const r=this._$transform._$rawMatrix();1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(s=ut(e,r));const n=this._$getBounds(null),a=gt(n,s),h=+a.xMax,o=+a.xMin,l=+a.yMax,_=+a.yMin;Q(a),Q(n);const c=T.ceil(T.abs(h-o)),$=T.ceil(T.abs(l-_));return t.setTransform(1,0,0,1,o,_),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,$),t.lineTo(0,$),t.lineTo(0,0),s!==e&&et(s),t.isPointInPath(i.x,i.y)}_$createTextAreaElement(t){if(!this._$textarea){this._$textarea=u.createElement("textarea"),this._$textarea.value=this.text,this._$textarea.id=`${mi}_TextField_${this._$instanceId}`,this._$wordWrap||(this._$textarea.wrap="off");const t=this._$defaultTextFormat;let e="";e+="position: absolute;",e+="outline: 0;",e+=`padding: 2px 2px 2px ${T.max(3,t.leftMargin||0)}px;`,e+="margin: 0;",e+="appearance: none;",e+="resize: none;",e+="overflow: hidden;",e+="z-index: 2147483647;",e+="vertical-align: top;",this._$textarea.setAttribute("style",e),this._$textarea.addEventListener(`${mi}_blur`,(t=>{let e=t.target.value;if(e&&this._$restrict){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new d(t,"gm"));e=i?i.join(""):""}const i=Zi();if(u.getElementById(i.contentElementId)){const t=u.getElementById(`${mi}_TextField_${this._$instanceId}`);t&&t.remove()}this.text=e,this._$focus=!1,this._$textAreaActive=!1,this._$doChanged(),x()})),this._$textarea.addEventListener("input",(t=>{const e=t.target,i=Zi();let s=e.value;if(this._$restrict&&!this._$isComposing&&s){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const e=s.match(new d(t,"gm"));s=e?e.join(""):""}if(!this._$isComposing&&this.text!==s){this.text=s,e.value=s,this.willTrigger(wt.CHANGE)&&this.dispatchEvent(new wt(wt.CHANGE,!0));const t=this._$transform.concatenatedMatrix,r=this._$getBounds(null);e.style.left=`${T.floor((t.tx+r.xMin+i.x/i._$scale/f)*i._$scale)}px`,e.style.top=`${T.floor((t.ty+r.yMin+i.y/i._$scale/f)*i._$scale)}px`,e.style.width=`${T.ceil((this.width-1)*i._$scale)}px`,e.style.height=`${T.ceil((this.height-1)*i._$scale)}px`}})),this._$textarea.addEventListener("compositionstart",(()=>{this._$isComposing=!0})),this._$textarea.addEventListener("compositionend",(t=>{this._$isComposing=!1;const e=t.target;let i=e.value;if(!this._$restrict||!i)return;let s=this._$restrict;"["!==s[0]&&(s="["+s),"]"!==s[s.length-1]&&(s+="]");const r=i.match(new d(s,"gm"));i=r?r.join(""):"",this.text=i,e.value=i})),this._$textarea.addEventListener("click",(()=>{this.willTrigger(It.CLICK)&&this.dispatchEvent(new It(It.CLICK))})),this._$textarea.addEventListener(yi,(t=>{this.scrollV+=t.deltaY})),this._$textarea.addEventListener(Ci,(t=>{const e=t.target;this.scrollV=e.scrollTop/(e.scrollHeight-e.clientHeight)*this.maxScrollV+1})),this._$textarea.addEventListener(pi,(()=>{Zi()._$state="down"})),this._$textarea.addEventListener(bi,(()=>{Zi()._$state="up"})),this._$textarea.addEventListener(Ti,(()=>{Zi()._$state="down"})),this._$textarea.addEventListener(Ei,(()=>{Zi()._$state="up"}))}const e=this._$defaultTextFormat,i=e.size?T.ceil(e.size*t*this._$transform.concatenatedMatrix.d):0;this._$textarea.style.fontSize=`${i}px`,this._$textarea.style.fontFamily=e.font||"Times New Roman",this._$textarea.style.lineHeight=(i+T.max(0,e.leading||0))/i+"em","none"!==this._$autoSize?this._$textarea.style.textAlign="center":this._$textarea.style.textAlign=e.align||"none",this._$textarea.addEventListener("keydown",(t=>{const e=t.target;let i=e.value;if(this._$restrict&&!this._$isComposing&&i){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const e=i.match(new d(t,"gm"));i=e?e.join(""):""}if(this._$isComposing||(this.text=i,e.value=i),"Enter"===t.code&&!this._$multiline)return!1}));const s=this._$textarea.style;this._$border?s.border=`solid 1px #${this.borderColor.toString(16)}`:s.border="none",this._$border||this._$background?s.backgroundColor=`#${this.backgroundColor.toString(16)}`:s.backgroundColor="transparent",this._$textarea.maxLength=this._$maxChars?this._$maxChars:2147483647}_$createWorkerInstance(){if(this._$created||!us)return;this._$created=!0;const t=this._$getBounds(),e={command:"createTextField",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,xMin:t.xMin,yMin:t.yMin,xMax:t.xMax,yMax:t.yMax,textData:this._$getTextData(),scrollV:this.scrollV,widthTable:this._$widthTable,heightTable:this._$heightTable,textHeightTable:this._$textHeightTable,objectTable:this._$objectTable,limitWidth:this.width,limitHeight:this.height,textHeight:this.textHeight,verticalAlign:this._$verticalAlign,autoSize:this._$autoSize,wordWrap:this._$wordWrap,border:this._$border,background:this._$background,thickness:this._$thickness};this._$border&&(e.borderColor=this._$borderColor),this._$background&&(e.backgroundColor=this._$backgroundColor),this._$thickness&&(e.thicknessColor=this._$backgroundColor),this._$characterId>-1&&(e.characterId=this._$characterId),this._$loaderInfo&&(e.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(e.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),us.postMessage(e)}_$postProperty(){if(!us)return;const t=this._$createMessage();t.textAreaActive=this._$textAreaActive;const e=this._$getBounds(null);t.xMin=e.xMin,t.yMin=e.yMin,t.xMax=e.xMax,t.yMax=e.yMax,Q(e),this._$isUpdated()&&(t.textData=this._$getTextData(),t.scrollV=this.scrollV,t.widthTable=this._$widthTable,t.heightTable=this._$heightTable,t.textHeightTable=this._$textHeightTable,t.objectTable=this._$objectTable,t.limitWidth=this.width,t.limitHeight=this.height,t.textHeight=this.textHeight,t.verticalAlign=this._$verticalAlign,t.autoSize=this._$autoSize,t.wordWrap=this._$wordWrap,t.border=this._$border,this._$border&&(t.borderColor=this._$borderColor),t.background=this._$background,this._$background&&(t.backgroundColor=this._$backgroundColor),t.thickness=this._$thickness,this._$thickness&&(t.thicknessColor=this._$backgroundColor)),us.postMessage(t),this._$posted=!0,this._$updated=!1}}const gi={TextField:di,TextFormat:_i};Object.entries(gi).forEach((([t,e])=>{Object.defineProperty(gi,t,{get:()=>e})}));const fi={Easing:ci,Job:$i,Tween:ui};Object.entries(fi).forEach((([t,e])=>{Object.defineProperty(fi,t,{get:()=>e})}));const mi="__next2d__",pi="touchstart",xi="touchmove",bi="touchend",Ti="mousedown",vi="mousemove",Ei="mouseup",yi="wheel",Ai="dblclick",Mi="mouseleave",Ci="scroll",wi=u.createElement("p"),Si=u.createElement("div");Si.innerHTML="a",Si.style.display="block",Si.style.position="absolute",Si.style.top="-9999px",Si.style.left="-9999px",Si.style.padding="0",Si.style.margin="0",Si.style.padding="0",Si.style.border="0",Si.style.outline="0",Si.style.verticalAlign="bottom",Si.style.lineHeight="100%";const Fi=Si;let Ri=null;const Bi=new Map;let Ii=null;const Li=t=>{Ii=t},Pi={lock:!1,position:{x:0,y:0},bounds:null},Oi=new Float32Array(256);new Float32Array(256);for(let t=0;t<256;++t)Oi[t]=T.pow(t/255,2.23333333),Oi[t]=t/255;const ki=new Float32Array([1,0,0,1,0,0]),Ni=[],Di=[],Ui=[],Vi=new Map;let Yi=!1,Xi=!1,zi=!1,Gi=!1,Hi=!1,Wi=!1;const ji=u.createElement("canvas");ji.width=1,ji.height=1;const qi=ji.getContext("2d");qi&&(qi.globalAlpha=0,qi.imageSmoothingEnabled=!1);const Ki=u.createElement("canvas");Ki.width=1,Ki.height=1;const Qi=Ki.getContext("2d");if(!Qi)throw new Error("the CanvasRenderingContext2D is null.");Qi.globalAlpha=0,Qi.imageSmoothingEnabled=!1;const Ji=Qi,Zi=()=>$.next2d.player,ts=()=>{const t=o();if(!t)return new kt;const e=Zi();let i=$.scrollX,s=$.scrollY;const r=u.getElementById(e.contentElementId);if(r){const t=r.getBoundingClientRect();i+=t.left,s+=t.top}let n=0,a=0;if("changedTouches"in t){const e=t.changedTouches[0];n=e.pageX,a=e.pageY}else"pageX"in t&&(n=t.pageX,a=t.pageY);const h=(n-i)/e._$scale-e.x/e._$scale/f,l=(a-s)/e._$scale-e.y/e._$scale/f;return new kt(h,l)},es=(t=1,e=0,i=0,s=1,r=0,n=0)=>{const a=Di.pop();return a?(a.setTo(t,e,i,s,r,n),a):new Nt(t,e,i,s,r,n)},is=t=>{Di.push(t)},ss=(t=1,e=1,i=1,s=1,r=0,n=0,a=0,h=0)=>{const o=Ui.length?Ui.pop():null;return o?(o.redMultiplier=t,o.greenMultiplier=e,o.blueMultiplier=i,o.alphaMultiplier=s,o.redOffset=r,o.greenOffset=n,o.blueOffset=a,o.alphaOffset=h,o):new Ot(t,e,i,s,r,n,a,h)},rs=t=>{Ui.push(t)},ns=(t,e)=>{t._$character?t._$character.audioBuffer=e:t._$audioBuffer=e},as=t=>{if(!Ri)throw new Error("the AudioContext is null.");let e=null;if(t._$character){const i=t._$character.buffer;i&&(e=new Uint8Array(i).buffer,at(i),t._$character.buffer=null)}else e=t._$arrayBuffer;return e?Ri.decodeAudioData(e).then((e=>(ns(t,e),Promise.resolve(t)))).catch((()=>{if(!e)throw new Error;return((t,e)=>{if(!Ri)throw new Error("the Audio Context is null.");const i=new Uint8Array(e);let s=0;for(;s=i.indexOf(255,s),-1!==s&&224!=(224&i[s+1]);)++s;if(s>-1)return Ri.decodeAudioData(i.subarray(s).buffer).then((e=>(ns(t,e),Promise.resolve(t)))).catch((()=>{throw new Error("This voice data is not available.")}));throw new Error("This voice data is not available.")})(t,e)})):Promise.resolve(t)},hs=()=>{if(Ri||(Ri=new AudioContext,Ri.resume()),Ri){const t=nt();for(let e=0;e<Ni.length;++e){const i=Ni[e];i._$character&&i._$character.audioBuffer&&t.push(Promise.resolve(i)),i._$audioBuffer&&t.push(Promise.resolve(i)),t.push(as(i))}Promise.all(t).then((t=>{Ni.length=0,Zi()._$loaders.push(...t)}))}};let os=-1;const ls=()=>{const t=Zi();if(t._$loadStatus===si.LOAD_END){t._$resize();const e=t.stage;e.willTrigger(wt.RESIZE)&&e.dispatchEvent(new wt(wt.RESIZE))}};$.addEventListener("resize",(()=>{L(os),os=I(ls,300)}));const _s=t=>{let e=null;switch(t.method.toUpperCase()){case"GET":if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():`${e[1]}&${t.data.toString()}`,t.url=e.join("?")}break;case"PUT":case"POST":t.data&&(e=t.data.toString())}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),i.responseType=t.format,i.withCredentials=t.withCredentials,t.event){const e=Object.keys(t.event);for(let s=0;s<e.length;++s){const r=e[s];i.addEventListener(r,t.event[r])}at(e)}for(let e=0;e<t.headers.length;++e){const s=t.headers[e];i.setRequestHeader(s.name,s.value)}i.send(e)},cs=t=>{const e=nt();if(t){const i=t.trim().split("\n"),s=i.length;for(let t=0;t<s;++t){const s=i[t].split(":");e.push(new g(`${s[0].trim()}`,`${s[1].trim()}`))}}return e},$s=t=>{switch(t){case ce.namespace:return new ce;case ue.namespace:return new ue;case di.namespace:return new di;case _e.namespace:return new _e;case le.namespace:return new le}};let us=null,ds=null,gs=null;const fs=URL.createObjectURL(new Blob(['(()=>{"use strict";var r=Uint8Array,n=Uint16Array,e=Int32Array,a=new r([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),t=new r([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),i=new r([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=function(r,a){for(var t=new n(31),i=0;i<31;++i)t[i]=a+=1<<r[i-1];var o=new e(t[30]);for(i=1;i<30;++i)for(var f=t[i];f<t[i+1];++f)o[f]=f-t[i]<<5|i;return{b:t,r:o}},f=o(a,2),u=f.b,v=f.r;u[28]=258,v[258]=28;for(var c=o(t,0),l=c.b,d=(c.r,new n(32768)),s=0;s<32768;++s){var w=(43690&s)>>1|(21845&s)<<1;w=(61680&(w=(52428&w)>>2|(13107&w)<<2))>>4|(3855&w)<<4,d[s]=((65280&w)>>8|(255&w)<<8)>>1}var h=function(r,e,a){for(var t=r.length,i=0,o=new n(e);i<t;++i)r[i]&&++o[r[i]-1];var f,u=new n(e);for(i=1;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(a){f=new n(1<<e);var v=15-e;for(i=0;i<t;++i)if(r[i])for(var c=i<<4|r[i],l=e-r[i],s=u[r[i]-1]++<<l,w=s|(1<<l)-1;s<=w;++s)f[d[s]>>v]=c}else for(f=new n(t),i=0;i<t;++i)r[i]&&(f[i]=d[u[r[i]-1]++]>>15-r[i]);return f},y=new r(288);for(s=0;s<144;++s)y[s]=8;for(s=144;s<256;++s)y[s]=9;for(s=256;s<280;++s)y[s]=7;for(s=280;s<288;++s)y[s]=8;var b=new r(32);for(s=0;s<32;++s)b[s]=5;var g=h(y,9,1),p=h(b,5,1),m=function(r){for(var n=r[0],e=1;e<r.length;++e)r[e]>n&&(n=r[e]);return n},k=function(r,n,e){var a=n/8|0;return(r[a]|r[a+1]<<8)>>(7&n)&e},x=function(r,n){var e=n/8|0;return(r[e]|r[e+1]<<8|r[e+2]<<16)>>(7&n)},T=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],z=function(r,n,e){var a=new Error(n||T[r]);if(a.code=r,Error.captureStackTrace&&Error.captureStackTrace(a,z),!e)throw a;return a},E=function(n,e,o,f){var v=n.length,c=f?f.length:0;if(!v||e.f&&!e.l)return o||new r(0);var d=!o||2!=e.i,s=e.i;o||(o=new r(3*v));var w,y=function(n){var e=o.length;if(n>e){var a=new r(Math.max(2*e,n));a.set(o),o=a}},b=e.f||0,T=e.p||0,E=e.b||0,M=e.l,S=e.d,U=e.m,A=e.n,C=8*v;do{if(!M){b=k(n,T,1);var q=k(n,T+1,3);if(T+=3,!q){var D=n[(w=T,(G=4+((w+7)/8|0))-4)]|n[G-3]<<8,F=G+D;if(F>v){s&&z(0);break}d&&y(E+D),o.set(n.subarray(G,F),E),e.b=E+=D,e.p=T=8*F,e.f=b;continue}if(1==q)M=g,S=p,U=9,A=5;else if(2==q){var I=k(n,T,31)+257,O=k(n,T+10,15)+4,J=I+k(n,T+5,31)+1;T+=14;for(var L=new r(J),N=new r(19),P=0;P<O;++P)N[i[P]]=k(n,T+3*P,7);T+=3*O;var R=m(N),j=(1<<R)-1,B=h(N,R,1);for(P=0;P<J;){var G,H=B[k(n,T,j)];if(T+=15&H,(G=H>>4)<16)L[P++]=G;else{var K=0,Q=0;for(16==G?(Q=3+k(n,T,3),T+=2,K=L[P-1]):17==G?(Q=3+k(n,T,7),T+=3):18==G&&(Q=11+k(n,T,127),T+=7);Q--;)L[P++]=K}}var V=L.subarray(0,I),W=L.subarray(I);U=m(V),A=m(W),M=h(V,U,1),S=h(W,A,1)}else z(1);if(T>C){s&&z(0);break}}d&&y(E+131072);for(var X=(1<<U)-1,Y=(1<<A)-1,Z=T;;Z=T){var $=(K=M[x(n,T)&X])>>4;if((T+=15&K)>C){s&&z(0);break}if(K||z(2),$<256)o[E++]=$;else{if(256==$){Z=T,M=null;break}var _=$-254;if($>264){var rr=a[P=$-257];_=k(n,T,(1<<rr)-1)+u[P],T+=rr}var nr=S[x(n,T)&Y],er=nr>>4;if(nr||z(3),T+=15&nr,W=l[er],er>3&&(rr=t[er],W+=x(n,T)&(1<<rr)-1,T+=rr),T>C){s&&z(0);break}d&&y(E+131072);var ar=E+_;if(E<W){var tr=c-W,ir=Math.min(W,ar);for(tr+E<0&&z(3);E<ir;++E)o[E]=f[tr+E]}for(;E<ar;E+=4)o[E]=o[E-W],o[E+1]=o[E+1-W],o[E+2]=o[E+2-W],o[E+3]=o[E+3-W];E=ar}}e.l=M,e.p=Z,e.b=E,e.f=b,M&&(b=1,e.m=U,e.d=S,e.n=A)}while(!b);return E==o.length?o:function(n,e,a){(null==e||e<0)&&(e=0),(null==a||a>n.length)&&(a=n.length);var t=new r(a-e);return t.set(n.subarray(e,a)),t}(o,0,E)},M=new r(0);function S(n,e){var a,t,i=function(r){31==r[0]&&139==r[1]&&8==r[2]||z(6,"invalid gzip data");var n=r[3],e=10;4&n&&(e+=2+(r[10]|r[11]<<8));for(var a=(n>>3&1)+(n>>4&1);a>0;a-=!r[e++]);return e+(2&n)}(n);return i+8>n.length&&z(6,"invalid gzip data"),E(n.subarray(i,-8),{i:2},e&&e.out||new r((t=(a=n).length,(a[t-4]|a[t-3]<<8|a[t-2]<<16|a[t-1]<<24)>>>0)),e&&e.dictionary)}function U(r,n){return E(r.subarray((e=r,a=n&&n.dictionary,(8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31)&&z(6,"invalid zlib data"),(e[1]>>5&1)==+!a&&z(6,"invalid zlib data: "+(32&e[1]?"need":"unexpected")+" dictionary"),2+(e[1]>>3&4)),-4),{i:2},n&&n.out,n&&n.dictionary);var e,a}var A="undefined"!=typeof TextDecoder&&new TextDecoder;try{A.decode(M,{stream:!0})}catch(r){}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;self.addEventListener("message",(r=>{return n=void 0,e=void 0,t=function*(){const n=31==(e=r.data)[0]&&139==e[1]&&8==e[2]?S(e,a):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?function(r,n){return E(r,{i:2},n&&n.out,n&&n.dictionary)}(e,a):U(e,a);var e,a;let t="";for(let r=0;r<n.length;r+=4096)t+=String.fromCharCode(...n.slice(r,r+4096));self.postMessage(JSON.parse(decodeURIComponent(t)))},new((a=void 0)||(a=Promise))((function(r,i){function o(r){try{u(t.next(r))}catch(r){i(r)}}function f(r){try{u(t.throw(r))}catch(r){i(r)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof a?e:new a((function(r){r(e)}))).then(o,f)}u((t=t.apply(n,e||[])).next())}));var n,e,a,t}))})();'],{type:"text/javascript"})),ms=[];let ps=null;const xs=()=>(ps||(ps=new Worker(fs)),ps);let bs=!1;const Ts=t=>{bs=t},vs=()=>bs,Es=()=>{if(u.body.appendChild(Fi),"OffscreenCanvas"in window){const t=new OffscreenCanvas(0,0).getContext("webgl2");us=null!==t?new Worker(URL.createObjectURL(new Blob(['(()=>{"use strict";let t=1,e=0,i=!1;const s=1/0,r=Math,n=Array,a=Map,h=Number,o=Float32Array,_=Int32Array,l=Int16Array,c=OffscreenCanvas,$=isNaN,u=requestAnimationFrame,d=setTimeout,g=clearTimeout,f=new o([1,0,0,1,0,0]),m=new o([1,1,1,1,0,0,0,0]),p=r.PI/180,x=(r.PI,[]),b=[],v=[],T=[],A=[],M=[],y=[],E=[],C=new c(1,1).getContext("2d"),S=(t=0,e=0,i=0,s=0)=>{const r=E.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return r.xMin=t,r.xMax=e,r.yMin=i,r.yMax=s,r},F=t=>{E.push(t)},B=(t=0,e=0,i=0,s=0)=>{const r=b.pop()||new o(4);return r[0]=t,r[1]=e,r[2]=i,r[3]=s,r},w=t=>{b.push(t)},R=(t=0,e=0,i=0,s=0,r=0,n=0)=>{const a=v.pop()||new o(6);return a[0]=t,a[1]=e,a[2]=i,a[3]=s,a[4]=r,a[5]=n,a},I=t=>{v.push(t)},P=(t=1,e=1,i=1,s=1,r=0,n=0,a=0,h=0)=>{const _=T.pop()||new o(8);return _[0]=t,_[1]=e,_[2]=i,_[3]=s,_[4]=r,_[5]=n,_[6]=a,_[7]=h,_},N=t=>{T.push(t)},L=(t=0,e=0,i=0,s=0,r=0,n=0,a=0,h=0,_=0)=>{const l=A.pop()||new o(9);return l[0]=t,l[1]=e,l[2]=i,l[3]=s,l[4]=r,l[5]=n,l[6]=a,l[7]=h,l[8]=_,l},k=(...t)=>{const e=M.pop()||[];return t.length&&e.push(...t),e},O=(t=null)=>{t&&(t.length&&(t.length=0),M.push(t))},U=t=>{t.size&&t.clear(),y.push(t)},D=()=>y.pop()||new a,X=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),V=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return L(t[4]*e,0-t[1]*e,0,0-t[3]*e,t[0]*e,0,i*e,s*e,1)},Y=(t,e,i,s=null)=>{const n=+t;return $(n)&&null!==s?s:r.min(r.max(e,$(n)?0:n),i)},z=(t,e)=>R(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),G=(t,e)=>P(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),H=(t,e)=>{const i=t.xMax*e[0]+t.yMax*e[2]+e[4],s=t.xMax*e[0]+t.yMin*e[2]+e[4],n=t.xMin*e[0]+t.yMax*e[2]+e[4],a=t.xMin*e[0]+t.yMin*e[2]+e[4],o=t.xMax*e[1]+t.yMax*e[3]+e[5],_=t.xMax*e[1]+t.yMin*e[3]+e[5],l=t.xMin*e[1]+t.yMax*e[3]+e[5],c=t.xMin*e[1]+t.yMin*e[3]+e[5],$=r.min(h.MAX_VALUE,i,s,n,a),u=r.max(0-h.MAX_VALUE,i,s,n,a),d=r.min(h.MAX_VALUE,o,_,l,c),g=r.max(0-h.MAX_VALUE,o,_,l,c);return S($,u,d,g)},W=t=>$(+t)?(t=>{if(!C)return 0;C.fillStyle=t;const e=+`0x${C.fillStyle.slice(1)}`;return C.fillStyle="rgba(0, 0, 0, 1)",e})(`${t}`):+t,q=(t,e,i)=>(t>>16)*(i?e:1)/255,j=(t,e,i)=>(t>>8&255)*(i?e:1)/255,K=(t,e,i)=>(255&t)*(i?e:1)/255,Q=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),J=(t,e,i=!1,s=!1)=>{let r="";return i&&(r="italic "),s&&(r+="bold "),`${r}${e}px \'${t}\',\'sans-serif\'`},Z=t=>{t.color&&N(t.color),t.isLayer=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.filters=null,t.blendMode="normal",t.sw=0,t.sh=0,x.push(t)},tt=new class{constructor(){this._$pool=[],this._$store=new Map,this._$timerMap=new Map,this._$context=null}set context(t){this._$context=t}reset(){for(const t of this._$store.values()){for(const e of t.values())this.destroy(e);U(t)}this._$store.clear(),this._$context&&this._$context.frameBuffer.clearCache()}destroy(t=null){if(t&&"object"==typeof t)if(t instanceof WebGLTexture)u((()=>{this._$context&&this._$context.frameBuffer.releaseTexture(t)}));else{if("canvas"in t&&t instanceof CanvasRenderingContext2D){const e=t.canvas,i=e.width,s=e.height;t.clearRect(0,0,i+1,s+1),e.width=e.height=1,this._$pool.push(e)}this._$context&&"index"in t&&this._$context.frameBuffer.textureManager.releasePosition(t)}}getCanvas(){return this._$pool.pop()||document.createElement("canvas")}remove(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t);i.has(e)&&(i.delete(e),i.size||(U(i),this._$store.delete(t)))}stopTimer(t){t=`${t}`,this._$timerMap.has(t)&&(g(this._$timerMap.get(t)),this._$timerMap.delete(t))}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const t of e.values())this.destroy(t);e.clear(),U(e),this._$store.delete(t)}this._$timerMap.delete(t)}setRemoveTimer(t){if(t=`${t}`,this.stopTimer(t),this._$store.has(t)){const e=d((()=>{this.removeCache(t)}),5e3);this._$timerMap.set(t,e)}}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){this.stopTimer(e);const t=this._$store.get(e);if(t.has(i))return t.get(i)}return null}set(t,e=null){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,D());const r=this._$store.get(i);if(null===e){if(!r.has(s))return;return this.destroy(r.get(s)),r.delete(s),void(r.size||(U(r),this._$store.delete(i)))}r.set(s,e)}has(t){const e=`${t[0]}`;return!!this._$store.has(e)&&this._$store.get(e).has(`${t[1]}`)}generateKeys(t,e=null,i=null){let s="";e&&e.length&&(s+=`${e[0]}_${e[1]}`),i&&i.length&&(s+=0===i[7]?"":`_${i[7]}`);const r=k();if(s){let t=0;const e=s.length;for(let i=0;i<e;i++)t=(t<<5)-t+s.charCodeAt(i),t|=0;r[1]=`_${t}`}else r[1]="_0";return r[0]=`${t}`,r}};class et{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,((t=!0)=>{i=t})()}}class it extends et{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=Y(+t,0,255,0))!==this._$blurX&&(this._$blurX=t,this._$doChanged())}get blurY(){return this._$blurY}set blurY(t){(t=Y(+t,0,255,0))!==this._$blurY&&(this._$blurY=t,this._$doChanged())}get quality(){return this._$quality}set quality(t){(t=Y(0|t,0,15,1))!==this._$quality&&(this._$quality=t,this._$doChanged())}clone(){return new it(this._$blurX,this._$blurY,this._$quality)}_$toArray(){return k(1,this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=0,i=0){const s=S(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$quality)return s;const n=it.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,h=0>=this._$blurY?1:this._$blurY*n;return e?a*=e:a=r.round(a),i?h*=i:h=r.round(h),s.xMin-=a,s.xMax+=2*a,s.yMin-=h,s.yMax+=2*h,s}_$canApply(){return 0!==this._$blurX&&0!==this._$blurY}_$applyFilter(e,i,s=!0){this._$updated=!1;const n=e.frameBuffer,a=n.currentAttachment,h=n.getTextureFromCurrentAttachment();if(!this._$canApply())return s?h:n.createTextureFromCurrentAttachment();let o=r.sqrt(i[0]*i[0]+i[1]*i[1]),_=r.sqrt(i[2]*i[2]+i[3]*i[3]);o/=t,_/=t,o*=2,_*=2;const l=S(0,h.width,0,h.height),c=this._$generateFilterRect(l,o,_);F(l);const $=0|r.ceil(c.xMax),u=0|r.ceil(c.yMax),d=r.ceil(r.abs(c.xMin)+.5*r.abs($-c.xMax)),g=r.ceil(r.abs(c.yMin)+.5*r.abs(u-c.yMax));e._$offsetX=d+e._$offsetX,e._$offsetY=g+e._$offsetY;const f=this._$blurX*o,m=this._$blurY*_;let p=1,x=1;f>128?p=.0625:f>64?p=.125:f>32?p=.25:f>16&&(p=.5),m>128?x=.0625:m>64?x=.125:m>32?x=.25:m>16&&(x=.5);const b=f*p,v=m*x,T=r.ceil($*p),A=r.ceil(u*x),M=n.createTextureAttachment(T,A),y=[M,n.createTextureAttachment(T,A)];let E=0;e._$bind(M),e.reset(),e.setTransform(p,0,0,x,0,0),e.drawImage(h,d,g,h.width,h.height),e.blend.toOneZero();let C=n.getTextureFromCurrentAttachment();for(let t=0;t<this._$quality;++t){if(this._$blurX>0){E=(E+1)%2;const t=y[E];e._$bind(t),e._$applyBlurFilter(C,!0,b),C=n.getTextureFromCurrentAttachment()}if(this._$blurY>0){E=(E+1)%2;const t=y[E];e._$bind(t),e._$applyBlurFilter(C,!1,v),C=n.getTextureFromCurrentAttachment()}}if(e.blend.reset(),1!==p||1!==x){const t=n.createTextureAttachment($,u);e._$bind(t),e.reset(),e.imageSmoothingEnabled=!0,e.setTransform(1/p,0,0,1/x,0,0),e.drawImage(C,0,0,T,A),C=n.getTextureFromCurrentAttachment(),e.reset(),e.setTransform(1,0,0,1,0,0),n.releaseAttachment(y[0],!0),n.releaseAttachment(y[1],!0),s?n.releaseAttachment(a,!0):n.releaseAttachment(t,!1)}else n.releaseAttachment(y[(E+1)%2],!0),s?n.releaseAttachment(a,!0):n.releaseAttachment(y[E],!1);return C}}class st extends et{constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,h=4,o=1,_=1,l="inner",c=!1){super(),this._$blurFilter=new it(a,h,_),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=s,this.shadowColor=r,this.shadowAlpha=n,this.strength=o,this.type=l,this.knockout=c}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=Y(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=Y(+t,0,1,0))!==this._$highlightAlpha&&(this._$highlightAlpha=t,this._$doChanged())}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=Y(W(t),0,16777215,16777215))!==this._$highlightColor&&(this._$highlightColor=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=Y(+t,0,1,0))!==this._$shadowAlpha&&(this._$shadowAlpha=t,this._$doChanged())}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=Y(W(t),0,16777215,0))!==this._$shadowColor&&(this._$shadowColor=t,this._$doChanged())}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){(t=`${t}`)!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new st(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return k(0,this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=S(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=this._$angle*p;let a=r.abs(r.cos(n)*this._$distance),h=r.abs(r.sin(n)*this._$distance);return e&&(a*=e),i&&(h*=i),s.xMin=r.min(s.xMin,a),a>0&&(s.xMax+=a),s.yMin=r.min(s.yMin,h),h>0&&(s.yMax+=h),s}_$canApply(){return this._$strength>0&&0!==this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(e,i){this._$updated=!1;const s=e.frameBuffer,n=s.currentAttachment;if(!n)throw new Error("the current attachment is null.");e.setTransform(1,0,0,1,0,0);const a=s.getTextureFromCurrentAttachment();if(!this._$canApply())return a;const h=n.width,o=n.height,_=e._$offsetX,l=e._$offsetY;let c=r.sqrt(i[0]*i[0]+i[1]*i[1]),$=r.sqrt(i[2]*i[2]+i[3]*i[3]);c/=t,$/=t,c*=2,$*=2;const u=this._$angle*p,d=r.cos(u)*this._$distance*c,g=r.sin(u)*this._$distance*$,f=s.createTextureAttachment(h,o);e._$bind(f),e.reset(),e.drawImage(a,0,0,h,o),e.globalCompositeOperation="erase",e.drawImage(a,2*d,2*g,h,o);const m=this._$blurFilter._$applyFilter(e,i,!1),x=m.width,b=m.height,v=r.ceil(x+2*r.abs(d)),T=r.ceil(b+2*r.abs(g)),A="inner"===this._$type,M=A?h:v,y=A?o:T,E=r.abs(d),C=r.abs(g),S=(x-h)/2,F=(b-o)/2,B=A?0:E+S,w=A?0:C+F,R=A?-S-d:E-d,I=A?-F-g:C-g;return e._$bind(n),s.releaseAttachment(f,!0),e._$applyBitmapFilter(m,M,y,h,o,B,w,x,b,R,I,!1,this._$type,this._$knockout,this._$strength,null,null,null,q(this._$highlightColor,this._$highlightAlpha,!0),j(this._$highlightColor,this._$highlightAlpha,!0),K(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,q(this._$shadowColor,this._$shadowAlpha,!0),j(this._$shadowColor,this._$shadowAlpha,!0),K(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),e._$offsetX=_+B,e._$offsetY=l+w,s.releaseTexture(m),s.getTextureFromCurrentAttachment()}}class rt extends et{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(t&&n.isArray(t)&&20===t.length){for(let e=0;e<20;++e)if(t[e]!==this._$matrix[e]){this._$doChanged();break}this._$matrix=t}}clone(){return new rt(this._$matrix)}_$toArray(){return k(2,this._$matrix)}_$generateFilterRect(t){return t}_$canApply(){return!0}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment(),r=s.width,n=s.height,a=e.createTextureAttachment(r,n);return t._$bind(a),t.reset(),t._$applyColorMatrixFilter(s,this._$matrix),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()}}class nt extends et{constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,h=0,o=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=s,this.bias=r,this.preserveAlpha=n,this.clamp=a,this.color=h,this.alpha=o}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get bias(){return this._$bias}set bias(t){t!==this._$bias&&(this._$bias=0|t,this._$doChanged())}get clamp(){return this._$clamp}set clamp(t){t!==this._$clamp&&(this._$clamp=!!t,this._$doChanged())}get color(){return this._$color}set color(t){(t=Y(W(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get divisor(){return this._$divisor}set divisor(t){t!==this._$divisor&&(this._$divisor=0|t,this._$doChanged())}get matrix(){return this._$matrix}set matrix(t){n.isArray(this._$matrix)&&O(this._$matrix),this._$matrix=n.isArray(t)?t:null,this._$doChanged()}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|Y(0|t,0,15,0))!==this._$matrixX&&(this._$matrixX=t,this._$doChanged())}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|Y(0|t,0,15,0))!==this._$matrixY&&(this._$matrixY=t,this._$doChanged())}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){t!==this._$preserveAlpha&&(this._$preserveAlpha=!!t,this._$doChanged())}clone(){return new nt(this._$matrixX,this._$matrixY,this._$matrix?this._$matrix.slice():null,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$toArray(){return k(3,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$matrix&&this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment();return this._$canApply()&&this._$matrix?(t._$applyConvolutionFilter(s,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,q(this._$color,this._$alpha,!1),j(this._$color,this._$alpha,!1),K(this._$color,this._$alpha,!1),this._$alpha),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()):s}}class at extends et{constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",h=0,o=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode="wrap",this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=s,this.scaleX=r,this.scaleY=n,this.mode=a,this.color=h,this.alpha=o}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get color(){return this._$color}set color(t){(t=Y(W(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get componentX(){return this._$componentX}set componentX(t){t!==this._$componentX&&(this._$componentX=t,this._$doChanged())}get componentY(){return this._$componentY}set componentY(t){t!==this._$componentY&&(this._$componentY=t,this._$doChanged())}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&(this._$mapBitmap=t,this._$doChanged())}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&(this._$mapPoint=t,this._$doChanged())}get mode(){return this._$mode}set mode(t){t!==this._$mode&&(this._$mode=t,this._$doChanged())}get scaleX(){return this._$scaleX}set scaleX(t){(t=Y(+t,-65535,65535,0))!==this._$scaleX&&(this._$scaleX=t,this._$doChanged())}get scaleY(){return this._$scaleY}set scaleY(t){(t=Y(+t,-65535,65535,0))!==this._$scaleY&&(this._$scaleY=t,this._$doChanged())}clone(){return new at(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$toArray(){return k(4,this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$mapBitmap&&this._$componentX>0&&this._$componentY>0&&0!==this._$scaleX&&0!==this._$scaleY}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer,s=i.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=i.getTextureFromCurrentAttachment();if(!this._$canApply()||!s||!this._$mapBitmap)return n;const a=r.sqrt(e[0]*e[0]+e[1]*e[1]),h=r.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(n,this._$mapBitmap,n.width/a,n.height/h,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,q(this._$color,this._$alpha,!0),j(this._$color,this._$alpha,!0),K(this._$color,this._$alpha,!0),this._$alpha),i.releaseAttachment(s,!0),i.getTextureFromCurrentAttachment()}}class ht extends et{constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,h=1,o=!1,_=!1,l=!1){super(),this._$blurFilter=new it(r,n,h),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=s,this.strength=a,this.inner=o,this.knockout=_,this.hideObject=l}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=Y(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=Y(W(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get hideObject(){return this._$hideObject}set hideObject(t){t!==this._$hideObject&&(this._$hideObject=!!t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new ht(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$toArray(){return k(5,this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=S(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=this._$angle*p;let a=r.cos(n)*this._$distance,h=r.sin(n)*this._$distance;return e&&(a*=e),i&&(h*=i),s.xMin=r.min(s.xMin,a),a>0&&(s.xMax+=a),s.yMin=r.min(s.yMin,h),h>0&&(s.yMax+=h),s}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(e,i){const s=e.frameBuffer,n=s.currentAttachment;if(!n)throw new Error("the current attachment is null.");if(e.setTransform(1,0,0,1,0,0),!this._$canApply())return s.getTextureFromCurrentAttachment();const a=n.width,h=n.height,o=e._$offsetX,_=e._$offsetY,l=this._$blurFilter._$applyFilter(e,i,!1),c=l.width,$=l.height,u=e._$offsetX,d=e._$offsetY,g=u-o,f=d-_;let m=r.sqrt(i[0]*i[0]+i[1]*i[1]),x=r.sqrt(i[2]*i[2]+i[3]*i[3]);m/=t,x/=t,m*=2,x*=2;const b=this._$angle*p,v=r.cos(b)*this._$distance*m,T=r.sin(b)*this._$distance*x,A=this._$inner?a:c+r.max(0,r.abs(v)-g),M=this._$inner?h:$+r.max(0,r.abs(T)-f),y=r.ceil(A),E=r.ceil(M),C=(y-A)/2,S=(E-M)/2,F=this._$inner?0:r.max(0,g-v)+C,B=this._$inner?0:r.max(0,f-T)+S,w=this._$inner?v-u:(v>0?r.max(0,v-g):0)+C,R=this._$inner?T-d:(T>0?r.max(0,T-f):0)+S;let I,P;return this._$inner?(I="inner",P=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(I="full",P=!0):(I="outer",P=this._$knockout),e._$bind(n),e._$applyBitmapFilter(l,y,E,a,h,F,B,c,$,w,R,!0,I,P,this._$strength,null,null,null,q(this._$color,this._$alpha,!0),j(this._$color,this._$alpha,!0),K(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),e._$offsetX=o+F,e._$offsetY=_+B,s.releaseTexture(l),s.getTextureFromCurrentAttachment()}}class ot extends et{constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,h=!1){super(),this._$blurFilter=new it(i,s,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=r,this.inner=a,this.knockout=h}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=Y(W(t),0,16777215,4))!==this._$color&&(this._$color=t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new ot(this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$toArray(){return k(6,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){const s=S(t.xMin,t.xMax,t.yMin,t.yMax);return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t.frameBuffer,s=i.currentAttachment;if(!s)throw new Error("the current attachment is null.");if(this._$updated=!1,t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const r=s.width,n=s.height,a=t._$offsetX,h=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),_=o.width,l=o.height,c=t._$offsetX,$=t._$offsetY,u=this._$inner?r:_,d=this._$inner?n:l,g=this._$inner?0:c-a,f=this._$inner?0:$-h,m=this._$inner?-c:0,p=this._$inner?-$:0,x=this._$inner?"inner":"outer";return t._$bind(s),t._$applyBitmapFilter(o,u,d,r,n,g,f,_,l,m,p,!0,x,this._$knockout,this._$strength,null,null,null,q(this._$color,this._$alpha,!0),j(this._$color,this._$alpha,!0),K(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=h+f,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class _t extends et{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,_="inner",l=!1){super(),this._$blurFilter=new it(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=_,this.knockout=l}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,n.isArray(t)){for(let e=0;e<t.length;++e){const i=t[e];t[e]=Y(+i,0,1,0)}this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=Y(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,n.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(W(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,n.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new _t(this._$distance,this._$angle,this._$colors?this._$colors.slice():null,this._$alphas?this._$alphas.slice():null,this._$ratios?this._$ratios.slice():null,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return k(7,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=S(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=this._$angle*p;let a=r.abs(r.cos(n)*this._$distance),h=r.abs(r.sin(n)*this._$distance);return e&&(a*=e),i&&(h*=i),s.xMin=r.min(s.xMin,a),a>0&&(s.xMax+=a),s.yMin=r.min(s.yMin,h),h>0&&(s.yMax+=h),s}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(e,i){this._$updated=!1;const s=e.frameBuffer,n=s.currentAttachment;e.setTransform(1,0,0,1,0,0);const a=s.getTextureFromCurrentAttachment();if(!this._$canApply()||!n)return a;const h=n.width,o=n.height,_=e._$offsetX,l=e._$offsetY;let c=r.sqrt(i[0]*i[0]+i[1]*i[1]),$=r.sqrt(i[2]*i[2]+i[3]*i[3]);c/=t,$/=t,c*=2,$*=2;const u=+this._$angle*p,d=+r.cos(u)*this._$distance*c,g=+r.sin(u)*this._$distance*$,f=s.createTextureAttachment(h,o);e._$bind(f),e.reset(),e.drawImage(a,0,0,h,o),e.globalCompositeOperation="erase",e.drawImage(a,2*d,2*g,h,o);const m=this._$blurFilter._$applyFilter(e,i,!1),x=m.width,b=m.height,v=r.ceil(x+2*r.abs(d)),T=r.ceil(b+2*r.abs(g)),A="inner"===this._$type,M=A?h:v,y=A?o:T,E=r.abs(d),C=r.abs(g),S=(x-h)/2,F=(b-o)/2,B=A?0:E+S,w=A?0:C+F,R=A?-S-d:E-d,I=A?-F-g:C-g;return e._$bind(n),e._$applyBitmapFilter(m,M,y,h,o,B,w,x,b,R,I,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),e._$offsetX=_+B,e._$offsetY=l+w,s.releaseAttachment(f,!0),s.getTextureFromCurrentAttachment()}}class lt extends et{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,_="inner",l=!1){super(),this._$blurFilter=new it(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=_,this.knockout=l}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,n.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(+t[e],0,1,0);this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=Y(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,n.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(W(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,n.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new lt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return k(8,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){let s=S(t.xMin,t.xMax,t.yMin,t.yMax);if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=this._$angle*p;let a=r.abs(r.cos(n)*this._$distance),h=r.abs(r.sin(n)*this._$distance);return e&&(a*=e),i&&(h*=i),s.xMin=r.min(s.xMin,a),a>0&&(s.xMax+=a),s.yMin=r.min(s.yMin,h),h>0&&(s.yMax+=h),s}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(e,i){this._$updated=!1;const s=e.frameBuffer,n=s.currentAttachment;if(e.setTransform(1,0,0,1,0,0),!this._$canApply()||!n)return s.getTextureFromCurrentAttachment();const a=n.width,h=n.height,o=e._$offsetX,_=e._$offsetY,l=this._$blurFilter._$applyFilter(e,i,!1),c=l.width,$=l.height,u=e._$offsetX,d=e._$offsetY,g=u-o,f=d-_;let m=r.sqrt(i[0]*i[0]+i[1]*i[1]),x=r.sqrt(i[2]*i[2]+i[3]*i[3]);m/=t,x/=t,m*=2,x*=2;const b=+this._$angle*p,v=+r.cos(b)*this._$distance*m,T=+r.sin(b)*this._$distance*x,A="inner"===this.type,M=A?a:c+r.max(0,r.abs(v)-g),y=A?h:$+r.max(0,r.abs(T)-f),E=r.ceil(M),C=r.ceil(y),S=(E-M)/2,F=(C-y)/2,B=A?0:r.max(0,g-v)+S,w=A?0:r.max(0,f-T)+F,R=A?v-u:(v>0?r.max(0,v-g):0)+S,I=A?T-d:(T>0?r.max(0,T-f):0)+F;return e._$bind(n),e._$applyBitmapFilter(l,E,C,a,h,B,w,c,$,R,I,!0,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),e._$offsetX=o+B,e._$offsetY=_+w,s.releaseTexture(l),s.getTextureFromCurrentAttachment()}}class ct{constructor(){this._$instanceId=-1,this._$parentId=-1,this._$loaderInfoId=-1,this._$characterId=-1,this._$clipDepth=0,this._$depth=0,this._$isMask=!1,this._$updated=!0,this._$matrix=R(1,0,0,1,0,0),this._$colorTransform=P(1,1,1,1,0,0,0,0),this._$blendMode="normal",this._$filters=null,this._$visible=!0,this._$maskId=-1,this._$maskMatrix=null,this._$isMask=!1,this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$scale9Grid=null,this._$matrixBase=null}_$shouldClip(t){const e=this._$getBounds(t),i=r.abs(e.xMax-e.xMin),s=r.abs(e.yMax-e.yMin);return F(e),!(!i||!s)}_$getLayerBounds(e){const i=this._$getBounds(),s=H(i,e);F(i);const n=this._$filters;if(!n||!n.length)return s;let a=S(0,r.abs(s.xMax-s.xMin),0,r.abs(s.yMax-s.yMin));F(s);let h=+r.sqrt(e[0]*e[0]+e[1]*e[1]),o=+r.sqrt(e[2]*e[2]+e[3]*e[3]);h/=t,o/=t,h*=2,o*=2;for(let t=0;t<n.length;++t)a=n[t]._$generateFilterRect(a,h,o);return a}_$getBounds(t=null){const e=S(this._$xMin,this._$xMax,this._$yMin,this._$yMax);if(!t)return e;let i=t;const s=this._$matrix;1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=z(t,s));const r=H(e,i);return F(e),i!==t&&I(i),r}_$startClip(t,e){t.drawInstacedArray();const i=this._$getBounds(e),s=t._$startClip(i);if(F(i),!s)return!1;t._$enterClip(),t._$beginClipDef();let r=!1;return"_$children"in this&&(r=!0,t._$updateContainerClipFlag(!0)),this._$clip(t,e),this._$updated=!1,r&&(t._$updateContainerClipFlag(!1),t._$drawContainerClip()),t._$endClipDef(),!0}_$doChanged(){if(this._$updated=!0,this._$parentId>-1){const t=ae.instances;if(!t.has(this._$parentId))return;const e=t.get(this._$parentId);e._$updated||e._$doChanged()}}_$update(t){if(this._$doChanged(),this._$visible=t.visible,"depth"in t&&(this._$depth=t.depth),"isMask"in t&&(this._$isMask=t.isMask),"clipDepth"in t&&(this._$clipDepth=t.clipDepth),"maskId"in t&&(this._$maskId=t.maskId,this._$maskId>-1&&t.maskMatrix&&(this._$maskMatrix=t.maskMatrix)),this._$matrix[0]="a"in t?t.a:1,this._$matrix[1]="b"in t?t.b:0,this._$matrix[2]="c"in t?t.c:0,this._$matrix[3]="d"in t?t.d:1,this._$matrix[4]="tx"in t?t.tx:0,this._$matrix[5]="ty"in t?t.ty:0,this._$colorTransform[0]="f0"in t?t.f0:1,this._$colorTransform[1]="f1"in t?t.f1:1,this._$colorTransform[2]="f2"in t?t.f2:1,this._$colorTransform[3]="f3"in t?t.f3:1,this._$colorTransform[4]="f4"in t?t.f4:0,this._$colorTransform[5]="f5"in t?t.f5:0,this._$colorTransform[6]="f6"in t?t.f6:0,this._$colorTransform[7]="f7"in t?t.f7:0,this._$blendMode=t.blendMode||"normal",this._$filters=null,t.filters&&t.filters.length){this._$filters=k();for(let e=0;e<t.filters.length;++e){const i=t.filters[e];switch(i.shift()){case 0:this._$filters.push(new st(...i));break;case 1:this._$filters.push(new it(...i));break;case 2:this._$filters.push(new rt(...i));break;case 3:this._$filters.push(new nt(...i));break;case 4:this._$filters.push(new at(...i));break;case 5:this._$filters.push(new ht(...i));break;case 6:this._$filters.push(new ot(...i));break;case 7:this._$filters.push(new _t(...i));break;case 8:this._$filters.push(new lt(...i))}}}t.grid&&(this._$scale9Grid=t.grid,t.matrixBase&&(this._$matrixBase=t.matrixBase))}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$remove(){this._$doChanged();const t=ae;tt.setRemoveTimer(this._$instanceId),this._$loaderInfoId>-1&&this._$characterId&&tt.setRemoveTimer(`${this._$loaderInfoId}@${this._$characterId}`),t.instances.delete(this._$instanceId),this._$instanceId=-1,this._$parentId=-1,this._$loaderInfoId=-1,this._$characterId=-1,this._$blendMode="normal",this._$filters=null,this._$visible=!0,this._$maskId=-1,this._$isMask=!1,this._$depth=0,this._$clipDepth=0,this._$scale9Grid=null}_$isUpdated(){return this._$updated}_$isFilterUpdated(t,e=null,i=!1){if(this._$isUpdated())return!0;if(i&&e)for(let t=0;t<e.length;++t)if(e[t]._$isUpdated())return!0;const s=tt.get([this._$instanceId,"f"]);return!s||s.filterState!==i||s.matrix!==`${t[0]}_${t[1]}_${t[2]}_${t[3]}`}_$applyFilter(t,e,i,s,n,a){const h=+r.sqrt(s[0]*s[0]+s[1]*s[1]),o=+r.sqrt(s[2]*s[2]+s[3]*s[3]),_=r.atan2(s[1],s[0]),l=r.atan2(0-s[2],s[3]),c=R(r.cos(_),r.sin(_),0-r.sin(l),r.cos(l),n/2,a/2),$=R(1,0,0,1,0-i.width/2,0-i.height/2),u=z(c,$);I(c),I($);const d=t.frameBuffer,g=d.currentAttachment,f=d.createCacheAttachment(n,a);t._$bind(f),t.reset(),t.setTransform(u[0],u[1],u[2],u[3],u[4],u[5]),I(u),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;const m=R(h,0,0,o,0,0);let p=null;for(let i=0;i<e.length;++i)p=e[i]._$applyFilter(t,m);if(I(m),!p)return i;const x=t._$offsetX,b=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,p.offsetX=x,p.offsetY=b,p.matrix=s[0]+"_"+s[1]+"_"+s[2]+"_"+s[3],p.filterState=!0,t._$bind(g),d.releaseAttachment(f,!1),p}_$drawFilter(t,e,i,s,n,a=null){const h=k(this._$instanceId,"f");let o=tt.get(h);const _=this._$isFilterUpdated(e,i,!0);if(o&&!_)return t.cachePosition=o,o;o&&tt.set(h,null);const l=t.frameBuffer,c=a||t.getTextureFromRect(t.cachePosition),$=this._$applyFilter(t,i,c,e,s,n);l.textureManager.release(c);const u=this._$getLayerBounds(e);return o=l.createCachePosition(r.ceil(r.abs(u.xMax-u.xMin)),r.ceil(r.abs(u.yMax-u.yMin))),F(u),o.filterState=!0,o.matrix=`${e[0]}_${e[1]}_${e[2]}_${e[3]}_0_0`,o.offsetX=$.offsetX,o.offsetY=$.offsetY,t.drawTextureFromRect($,o),tt.set(h,o),O(h),o}}class $t extends ct{constructor(){super(),this._$recodes=null,this._$maxAlpha=0,this._$canDraw=!1,this._$uniqueKey="",this._$cacheKeys=k(),this._$cacheParams=k(0,0,0),this._$bitmapId=0,this._$mode="shape"}_$clip(t,e){if(!this._$recodes)return;const i=this._$getBounds(),n=H(i,e);F(i);const a=r.ceil(r.abs(n.xMax-n.xMin)),h=r.ceil(r.abs(n.yMax-n.yMin));switch(F(n),!0){case 0===a:case 0===h:case a===-1/0:case h===-1/0:case a===s:case h===s:return}t.reset(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,this._$recodes,null,!0),t.clip()}_$createCacheKey(){if(!this._$recodes)return"";let t=0;for(let e=0;e<this._$recodes.length;e++)t=(t<<5)-t+this._$recodes[e],t|=0;return`${t}`}_$createBitmapTexture(t,e,i,s,r,n){if("bitmap"!==this._$mode)return null;t.drawInstacedArray();const a=t.frameBuffer,h=a.currentAttachment,o=a.createCacheAttachment(r,n);t._$bind(o),t.reset();const _=R(i,0,0,s,r/2,n/2),l=t.getTextureFromRect(e),c=R(1,0,0,1,-l.width/2,-l.height/2),$=z(_,c);I(_),I(c),t.setTransform($[0],$[1],$[2],$[3],$[4],$[5]),t.drawImage(l,0,0,l.width,l.height);const u=a.getTextureFromCurrentAttachment();return t._$bind(h),a.releaseAttachment(o),a.textureManager.release(l),u}_$draw(t,e,i,n="normal",a=null){if(!(this._$visible&&this._$recodes&&this._$maxAlpha&&this._$canDraw))return;const o=Y(i[3]+i[7]/255,0,1,0);if(!o)return;const _=this._$matrix;let l=null!==this._$scale9Grid;l&&(l=l&&r.abs(_[1])<.001&&r.abs(_[2])<1e-4);const c=S(this._$xMin,this._$xMax,this._$yMin,this._$yMax),$=H(c,e),u=$.xMax,d=$.xMin,g=$.yMax,f=$.yMin;F($);const m=r.ceil(r.abs(u-d)),p=r.ceil(r.abs(g-f));switch(!0){case 0===m:case 0===p:case m===-1/0:case p===-1/0:case m===s:case p===s:return}let x=+r.sqrt(e[0]*e[0]+e[1]*e[1]);if(!h.isInteger(x)){const t=x.toString(),e=t.indexOf("e");-1!==e&&(x=+t.slice(0,e)),x=+x.toFixed(4)}let b=+r.sqrt(e[2]*e[2]+e[3]*e[3]);if(!h.isInteger(b)){const t=b.toString(),e=t.indexOf("e");-1!==e&&(b=+t.slice(0,e)),b=+b.toFixed(4)}const v=null!==a&&a.length>0&&this._$canApply(a);let T=S(0,m,0,p);if(v&&a)for(let t=0;t<a.length;++t)T=a[t]._$generateFilterRect(T,x,b);const A=t.frameBuffer,M=A.currentAttachment;if(!M||d-T.xMin>M.width||f-T.yMin>M.height)return void F(T);if(0>d+T.xMax||0>f+T.yMax)return void F(T);if(F(T),""===this._$uniqueKey&&(!l&&this._$loaderInfoId>-1&&this._$characterId>-1?this._$uniqueKey=`${this._$loaderInfoId}@${this._$characterId}`:this._$uniqueKey=this._$createCacheKey()),"bitmap"===this._$mode)this._$cacheKeys.length||(this._$cacheKeys=tt.generateKeys(this._$uniqueKey));else if(!this._$cacheKeys.length||this._$cacheParams[0]!==x||this._$cacheParams[1]!==b||this._$cacheParams[2]!==i[7]){const t=k();t[0]=x,t[1]=b,this._$cacheKeys=tt.generateKeys(this._$uniqueKey,t,i),O(t),this._$cacheParams[0]=x,this._$cacheParams[1]=b,this._$cacheParams[2]=i[7]}if(t.cachePosition=tt.get(this._$cacheKeys),!t.cachePosition){const s=A.currentAttachment;s&&s.mask&&t.stopStencil();let n=0,a=0;if("shape"===this._$mode){n=r.ceil(r.abs(c.xMax-c.xMin)*x),a=r.ceil(r.abs(c.yMax-c.yMin)*b);const e=t._$getTextureScale(n,a);e<1&&(n*=e,a*=e)}else n=r.ceil(r.abs(c.xMax-c.xMin)),a=r.ceil(r.abs(c.yMax-c.yMin));if(t.cachePosition=A.createCachePosition(n,a),t.bindRenderBuffer(t.cachePosition),t.reset(),"shape"===this._$mode?t.setTransform(x,0,0,b,-c.xMin*x,-c.yMin*b):t.setTransform(1,0,0,1,-c.xMin,-c.yMin),l){const i=ae.scaleX,s=R(i,0,0,i,0,0),n=z(s,_);I(s);const a=this._$matrixBase,h=R(a[0],a[1],a[2],a[3],a[4]*i-d,a[5]*i-f),o=z(h,n),l=o[4]-(e[4]-d),$=o[5]-(e[5]-f);I(o);const u=H(c,n),g=+u.xMax,m=+u.xMin,p=+u.yMax,x=+u.yMin,b=r.ceil(r.abs(g-m)),v=r.ceil(r.abs(p-x));F(u),t.grid.enable(m,x,b,v,c,this._$scale9Grid,i,n[0],n[1],n[2],n[3],n[4],n[5],h[0],h[1],h[2],h[3],h[4]-l,h[5]-$),I(n),I(h)}this._$runCommand(t,this._$recodes,i,!1),l&&t.grid.disable(),A.transferTexture(t.cachePosition),tt.set(this._$cacheKeys,t.cachePosition),t._$bind(s)}let y=0,E=0;if(v&&a){const i=this._$createBitmapTexture(t,t.cachePosition,x,b,m,p),s=this._$drawFilter(t,e,a,m,p,i);s.offsetX&&(y=s.offsetX),s.offsetY&&(E=s.offsetY),t.cachePosition=s}if(v||"bitmap"!==this._$mode){const i=r.atan2(e[1],e[0]),s=r.atan2(-e[2],e[3]);if(v||!i&&!s)t.setTransform(1,0,0,1,d-y,f-E);else{const n=c.xMin*x,a=c.yMin*b,h=r.cos(i),o=r.sin(i),_=r.cos(s),l=r.sin(s);t.setTransform(h,o,-l,_,n*h-a*l+e[4],n*o+a*_+e[5])}}else t.setTransform(e[0],e[1],e[2],e[3],c.xMin*e[0]+c.yMin*e[2]+e[4],c.xMin*e[1]+c.yMin*e[3]+e[5]);t.cachePosition&&(t.globalAlpha=o,t.imageSmoothingEnabled="shape"===this._$mode,t.globalCompositeOperation=n,t.drawInstance(d-y,f-E,u,g,i),t.cachePosition=null),F(c)}setupStroke(t,e,i,s,r){switch(t.lineWidth=e,i){case 0:t.lineCap="none";break;case 1:t.lineCap="round";break;case 2:t.lineCap="square"}switch(s){case 0:t.lineJoin="bevel";break;case 1:t.lineJoin="miter";break;case 2:t.lineJoin="round"}t.miterLimit=r}createGradientStyle(t,e,i,s,n,a,h,o=null){let _,l="pad";switch(n){case 0:l="reflect";break;case 1:l="repeat"}if(0===e){const e=(t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],s=-819.2*t[0]+819.2*t[2]+t[4],n=-819.2*t[1]-819.2*t[3]+t[5],a=819.2*t[1]-819.2*t[3]+t[5];let h=s-e,o=-819.2*t[1]+819.2*t[3]+t[5]-n;const _=r.sqrt(h*h+o*o);_?(h/=_,o/=_):(h=0,o=0);const l=(i-e)*h+(a-n)*o;return B(e+l*h,n+l*o,i,a)})(s);_=t.createLinearGradient(e[0],e[1],e[2],e[3],a?"rgb":"linearRGB",l)}else t.save(),t.transform(s[0],s[1],s[2],s[3],s[4],s[5]),_=t.createRadialGradient(0,0,0,0,0,819.2,a?"rgb":"linearRGB",l,h);for(let t=0;t<i.length;++t){const e=i[t];let s=e.A;o&&(1===o[3]&&0===o[7]||(s=0|r.max(0,r.min(e.A*o[3]+o[7],255)))),_.addColorStop(e.ratio,B(e.R,e.G,e.B,s))}return _}_$runCommand(t,e,i=null,s=!1){t.reset(),t.beginPath();const n=e.length;for(let a=0;a<n;)switch(e[a++]){case 9:t.beginPath();break;case 0:t.moveTo(e[a++],e[a++]);break;case 2:t.lineTo(e[a++],e[a++]);break;case 1:t.quadraticCurveTo(e[a++],e[a++],e[a++],e[a++]);break;case 5:{if(s){a+=4;continue}const n=B();n[0]=e[a++]/255,n[1]=e[a++]/255,n[2]=e[a++]/255,n[3]=e[a++]/255,null!==i&&(1===i[3]&&0===i[7]||(n[3]=r.max(0,r.min(n[3]*i[3]+i[7],255))/255)),t.fillStyle=n}break;case 7:s||t.fill();break;case 6:{if(s){a+=8;continue}this.setupStroke(t,e[a++],e[a++],e[a++],e[a++]);const n=B();n[0]=e[a++]/255,n[1]=e[a++]/255,n[2]=e[a++]/255,n[3]=e[a++]/255,null!==i&&(1===i[3]&&0===i[7]||(n[3]=r.max(0,r.min(n[3]*i[3]+i[7],255))/255)),t.strokeStyle=n}break;case 8:s||t.stroke();break;case 12:t.closePath();break;case 3:t.bezierCurveTo(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);break;case 4:t.arc(e[a++],e[a++],e[a++]);break;case 10:{if(s){a+=1;const t=e[a++];a+=5*t,a+=9;continue}const r=e[a++];let n=e[a++];const h=k();for(;n;)h.push({ratio:e[a++],R:e[a++],G:e[a++],B:e[a++],A:e[a++]}),n--;const o=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);t.fillStyle=this.createGradientStyle(t,r,h,o,e[a++],e[a++],e[a++],i),t.fill(),1===r&&t.restore(),I(o),O(h)}break;case 11:{if(s){a+=5;const t=e[a++];a+=5*t,a+=9;continue}this.setupStroke(t,e[a++],e[a++],e[a++],e[a++]);const r=e[a++];let n=e[a++];const h=k();for(;n;)h.push({ratio:e[a++],R:e[a++],G:e[a++],B:e[a++],A:e[a++]}),n--;const o=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);t.strokeStyle=this.createGradientStyle(t,r,h,o,e[a++],e[a++],e[a++],i),t.stroke(),1===r&&t.restore(),I(o),O(h)}break;case 13:{const r=e[a++],n=e[a++],h=e[a++],o=e[a++],_=e[a++];if(s){a+=_,a+=8;continue}const l=new Uint8Array(e.subarray(a,_+a));a+=_;const c=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]),$=!!e[a++],u=!!e[a++];t.save(),1===c[0]&&0===c[1]&&0===c[2]&&1===c[3]&&0===c[4]&&0===c[5]||t.transform(c[0],c[1],c[2],c[3],c[4],c[5]),I(c);const d=t.frameBuffer,g=d.createTextureFromPixels(r,n,l,!0);$||r!==h||n!==o?(t.fillStyle=t.createPattern(g,$,i||P()),t.imageSmoothingEnabled=u,t.fill()):(t.drawImage(g,0,0,r,n),d.releaseTexture(g)),t.restore(),t.imageSmoothingEnabled=!1}break;case 14:{if(s){a+=4;const t=e[a++];a+=t,a+=8;continue}t.save(),this.setupStroke(t,e[a++],e[a++],e[a++],e[a++]);const r=e[a++],n=e[a++],h=e[a++],o=new Uint8Array(e.subarray(a,h+a));a+=h;const _=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||t.transform(_[0],_[1],_[2],_[3],_[4],_[5]),I(_);const l=!!e[a++],c=!!e[a++],$=t.frameBuffer.createTextureFromPixels(r,n,o,!0);t.strokeStyle=t.createPattern($,l,i||P()),t.imageSmoothingEnabled=c,t.stroke(),t.restore(),t.imageSmoothingEnabled=!1}}}_$update(t){super._$update(t),t.recodes&&(this._$recodes=t.recodes,this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,this._$maxAlpha=t.maxAlpha,this._$canDraw=t.canDraw,tt.removeCache(this._$instanceId),this._$loaderInfoId>-1&&this._$characterId>-1&&tt.removeCache(`${this._$loaderInfoId}@${this._$characterId}`))}}class ut extends $t{constructor(){super(),this._$children=k()}_$clip(t,e){let i=e;const s=this._$matrix;1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=z(e,s)),this._$recodes&&this._$canDraw&&super._$clip(t,i);const r=ae.instances,n=this._$children;for(let e=0;e<this._$children.length;++e){const s=n[e];if(!r.has(s))continue;const a=r.get(s);a&&!a._$isMask&&(a._$clip(t,i),a._$updated=!1)}i!==e&&I(i)}_$draw(t,e,i){if(!this._$visible)return;let s=i;const r=this._$colorTransform;if(1===r[0]&&1===r[1]&&1===r[2]&&1===r[3]&&0===r[4]&&0===r[5]&&0===r[6]&&0===r[7]||(s=G(i,r)),!Y(s[3]+s[7]/255,0,1,0))return;const n=this._$children,a=n.length;if(!(a||this._$recodes&&this._$canDraw))return;const h=this._$preDraw(t,e);if(!h)return;if(h.isLayer&&!h.isUpdated)return void this._$postDraw(t,e,s,h);const o=h.matrix,_=h.isLayer&&h.color?h.color:s;this._$recodes&&this._$canDraw&&this._$maxAlpha>0&&super._$draw(t,o,_);let l=!0,c=0;const $=ae.instances,u=t.isLayer;for(let e=0;e<a;++e){const i=n[e];if(!$.has(i))continue;const s=$.get(i);if(s._$isMask)continue;const r=s._$blendMode;if(("alpha"===r||"erase"===r)&&!u)continue;if(c&&(s._$depth>c||s._$clipDepth>0)&&(t.restore(),l&&t._$leaveClip(),c=0,l=!0),!l)continue;if(s._$clipDepth>0){c=s._$clipDepth,l=s._$shouldClip(o),l&&(t.save(),l=s._$startClip(t,o));continue}const a=s._$maskId>-1&&$.has(s._$maskId)?$.get(s._$maskId):null;if(a){let e;if(a._$updated=!1,this._$instanceId===a._$parentId)e=o;else{e=f;let i=$.get(a._$parentId);for(;i||i._$instanceId!==i._$parentId;)e=z(i._$matrix,e),i=$.get(i._$parentId);const s=ae.scaleX,r=R(s,0,0,s,0,0);if(e=z(r,e),I(r),t.isLayer){const i=t.getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}}if(!a._$shouldClip(e))continue;const i=a._$startClip(t,e);if(t.save(),!i){t.restore();continue}}s._$draw(t,o,_),s._$updated=!1,a&&(t.restore(),t._$leaveClip())}if(c&&(t.restore(),l&&t._$leaveClip()),h.isLayer)return this._$postDraw(t,e,s,h);h.matrix!==e&&I(h.matrix),s!==i&&N(s),Z(h)}_$getLayerBounds(e){const i=!!this._$recodes,s=this._$children;if(!s.length&&!i)return S(0,0,0,0);const n=h.MAX_VALUE;let a=n,o=-n,_=n,l=-n;if(i){const t=S(this._$xMin,this._$xMax,this._$yMin,this._$yMax),i=H(t,e);F(t),a=+i.xMin,o=+i.xMax,_=+i.yMin,l=+i.yMax,F(i)}const c=ae.instances;for(let t=0;t<s.length;++t){const i=s[t];if(!c.has(i))continue;const n=c.get(i);let h=e;const $=n._$matrix;1===$[0]&&0===$[1]&&0===$[2]&&1===$[3]&&0===$[4]&&0===$[5]||(h=z(e,$));const u=n._$getLayerBounds(h);a=r.min(a,u.xMin),o=r.max(o,u.xMax),_=r.min(_,u.yMin),l=r.max(l,u.yMax),F(u),h!==e&&I(h)}if(!this._$filters||!this._$filters.length)return S(a,o,_,l);let $=S(0,o-a,0,l-_),u=+r.sqrt(e[0]*e[0]+e[1]*e[1]),d=+r.sqrt(e[2]*e[2]+e[3]*e[3]);u/=t,d/=t,u*=2,d*=2;for(let t=0;t<this._$filters.length;++t)$=this._$filters[t]._$generateFilterRect($,u,d);return o+=$.xMax-(o-a),l+=$.yMax-(l-_),a+=$.xMin,_+=$.yMin,F($),S(a,o,_,l)}_$getBounds(t=null){let e=f;if(t){e=t;const i=this._$matrix;1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=z(t,i))}const i=!!this._$recodes,s=this._$children;if(!s.length&&!i){const i=S(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&I(e),i}const n=h.MAX_VALUE;let a=n,o=-n,_=n,l=-n;if(i){const t=S(this._$xMin,this._$xMax,this._$yMin,this._$yMax);F(t);const i=H(t,e);a=i.xMin,o=i.xMax,_=i.yMin,l=i.yMax,F(i)}const c=ae.instances;for(let t=0;t<s.length;++t){const i=s[t];if(!c.has(i))continue;const n=c.get(i)._$getBounds(e);a=r.min(a,n.xMin),o=r.max(o,n.xMax),_=r.min(_,n.yMin),l=r.max(l,n.yMax),F(n)}return t&&e!==t&&I(e),S(a,o,_,l)}_$preDraw(t,e){let i=e;const s=this._$matrix;if(1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=z(e,s)),!i[0]&&!i[1]||!i[2]&&!i[3])return null;const n=x.pop()||{isLayer:!1,isUpdated:null,canApply:null,matrix:null,color:null,blendMode:"normal",filters:null,sw:0,sh:0};n.matrix=i;const a=this._$blendMode;if("normal"!==a||this._$filters&&this._$filters.length>0){const s=this._$getBounds(null),o=H(s,i);F(s);const _=+o.xMax,l=+o.xMin,c=+o.yMax,$=+o.yMin;F(o);const u=r.ceil(r.abs(_-l)),d=r.ceil(r.abs(c-$));if(0>=u||0>=d)return Z(n),i!==e&&I(i),null;let g=+r.sqrt(i[0]*i[0]+i[1]*i[1]);if(!h.isInteger(g)){const t=g.toString(),e=t.indexOf("e");-1!==e&&(g=+t.slice(0,e)),g=+g.toFixed(4)}let f=+r.sqrt(i[2]*i[2]+i[3]*i[3]);if(!h.isInteger(f)){const t=f.toString(),e=t.indexOf("e");-1!==e&&(f=+t.slice(0,e)),f=+f.toFixed(4)}n.canApply=this._$canApply(this._$filters);let m=S(0,u,0,d);if(n.canApply&&this._$filters)for(let t=0;t<this._$filters.length;++t)m=this._$filters[t]._$generateFilterRect(m,g,f);const p=t.frameBuffer.currentAttachment;if(!p||!p.texture||l-m.xMin>p.width||$-m.yMin>p.height)return F(m),Z(n),i!==e&&I(i),null;if(0>l+m.xMax||0>$+m.yMax)return F(m),Z(n),i!==e&&I(i),null;let x=i[4]-l,b=i[5]-$;t._$startLayer(S(l,_,$,c));const v=this._$isFilterUpdated(i,this._$filters,n.canApply),T=this._$getLayerBounds(i),A=r.ceil(r.abs(T.xMax-T.xMin)),M=r.ceil(r.abs(T.yMax-T.yMin));F(T);const y=A-m.xMax+m.xMin,E=M-m.yMax+m.yMin;x+=y,b+=E,n.sw=y,n.sh=E,v&&t._$saveAttachment(r.ceil(u+y),r.ceil(d+E),!0),n.isLayer=!0,n.isUpdated=v,n.filters=this._$filters,n.blendMode=a,n.color=P(),n.matrix=R(i[0],i[1],i[2],i[3],x,b),i!==e&&I(i),F(m)}return n}_$postDraw(t,e,i,s){t.drawInstacedArray();const r=k(this._$instanceId,"f"),n=t.frameBuffer,a=s.matrix;let h=0,o=0,_=tt.get(r);if(!_||s.isUpdated){_&&tt.set(r,null),_=n.getTextureFromCurrentAttachment();const i=s.filters;let l=!1;if(i&&i.length){for(let s=0;s<i.length;++s)_=i[s]._$applyFilter(t,e);l=!0,h=t._$offsetX,o=t._$offsetY,t._$offsetX=0,t._$offsetY=0}_.filterState=l,_.matrix=`${a[0]}_${a[1]}_${a[2]}_${a[3]}`,_.offsetX=h,_.offsetY=o,tt.set(r,_),t._$restoreAttachment()}_.offsetX&&(h=_.offsetX),_.offsetY&&(o=_.offsetY),t.reset(),t.globalAlpha=Y(i[3]+i[7]/255,0,1),t.globalCompositeOperation=s.blendMode;const l=t.getCurrentPosition();t.setTransform(1,0,0,1,l.xMin-h-s.sw,l.yMin-o-s.sh),t.drawImage(_,0,0,_.width,_.height,i),t._$endLayer(),t._$endLayer(),I(s.matrix),Z(s),t.cachePosition=null}_$remove(){this._$children.length=0,this._$recodes=null,super._$remove(),_e.push(this)}}class dt{constructor(){this._$rgb="rgb",this._$mode="pad",this._$type="linear",this._$focalPointRatio=0,this._$points=R(),this._$stops=k()}dispose(){const t=this._$stops;for(let e=0;e<t.length;++e)w(t[e][1]);I(this._$points)}get mode(){return this._$mode}get type(){return this._$type}get rgb(){return this._$rgb}get points(){return this._$points}get focalPointRatio(){return this._$focalPointRatio}get stops(){return this._$stops.sort(((t,e)=>{switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}})),this._$stops}linear(t,e,i,s,r="rgb",n="pad"){return this._$type="linear",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,r,n,a="rgb",h="pad",o=0){return this._$type="radial",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=r,this._$points[5]=n,this._$rgb=a,this._$mode=h,this._$focalPointRatio=Y(o,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push(k(t,e))}}class gt{constructor(t,e,i,s){this._$context=t,this._$texture=e,this._$repeat=i,this._$colorTransform=s}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$colorTransform}}class ft{constructor(){this._$fillStyle=B(1,1,1,1),this._$strokeStyle=B(1,1,1,1),this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5}get miterLimit(){return this._$miterLimit}set miterLimit(t){this._$miterLimit=t}get lineWidth(){return this._$lineWidth}set lineWidth(t){this._$lineWidth=t}get lineCap(){return this._$lineCap}set lineCap(t){this._$lineCap=t}get lineJoin(){return this._$lineJoin}set lineJoin(t){this._$lineJoin=t}get fillStyle(){return this._$fillStyle}set fillStyle(t){this._$fillStyle instanceof o&&w(this._$fillStyle),this._$fillStyle=t}get strokeStyle(){return this._$strokeStyle}set strokeStyle(t){this._$strokeStyle instanceof o&&w(this._$strokeStyle),this._$strokeStyle=t}clear(){this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5,this._$clearFill(),this._$clearStroke()}_$clearFill(){if(this._$fillStyle instanceof dt)return this._$fillStyle.dispose(),void(this._$fillStyle=B(1,1,1,1));this._$fillStyle instanceof gt?this._$fillStyle=B(1,1,1,1):this._$fillStyle.fill(1)}_$clearStroke(){if(this._$strokeStyle instanceof dt)return this._$strokeStyle.dispose(),void(this._$strokeStyle=B(1,1,1,1));this._$strokeStyle instanceof gt?this._$strokeStyle=B(1,1,1,1):this._$strokeStyle.fill(1)}}const mt=4096;class pt{constructor(t){t.pixelStorei(t.UNPACK_ALIGNMENT,1),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$atlasTextures=[],this._$atlasCacheMap=new Map,this._$positionObjectArray=[],this._$nodeObjectArray=[],this._$atlasNodes=new Map}createTextureAtlas(){const t=this._$gl.createTexture();t.width=mt,t.height=mt,this._$gl.activeTexture(this._$gl.TEXTURE3),this._$gl.bindTexture(this._$gl.TEXTURE_2D,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST),this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,mt,mt),this._$gl.bindTexture(this._$gl.TEXTURE_2D,null),this._$activeTexture>-1&&this._$gl.activeTexture(this._$activeTexture);const e=this._$atlasTextures.length;this._$atlasNodes.set(e,[]),this._$atlasCacheMap.set(e,[]),this._$atlasTextures.push(t)}getAtlasTexture(t){return this._$atlasTextures[t]}getNode(t,e,i,s){const r=this._$nodeObjectArray.length?this._$nodeObjectArray.pop():{x:0,y:0,w:0,h:0};return r.x=t,r.y=e,r.w=i,r.h=s,r}createCachePosition(t,e){const i=this._$positionObjectArray.length?this._$positionObjectArray.pop():{index:0,x:0,y:0,w:0,h:0};i.x=i.y=0,i.w=t,i.h=e;for(const[s,r]of this._$atlasNodes){if(!r.length)return t>e?(mt-t-1>0&&r.push(this.getNode(t+1,0,mt-t-1,e)),mt-e-1>0&&r.push(this.getNode(0,e+1,mt,mt-e-1))):(mt-e-1>0&&r.push(this.getNode(0,e+1,t,mt-e-1)),mt-t-1>0&&r.push(this.getNode(t+1,0,mt-t-1,mt))),i.index=s,this._$atlasCacheMap.get(i.index).push(i),i;const n=r.length;for(let a=0;a<n;++a){const n=r[a];if(!(t>n.w||e>n.h))return i.index=s,i.x=n.x,i.y=n.y,this._$atlasCacheMap.get(i.index).push(i),n.w!==t||n.h!==e?t>e?(n.h-e-1>0&&r.push(this.getNode(n.x,n.y+e+1,n.w,n.h-e-1)),n.w-t-1>0?(n.x=n.x+t+1,n.w=n.w-t-1,n.h=e):(r.splice(a,1),this._$nodeObjectArray.push(n))):(n.w-t-1>0&&r.push(this.getNode(n.x+t+1,n.y,n.w-t-1,n.h)),n.h-e-1>0?(n.y=n.y+e+1,n.w=t,n.h=n.h-e-1):(r.splice(a,1),this._$nodeObjectArray.push(n))):(r.splice(a,1),this._$nodeObjectArray.push(n)),i}}const s=this._$atlasTextures.length;if(s)return tt.reset(),this.createCachePosition(t,e);this.createTextureAtlas();const r=this._$atlasNodes.get(s);return t>e?(mt-t-1>0&&r.push(this.getNode(t+1,0,mt-t-1,e)),mt-e-1>0&&r.push(this.getNode(0,e+1,mt,mt-e-1))):(mt-e-1>0&&r.push(this.getNode(0,e+1,t,mt-e-1)),mt-t-1>0&&r.push(this.getNode(t+1,0,mt-t-1,mt))),i.index=s,this._$atlasCacheMap.get(i.index).push(i),i}releasePosition(t){var e;this._$atlasNodes.has(t.index)&&(null===(e=this._$atlasNodes.get(t.index))||void 0===e||e.unshift(this.getNode(t.x,t.y,t.w,t.h)),this._$positionObjectArray.push(t))}clearCache(){for(const t of this._$atlasCacheMap.values())t.length=0;for(const t of this._$atlasNodes.values())t.length=0}_$createTexture(t,e){const i=this._$gl.createTexture();return i.width=0,i.height=0,i.area=0,i.dirty=!0,i.smoothing=!0,this.bind0(i,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,t,e),i}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}create(t,e,i=null,s=!1,r=!0){const n=this._$getTexture(t,e);return s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,t,e,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):i&&(n.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,t,e,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)),s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),n}createFromImage(t,e=!1){return this._$createFromElement(t.width,t.height,t,e)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1)}createFromVideo(t,e=!1){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e)}_$createFromElement(t,e,i,s=!1){const r=this._$getTexture(t,e);return r.dirty=!1,this.bind0(r,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r.width!==t||r.height!==e?(r.width=t,r.height=e,r.area=t*e,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPool.length&&this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i=null,s=null){const r=i!==this._$boundTextures[t],n=null!==s&&null!==i&&s!==i.smoothing;if((r||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),r&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i&&(i.smoothing=!!s);const t=s?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class xt{constructor(t){this._$gl=t,this._$objectPool=k(),this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}set maxWidth(t){this._$maxWidth=t}set maxHeight(t){this._$maxHeight=t}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the stencil buffer is null.");return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;++s){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();if(t)return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();t&&(this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t))}}}class bt{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=k()}set samples(t){this._$samples=t}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the color buffer is null.");const e=this._$gl.createRenderbuffer();if(!e)throw new Error("the stencil buffer is null.");return t.stencil=e,t.samples=0,t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}const i=this._$objectPool.shift();if(!i)throw new Error("the color buffer is void.");return i}create(t,e,i=0){t=r.max(256,X(t)),e=r.max(256,X(e));const s=this._$getColorBuffer(t*e);return i||(i=this._$samples),(s.width<t||s.height<e||s.samples!==i)&&(t=r.max(t,s.width),e=r.max(e,s.height),s.samples=i,s.width=t,s.height=e,s.area=t*e,s.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,s),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,s.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i,this._$gl.STENCIL_INDEX8,t,e)),s}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;r.abs(i-e)>1;){const s=r.floor((i+e)/2);t<=this._$objectPool[s].area?i=s:e=s}return i}}class vt{constructor(t,e){this._$gl=t,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer),this._$frameBufferTexture=t.createFramebuffer(),this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new pt(t),this._$stencilBufferPool=new xt(t),this._$colorBufferPool=new bt(t,e),this._$isRenderBinding=!1,this._$colorBuffer=this._$gl.createRenderbuffer(),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$colorBuffer),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,e,this._$gl.RGBA8,mt,mt),this._$stencilBuffer=this._$gl.createRenderbuffer(),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$stencilBuffer),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,e,this._$gl.STENCIL_INDEX8,mt,mt)}bindRenderBuffer(){this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),this._$isRenderBinding||(this._$isRenderBinding=!0,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$colorBuffer),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,this._$colorBuffer),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,this._$stencilBuffer),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,this._$stencilBuffer))}get currentAttachment(){return this._$currentAttachment}get textureManager(){return this._$textureManager}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(t,e)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}clearCache(){this._$textureManager.clearCache()}setMaxSize(t,e){this._$stencilBufferPool._$maxWidth=t,this._$stencilBufferPool._$maxHeight=e,this._$textureManager._$maxWidth=t,this._$textureManager._$maxHeight=e}createTextureAttachment(t,e){const i=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!0};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t=null,e=!1){t&&t.isActive&&(t.msaa?t.color instanceof WebGLRenderbuffer&&this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&t.texture&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?t.color instanceof WebGLRenderbuffer&&(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):t.color instanceof WebGLTexture&&(t.color&&this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil),this._$isRenderBinding=!1}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}transferToMainTexture(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;if(!i)throw new Error("the texture is null.");this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,null),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBuffer)}createCachePosition(t,e){return this._$textureManager.createCachePosition(t,e)}transferTexture(t){this._$gl.disable(this._$gl.SCISSOR_TEST),this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture);const e=this._$textureManager.getAtlasTexture(t.index);this._$textureManager.bind0(e),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,e,0);const i=r.max(0,t.x-1),s=r.max(0,t.y-1),n=r.min(mt,t.x+t.w+1),a=r.min(mt,t.y+t.h+1);this._$gl.blitFramebuffer(i,s,n,a,i,s,n,a,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)}getTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");if(!this._$currentAttachment.msaa&&this._$currentAttachment.texture)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;if(!i)throw new Error("the texture is null.");return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t,e=!1){return this._$textureManager.createFromImage(t,e)}createTextureFromVideo(t,e=!1){return this._$textureManager.createFromVideo(t,e)}createTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class Tt{constructor(){this._$bezierConverterBuffer=new o(32)}cubicToQuad(t,e,i,s,r,n,a,h){this._$split2Cubic(t,e,i,s,r,n,a,h,0,16),this._$split2Cubic(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0,8),this._$split2Cubic(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16,24),this._$split2Quad(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0),this._$split2Quad(this._$bezierConverterBuffer[8],this._$bezierConverterBuffer[9],this._$bezierConverterBuffer[10],this._$bezierConverterBuffer[11],this._$bezierConverterBuffer[12],this._$bezierConverterBuffer[13],this._$bezierConverterBuffer[14],this._$bezierConverterBuffer[15],8),this._$split2Quad(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16),this._$split2Quad(this._$bezierConverterBuffer[24],this._$bezierConverterBuffer[25],this._$bezierConverterBuffer[26],this._$bezierConverterBuffer[27],this._$bezierConverterBuffer[28],this._$bezierConverterBuffer[29],this._$bezierConverterBuffer[30],this._$bezierConverterBuffer[31],24)}_$split2Cubic(t,e,i,s,r,n,a,h,o,_){const l=.125*(t+3*(i+r)+a),c=.125*(e+3*(s+n)+h),$=.125*(a+r-i-t),u=.125*(h+n-s-e);this._$bezierConverterBuffer[o]=t,this._$bezierConverterBuffer[o+1]=e,this._$bezierConverterBuffer[o+2]=.5*(t+i),this._$bezierConverterBuffer[o+3]=.5*(e+s),this._$bezierConverterBuffer[o+4]=l-$,this._$bezierConverterBuffer[o+5]=c-u,this._$bezierConverterBuffer[o+6]=l,this._$bezierConverterBuffer[o+7]=c,this._$bezierConverterBuffer[_]=l,this._$bezierConverterBuffer[_+1]=c,this._$bezierConverterBuffer[_+2]=l+$,this._$bezierConverterBuffer[_+3]=c+u,this._$bezierConverterBuffer[_+4]=.5*(r+a),this._$bezierConverterBuffer[_+5]=.5*(n+h),this._$bezierConverterBuffer[_+6]=a,this._$bezierConverterBuffer[_+7]=h}_$split2Quad(t,e,i,s,r,n,a,h,o){const _=.125*(t+3*(i+r)+a),l=.125*(e+3*(s+n)+h);this._$bezierConverterBuffer[o]=.25*t+.75*i,this._$bezierConverterBuffer[o+1]=.25*e+.75*s,this._$bezierConverterBuffer[o+2]=_,this._$bezierConverterBuffer[o+3]=l,this._$bezierConverterBuffer[o+4]=.75*r+.25*a,this._$bezierConverterBuffer[o+5]=.75*n+.25*h,this._$bezierConverterBuffer[o+6]=a,this._$bezierConverterBuffer[o+7]=h}}class At{constructor(){this._$currentPath=k(),this._$vertices=k(),this._$bezierConverter=new Tt}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)O(this._$vertices.pop())}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,r,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(r,n))return;const a=+this._$currentPath[this._$currentPath.length-3],h=+this._$currentPath[this._$currentPath.length-2];this._$bezierConverter.cubicToQuad(a,h,t,e,i,s,r,n);const o=this._$bezierConverter._$bezierConverterBuffer;for(let t=0;t<32;)this.quadTo(o[t++],o[t++],o[t++],o[t++])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=+this._$currentPath[0],e=+this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=+this._$currentPath[this._$currentPath.length-3],s=+this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t,e,i)}_$pushCurrentPathToVertices(){this._$currentPath.length<4?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=k())}createRectVertices(t,e,i,s){return k(k(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class Mt{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,i,s,n,a,h,o,_,l,c,$,u,d,g,f,m,p,x){const b=n.xMax-n.xMin,v=n.yMax-n.yMin,T=a.w,A=a.h,M=r.abs(r.ceil(b*h)),y=r.abs(r.ceil(v*h)),E=T>0?(a.x-n.xMin)/b:1e-5,C=A>0?(a.y-n.yMin)/v:1e-5,S=T>0?(a.x+a.w-n.xMin)/b:.99999,F=A>0?(a.y+a.h-n.yMin)/v:.99999;let B=M*E/i,w=y*C/s,R=(i-M*(1-S))/i,I=(s-y*(1-F))/s;if(B>=R){const t=E/(E+(1-S));B=r.max(t-1e-5,0),R=r.min(t+1e-5,1)}if(w>=I){const t=C/(C+(1-F));w=r.max(t-1e-5,0),I=r.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=o,this.parentMatrixB=_,this.parentMatrixD=l,this.parentMatrixE=c,this.parentMatrixG=$,this.parentMatrixH=u,this.ancestorMatrixA=d,this.ancestorMatrixB=g,this.ancestorMatrixD=f,this.ancestorMatrixE=m,this.ancestorMatrixG=p,this.ancestorMatrixH=x,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=i,this.parentViewportH=s,this.minXST=E,this.minYST=C,this.minXPQ=B,this.minYPQ=w,this.maxXST=S,this.maxYST=F,this.maxXPQ=R,this.maxYPQ=I}disable(){this.enabled=!1}}class yt{constructor(t,e){this._$gl=t,this._$array=[],this._$map=D();const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r=this._$gl.getUniformLocation(e,s);if(i.type===this._$gl.SAMPLER_2D&&1===i.size)continue;const n={};switch(i.type){case this._$gl.FLOAT_VEC4:n.method=this._$gl.uniform4fv.bind(this._$gl,r),n.array=new o(4*i.size),n.assign=-1;break;case this._$gl.INT_VEC4:n.method=this._$gl.uniform4iv.bind(this._$gl,r),n.array=new _(4*i.size),n.assign=-1;break;case this._$gl.SAMPLER_2D:n.method=this._$gl.uniform1iv.bind(this._$gl,r),n.array=new _(i.size),n.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(n),this._$map.set(s,n)}}getArray(t){const e=this._$map.get(t);if(!e||!e.array)throw new Error("the UniformData is null.");return e.array}get textures(){const t=this._$map.get("u_textures");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get highp(){const t=this._$map.get("u_highp");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get mediump(){const t=this._$map.get("u_mediump");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get integer(){const t=this._$map.get("u_integer");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];void 0!==t.method&&void 0!==t.assign&&(t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array)))}}}class Et{constructor(){this._$attributes=[],this._$count=0}get attributes(){return this._$attributes}get count(){return this._$count}set count(t){this._$count=t}clear(){this._$attributes.length=0,this._$count=0}}class Ct{constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new yt(t,this._$program),this._$instance=null}get instance(){return this._$instance||(this._$instance=new Et),this._$instance}get uniform(){return this._$uniform}_$createProgram(t,i){const s=this._$gl.createProgram();s.id=e++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);this._$gl.shaderSource(r,t),this._$gl.compileShader(r);const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);return this._$gl.shaderSource(n,i),this._$gl.compileShader(n),this._$gl.attachShader(s,r),this._$gl.attachShader(s,n),this._$gl.linkProgram(s),this._$gl.detachShader(s,r),this._$gl.detachShader(s,n),this._$gl.deleteShader(r),this._$gl.deleteShader(n),s}_$attachProgram(){const t=this._$context.shaderList;t.currentProgramId!==this._$program.id&&(t.currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}drawArraysInstanced(t){this._$attachProgram(),this._$context.vao.bindInstnceArray(t),this._$gl.drawArraysInstanced(this._$gl.TRIANGLE_STRIP,0,4,t.count)}_$drawImage(){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(t,e){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(t,e),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawElements(this._$gl.TRIANGLES,t.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t);const e=t.indexRanges,i=e[e.length-1];this._$gl.drawArrays(this._$gl.TRIANGLES,0,i.first+i.count)}_$containerClip(t,e,i){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.TRIANGLES,e,i)}_$drawPoints(t,e,i){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.POINTS,e,i)}}class St{static FUNCTION_GRID_OFF(){return"\\n\\nvec2 applyMatrix(in vec2 vertex) {\\n    mat3 matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n\\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\\n\\n    return position;\\n}\\n\\n"}static FUNCTION_GRID_ON(t){return`\\n\\nvec2 applyMatrix(in vec2 vertex) {\\n    mat3 parent_matrix = mat3(\\n        u_highp[${t}].xyz,\\n        u_highp[${t+1}].xyz,\\n        u_highp[${t+2}].xyz\\n    );\\n    mat3 ancestor_matrix = mat3(\\n        u_highp[${t+3}].xyz,\\n        u_highp[${t+4}].xyz,\\n        u_highp[${t+5}].xyz\\n    );\\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\\n    vec4 grid_min = u_highp[${t+6}];\\n    vec4 grid_max = u_highp[${t+7}];\\n\\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\\n    position = (position - parent_offset) / parent_size;\\n\\n    vec4 ga = grid_min;\\n    vec4 gb = grid_max  - grid_min;\\n    vec4 gc = vec4(1.0) - grid_max;\\n\\n    vec2 pa = position;\\n    vec2 pb = position - grid_min.st;\\n    vec2 pc = position - grid_max.st;\\n\\n    position = (ga.pq / ga.st) * min(pa, ga.st)\\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\\n\\n    position = position * parent_size + parent_offset;\\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\\n\\n    return position;\\n}\\n\\n`}}class Ft{static TEMPLATE(t,e,i,s){const r=e-1,n=i?this.VARYING_UV_ON():"",a=i?this.STATEMENT_UV_ON():"";return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\nlayout (location = 1) in vec2 a_option1;\\nlayout (location = 2) in vec2 a_option2;\\nlayout (location = 3) in float a_type;\\n\\nuniform vec4 u_highp[${t}];\\n\\n${n}\\n\\n${s?St.FUNCTION_GRID_ON(i?5:0):St.FUNCTION_GRID_OFF()}\\n\\nfloat crossVec2(in vec2 v1, in vec2 v2) {\\n    return v1.x * v2.y - v2.x * v1.y;\\n}\\n\\nvec2 perpendicularVec2(in vec2 v1) {\\n    float face = u_highp[${r}][1];\\n\\n    return face * vec2(v1.y, -v1.x);\\n}\\n\\nvec2 calculateNormal(in vec2 direction) {\\n    vec2 normalized = normalize(direction);\\n    return perpendicularVec2(normalized);\\n}\\n\\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\\n    return (o1 + t * v1);\\n}\\n\\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\\n    float miter_limit = u_highp[${r}][2];\\n\\n    vec2 a = applyMatrix(a_option1);\\n    vec2 b = applyMatrix(a_option2);\\n\\n    v1 = convex * (position - a);\\n    v2 = convex * (b - position);\\n    o1 = calculateNormal(v1) + a;\\n    o2 = calculateNormal(v2) + position;\\n\\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\\n    return normalize(anchor) * min(length(anchor), miter_limit);\\n}\\n\\nvoid main() {\\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\\n    float half_width = u_highp[${r}][0];\\n\\n    vec2 position = applyMatrix(a_vertex);\\n    vec2 offset = vec2(0.0);\\n    vec2 v1, v2, o1, o2;\\n\\n    if (a_type == 1.0 || a_type == 2.0) { // \\n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\\n    } else if (a_type == 10.0) { // \\n        offset = normalize(position - applyMatrix(a_option1));\\n        offset += a_option2 * perpendicularVec2(offset);\\n    } else if (a_type == 21.0) { // B\\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\\n    } else if (a_type == 22.0) { // A\\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\\n    } else if (a_type == 23.0) { // A\\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\\n    } else if (a_type == 24.0) { // B\\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\\n    } else if (a_type >= 30.0) { // \\n        float face = u_highp[${r}][1];\\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\\n    }\\n    \\n    offset *= half_width;\\n    position += offset;\\n    ${a}\\n\\n    position /= viewport;\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n`}static VARYING_UV_ON(){return"\\nout vec2 v_uv;\\n"}static STATEMENT_UV_ON(){return"\\n    mat3 uv_matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n    mat3 inverse_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\\n    );\\n\\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\\n    v_uv += offset;\\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\\n"}}class Bt{static TEMPLATE(t,e,i,s){const r=i?this.ATTRIBUTE_BEZIER_ON():"",n=i?this.VARYING_BEZIER_ON():e?this.VARYING_UV_ON():"",a=i?this.STATEMENT_BEZIER_ON():e?this.STATEMENT_UV_ON():"";return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n${r}\\n\\nuniform vec4 u_highp[${t}];\\n\\n${n}\\n\\n${s?St.FUNCTION_GRID_ON(e?5:0):St.FUNCTION_GRID_OFF()}\\n\\nvoid main() {\\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\\n\\n    ${a}\\n\\n    vec2 pos = applyMatrix(a_vertex) / viewport;\\n    pos = pos * 2.0 - 1.0;\\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\\n}\\n\\n`}static ATTRIBUTE_BEZIER_ON(){return"\\nlayout (location = 1) in vec2 a_bezier;\\n"}static VARYING_UV_ON(){return"\\nout vec2 v_uv;\\n"}static VARYING_BEZIER_ON(){return"\\nout vec2 v_bezier;\\n"}static STATEMENT_UV_ON(){return"\\n    mat3 uv_matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n    mat3 inverse_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\\n    );\\n\\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\\n"}static STATEMENT_BEZIER_ON(){return"\\n    v_bezier = a_bezier;\\n"}}class wt{static FUNCTION_IS_INSIDE(){return"\\n\\nfloat isInside(in vec2 uv) {\\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\\n}\\n\\n"}static STATEMENT_INSTANCED_COLOR_TRANSFORM_ON(){return"\\n    src.rgb /= max(0.0001, src.a);\\n    src = clamp(src * mul + add, 0.0, 1.0);\\n    src.rgb *= src.a;\\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\\n    vec4 mul = u_mediump[${t}];\\n    vec4 add = u_mediump[${t+1}];\\n${wt.STATEMENT_INSTANCED_COLOR_TRANSFORM_ON()}\\n`}}class Rt{static SOLID_COLOR(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump;\\n\\nout vec4 o_color;\\n\\nvoid main() {\\n    o_color = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\\n}\\n\\n"}static BITMAP_CLIPPED(){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[3];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\\n\\n    vec4 src = texture(u_texture, uv);\\n    ${wt.STATEMENT_COLOR_TRANSFORM_ON(1)}\\n    o_color = src;\\n}`}static BITMAP_PATTERN(){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[3];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\\n    \\n    vec4 src = texture(u_texture, uv);\\n    ${wt.STATEMENT_COLOR_TRANSFORM_ON(1)}\\n    o_color = src;\\n}`}static MASK(){return"#version 300 es\\nprecision mediump float;\\n\\nin vec2 v_bezier;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 px = dFdx(v_bezier);\\n    vec2 py = dFdy(v_bezier);\\n\\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\\n\\n    if (alpha > 0.0) {\\n        o_color = vec4(min(alpha, 1.0));\\n    } else {\\n        discard;\\n    }    \\n}\\n\\n"}}class It{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Ft.TEMPLATE(s,r,!1,e):Bt.TEMPLATE(s,!1,!1,e);const a=new Ct(this._$gl,this._$context,n,Rt.SOLID_COLOR());return this._$collection.set(i,a),a}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r=(i?13:5)+(t?1:0),n=r;let a;a=t?Ft.TEMPLATE(r,n,!0,i):Bt.TEMPLATE(r,!0,!1,i);const h=e?Rt.BITMAP_PATTERN():Rt.BITMAP_CLIPPED(),o=new Ct(this._$gl,this._$context,a,h);return this._$collection.set(s,o),o}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Ft.TEMPLATE(s,r,!1,e):Bt.TEMPLATE(s,!1,!0,e);const a=new Ct(this._$gl,this._$context,n,Rt.MASK());return this._$collection.set(i,a),a}setSolidColorShapeUniform(t,e,i,s,r,n,a,h,o,_,l,c){const $=t.highp;let u;n?($[0]=_.parentMatrixA,$[1]=_.parentMatrixB,$[2]=_.parentMatrixC,$[4]=_.parentMatrixD,$[5]=_.parentMatrixE,$[6]=_.parentMatrixF,$[8]=_.parentMatrixG,$[9]=_.parentMatrixH,$[10]=_.parentMatrixI,$[12]=_.ancestorMatrixA,$[13]=_.ancestorMatrixB,$[14]=_.ancestorMatrixC,$[16]=_.ancestorMatrixD,$[17]=_.ancestorMatrixE,$[18]=_.ancestorMatrixF,$[20]=_.ancestorMatrixG,$[21]=_.ancestorMatrixH,$[22]=_.ancestorMatrixI,$[3]=h,$[7]=o,$[11]=_.parentViewportX,$[15]=_.parentViewportY,$[19]=_.parentViewportW,$[23]=_.parentViewportH,$[24]=_.minXST,$[25]=_.minYST,$[26]=_.minXPQ,$[27]=_.minYPQ,$[28]=_.maxXST,$[29]=_.maxYST,$[30]=_.maxXPQ,$[31]=_.maxYPQ,u=32):($[0]=a[0],$[1]=a[1],$[2]=a[2],$[4]=a[3],$[5]=a[4],$[6]=a[5],$[8]=a[6],$[9]=a[7],$[10]=a[8],$[3]=h,$[7]=o,u=12),e&&($[u]=i,$[u+1]=s,$[u+2]=r);const d=t.mediump;d[0]=l[0],d[1]=l[1],d[2]=l[2],d[3]=l[3]*c}setBitmapShapeUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u,d,g,f,m,p,x,b){const v=t.highp;let T;v[0]=a[0],v[1]=a[1],v[2]=a[2],v[4]=a[3],v[5]=a[4],v[6]=a[5],v[8]=a[6],v[9]=a[7],v[10]=a[8],v[12]=h[0],v[13]=h[1],v[14]=h[2],v[16]=h[3],v[17]=h[4],v[18]=h[5],v[11]=h[6],v[15]=h[7],v[19]=h[8],v[3]=o,v[7]=_,T=20,n&&(v[T]=l.parentMatrixA,v[T+1]=l.parentMatrixB,v[T+2]=l.parentMatrixC,v[T+4]=l.parentMatrixD,v[T+5]=l.parentMatrixE,v[T+6]=l.parentMatrixF,v[T+8]=l.parentMatrixG,v[T+9]=l.parentMatrixH,v[T+10]=l.parentMatrixI,v[T+12]=l.ancestorMatrixA,v[T+13]=l.ancestorMatrixB,v[T+14]=l.ancestorMatrixC,v[T+16]=l.ancestorMatrixD,v[T+17]=l.ancestorMatrixE,v[T+18]=l.ancestorMatrixF,v[T+20]=l.ancestorMatrixG,v[T+21]=l.ancestorMatrixH,v[T+22]=l.ancestorMatrixI,v[T+11]=l.parentViewportX,v[T+15]=l.parentViewportY,v[T+19]=l.parentViewportW,v[T+23]=l.parentViewportH,v[T+24]=l.minXST,v[T+25]=l.minYST,v[T+26]=l.minXPQ,v[T+27]=l.minYPQ,v[T+28]=l.maxXST,v[T+29]=l.maxYST,v[T+30]=l.maxXPQ,v[T+31]=l.maxYPQ,T=52),e&&(v[T]=i,v[T+1]=s,v[T+2]=r);const A=t.mediump;A[0]=c,A[1]=$,A[4]=u,A[5]=d,A[6]=g,A[7]=f,A[8]=m,A[9]=p,A[10]=x,A[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u=null){const d=t.highp;e&&u?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=c,d[7]=$,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=h,d[8]=o,d[9]=_,d[10]=l,d[3]=c,d[7]=$)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class Pt{static TEMPLATE(t,e,i,s,r){const n=i?this.STATEMENT_GRADIENT_TYPE_RADIAL(e,s):this.STATEMENT_GRADIENT_TYPE_LINEAR(e);let a;switch(r){case"reflect":a="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":a="fract(t)";break;default:a="clamp(t, 0.0, 1.0)"}return`#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_highp[${t}];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 p = v_uv;\\n    ${n}\\n    t = ${a};\\n    o_color = texture(u_texture, vec2(t, 0.5));\\n}\\n\\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\\n    vec2 a = u_highp[${t}].xy;\\n    vec2 b = u_highp[${t}].zw;\\n\\n    vec2 ab = b - a;\\n    vec2 ap = p - a;\\n\\n    float t = dot(ab, ap) / dot(ab, ab);\\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\\n    float radius = u_highp[${t}][0];\\n\\n    vec2 coord = p / radius;\\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\\n    float t = length(coord);\\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\\n\\n    vec2 dir = normalize(coord - focal);\\n\\n    float a = dot(dir, dir);\\n    float b = 2.0 * dot(dir, focal);\\n    float c = dot(focal, focal) - 1.0;\\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\\n\\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\\n`}}class Nt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(e?13:5)+(t?1:0)+1,h=a-1;let o;o=t?Ft.TEMPLATE(a,h,!0,e):Bt.TEMPLATE(a,!0,!1,e);const _=new Ct(this._$gl,this._$context,o,Pt.TEMPLATE(a,h,i,s,r));return this._$collection.set(n,_),_}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",h=i?"y":"n",o=i&&s?"y":"n";let _=0;switch(r){case"reflect":_=1;break;case"repeat":_=2}return`${n}${a}${h}${o}${_}`}setGradientShapeUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=h[0],d[13]=h[1],d[14]=h[2],d[16]=h[3],d[17]=h[4],d[18]=h[5],d[11]=h[6],d[15]=h[7],d[19]=h[8],d[3]=o,d[7]=_;let g=20;n&&(d[g]=l.parentMatrixA,d[g+1]=l.parentMatrixB,d[g+2]=l.parentMatrixC,d[g+4]=l.parentMatrixD,d[g+5]=l.parentMatrixE,d[g+6]=l.parentMatrixF,d[g+8]=l.parentMatrixG,d[g+9]=l.parentMatrixH,d[g+10]=l.parentMatrixI,d[g+12]=l.ancestorMatrixA,d[g+13]=l.ancestorMatrixB,d[g+14]=l.ancestorMatrixC,d[g+16]=l.ancestorMatrixD,d[g+17]=l.ancestorMatrixE,d[g+18]=l.ancestorMatrixF,d[g+20]=l.ancestorMatrixG,d[g+21]=l.ancestorMatrixH,d[g+22]=l.ancestorMatrixI,d[g+11]=l.parentViewportX,d[g+15]=l.parentViewportY,d[g+19]=l.parentViewportW,d[g+23]=l.parentViewportH,d[g+24]=l.minXST,d[g+25]=l.minYST,d[g+26]=l.minXPQ,d[g+27]=l.minYPQ,d[g+28]=l.maxXST,d[g+29]=l.maxYST,d[g+30]=l.maxXPQ,d[g+31]=l.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=s,d[g+2]=r,g+=4),c?(d[g]=$[5],d[g+1]=u):(d[g]=$[0],d[g+1]=$[1],d[g+2]=$[2],d[g+3]=$[3])}}class Lt{static TEXTURE(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 position = a_vertex * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static BLEND(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[4];\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 offset   = u_highp[0].xy;\\n    vec2 size     = u_highp[0].zw;\\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position = position * size + offset;\\n    position = (matrix * vec3(position, 1.0)).xy;\\n    position /= viewport;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}static INSTANCE_BLEND(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[5];\\n\\nout vec2 v_src_coord;\\nout vec2 v_dst_coord;\\n\\nvoid main() {\\n    vec4 rect     = vec4(u_highp[0].x, u_highp[0].y, u_highp[0].z, u_highp[0].w);\\n    vec2 size     = vec2(u_highp[4].x, u_highp[4].y);\\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    v_src_coord = a_vertex * rect.zw + rect.xy;\\n    v_dst_coord = a_vertex;\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position = position * size;\\n    position = (matrix * vec3(position, 1.0)).xy;\\n    position /= viewport;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}static INSTANCE(t=!1){return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\nlayout (location = 1) in vec4 a_rect;\\nlayout (location = 2) in vec4 a_size;\\nlayout (location = 3) in vec2 a_offset;\\nlayout (location = 4) in vec4 a_matrix;\\n${t?"\\nlayout (location = 5) in vec4 a_mul;\\nlayout (location = 6) in vec4 a_add;":""}\\n\\nout vec2 v_coord;\\n${t?"\\nout vec4 mul;\\nout vec4 add;":""}\\n\\nvoid main() {\\n    v_coord = a_vertex * a_rect.zw + a_rect.xy;\\n    ${t?"\\n    mul = a_mul;\\n    add = a_add;":""}\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position = position * a_size.xy;\\n    mat3 matrix = mat3(a_matrix.x, a_matrix.y, 0.0, a_matrix.z, a_matrix.w, 0.0, a_offset.x, a_offset.y, 1.0);\\n    position = (matrix * vec3(position, 1.0)).xy;\\n    position /= a_size.zw;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n`}static BLEND_CLIP(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[4];\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 offset     = u_highp[0].xy;\\n    vec2 size       = u_highp[0].zw;\\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position *= viewport;\\n    position = (inv_matrix * vec3(position, 1.0)).xy;\\n    position = (position - offset) / size;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}}class kt{static TEMPLATE(t,e,i){let s="";for(let t=1;t<e;t++){const i=t-1,n=t,a=`u_mediump[${e+r.floor(i/4)}][${i%4}]`,h=`u_mediump[${e+r.floor(n/4)}][${n%4}]`;s+=`\\n    if (t <= ${h}) {\\n        return mix(u_mediump[${i}], u_mediump[${n}], (t - ${a}) / (${h} - ${a}));\\n    }\\n`}return`#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvec4 getGradientColor(in float t) {\\n    if (t <= u_mediump[${e}][0]) {\\n        return u_mediump[0];\\n    }\\n    ${s}\\n    return u_mediump[${e-1}];\\n}\\n\\nvoid main() {\\n    vec4 color = getGradientColor(v_coord.x);\\n    ${i?"color = pow(color, vec4(0.45454545));":""}\\n    color.rgb *= color.a;\\n\\n    o_color = color;\\n}\\n\\n`}}class Ot{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=r.ceil(5*t/4),n=new Ct(this._$gl,this._$context,Lt.TEXTURE(),kt.TEMPLATE(s,t,e));return this._$collection.set(i,n),n}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n++]=r[i[0]],a[n++]=r[i[1]],a[n++]=r[i[2]],a[n++]=r[i[3]]}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const h=t.mediump;for(let t=r;t<n;t++){const e=i[t];h[a++]=(e>>16)/255,h[a++]=(e>>8&255)/255,h[a++]=(255&e)/255,h[a++]=s[t]}for(let t=r;t<n;t++)h[a++]=e[t]}}class Ut{static TEMPLATE(t,e,i,s,r,n,a,h,o){let _=0;const l=i?this.STATEMENT_BASE_TEXTURE_TRANSFORM(_++):"",c=s?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(_++):this.STATEMENT_BLUR_TEXTURE(),$="inner"===n,u=_;let d,g,f=4*_;switch(o?d=r?this.STATEMENT_GLOW(!1,i,h,o,u,f):this.STATEMENT_BEVEL(i,s,h,o,u,f):r?(f+=4,d=this.STATEMENT_GLOW($,i,h,o,u,f)):(f+=8,d=this.STATEMENT_BEVEL(i,s,h,o,u,f)),n){case"outer":g=a?"blur - blur * base.a":"base + blur - blur * base.a";break;case"full":g=a?"blur":"base - base * blur.a + blur";break;default:g="blur"}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[${t}];\\nuniform vec4 u_mediump[${e}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${wt.FUNCTION_IS_INSIDE()}\\n\\nvoid main() {\\n    ${l}\\n    ${c}\\n    ${d}\\n    o_color = ${g};\\n}\\n\\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t){return`\\n    vec2 base_scale  = u_mediump[${t}].xy;\\n    vec2 base_offset = u_mediump[${t}].zw;\\n\\n    vec2 uv = v_coord * base_scale - base_offset;\\n    vec4 base = mix(vec4(0.0), texture(u_textures[1], uv), isInside(uv));\\n`}static STATEMENT_BLUR_TEXTURE(){return"\\n    vec4 blur = texture(u_textures[0], v_coord);\\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t){return`\\n    vec2 blur_scale  = u_mediump[${t}].xy;\\n    vec2 blur_offset = u_mediump[${t}].zw;\\n\\n    vec2 st = v_coord * blur_scale - blur_offset;\\n    vec4 blur = mix(vec4(0.0), texture(u_textures[0], st), isInside(st));\\n`}static STATEMENT_GLOW(t,e,i,s,r,n){return`\\n    ${t?"blur.a = 1.0 - blur.a;":""}\\n    ${i?this.STATEMENT_GLOW_STRENGTH(n):""}\\n    ${s?this.STATEMENT_GLOW_GRADIENT_COLOR(e):this.STATEMENT_GLOW_SOLID_COLOR(r)}\\n`}static STATEMENT_GLOW_STRENGTH(t){return`\\n    float strength = u_mediump[${r.floor(t/4)}][${t%4}];\\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\\n    vec4 color = u_mediump[${t}];\\n    blur = color * blur.a;\\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t){return`\\n    blur = texture(u_textures[${t?2:1}], vec2(blur.a, 0.5));\\n`}static STATEMENT_BEVEL(t,e,i,s,r,n){return`\\n    ${e?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2():this.STATEMENT_BLUR_TEXTURE_2()}\\n    float highlight_alpha = blur.a - blur2.a;\\n    float shadow_alpha    = blur2.a - blur.a;\\n    ${i?this.STATEMENT_BEVEL_STRENGTH(n):""}\\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\\n    ${s?this.STATEMENT_BEVEL_GRADIENT_COLOR(t):this.STATEMENT_BEVEL_SOLID_COLOR(r)}\\n`}static STATEMENT_BLUR_TEXTURE_2(){return"\\n    vec4 blur2 = texture(u_textures[0], 1.0 - v_coord);\\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(){return"\\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\\n    vec4 blur2 = mix(vec4(0.0), texture(u_textures[0], pq), isInside(pq));\\n"}static STATEMENT_BEVEL_STRENGTH(t){return`\\n    float strength = u_mediump[${r.floor(t/4)}][${t%4}];\\n    highlight_alpha *= strength;\\n    shadow_alpha    *= strength;\\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\\n    vec4 highlight_color = u_mediump[${t}];\\n    vec4 shadow_color    = u_mediump[${t+1}];\\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t){return`\\n    blur = texture(u_textures[${t?2:1}], vec2(\\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\\n        0.5\\n    ));\\n`}}class Dt{static TEMPLATE(t){const e=t.toFixed(1);return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump;\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2  offset   = u_mediump.xy;\\n    float fraction = u_mediump.z;\\n    float samples  = u_mediump.w;\\n    \\n    vec4 color = texture(u_texture, v_coord);\\n\\n    for (float i = 1.0; i < ${e}; i += 1.0) {\\n        color += texture(u_texture, v_coord + offset * i);\\n        color += texture(u_texture, v_coord - offset * i);\\n    }\\n    color += texture(u_texture, v_coord + offset * ${e}) * fraction;\\n    color += texture(u_texture, v_coord - offset * ${e}) * fraction;\\n    color /= samples;\\n\\n    o_color = color;\\n}\\n\\n`}}class Xt{static TEMPLATE(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[5];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\\n    vec4 add = u_mediump[4];\\n    \\n    vec4 color = texture(u_texture, v_coord);\\n\\n    color.rgb /= max(0.0001, color.a);\\n    color = clamp(color * mul + add, 0.0, 1.0);\\n    color.rgb *= color.a;\\n\\n    o_color = color;\\n}\\n\\n"}}class Vt{static TEMPLATE(t,e,i,s,n){const a=r.floor(.5*e),h=r.floor(.5*i),o=e*i;let _="";const l=n?1:2;for(let t=0;t<o;++t)_+=`\\n    result += getWeightedColor(${t}, u_mediump[${l+r.floor(t/4)}][${t%4}]);\\n`;const c=s?"result.a = texture(u_texture, v_coord).a;":"",$=n?"":"\\n    vec4 substitute_color = u_mediump[1];\\n    color = mix(substitute_color, color, isInside(uv));\\n";return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${wt.FUNCTION_IS_INSIDE()}\\n\\nvec4 getWeightedColor (in int i, in float weight) {\\n    vec2 rcp_size = u_mediump[0].xy;\\n\\n    int i_div_x = i / ${e};\\n    int i_mod_x = i - ${e} * i_div_x;\\n    vec2 offset = vec2(i_mod_x - ${a}, ${h} - i_div_x);\\n    vec2 uv = v_coord + offset * rcp_size;\\n\\n    vec4 color = texture(u_texture, uv);\\n    color.rgb /= max(0.0001, color.a);\\n    ${$}\\n\\n    return color * weight;\\n}\\n\\nvoid main() {\\n    float rcp_divisor = u_mediump[0].z;\\n    float bias        = u_mediump[0].w;\\n\\n    vec4 result = vec4(0.0);\\n    ${_}\\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\\n    ${c}\\n\\n    result.rgb *= result.a;\\n    o_color = result;\\n}\\n\\n`}}class Yt{static TEMPLATE(t,e,i,s){let r,n,a;switch(e){case 1:r="map_color.r";break;case 2:r="map_color.g";break;case 4:r="map_color.b";break;case 8:r="map_color.a";break;default:r="0.5"}switch(i){case 1:n="map_color.r";break;case 2:n="map_color.g";break;case 4:n="map_color.b";break;case 8:n="map_color.a";break;default:n="0.5"}switch(s){case"clamp":a="\\n    vec4 source_color = texture(u_textures[0], uv);\\n";break;case"ignore":a="\\n    vec4 source_color =texture(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\\n";break;case"color":a="\\n    vec4 substitute_color = u_mediump[2];\\n    vec4 source_color = mix(substitute_color, texture(u_textures[0], uv), isInside(uv));\\n";break;default:a="\\n    vec4 source_color = texture(u_textures[0], fract(uv));\\n"}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${wt.FUNCTION_IS_INSIDE()}\\n\\nvoid main() {\\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\\n    vec2 uv_to_st_offset = u_mediump[0].zw;\\n    vec2 scale           = u_mediump[1].xy;\\n\\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\\n    vec4 map_color = texture(u_textures[1], st);\\n\\n    vec2 offset = vec2(${r}, ${n}) - 0.5;\\n    vec2 uv = v_coord + offset * scale;\\n    ${a}\\n\\n    o_color = mix(texture(u_textures[0], v_coord), source_color, isInside(st));\\n}\\n\\n`}}class zt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getBlurFilterShader(t){const e=`b${t}`;if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new Ct(this._$gl,this._$context,Lt.TEXTURE(),Dt.TEMPLATE(t));return this._$collection.set(e,i),i}getBitmapFilterShader(t,e,i,s,n,a,h){const o=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${s}${n?"y":"n"}${a?"y":"n"}`;if(this._$collection.has(o)){const t=this._$collection.get(o);if(t)return t}let _=1;t&&_++,h&&_++;let l=(t?4:0)+(e?4:0)+(a?1:0);h||(l+=i?4:8),l=r.ceil(l/4);const c=new Ct(this._$gl,this._$context,Lt.TEXTURE(),Ut.TEMPLATE(_,l,t,e,i,s,n,a,h));return this._$collection.set(o,c),c}getColorMatrixFilterShader(){if(this._$collection.has("m")){const t=this._$collection.get("m");if(t)return t}const t=new Ct(this._$gl,this._$context,Lt.TEXTURE(),Xt.TEMPLATE());return this._$collection.set("m",t),t}getConvolutionFilterShader(t,e,i,s){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${s?"y":"n"}`;if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(s?1:2)+r.ceil(t*e/4),h=new Ct(this._$gl,this._$context,Lt.TEXTURE(),Vt.TEMPLATE(a,t,e,i,s));return this._$collection.set(n,h),h}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r="color"===i?3:2,n=new Ct(this._$gl,this._$context,Lt.TEXTURE(),Yt.TEMPLATE(r,t,e,i));return this._$collection.set(s,n),n}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u,d,g,f,m,p,x,b,v,T,A,M){let y;v?(y=t.textures,y[0]=0,y[1]=1,M&&(y[2]=2)):M&&(y=t.textures,y[0]=0,y[1]=2);const E=t.mediump;let C=0;v&&(E[C]=e/s,E[C+1]=i/r,E[C+2]=n/s,E[C+3]=(i-r-a)/r,C+=4),T&&(E[C]=e/h,E[C+1]=i/o,E[C+2]=_/h,E[C+3]=(i-o-l)/o,C+=4),M||(c?(E[C]=u,E[C+1]=d,E[C+2]=g,E[C+3]=f,C+=4):(E[C]=u,E[C+1]=d,E[C+2]=g,E[C+3]=f,E[C+4]=m,E[C+5]=p,E[C+6]=x,E[C+7]=b,C+=8)),A&&(E[C]=$)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,h,o,_,l){const c=t.mediump;c[0]=1/e,c[1]=1/i,c[2]=1/r,c[3]=n/255;let $=4;a||(c[$]=h,c[$+1]=o,c[$+2]=_,c[$+3]=l,$+=4);const u=s.length;for(let t=0;t<u;t++)c[$++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=h/s,g[5]=-o/r,"color"===_&&(g[8]=l,g[9]=c,g[10]=$,g[11]=u)}}class Gt{static TEMPLATE(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\n${t?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src = texture(u_texture, v_coord);\\n    ${t?wt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = src;\\n}\\n\\n`}static INSTANCE_TEMPLATE(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\n${t?"\\nin vec4 mul;\\nin vec4 add;":""}\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src = texture(u_texture, v_coord);\\n    ${t?wt.STATEMENT_INSTANCED_COLOR_TRANSFORM_ON():""}\\n    o_color = src;\\n}\\n\\n`}}class Ht{static TEMPLATE(t,e){let i;switch(t){case"subtract":i=this.FUNCTION_SUBTRACT();break;case"multiply":i=this.FUNCTION_MULTIPLY();break;case"lighten":i=this.FUNCTION_LIGHTEN();break;case"darken":i=this.FUNCTION_DARKEN();break;case"overlay":i=this.FUNCTION_OVERLAY();break;case"hardlight":i=this.FUNCTION_HARDLIGHT();break;case"difference":i=this.FUNCTION_DIFFERENCE();break;case"invert":i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\n${e?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${i}\\n\\nvoid main() {\\n    vec4 dst = texture(u_textures[0], v_coord);\\n    vec4 src = texture(u_textures[1], v_coord);\\n    ${e?wt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = blend(src, dst);\\n}\\n\\n`}static INSTANCE_TEMPLATE(t,e){let i;switch(t){case"subtract":i=this.FUNCTION_SUBTRACT();break;case"multiply":i=this.FUNCTION_MULTIPLY();break;case"lighten":i=this.FUNCTION_LIGHTEN();break;case"darken":i=this.FUNCTION_DARKEN();break;case"overlay":i=this.FUNCTION_OVERLAY();break;case"hardlight":i=this.FUNCTION_HARDLIGHT();break;case"difference":i=this.FUNCTION_DIFFERENCE();break;case"invert":i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\n${e?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_src_coord;\\nin vec2 v_dst_coord;\\nout vec4 o_color;\\n\\n${i}\\n\\nvoid main() {\\n    vec4 dst = texture(u_textures[0], v_dst_coord);\\n    vec4 src = texture(u_textures[1], v_src_coord);\\n    ${e?wt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = blend(src, dst);\\n}\\n\\n`}static FUNCTION_NORMAL(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    return src + dst - dst * src.a;\\n}\\n\\n"}static FUNCTION_SUBTRACT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_MULTIPLY(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n    vec4 c = src * dst;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_LIGHTEN(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_DARKEN(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_OVERLAY(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 mul = src * dst;\\n    vec3 c1 = 2.0 * mul.rgb;\\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_HARDLIGHT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 mul = src * dst;\\n    vec3 c1 = 2.0 * mul.rgb;\\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_DIFFERENCE(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_INVERT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 b = dst - dst * src.a;\\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\\n\\n    return b + c;\\n}\\n\\n"}}class Wt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getInstanceShader(t){const e="i"+(t?"y":"n");if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new Ct(this._$gl,this._$context,Lt.INSTANCE(t),Gt.INSTANCE_TEMPLATE(t));return this._$collection.set(e,i),i}getNormalBlendShader(t){const e="n"+(t?"y":"n");if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new Ct(this._$gl,this._$context,Lt.BLEND(),Gt.TEMPLATE(t));return this._$collection.set(e,i),i}getClipShader(){if(this._$collection.has("c")){const t=this._$collection.get("c");if(t)return t}const t=new Ct(this._$gl,this._$context,Lt.BLEND_CLIP(),Gt.TEMPLATE(!1));return this._$collection.set("c",t),t}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=new Ct(this._$gl,this._$context,Lt.BLEND(),Ht.TEMPLATE(t,e));return this._$collection.set(i,s),s}getInstanceBlendShader(t,e){const i=`i${t}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=new Ct(this._$gl,this._$context,Lt.INSTANCE_BLEND(),Ht.INSTANCE_TEMPLATE(t,e));return this._$collection.set(i,s),s}setNormalBlendUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u,d,g,f){const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=h,o){const e=t.mediump;e[0]=_,e[1]=l,e[2]=c,e[3]=$,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}pushNormalBlend(t,e,i,s,r,n,a,h,o=1,_=1,l=1,c=1,$=0,u=0,d=0,g=0){t.attributes.push(e/mt,i/mt,s/mt,r/mt,s,r,a,h,n[6],n[7],n[0],n[1],n[3],n[4],o,_,l,c,$,u,d,g),t.count++}setClipUniform(t,e,i,s,r,n,a,h){const o=t.highp;o[0]=e,o[1]=i,o[2]=s,o[3]=r,o[4]=n[0],o[5]=n[1],o[6]=n[2],o[8]=n[3],o[9]=n[4],o[10]=n[5],o[12]=n[6],o[13]=n[7],o[14]=n[8],o[7]=a,o[11]=h}setInstanceBlendUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u,d,g,f,m,p){const x=t.textures;x[0]=0,x[1]=1;const b=t.highp;if(b[0]=e,b[1]=i,b[2]=s,b[3]=r,b[4]=h[0],b[5]=h[1],b[6]=h[2],b[8]=h[3],b[9]=h[4],b[10]=h[5],b[12]=h[6],b[13]=h[7],b[14]=h[8],b[7]=o,b[11]=_,b[16]=n,b[17]=a,l){const e=t.mediump;e[0]=c,e[1]=$,e[2]=u,e[3]=d,e[4]=g,e[5]=f,e[6]=m,e[7]=p}}setBlendUniform(t,e,i,s,r,n,a,h,o,_,l,c,$,u,d,g,f){const m=t.textures;m[0]=0,m[1]=1;const p=t.highp;if(p[0]=e,p[1]=i,p[2]=s,p[3]=r,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=h,o){const e=t.mediump;e[0]=_,e[1]=l,e[2]=c,e[3]=$,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class qt{constructor(t,e){this._$currentProgramId=-1,this._$shapeShaderVariants=new It(t,e),this._$gradientShapeShaderVariants=new Nt(t,e),this._$gradientLUTShaderVariants=new Ot(t,e),this._$filterShaderVariants=new zt(t,e),this._$blendShaderVariants=new Wt(t,e)}get currentProgramId(){return this._$currentProgramId}set currentProgramId(t){this._$currentProgramId=t}get shapeShaderVariants(){return this._$shapeShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class jt{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=r.floor(.75*e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new Float32Array(256),this._$rgbIdentityTable=new Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=r.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment,s=this._$context.cachePosition;s&&this._$gl.disable(this._$gl.SCISSOR_TEST),this._$context._$bind(this._$attachment);const n=t.length,a=this._$context.shaderList.gradientLUTShaderVariants,h=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<n;i+=this._$maxLength-1){const s=r.min(i+this._$maxLength,n),o=a.getGradientLUTShader(s-i,e),_=o.uniform;a.setGradientLUTUniformForShape(_,t,i,s,h),o._$drawGradient(0===i?0:t[i][0],s===n?1:t[s-1][0])}if(this._$context._$bind(i),!this._$attachment.texture)throw new Error("the texture is null.");return s&&this._$context.bindRenderBuffer(s),this._$attachment.texture}generateForFilter(t,e,i){const s=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context.shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let s=0;s<n;s+=this._$maxLength-1){const h=r.min(s+this._$maxLength,n),o=a.getGradientLUTShader(h-s,!1),_=o.uniform;a.setGradientLUTUniformForFilter(_,t,e,i,s,h),o._$drawGradient(0===s?0:t[s],h===n?1:t[h-1])}if(this._$context._$bind(s),!this._$attachment.texture)throw new Error("the texture is null.");return this._$attachment.texture}}class Kt{static get indexRangePool(){return this._$indexRangePool}static generate(t){let e=0;for(let i=0;i<t.length;++i)e+=12*(t[i].length/3-2);this._$vertexBufferData=new o(e),this._$indexRanges=k(),this._$currentIndex=0;for(let e=0;e<t.length;++e){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i,r=this._$indexRangePool.pop()||{first:0,count:0};r.first=i,r.count=s,this._$indexRanges.push(r)}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}Kt._$indexRangePool=k();class Qt{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new o(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new o(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new l(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){let a=t,h=e;for(let o=1;o<11;o++){const _=o/11,l=1-_,c=(t*l+i*_)*l+(i*l+r*_)*_,$=(e*l+s*_)*l+(s*l+n*_)*_;this._$addLineSegmentMesh(a,h,c,$,2),a=c,h=$}this._$addLineSegmentMesh(a,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,h=n+2,o=n+3;this._$expandIndexBufferIfNeeded(6);const _=this._$indexBufferData;let l=this._$indexBufferPos;_[l++]=n,_[l++]=a,_[l++]=o,_[l++]=o,_[l++]=h,_[l++]=n,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(28);const c=this._$vertexBufferData;let $=this._$vertexBufferPos;c[$++]=t,c[$++]=e,c[$++]=i,c[$++]=s,c[$++]=1,c[$++]=1,c[$++]=1,c[$++]=t,c[$++]=e,c[$++]=i,c[$++]=s,c[$++]=-1,c[$++]=-1,c[$++]=1,c[$++]=i,c[$++]=s,c[$++]=t,c[$++]=e,c[$++]=-1,c[$++]=-1,c[$++]=r,c[$++]=i,c[$++]=s,c[$++]=t,c[$++]=e,c[$++]=1,c[$++]=1,c[$++]=r,this._$vertexBufferPos=$}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,s,n,a,h,o,_,l=0,c=0){const $=i-t,u=s-e,d=a-i,g=h-s,f=this._$cross($,u,d,g);if(!(r.abs(f)<1e-4))if(2!==n)switch(this._$lineJoin){case"round":this._$addRoundJoinMesh(i,s);break;case"miter":this._$addMiterJoinMesh(i,s,t,e,a,h,l,o,_,c);break;default:this._$addBevelJoinMesh(i,s,l,o,_,c)}else this._$addBevelJoinMesh(i,s,l,o,_,c)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,h,o,_){const l=this._$vertexBufferPos/7,c=l+1,$=l+2,u=l+3,d=l+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=l,g[f++]=a,g[f++]=c,g[f++]=l,g[f++]=c,g[f++]=$,g[f++]=l,g[f++]=$,g[f++]=h,g[f++]=l,g[f++]=o,g[f++]=u,g[f++]=l,g[f++]=u,g[f++]=d,g[f++]=l,g[f++]=d,g[f++]=_,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const m=this._$vertexBufferData;let p=this._$vertexBufferPos;m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=0,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=21,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=22,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=23,m[p++]=t,m[p++]=e,m[p++]=i,m[p++]=s,m[p++]=r,m[p++]=n,m[p++]=24,this._$vertexBufferPos=p}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let o=this._$indexBufferPos;h[o++]=a,h[o++]=i,h[o++]=s,h[o++]=a,h[o++]=r,h[o++]=n,this._$indexBufferPos=o,this._$expandVertexBufferIfNeeded(7);const _=this._$vertexBufferData;let l=this._$vertexBufferPos;_[l++]=t,_[l++]=e,_[l++]=0,_[l++]=0,_[l++]=0,_[l++]=0,_[l++]=0,this._$vertexBufferPos=l}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],h=i[e-7],o=i[e-6],_=i[e-5],l=i[e-4],c=t/7,$=e/7;s!==h||r!==o?(this._$addLineCapMesh(s,r,n,a,c,c+1),this._$addLineCapMesh(h,o,_,l,$-1,$-2)):this._$addLineJoinMesh(_,l,s,r,n,a,$-2,$-1,c,c+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case"round":this._$addRoundJoinMesh(t,e);break;case"square":this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,h=a+1;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let _=this._$indexBufferPos;o[_++]=r,o[_++]=a,o[_++]=h,o[_++]=h,o[_++]=n,o[_++]=r,this._$indexBufferPos=_,this._$expandVertexBufferIfNeeded(14);const l=this._$vertexBufferData;let c=this._$vertexBufferPos;l[c++]=t,l[c++]=e,l[c++]=i,l[c++]=s,l[c++]=-1,l[c++]=-1,l[c++]=10,l[c++]=t,l[c++]=e,l[c++]=i,l[c++]=s,l[c++]=1,l[c++]=1,l[c++]=10,this._$vertexBufferPos=c}}Qt._$cross=(t,e,i,s)=>t*s-i*e;class Jt{constructor(t){this._$gl=t,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new Float32Array([0,0,0,1,1,0,1,1]),this._$attributeVertexBuffer=t.createBuffer(),this._$attributeBuffer=new Float32Array(22),this._$instanceVertexArray=this._$getCommonVertexArray(),this._$commonVertexArray=this._$getVertexArray(0,1)}_$getCommonVertexArray(){const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,0,1,1]),this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,this._$attributeVertexBuffer),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$attributeBuffer.byteLength,this._$gl.DYNAMIC_DRAW),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(1,4,this._$gl.FLOAT,!1,88,0),this._$gl.vertexAttribDivisor(1,1),this._$gl.enableVertexAttribArray(2),this._$gl.vertexAttribPointer(2,4,this._$gl.FLOAT,!1,88,16),this._$gl.vertexAttribDivisor(2,1),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(3,2,this._$gl.FLOAT,!1,88,32),this._$gl.vertexAttribDivisor(3,1),this._$gl.enableVertexAttribArray(4),this._$gl.vertexAttribPointer(4,4,this._$gl.FLOAT,!1,88,40),this._$gl.vertexAttribDivisor(4,1),this._$gl.enableVertexAttribArray(5),this._$gl.vertexAttribPointer(5,4,this._$gl.FLOAT,!1,88,56),this._$gl.vertexAttribDivisor(5,1),this._$gl.enableVertexAttribArray(6),this._$gl.vertexAttribPointer(6,4,this._$gl.FLOAT,!1,88,72),this._$gl.vertexAttribDivisor(6,1),t}_$getVertexArray(t,e){const i=this._$gl.createVertexArray();this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length){const t=this._$fillVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length){const t=this._$strokeVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=Kt.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=X(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const s=Qt.generate(t,e,i),r=s.vertexBufferData,n=s.indexBufferData,a=this._$getStrokeVertexArray();return a.indexCount=n.length,this.bind(a),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,a.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,a.indexBuffer),a.vertexLength<r.length&&(a.vertexLength=X(r.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*a.vertexLength,this._$gl.DYNAMIC_DRAW)),a.indexLength<n.length&&(a.indexLength=X(n.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*a.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,r),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,n),a}releaseFill(t){this._$fillVertexArrayPool.push(t)}releaseStroke(t){this._$strokeVertexArrayPool.push(t)}bind(t=null){t!==this._$boundVertexArray&&(this._$boundVertexArray=t,this._$gl.bindVertexArray(t))}bindInstnceArray(t){this.bind(this._$instanceVertexArray),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,this._$attributeVertexBuffer),t.attributes.length>this._$attributeBuffer.length&&(this._$attributeBuffer=new Float32Array(t.attributes.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$attributeBuffer.byteLength,this._$gl.DYNAMIC_DRAW)),this._$attributeBuffer.set(t.attributes),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,this._$attributeBuffer)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class Zt{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$poolClip=[],this._$clipStatus=!1,this._$containerClip=!1,this._$currentClip=!1}get containerClip(){return this._$containerClip}set containerClip(t){this._$containerClip=t}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel;let i=0;for(let t=0;t<e;++t)i|=(1<<e-t)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&i,i),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");if(--t.clipLevel,t.mask=!!t.clipLevel,!t.clipLevel)return void this._$context._$clearRectStencil();const e=t.width,i=t.height,s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);O(s.pop()),O(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(r,o.first,o.count);const _=r.indexRanges;for(let t=0;t<_.length;++t)Kt.indexRangePool.push(_[t]);O(r.indexRanges),this._$context.vao.releaseFill(r),this._$endClipDef()}_$drawContainerClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel,i=this._$context.shaderList.shapeShaderVariants,s=i.getMaskShapeShader(!1,!1),r=s.uniform;let n=e;const a=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);const o=this._$poolClip.length;for(let t=0;t<o;++t){const t=this._$poolClip.shift();if(!t)continue;i.setMaskShapeUniform(r,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const o=t.vertexArrayObject.indexRanges;for(let e=0;e<o.length;++e){const i=o[e];this._$gl.stencilMask(1<<n-1),s._$containerClip(t.vertexArrayObject,i.first,i.count),Kt.indexRangePool.push(i)}O(o),this._$context.vao.releaseFill(t.vertexArrayObject),++n,n>7&&(this._$unionStencilMask(e,a,h),n=e)}n>e+1&&this._$unionStencilMask(e,a,h)}_$unionStencilMask(t,e,i){const s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);O(s.pop()),O(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(r,o.first,o.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT));const _=r.indexRanges;for(let t=0;t<_.length;++t)Kt.indexRangePool.push(_[t]);O(r.indexRanges),this._$context.vao.releaseFill(r)}_$onClip(t,e,i,s){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip.push({vertexArrayObject:t,matrixA:e[0],matrixB:e[1],matrixC:e[2],matrixD:e[3],matrixE:e[4],matrixF:e[5],matrixG:e[6],matrixH:e[7],matrixI:e[8],viewportWidth:i,viewportHeight:s}),!0)}_$onSave(){this._$clips.push(this._$clipStatus)}_$onRestore(){this._$clips.length&&(this._$clipStatus=!!this._$clips.pop())}}class te{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this._$currentShader=null,this._$currentOperation="normal",this._$currentIndex=-1,this._$currentSmoothing=null,this.enable()}get currentShader(){return this._$currentShader}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case"add":this.toAdd();break;case"screen":this.toScreen();break;case"alpha":this.toAlpha();break;case"erase":this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}clearInstacedArray(){if(!this._$currentShader)return;const t=this._$currentShader.instance;t.count&&t.clear()}drawInstacedArray(){if(!this._$currentShader)return;const t=this._$currentShader.instance;if(!t.count)return;const e=this._$context.frameBuffer,i=e.textureManager.getAtlasTexture(this._$currentIndex);e.textureManager.bind0(i,this._$currentSmoothing),this.toOperation(this._$currentOperation),this._$currentShader.drawArraysInstanced(t),t.clear()}drawInstance(t,e,i,s,r,n,a,h,o,_,l,c,$,u){const d=1!==e||1!==i||1!==s||1!==r||0!==n||0!==a||0!==h||0!==o,g=this._$context.shaderList.blendShaderVariants;this._$currentOperation||(this._$currentOperation=_);const f=g.getInstanceShader(d);this._$currentShader||(this._$currentShader=f),-1===this._$currentIndex&&(this._$currentIndex=t.index),null===this._$currentSmoothing&&(this._$currentSmoothing=u),this._$currentShader===f&&this._$currentOperation===_&&this._$currentIndex===t.index&&this._$currentSmoothing===u||(this.drawInstacedArray(),this._$currentShader=f,this._$currentOperation=_,this._$currentIndex=t.index,this._$currentSmoothing=u),g.pushNormalBlend(f.instance,t.x,t.y,t.w,t.h,$,l,c,e,i,s,r,n,a,h,o)}drawInstanceBlend(t,e,i,s,n,a,h,o,_,l,c,$,u,d,g,f,m,p,x){this.drawInstacedArray();const b=this._$context.frameBuffer,v=b.currentAttachment,T=1!==a||1!==h||1!==o||1!==_||0!==l||0!==c||0!==$||0!==u,A=this._$context.shaderList.blendShaderVariants,M=b.getTextureFromCurrentAttachment(),y=this._$context.frameBuffer.createTextureAttachment(d.w,d.h);this._$context._$bind(y),b.textureManager.bind0(M);const E=A.getClipShader(),C=E.uniform;A.setClipUniform(C,0,0,d.w,d.h,V(p),f,m),this.reset(),E._$drawImage();const S=b.getTextureFromCurrentAttachment();this._$context._$bind(v),b.textureManager.bind01(S,t,x);const F=A.getInstanceBlendShader(g,T);A.setInstanceBlendUniform(F.uniform,d.x/t.width,d.y/t.height,d.w/t.width,d.h/t.height,d.w,d.h,p,f,m,T,a,h,o,_,l,c,$,u);const B=r.abs(s-e),w=r.abs(n-i);this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(e,m-(i+w),B,w),this.toOneZero(),F._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),b.releaseAttachment(y,!0)}drawImage(t,e,i,s,n,a,o,_,l,c,$,u,d,g,f,m,p,x){const b=this._$context.frameBuffer,v=b.currentAttachment,T=1!==a||1!==o||1!==_||1!==l||0!==c||0!==$||0!==u||0!==d,A=this._$context.shaderList.blendShaderVariants;switch(g){case"normal":case"layer":case"add":case"screen":case"alpha":case"erase":case"copy":{b.textureManager.bind0(t,x);const v=A.getNormalBlendShader(T);A.setNormalBlendUniform(v.uniform,e,i,s,n,p,f,m,T,a,o,_,l,c,$,u,d);const M=p[0],y=p[1],E=p[3],C=p[4],S=p[6],F=p[7];if(1!==M||0!==y||0!==E||1!==C){const t=e+s,a=i+n,o=+(t*M+a*E+S),_=+(t*M+i*E+S),l=+(e*M+a*E+S),c=+(e*M+i*E+S),$=+(t*y+a*C+F),u=+(t*y+i*C+F),d=+(e*y+a*C+F),g=+(e*y+i*C+F),p=h.MAX_VALUE,x=+r.min(r.min(r.min(r.min(p,o),_),l),c),b=+r.max(r.max(r.max(r.max(-p,o),_),l),c),v=+r.min(r.min(r.min(r.min(p,$),u),d),g),T=+r.max(r.max(r.max(r.max(-p,$),u),d),g),A=r.max(0,x),B=r.max(0,v),w=r.min(r.max(0,f-A),r.ceil(r.abs(b-x))),R=r.min(r.max(0,m-B),r.ceil(r.abs(T-v)));if(!w||!R)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(A,r.max(0,m-(B+R)),w+1,R+1)}else{const t=r.max(0,e+S),a=r.max(0,i+F),h=r.min(r.max(0,f-t),s),o=r.min(r.max(0,m-a),n);if(!h||!o)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,r.max(0,m-(a+o)),h+1,o+1)}this.toOperation(g),v._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const h=r.max(0,e+p[6]),M=r.max(0,i+p[7]),y=r.min(r.max(0,f-h),s),E=r.min(r.max(0,m-M),n);if(!y||!E)return;const C=b.getTextureFromCurrentAttachment(),S=this._$context.frameBuffer.createTextureAttachment(s,n);this._$context._$bind(S),b.textureManager.bind0(C);const F=A.getClipShader(),B=F.uniform;A.setClipUniform(B,e,i,s,n,V(p),f,m),this.reset(),F._$drawImage();const w=b.getTextureFromCurrentAttachment();this._$context._$bind(v),b.textureManager.bind01(w,t,x);const R=A.getBlendShader(g,T);A.setBlendUniform(R.uniform,e,i,s,n,p,f,m,T,a,o,_,l,c,$,u,d),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(h,r.max(0,m-(M+E)),y,E),this.toOneZero(),R._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),b.releaseAttachment(S,!0)}}}}class ee{constructor(t,e){this._$gl=t;const i=r.min(e,t.getParameter(t.MAX_SAMPLES));this._$maxTextureSize=r.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new ft,this._$cacheBounds=S(),this._$matrix=L(1,0,0,0,1,0,0,0,1),this._$cacheAttachment=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation="normal",this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new vt(t,i),this._$path=new At,this._$grid=new Mt,this._$offsetX=0,this._$offsetY=0,this._$blends=k(),this._$positions=k(),this._$isLayer=!1,this._$shaderList=new qt(this,t),this._$gradientLUT=new jt(this,t),this._$vao=new Jt(t),this._$mask=new Zt(this,t),this._$blend=new te(this,t),this._$attachmentArray=[],this._$maskBounds=S(0,0,0,0),this._$cachePosition=null}get cachePosition(){return this._$cachePosition}set cachePosition(t){this._$cachePosition=t}reset(){this._$globalAlpha=1,this._$globalCompositeOperation="normal",this._$imageSmoothingEnabled=!1,this._$contextStyle.clear()}get isLayer(){return this._$isLayer}get canvas(){return this._$gl.canvas}get cacheAttachment(){return this._$cacheAttachment}set cacheAttachment(t){this._$cacheAttachment=t}get cacheBounds(){return this._$cacheBounds}get fillStyle(){return this._$contextStyle.fillStyle}set fillStyle(t){this._$contextStyle.fillStyle=t}get strokeStyle(){return this._$contextStyle.strokeStyle}set strokeStyle(t){this._$contextStyle.strokeStyle=t}get lineWidth(){return this._$contextStyle.lineWidth}set lineWidth(t){this._$contextStyle.lineWidth=t}get lineCap(){return this._$contextStyle.lineCap}set lineCap(t){this._$contextStyle.lineCap=t}get lineJoin(){return this._$contextStyle.lineJoin}set lineJoin(t){this._$contextStyle.lineJoin=t}get miterLimit(){return this._$contextStyle.miterLimit}set miterLimit(t){this._$contextStyle.miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=Y(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=t}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get shaderList(){return this._$shaderList}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get blend(){return this._$blend}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$getTextureScale(t,e){const i=r.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}drawInstacedArray(){this.blend.drawInstacedArray()}clearInstacedArray(){this.blend.clearInstacedArray()}bindRenderBuffer(t){this._$frameBufferManager.bindRenderBuffer(),this._$gl.clearColor(0,0,0,0),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$viewportWidth=t.w,this._$viewportHeight=t.h,this._$gl.viewport(t.x,t.y,t.w,t.h),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t.x,t.y,t.w,t.h)}getTextureFromRect(t){const e=this._$frameBufferManager,i=e.textureManager.getAtlasTexture(t.index),s=e.currentAttachment,r=e.createTextureAttachment(t.w,t.h);this._$bind(r),this.save(),this.setTransform(1,0,0,1,0,0),this.reset(),this.drawImage(i,-t.x,-i.height+t.h+t.y,i.width,i.height),this.restore();const n=r.texture;return e.releaseAttachment(r),this._$bind(s),n}drawBitmap(t){const e=this._$shaderList.blendShaderVariants,i=e.getNormalBlendShader(!1);e.setNormalBlendUniform(i.uniform,0,0,t.width,t.height,this._$matrix,this._$viewportWidth,this._$viewportHeight,!1,1,1,1,1,0,0,0,0),this._$frameBufferManager.textureManager.bind0(t,this._$imageSmoothingEnabled),this.blend.toOperation("normal"),i._$drawImage()}drawTextureFromRect(t,e){const i=this._$frameBufferManager,s=i.currentAttachment;this.bindRenderBuffer(e),i.transferTexture(e);const r=i.textureManager.getAtlasTexture(e.index),n=i.createTextureAttachmentFrom(r);this._$bind(n),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(e.x,e.y,e.w,e.h),this._$gl.clearColor(0,0,0,0),this._$gl.disable(this._$gl.SCISSOR_TEST),this.save(),this.setTransform(1,0,0,1,0,0),this.reset(),this.drawImage(t,e.x,r.height-e.h-e.y,t.width,t.height),this.restore(),i.releaseAttachment(n),this._$bind(s),i.textureManager.release(t)}stopStencil(){this._$mask._$onClearRect()}_$bind(t=null){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e&&e.dirty||i&&i.dirty)&&(e&&(e.dirty=!1),i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}setMaxSize(t,e){this._$frameBufferManager.setMaxSize(t,e)}transform(t,e,i,s,r,n){const a=this._$matrix[0],h=this._$matrix[1],o=this._$matrix[3],_=this._$matrix[4],l=this._$matrix[6],c=this._$matrix[7];this._$matrix[0]=t*a+e*o,this._$matrix[1]=t*h+e*_,this._$matrix[3]=i*a+s*o,this._$matrix[4]=i*h+s*_,this._$matrix[6]=r*a+n*o+l,this._$matrix[7]=r*h+n*_+c}debug(t=0){const e=this._$frameBufferManager,i=e.textureManager.getAtlasTexture(t),s=e.currentAttachment,r=e.createTextureAttachmentFrom(i);this._$bind(r);const n=new Uint8Array(i.width*i.height*4);this._$gl.readPixels(0,0,i.width,i.height,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,n);const a=document.createElement("canvas");a.width=i.width,a.height=i.height;const h=a.getContext("2d"),o=new ImageData(i.width,i.height);for(let t=0;t<n.length;++t)o.data[t]=n[t];null==h||h.putImageData(o,0,0),console.log(a.toDataURL()),this._$bind(s),e.releaseAttachment(r)}drawInstance(t,e,i,s,r){let n=1,a=1,h=1,o=0,_=0,l=0;const c=this._$globalAlpha;r&&(n=r[0],a=r[1],h=r[2],o=r[4]/255,_=r[5]/255,l=r[6]/255);const $=this._$cachePosition;if($)switch(this._$globalCompositeOperation){case"normal":case"layer":case"add":case"screen":case"alpha":case"erase":case"copy":this.blend.drawInstance($,n,a,h,c,o,_,l,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled);break;default:{const r=this._$frameBufferManager.textureManager.getAtlasTexture($.index);this.blend.drawInstanceBlend(r,t,e,i,s,n,a,h,c,o,_,l,0,$,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}}}drawImage(t,e,i,s,r,n=null){let a=1,h=1,o=1,_=0,l=0,c=0;const $=this._$globalAlpha;n&&(a=n[0],h=n[1],o=n[2],_=n[4]/255,l=n[5]/255,c=n[6]/255),this.blend.drawImage(t,e,i,s,r,a,h,o,$,_,l,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(this._$maskBounds.xMin,this._$maskBounds.yMin,this._$maskBounds.xMax,this._$maskBounds.yMax),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin()}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}fill(){const t=this._$path.vertices;if(!t.length)return;const e=k();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void O(e);const i=this._$vao.createFill(e),s=this.fillStyle;let r,n,a,h=this._$matrix;const o=this._$grid.enabled;if(s instanceof dt){const t=s.stops,e="linearRGB"===s.rgb;if(r=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(r,!0),this._$frameBufferManager.bindRenderBuffer(),n=this._$shaderList.gradientShapeShaderVariants,"linear"===s.type)a=n.getGradientShapeShader(!1,o,!1,!1,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,s.points,0);else{h=this._$stack[this._$stack.length-1];const t=0!==s.focalPointRatio;a=n.getGradientShapeShader(!1,o,!0,t,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,s.points,s.focalPointRatio)}}else if(s instanceof gt){h=this._$stack[this._$stack.length-1];const t=s.colorTransform;r=s.texture,this._$frameBufferManager.textureManager.bind0(r,this._$imageSmoothingEnabled),n=this._$shaderList.shapeShaderVariants,a=n.getBitmapShapeShader(!1,s.repeat,o),t?n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,1,1,1,this._$globalAlpha,0,0,0,0)}else n=this._$shaderList.shapeShaderVariants,a=n.getSolidColorShapeShader(!1,this._$grid.enabled),n.setSolidColorShapeUniform(a.uniform,!1,0,0,0,o,h,this._$viewportWidth,this._$viewportHeight,this._$grid,s,this._$globalAlpha);const _=this._$shaderList.shapeShaderVariants,l=_.getMaskShapeShader(!1,o);_.setMaskShapeUniform(l.uniform,o,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],this._$viewportWidth,this._$viewportHeight,this._$grid),this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),l._$fill(i),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),a._$fill(i),this._$gl.disable(this._$gl.STENCIL_TEST),this.releaseFillVertexArray(i)}releaseFillVertexArray(t){this._$vao.releaseFill(t);const e=t.indexRanges;for(let t=0;t<e.length;++t)Kt.indexRangePool.push(e[t]);O(e)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$updateContainerClipFlag(t){this._$mask.containerClip=t}_$startClip(t){const e=t.xMin,i=t.yMin,s=Math.abs(t.xMax-t.xMin),n=Math.abs(t.yMax-t.yMin),a=this._$frameBufferManager.currentAttachment;if(!a)throw new Error("the current Attachment is null.");return!(e>a.width||i>a.height||0>e&&0>=s+e||0>i&&0>=n+i||(this._$maskBounds.xMin=r.max(0,r.min(this._$maskBounds.xMin,e)),this._$maskBounds.yMin=r.max(0,r.min(this._$maskBounds.yMin,i)),this._$maskBounds.xMax=r.min(a.width,r.min(this._$maskBounds.xMax,s)),this._$maskBounds.yMax=r.min(a.height,r.min(this._$maskBounds.yMax,n)),0))}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this.drawInstacedArray(),this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}closePath(){this._$path.close()}stroke(){const t=this._$path.vertices;if(!t.length)return;const e=k();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return void O(e);const i=this._$vao.createStroke(t,this.lineCap,this.lineJoin);let s=this._$matrix;const n=this.strokeStyle;let a=r.sign(s[0]*s[4]);a>0&&0!==s[1]&&0!==s[3]&&(a=-r.sign(s[1]*s[3]));let h,o,_=.5*this.lineWidth;this._$grid.enabled?(h=r.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),o=r.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(h=r.abs(s[0]+s[3]),o=r.abs(s[1]+s[4]));const l=r.min(h,o),c=r.max(h,o);_*=c*(1-.3*r.cos(.5*r.PI*(l/c))),_=r.max(1,_);const $=this._$grid.enabled;let u,d,g;if(n instanceof dt){"radial"===n.type&&(s=this._$stack[this._$stack.length-1]);const t=n.stops,e="linearRGB"===n.rgb;if(u=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(u,!0),d=this._$shaderList.gradientShapeShaderVariants,"linear"===n.type)g=d.getGradientShapeShader(!0,$,!1,!1,n.mode),d.setGradientShapeUniform(g.uniform,!0,_,a,this.miterLimit,$,s,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,n.points,0);else{s=this._$stack[this._$stack.length-1];const t=0!==n.focalPointRatio;g=d.getGradientShapeShader(!0,$,!0,t,n.mode),d.setGradientShapeUniform(g.uniform,!0,_,a,this.miterLimit,$,s,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,n.points,n.focalPointRatio)}}else if(n instanceof gt){s=this._$stack[this._$stack.length-1];const t=n.colorTransform;u=n.texture,this._$frameBufferManager.textureManager.bind0(u),d=this._$shaderList.shapeShaderVariants,g=d.getBitmapShapeShader(!0,n.repeat,this._$grid.enabled),t?d.setBitmapShapeUniform(g.uniform,!0,_,a,this.miterLimit,$,s,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,u.width,u.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):d.setBitmapShapeUniform(g.uniform,!0,_,a,this.miterLimit,$,s,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,u.width,u.height,1,1,1,this._$globalAlpha,0,0,0,0)}else d=this._$shaderList.shapeShaderVariants,g=d.getSolidColorShapeShader(!0,this._$grid.enabled),d.setSolidColorShapeUniform(g.uniform,!0,_,a,this.miterLimit,$,s,this._$viewportWidth,this._$viewportHeight,this._$grid,n,this._$globalAlpha);g._$stroke(i),this._$vao.releaseStroke(i)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(){const t=this._$path.vertices;if(!t.length)return;const e=k();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void O(e);const i=this._$vao.createFill(e),s=this._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;s.setMaskShapeUniform(n,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),this._$mask._$onClip(i,this._$matrix,this._$viewportWidth,this._$viewportHeight)||(r._$fill(i),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(L(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){var t;this._$stack.length&&(t=this._$matrix,A.push(t),this._$matrix=this._$stack.pop()||L()),this._$mask._$onRestore()}createPattern(t,e,i){return new gt(this,t,e,i)}createLinearGradient(t,e,i,s,r="rgb",n="pad"){return(new dt).linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a="rgb",h="pad",o=0){return(new dt).radial(t,e,i,s,r,n,a,h,o)}_$applyBlurFilter(t,e,i){const s=this._$frameBufferManager,n=s.currentAttachment;if(!n)throw new Error("the current attachment is null.");const a=n.width,h=n.height;s.textureManager.bind0(t,!0);const o=r.ceil(.5*i),_=1-(o-.5*i),l=1+i,c=this._$shaderList.filterShaderVariants,$=c.getBlurFilterShader(o);c.setBlurFilterUniform($.uniform,a,h,e,_,l),$._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,h,o,_,l,c,$,u,d,g=null,f=null,m=null,p=0,x=0,b=0,v=0,T=0,A=0,M=0,y=0){const E=this._$frameBufferManager,C="inner"===$,S=E.currentAttachment,F=E.getTextureFromCurrentAttachment();let B=null;const w=null!==g&&null!==f&&null!==m;let R;null!==g&&null!==f&&null!==m&&(B=this._$gradientLUT.generateForFilter(g,f,m)),C?w&&B?E.textureManager.bind02(t,B,!0):E.textureManager.bind0(t):(R=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(R),w&&B?E.textureManager.bind012(t,F,B,!0):E.textureManager.bind01(t,F));const I=!(C||"full"===$&&u),P=!(e===h&&i===o&&0===_&&0===l),N=!(1===d),L=this._$shaderList.filterShaderVariants,k=L.getBitmapFilterShader(I,P,c,$,u,N,w);L.setBitmapFilterUniform(k.uniform,e,i,s,r,n,a,h,o,_,l,c,d,p,x,b,v,T,A,M,y,I,P,N,w),C?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),k._$drawImage(),C||E.releaseAttachment(S,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager.textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,h,o,_,l,c){const $=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment($,u);this._$bind(d),this._$frameBufferManager.textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,h);g.setConvolutionFilterUniform(f.uniform,$,u,s,r,n,h,o,_,l,c),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,h,o,_,l,c,$,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),r||(r={x:0,y:0});const m=this._$frameBufferManager.createTextureFromImage(e);this._$frameBufferManager.textureManager.bind01(t,m);const p=this._$shaderList.filterShaderVariants,x=p.getDisplacementMapFilterShader(n,a,_);p.setDisplacementMapFilterUniform(x.uniform,e.width,e.height,i,s,r.x,r.y,h,o,_,l,c,$,u),this.blend.reset(),x._$drawImage(),this._$frameBufferManager.releaseTexture(m)}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){const t=this._$positions.pop();t&&F(t),this._$isLayer=!!this._$blends.pop()}_$saveAttachment(t,e,i=!1){this.drawInstacedArray();const s=this._$frameBufferManager;this._$attachmentArray.push(s.currentAttachment),this._$bind(s.createCacheAttachment(t,e,i))}_$restoreAttachment(t=!1){const e=this._$frameBufferManager;e.releaseAttachment(e.currentAttachment,t),this._$bind(this._$attachmentArray.pop())}getCurrentPosition(){return this._$positions[this._$positions.length-1]}textureScale(t,e){const i=r.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}}class ie extends $t{_$clip(t,e){let i=e;const n=this._$matrix;1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(i=z(e,n));const a=this._$getBounds(),h=H(a,i);F(a);const o=r.ceil(r.abs(h.xMax-h.xMin)),_=r.ceil(r.abs(h.yMax-h.yMin));switch(F(h),!0){case 0===o:case 0===_:case o===-1/0:case _===-1/0:case o===s:case _===s:return}super._$clip(t,i),i!==e&&I(i)}_$draw(t,e,i){if(!this._$visible||!this._$maxAlpha||!this._$canDraw)return;let s=i;const r=this._$colorTransform;if(1===r[0]&&1===r[1]&&1===r[2]&&1===r[3]&&0===r[4]&&0===r[5]&&0===r[6]&&0===r[7]||(s=G(i,r)),!Y(s[3]+s[7]/255,0,1,0))return void(s!==i&&N(s));let n=e;const a=this._$matrix;1===a[0]&&0===a[1]&&0===a[2]&&1===a[3]&&0===a[4]&&0===a[5]||(n=z(e,a)),super._$draw(t,n,s,this._$blendMode,this._$filters),n!==e&&I(n),s!==i&&N(s)}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$recodes=null,super._$remove(),he.push(this)}}class se extends ct{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$wordWrap=!1,this._$textData=k(),this._$textAreaActive=!1,this._$thickness=0,this._$thicknessColor=0,this._$limitWidth=0,this._$limitHeight=0,this._$autoSize="none",this._$widthTable=k(),this._$heightTable=k(),this._$objectTable=k(),this._$textHeightTable=k(),this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$maxScrollV=null,this._$scrollV=1,this._$textHeight=0,this._$verticalAlign="top",this._$cacheKeys=k(),this._$cacheParams=k(0,0,0)}get width(){const t=H(this._$getBounds(null),this._$matrix),e=r.abs(t.xMax-t.xMin);switch(F(t),!0){case 0===e:case e===s:case e===-1/0:return 0;default:return e}}get height(){const t=H(this._$getBounds(null),this._$matrix),e=r.abs(t.yMax-t.yMin);switch(F(t),e){case 0:case s:case-1/0:return 0;default:return e}}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1;const t=this._$textHeightTable.length,e=this.height;if(e>this._$textHeight)return this._$maxScrollV;let i=0,s=0;for(;t>s&&(i+=this._$textHeightTable[s++],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}_$clip(t,e){const i=this._$getBounds(),s=i.xMax,n=i.xMin,a=i.yMax,h=i.yMin;F(i);const o=r.ceil(r.abs(s-n)),_=r.ceil(r.abs(a-h));if(!o||!_)return;let l=e;const c=this._$matrix;1===c[0]&&0===c[1]&&0===c[2]&&1===c[3]&&0===c[4]&&0===c[5]||(l=z(e,c)),t.reset(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(o,0),t.lineTo(o,_),t.lineTo(0,_),t.lineTo(0,0),t.clip(),l!==e&&I(l)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&2>this._$textData.length)return;let n=i;const a=this._$colorTransform;1===a[0]&&1===a[1]&&1===a[2]&&1===a[3]&&0===a[4]&&0===a[5]&&0===a[6]&&0===a[7]||(n=G(i,a));const o=Y(n[3]+n[7]/255,0,1);if(!o)return;let _=e;const l=this._$matrix;1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(_=z(e,l));const c=this._$getBounds(null);c.xMin-=this._$thickness,c.xMax+=this._$thickness,c.yMin-=this._$thickness,c.yMax+=this._$thickness;const $=H(c,_),u=+$.xMax,d=+$.xMin,g=+$.yMax,f=+$.yMin;F($);const m=r.ceil(r.abs(u-d)),p=r.ceil(r.abs(g-f));switch(!0){case 0===m:case 0===p:case m===-1/0:case p===-1/0:case m===s:case p===s:return}let x=+r.sqrt(_[0]*_[0]+_[1]*_[1]);if(!h.isInteger(x)){const t=x.toString(),e=t.indexOf("e");-1!==e&&(x=+t.slice(0,e)),x=+x.toFixed(4)}let b=+r.sqrt(_[2]*_[2]+_[3]*_[3]);if(!h.isInteger(b)){const t=b.toString(),e=t.indexOf("e");-1!==e&&(b=+t.slice(0,e)),b=+b.toFixed(4)}const v=this._$filters,T=null!==v&&v.length>0&&this._$canApply(v);let A=S(0,m,0,p);if(T&&v)for(let t=0;t<v.length;++t)A=v[t]._$generateFilterRect(A,x,b);const M=t.frameBuffer,y=M.currentAttachment;if(!y||d-A.xMin>y.width||f-A.yMin>y.height)return void F(A);if(0>d+A.xMax||0>f+A.yMax)return void F(A);if(F(A),this._$isUpdated()&&(tt.removeCache(this._$instanceId),t.cachePosition=null,this._$cacheKeys.length=0),!this._$cacheKeys.length||this._$cacheParams[0]!==x||this._$cacheParams[1]!==b||this._$cacheParams[2]!==i[7]){const t=k(x,b);this._$cacheKeys=tt.generateKeys(this._$instanceId,t),O(t),this._$cacheParams[0]=x,this._$cacheParams[1]=b,this._$cacheParams[2]=i[7]}if(t.cachePosition=tt.get(this._$cacheKeys),!t.cachePosition){const s=r.min(1,r.max(x,b)),a=r.ceil(r.abs(c.xMax-c.xMin)*x),h=r.ceil(r.abs(c.yMax-c.yMin)*b);n[3]=1;const o=new OffscreenCanvas(a+2*s,h+2*s).getContext("2d");if(!o)return;if(this._$background||this._$border){if(o.beginPath(),o.moveTo(0,0),o.lineTo(a,0),o.lineTo(a,h),o.lineTo(0,h),o.lineTo(0,0),this._$background){const t=Q(this._$backgroundColor),e=r.max(0,r.min(255*t.A*i[3]+i[7],255))/255;o.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,o.fill()}if(this._$border){const t=Q(this._$borderColor),e=r.max(0,r.min(255*t.A*i[3]+i[7],255))/255;o.lineWidth=s,o.strokeStyle=`rgba(${t.R},${t.G},${t.B},${e})`,o.stroke()}}o.save(),o.beginPath(),o.moveTo(2,2),o.lineTo(a-2,2),o.lineTo(a-2,h-2),o.lineTo(2,h-2),o.lineTo(2,2),o.clip(),o.beginPath(),o.setTransform(x,0,0,b,0,0),this._$doDraw(o,e,i,a/x),o.restore();const _=M.createCachePosition(m,p),l=M.createTextureFromCanvas(o.canvas);t.drawTextureFromRect(l,_),t.cachePosition=_,tt.set(this._$cacheKeys,_)}let E=!1,C=0,B=0;if(v&&v.length&&this._$canApply(v)){E=!0;const e=this._$drawFilter(t,_,v,m,p);e.offsetX&&(C=e.offsetX),e.offsetY&&(B=e.offsetY),t.cachePosition=e}const w=r.atan2(_[1],_[0]),R=r.atan2(-_[2],_[3]);if(E||!w&&!R)t.setTransform(1,0,0,1,d-C,f-B);else{const e=c.xMin*x,i=c.yMin*b,s=r.cos(w),n=r.sin(w),a=r.cos(R),h=r.sin(R);t.setTransform(s,n,-h,a,e*s-i*h+_[4],e*n+i*a+_[5])}t.cachePosition&&(t.globalAlpha=o,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=this._$blendMode,t.drawInstance(d-C,f-B,u,g,i),t.cachePosition=null),F(c),_!==e&&I(_),n!==i&&N(n)}_$doDraw(t,e,i,s){const n=this.width,a=this.height;let h=0,o=0,_=0,l=0;if("top"!==this._$verticalAlign&&this.height>this._$textHeight)switch(this._$verticalAlign){case"middle":l=(this.height-this._$textHeight+2)/2;break;case"bottom":l=this.height-this._$textHeight+2}const c=this._$textData.length;for(let $=0;$<c;++$){const c=this._$textData[$];if(0===c.width)continue;const u=h+c.x;if("none"===this._$autoSize&&(o>a||u>n))continue;const d=c.textFormat,g=Q(c.textFormat._$color),f=r.max(0,r.min(255*g.A*i[3]+i[7],255))/255;if(t.fillStyle=`rgba(${g.R},${g.G},${g.B},${f})`,this._$thickness){const e=Q(this._$thicknessColor),s=r.max(0,r.min(255*e.A*i[3]+i[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${s})`}const m=c.yIndex;switch(c.mode){case"break":case"wrap":if(_++,this._$scrollV>_)continue;if(o+=this._$textHeightTable[m],h=this._$getAlignOffset(this._$objectTable[m],s),d._$underline){const s=c.textFormat._$size/12,n=Q(d._$color),a=r.max(0,r.min(255*n.A*i[3]+i[7],255))/255;t.lineWidth=r.max(1,1/r.min(e[0],e[3])),t.strokeStyle=`rgba(${n.R},${n.G},${n.B},${a})`,t.beginPath(),t.moveTo(h,l+o-s),t.lineTo(h+this._$widthTable[m],l+o-s),t.stroke()}break;case"text":{if(this._$scrollV>_)continue;let e=o-this._$heightTable[0];ne||(e+=c.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=J(d._$font,d._$size,d._$italic,d._$bold),this._$thickness&&t.strokeText(c.text,u,l+e),t.fillText(c.text,u,l+e)}break;case"image":if(!c.loaded)continue;t.beginPath(),t.drawImage(c.image,c.hspace,l+c.y,c.width,c.height)}}}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],s=t.textFormat,n=s._$blockIndent+s._$leftMargin>0?s._$blockIndent+s._$leftMargin:0;switch(!0){case!this._$wordWrap&&i>e:return r.max(0,n);case"center"===s._$align:case"center"===this._$autoSize:return r.max(0,e/2-n-s._$rightMargin-i/2);case"right"===s._$align:case"right"===this._$autoSize:return r.max(0,e-n-i-s._$rightMargin-2);default:return r.max(0,n+2)}}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$textData.length=0,this._$widthTable.length=0,this._$heightTable.length=0,this._$objectTable.length=0,this._$textHeightTable.length=0,this._$textAreaActive=!1,super._$remove(),oe.push(this)}_$updateProperty(t){this._$textAreaActive=!!t.textAreaActive,this._$textData.length=0,this._$widthTable.length=0,this._$heightTable.length=0,this._$objectTable.length=0,this._$textHeightTable.length=0,this._$textData.push(...t.textData),this._$widthTable.push(...t.widthTable),this._$heightTable.push(...t.heightTable),this._$objectTable.push(...t.objectTable),this._$textHeightTable.push(...t.textHeightTable),this._$wordWrap=t.wordWrap,this._$limitWidth=t.limitWidth,this._$limitHeight=t.limitHeight,this._$autoSize=t.autoSize,this._$scrollV=t.scrollV,this._$textHeight=t.textHeight,this._$verticalAlign=t.verticalAlign,this._$border=t.border,this._$border&&(this._$borderColor=t.borderColor),this._$background=t.background,this._$background&&(this._$backgroundColor=t.backgroundColor),"thickness"in t&&(this._$thickness=t.thickness,this._$thicknessColor=t.thicknessColor)}_$update(t){super._$update(t),this._$textAreaActive=!!t.textAreaActive,this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,t.textData&&this._$updateProperty(t)}}class re extends ct{constructor(){super(),this._$imageBitmap=null,this._$context=null,this._$smoothing=!0,this._$cacheKeys=k(),this._$cacheParams=k(0,0,0)}_$clip(t,e){const i=this._$xMax,s=this._$yMax;if(!i||!s)return;let r=e;const n=this._$matrix;1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(r=z(e,n)),t.reset(),t.setTransform(r[0],r[1],r[2],r[3],r[4],r[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(),r!==e&&I(r)}_$draw(t,e,i){if(!this._$visible||!this._$imageBitmap||!this._$context)return;let n=i;const a=this._$colorTransform;1===a[0]&&1===a[1]&&1===a[2]&&1===a[3]&&0===a[4]&&0===a[5]&&0===a[6]&&0===a[7]||(n=G(i,a));const o=Y(n[3]+n[7]/255,0,1,0);if(!o)return void(n!==i&&N(n));let _=e;const l=this._$matrix;1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(_=z(e,l));const c=this._$getBounds();F(c);const $=H(c,_),u=+$.xMax,d=+$.xMin,g=+$.yMax,f=+$.yMin;F($);const m=r.ceil(r.abs(u-d)),p=r.ceil(r.abs(g-f));switch(!0){case 0===m:case 0===p:case m===-1/0:case p===-1/0:case m===s:case p===s:return}let x=+r.sqrt(_[0]*_[0]+_[1]*_[1]);if(!h.isInteger(x)){const t=x.toString(),e=t.indexOf("e");-1!==e&&(x=+t.slice(0,e)),x=+x.toFixed(4)}let b=+r.sqrt(_[2]*_[2]+_[3]*_[3]);if(!h.isInteger(b)){const t=b.toString(),e=t.indexOf("e");-1!==e&&(b=+t.slice(0,e)),b=+b.toFixed(4)}const v=this._$filters,T=null!==v&&v.length>0&&this._$canApply(v);let A=S(0,m,0,p);if(T&&v)for(let t=0;t<v.length;++t)A=v[t]._$generateFilterRect(A,x,b);const M=t.frameBuffer,y=M.currentAttachment;if(!y||d-A.xMin>y.width||f-A.yMin>y.height)return void F(A);if(0>d+A.xMax||0>f+A.yMax)return void F(A);if(F(A),!this._$cacheKeys.length||this._$cacheParams[0]!==x||this._$cacheParams[1]!==b||this._$cacheParams[2]!==i[7]){const t=k();t[0]=x,t[1]=b,this._$cacheKeys=tt.generateKeys(this._$instanceId,t,i),O(t),this._$cacheParams[0]=x,this._$cacheParams[1]=b,this._$cacheParams[2]=i[7]}if(t.cachePosition=tt.get(this._$cacheKeys),!t.cachePosition){const e=r.ceil(r.abs(this._$xMax-this._$xMin)),i=r.ceil(r.abs(this._$yMax-this._$yMin)),s=M.createCachePosition(e,i);t.cachePosition=s,tt.set(this._$cacheKeys,s)}this._$context.drawImage(this._$imageBitmap,0,0);const E=M.textureManager._$createFromElement(this._$imageBitmap.width,this._$imageBitmap.height,this._$context.canvas,this._$smoothing);let C=0,B=0;if(T&&v){const e=M.currentAttachment,i=M.createCacheAttachment(m,p);t._$bind(i),t.reset();const s=R(x,0,0,b,m/2,p/2),r=R(1,0,0,1,-E.width/2,-E.height/2),n=z(s,r);I(s),I(r),t.setTransform(n[0],n[1],n[2],n[3],n[4],n[5]),t.drawImage(E,0,0,E.width,E.height);const a=M.getTextureFromCurrentAttachment();t._$bind(e),M.releaseAttachment(i),t.drawTextureFromRect(E,t.cachePosition);const h=this._$drawFilter(t,_,v,m,p,a);h.offsetX&&(C=h.offsetX),h.offsetY&&(B=h.offsetY),t.cachePosition=h,t.setTransform(1,0,0,1,d-C,f-B)}else t.drawTextureFromRect(E,t.cachePosition),t.setTransform(_[0],_[1],_[2],_[3],_[4],_[5]);t.cachePosition&&(t.globalAlpha=o,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=this._$blendMode,t.drawInstance(d-C,f-B,u,g,i),t.cachePosition=null),_!==e&&I(_),n!==i&&N(n)}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$context=null,this._$imageBitmap=null,this._$smoothing=!0,super._$remove(),le.push(this)}_$updateProperty(t){if(this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,this._$imageBitmap=t.imageBitmap,this._$smoothing=t.smoothing,!this._$context&&this._$imageBitmap){const t=new c(this._$imageBitmap.width,this._$imageBitmap.height);this._$context=t.getContext("2d")}}_$update(t){super._$update(t),this._$updateProperty(t)}}let ne=!1;const ae=new class{constructor(){this._$instances=new Map,this._$matrix=R(1,0,0,1,0,0),this._$colorTransform=new o([1,1,1,1,0,0,0,0]),this._$width=0,this._$height=0,this._$stage=new ut,this._$samples=4,this._$canvas=null,this._$context=null,this._$attachment=null}get instances(){return this._$instances}get context(){return this._$context}get scaleX(){return this._$matrix[0]}stop(){tt.reset()}_$initialize(e,i=4,s=2){(e=>{t=e})(s),this._$samples=i,this._$canvas=e;const r=e.getContext("webgl2",{stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0});if(r){const t=new ee(r,i);this._$context=t,tt.context=t}}_$setBackgroundColor(t="transparent"){var e;if(this._$context)if("transparent"===t)this._$context._$setColor(0,0,0,0);else{const i={A:(e=W(t))>>>24,R:(16711680&e)>>16,G:(65280&e)>>8,B:255&e};this._$context._$setColor(i.R/255,i.G/255,i.B/255,1)}}_$bitmapDraw(t,e,i,s){const r=this._$context;if(!r)return;r._$bind(this._$attachment),r.reset(),r.setTransform(1,0,0,1,0,0),r.clearRect(0,0,this._$width,this._$height),r.beginPath(),t._$draw(r,e,i),r.frameBuffer.transferToMainTexture();const n=s.getContext("2d");n&&this._$canvas&&n.drawImage(this._$canvas,0,0)}_$draw(){if(!this._$width||!this._$height)return;if(!this._$stage._$updated)return;const t=this._$context;t&&(t.reset(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.beginPath(),this._$stage._$draw(t,this._$matrix,m),this._$stage._$updated=!1,t.drawInstacedArray(),t.frameBuffer.transferToMainTexture())}_$resize(t,e,i,s=0,r=0){if(this._$width=t,this._$height=e,!this._$canvas)return;if(this._$canvas.width===t&&this._$canvas.height===e)return;const n=this._$context;if(!n)return;this._$matrix[0]=i,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[5]=r,this._$stage._$updated=!0,tt.reset(),n.clearInstacedArray(),this._$canvas.width=t,this._$canvas.height=e,n._$gl.viewport(0,0,t,e);const a=n.frameBuffer;this._$attachment&&(a.unbind(),a.releaseAttachment(this._$attachment,!0)),this._$attachment=a.createCacheAttachment(t,e,!0),n.setMaxSize(t,e),a.clearCache(),n._$bind(this._$attachment)}_$setStage(t){this._$stage._$instanceId=t,this._$instances.set(t,this._$stage)}_$updateStage(){this._$stage._$updated=!0}_$createDisplayObjectContainer(t){const e=ce();e._$instanceId=t.instanceId,t.recodes&&(e._$recodes=t.recodes,e._$maxAlpha=t.maxAlpha||1,e._$canDraw=t.canDraw||!0,e._$xMin=t.xMin||0,e._$yMin=t.yMin||0,e._$xMax=t.xMax||0,e._$yMax=t.yMax||0),t.grid&&(e._$scale9Grid=t.grid),this._$instances.set(e._$instanceId,e)}_$createShape(t){const e=de();e._$instanceId=t.instanceId,e._$parentId=t.parentId,t.recodes&&(e._$recodes=t.recodes),e._$maxAlpha=t.maxAlpha||1,e._$canDraw=t.canDraw||!0,e._$xMin=t.xMin||0,e._$yMin=t.yMin||0,e._$xMax=t.xMax||0,e._$yMax=t.yMax||0,t.characterId&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId||0),t.grid&&(e._$scale9Grid=t.grid),this._$instances.set(e._$instanceId,e)}_$createVideo(t){const e=ue();e._$instanceId=t.instanceId,t.characterId&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId||0),e._$updateProperty(t),this._$instances.set(e._$instanceId,e)}_$createTextField(t){const e=$e();e._$instanceId=t.instanceId,e._$xMin=t.xMin||0,e._$yMin=t.yMin||0,e._$xMax=t.xMax||0,e._$yMax=t.yMax||0,t.characterId&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId||0),e._$updateProperty(t),this._$instances.set(e._$instanceId,e)}},he=[],oe=[],_e=[],le=[],ce=()=>_e.pop()||new ut,$e=()=>oe.pop()||new se,ue=()=>le.pop()||new re,de=()=>he.pop()||new ie;const ge=new class{constructor(){this.state="deactivate",this.queue=[]}execute(){for(this.state="active";this.queue.length;){const e=this.queue.shift();switch(e.command){case"draw":ae._$draw();break;case"setProperty":{const t=ae.instances;if(!t.has(e.instanceId))continue;t.get(e.instanceId)._$update(e)}break;case"setChildren":{const t=ae.instances;if(!t.has(e.instanceId))continue;const i=t.get(e.instanceId);i._$doChanged(),i._$children=e.children}break;case"remove":{const t=ae.instances;if(!t.has(e.instanceId))continue;t.get(e.instanceId)._$remove(),t.delete(e.instanceId)}break;case"createShape":ae._$createShape(e);break;case"createDisplayObjectContainer":ae._$createDisplayObjectContainer(e);break;case"createTextField":ae._$createTextField(e);break;case"createVideo":ae._$createVideo(e);break;case"resize":ae._$resize(e.width,e.height,e.scale,e.tx,e.ty);break;case"initialize":ae._$initialize(e.canvas,e.samples,e.devicePixelRatio);break;case"setSafari":t=e.isSafari,ne=t;break;case"setBackgroundColor":ae._$setBackgroundColor(e.backgroundColor);break;case"setStage":ae._$setStage(e.instanceId);break;case"stop":ae.stop();break;case"removeCache":tt.removeCache(e.id);break;case"bitmapDraw":{const t=ae.instances;if(!t.has(e.sourceId))continue;const i=t.get(e.sourceId),s=new c(e.width,e.height);ae._$bitmapDraw(i,e.matrix||f,e.colorTransform||m,s);const r=s.transferToImageBitmap();globalThis.postMessage({command:"bitmapDraw",sourceId:e.sourceId,imageBitmap:r},[r])}}}var t;this.state="deactivate"}};self.addEventListener("message",(t=>{return e=void 0,i=void 0,r=function*(){ge.queue.push(t.data),"deactivate"===ge.state&&ge.execute()},new((s=void 0)||(s=Promise))((function(t,n){function a(t){try{o(r.next(t))}catch(t){n(t)}}function h(t){try{o(r.throw(t))}catch(t){n(t)}}function o(e){var i;e.done?t(e.value):(i=e.value,i instanceof s?i:new s((function(t){t(i)}))).then(a,h)}o((r=r.apply(e,i||[])).next())}));var e,i,s,r}))})();'],{type:"text/javascript"}))):null,us=null,us&&(gs=t=>{t._$createWorkerInstance(),t._$postProperty();const e=t._$needsChildren?t._$getChildren():t._$children,i=nt();for(let t=0;t<e.length;++t){const s=e[t];s&&(i.push(s._$instanceId),"_$children"in s?gs(s):(s._$createWorkerInstance(),s._$postProperty()))}t._$postChildrenIds(i),at(i)},ds=t=>{t._$removeWorkerInstance();const e=t._$needsChildren?t._$getChildren():t._$children;for(let t=0;t<e.length;++t){const i=e[t];i&&("_$children"in i?ds(i):i._$removeWorkerInstance())}})}return new Promise((t=>{const e=navigator.userAgentData;if(e)e.getHighEntropyValues(["platform","mobile"]).then((e=>{const i=e.brands;for(let t=0;t<i.length;++t)if(-1!==i[t].brand.indexOf("Chrome")){Yi=!0;break}Gi="Android"===e.platform,Hi="iOS"===e.platform,Wi=Gi||Hi,t()}));else{const e=navigator.userAgent;Gi=e.indexOf("Android")>-1,Hi=e.indexOf("iPhone")>-1||e.indexOf("iPod")>-1,Yi=e.indexOf("Chrome")>-1,zi=e.indexOf("Firefox")>-1,Xi=-1===e.indexOf("Chrome")&&e.indexOf("Safari")>-1,Wi=Gi||Hi,t()}}))};"next2d"in window||(console.log("%c Next2D Player %c 1.16.0 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729",""),window.next2d=new class{constructor(t){this._$promises=t,this._$player=new si,this.display=ni,this.events=ri,this.filters=ai,this.geom=hi,this.media=oi,this.net=li,this.text=gi,this.ui=fi}get player(){return this._$player}load(t,e){Promise.all(this._$promises).then((()=>{if(at(this._$promises),"develop"===t){const e=location.search.slice(1).split("&")[0];if(!e)return;t=`${location.origin}/${e}`}if(!t)return;"/"===t.charAt(1)&&(t=t.slice(1)),e&&"base"in e||!(t.indexOf("//")>-1)||(this._$player.base=t),this._$player.setOptions(e),this._$player._$initialize();const i=new $e;i.contentLoaderInfo.addEventListener(Bt.IO_ERROR,(t=>{t.target&&t.target.removeEventListener(Bt.IO_ERROR,t.listener),alert("Error: "+t.text)})),i.contentLoaderInfo.addEventListener(wt.COMPLETE,(t=>{const e=t.target,i=this._$player;if(e.removeEventListener(wt.COMPLETE,t.listener),e._$data){const t=e._$data.stage;i.bgColor=t.bgColor,i._$setBackgroundColor(t.bgColor),i.stage.addChild(e.content),i.width=t.width,i.height=t.height,i.stage._$frameRate=$t(+t.fps,1,60,60)}i._$resize()})),i.load(new Mt(t))}))}createRootMovieClip(t=240,e=240,i=24,s=null){return Promise.all(this._$promises).then((()=>{at(this._$promises);const r=this._$player;r.width=0|t,r.height=0|e,r.mode="create",r.stage._$frameRate=0|i,r.setOptions(s),r._$initialize();const n=r.stage.addChild(new _e);return r._$loadStatus=si.LOAD_END,r.play(),Promise.resolve(n)}))}}([new Promise((t=>{if("loading"===document.readyState){const e=()=>{window.removeEventListener("DOMContentLoaded",e),Es().then((()=>{us&&us.postMessage({command:"setSafari",isSafari:Xi}),Zi()._$initializeCanvas(),t()}))};window.addEventListener("DOMContentLoaded",e)}else Es().then((()=>{us&&us.postMessage({command:"setSafari",isSafari:Xi}),Zi()._$initializeCanvas(),t()}))}))]))})();