/*!
 * licenses: MIT Licenses.
 * version: 1.14.4
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2013-2023 Toshiyuki Ienaga.
 */
"next2d"in window||(t=>{"use strict";let e=0,i=0,r=0;const s=t,n=s.devicePixelRatio,a=s.document,o=s.navigator,h=s.location,l=s.isNaN,$=s.Math,_=s.Array,c=s.Number,u=s.RegExp,d=s.Map,g=s.URL,p=s.Blob,f=s.parseFloat,m=s.performance,x=s.clearTimeout,b=s.cancelAnimationFrame,T=s.CanvasRenderingContext2D,v=s.OffscreenCanvas,y=s.setTimeout,A=s.requestAnimationFrame,M=s.Image,E=s.WebGLTexture,C=s.Uint8Array,S=s.Float32Array,R=s.Int16Array,F=s.Infinity,B={$PREFIX:"__next2d__",$HIGH_SAMPLES:4,$MEDIUM_SAMPLES:2,$LOW_SAMPLES:0,$LOAD_START:"loadstart",$PROGRESS:"progress",$LOADEND:"loadend",$TOUCH_START:"touchstart",$TOUCH_MOVE:"touchmove",$TOUCH_END:"touchend",$MOUSE_DOWN:"mousedown",$MOUSE_MOVE:"mousemove",$MOUSE_UP:"mouseup",$MOUSE_WHEEL:"wheel",$DOUBLE_CLICK:"dblclick",$MOUSE_LEAVE:"mouseleave",$KEY_DOWN:"keydown",$KEY_UP:"keyup",$SCROLL:"scroll"};B.$P_TAG=a.createElement("p"),B.$COLOR_ARRAY_IDENTITY=new S([1,1,1,1,0,0,0,0]),B.$COLOR_MATRIX_FILTER=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],B.$useCache=!0,B.$soundMixerVolume=1,B.$bezierConverterBuffer=new Array(32),B.$Deg2Rad=$.PI/180,B.$Rad2Deg=180/$.PI,B.$audioContext=null,B.$variables=new Map,B.$loadedImages=new Map,B.$isUpdated=!1,B.$event=null,B.$dropTarget=null,B.$dragRules={lock:!1,position:{x:0,y:0},bounds:null},B.$rgbToLinearTable=new S(256),B.$rgbIdentityTable=new S(256);for(let t=0;t<256;++t)B.$rgbToLinearTable[t]=$.pow(t/255,2.23333333),B.$rgbIdentityTable[t]=t/255;B.$SHORT_INT_MIN=-32768,B.$SHORT_INT_MAX=32767,B.$MATRIX_HIT_ARRAY_IDENTITY=new S([1,0,0,1,0,0]),B.$MATRIX_ARRAY_IDENTITY=new S([1,0,0,1,0,0]),B.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0=new Float32Array([n,0,0,n,0,0]),B.$bounds=[],B.$arrays=[],B.$audios=[],B.$maps=[],B.$preObjects=[],B.$matrices=[],B.$colors=[],B.$float32Array4=[],B.$float32Array6=[],B.$float32Array8=[],B.$float32Array9=[],B.$bitmapDrawMap=new Map;const w=o.userAgentData;if(w)B.$isSafari=B.$isFireFox=!1,w.getHighEntropyValues(["platform","mobile"]).then((t=>{B.$isTouch=t.mobile;for(let e=0;e<t.brands.length;++e)if(-1!==t.brands[e].brand.indexOf("Chrome")){B.$isChrome=!0;break}}));else{const t=o.userAgent;B.$isAndroid=t.indexOf("Android")>-1,B.isiOS=t.indexOf("iPhone")>-1||t.indexOf("iPod")>-1,B.$isTouch=B.$isAndroid||B.isiOS,B.$isChrome=t.indexOf("Chrome")>-1,B.$isFireFox=t.indexOf("Firefox")>-1,B.$isSafari=-1===t.indexOf("Chrome")&&t.indexOf("Safari")>-1}B.$currentLoaderInfo=null;const I=a.createElement("canvas");I.width=1,I.height=1,B.$hitContext=I.getContext("2d"),B.$hitContext.globalAlpha=0,B.$hitContext.imageSmoothingEnabled=!1;const U=a.createElement("canvas");U.width=1,U.height=1,B.$textContext=U.getContext("2d"),B.$hitContext.globalAlpha=0,B.$hitContext.imageSmoothingEnabled=!1,B.$DIV=null,B.$getArray=(...t)=>{const e=B.$arrays.pop()||[];return t.length&&e.push.apply(e,t),e},B.$poolArray=t=>{t.length&&(t.length=0),B.$arrays.push(t)},B.$clamp=(t,e,i,r=null)=>{const s=+t;return l(s)&&null!==r?r:$.min($.max(e,l(s)?0:s),i)},B.$multiplicationColor=(t,e)=>B.$getFloat32Array8(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),B.$multiplicationMatrix=(t,e)=>B.$getFloat32Array6(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),B.$getBoundsObject=(t=0,e=0,i=0,r=0)=>{const s=B.$bounds.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return s.xMin=t,s.xMax=e,s.yMin=i,s.yMax=r,s},B.$poolBoundsObject=t=>{B.$bounds.push(t)},B.$poolMap=t=>{t.size&&t.clear(),B.$maps.push(t)},B.$getMap=()=>B.$maps.pop()||new d,B.$getFloat32Array4=(t=0,e=0,i=0,r=0)=>{const s=B.$float32Array4.pop()||new S(4);return s[0]=t,s[1]=e,s[2]=i,s[3]=r,s},B.$poolFloat32Array4=t=>{B.$float32Array4.push(t)},B.$getFloat32Array6=(t=0,e=0,i=0,r=0,s=0,n=0)=>{const a=B.$float32Array6.pop()||new S(6);return a[0]=t,a[1]=e,a[2]=i,a[3]=r,a[4]=s,a[5]=n,a},B.$poolFloat32Array6=t=>{B.$float32Array6.push(t)},B.$getFloat32Array8=(t=1,e=1,i=1,r=1,s=0,n=0,a=0,o=0)=>{const h=B.$float32Array8.pop()||new S(8);return h[0]=t,h[1]=e,h[2]=i,h[3]=r,h[4]=s,h[5]=n,h[6]=a,h[7]=o,h},B.$poolFloat32Array8=t=>{B.$float32Array8.push(t)},B.$getFloat32Array9=(t=0,e=0,i=0,r=0,s=0,n=0,a=0,o=0,h=0)=>{const l=B.$float32Array9.pop()||new S(9);return l[0]=t,l[1]=e,l[2]=i,l[3]=r,l[4]=s,l[5]=n,l[6]=a,l[7]=o,l[8]=h,l},B.$poolFloat32Array9=t=>{B.$float32Array9.push(t)},B.$currentPlayer=()=>s.next2d._$player,B.$currentMousePoint=()=>{const t=B.$currentPlayer();let e=s.pageXOffset,i=s.pageYOffset;const r=a.getElementById(t.contentElementId);if(r){const t=r.getBoundingClientRect();e+=t.left,i+=t.top}let o=B.$event.pageX,h=B.$event.pageY;if(B.$isTouch){const t=B.$event.changedTouches[0];o=t.pageX,h=t.pageY}const l=(o-e)/t._$scale-t._$tx/t._$scale/n,$=(h-i)/t._$scale-t._$ty/t._$scale/n;return new z(l,$)},B.$boundsMatrix=(t,e)=>{const i=t.xMax*e[0]+t.yMax*e[2]+e[4],r=t.xMax*e[0]+t.yMin*e[2]+e[4],s=t.xMin*e[0]+t.yMax*e[2]+e[4],n=t.xMin*e[0]+t.yMin*e[2]+e[4],a=t.xMax*e[1]+t.yMax*e[3]+e[5],o=t.xMax*e[1]+t.yMin*e[3]+e[5],h=t.xMin*e[1]+t.yMax*e[3]+e[5],l=t.xMin*e[1]+t.yMin*e[3]+e[5],_=$.min(c.MAX_VALUE,i,r,s,n),u=$.max(-c.MAX_VALUE,i,r,s,n),d=$.min(c.MAX_VALUE,a,o,h,l),g=$.max(-c.MAX_VALUE,a,o,h,l);return B.$getBoundsObject(_,u,d,g)},B.$upperPowerOfTwo=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),B.$getMatrix=(t=1,e=0,i=0,r=1,s=0,n=0)=>{if(!B.$matrices.length)return new Y(t,e,i,r,s,n);const a=B.$matrices.pop();return a._$matrix=B.$getFloat32Array6(t,e,i,r,s,n),a},B.$poolMatrix=t=>{B.$poolFloat32Array6(t._$matrix),t._$matrix=null,B.$matrices.push(t)},B.$toBoolean=(t=!1)=>{switch(typeof t){case"boolean":return t;case"function":return!0;case"object":case"string":case"number":return!!t;default:return!1}},B.$getColorTransform=(t=1,e=1,i=1,r=1,s=0,n=0,a=0,o=0)=>{if(!B.$colors.length)return new X(t,e,i,r,s,n,a,o);const h=B.$colors.pop();return h._$colorTransform=B.$getFloat32Array8(t,e,i,r,s,n,a,o),h},B.$poolColorTransform=t=>{B.$poolFloat32Array8(t._$colorTransform),t._$colorTransform=null,B.$colors.push(t)},B.$toColorInt=t=>l(+t)?B.$colorStringToInt(t):+t,B.$colorStringToInt=t=>{B.$hitContext.fillStyle=t;const e=B.$hitContext.fillStyle.slice(1);return B.$hitContext.fillStyle="rgba(0, 0, 0, 1)",0|`0x${e}`},B.$intToR=(t,e,i)=>(t>>16)*(i?e:1)/255,B.$intToG=(t,e,i)=>(t>>8&255)*(i?e:1)/255,B.$intToB=(t,e,i)=>(255&t)*(i?e:1)/255,B.$uintToRGBA=t=>({A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}),B.$intToRGBA=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),B.$generateColorTransform=(t,e)=>({R:$.max(0,$.min(t.R*e[0]+e[4],255)),G:$.max(0,$.min(t.G*e[1]+e[5],255)),B:$.max(0,$.min(t.B*e[2]+e[6],255)),A:$.max(0,$.min(255*t.A*e[3]+e[7],255))/255}),B.$cacheStore=()=>B.$currentPlayer()._$cacheStore,B.$inverseMatrix=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],r=t[1]*t[6]-t[0]*t[7];return B.$getFloat32Array9(t[4]*e,-t[1]*e,0,-t[3]*e,t[0]*e,0,i*e,r*e,1)},B.$decodeAudioFailed=function(){const t=this._$character?this._$character.buffer:this._$buffer;let e=0;for(;e=t.indexOf(255,e),-1!==e&&224!=(224&t[e+1]);)++e;e>-1&&B.$audioContext.decodeAudioData(t.buffer.subarray(e),B.$decodeAudioSuccess.bind(this))},B.$decodeAudioSuccess=function(t){this._$character?(this._$character.buffer=null,this._$character.audioBuffer=t):(this._$buffer=null,this._$audioBuffer=t)},B.$decodeAudioData=t=>{const e=t._$character?t._$character.buffer:t._$buffer;e&&B.$audioContext.decodeAudioData(e.buffer,B.$decodeAudioSuccess.bind(t),B.$decodeAudioFailed.bind(t))},B.$loadAudioData=()=>{if(B.$audioContext||(B.$audioContext=new s.AudioContext,B.$audioContext.resume()),B.$audioContext){const t=B.$audios.length;for(let e=0;e<t;++e){const t=B.$audios[e];if(t._$character&&t._$character.audioBuffer)return;if(t._$audioBuffer)return;B.$decodeAudioData(t)}B.$audios.length=0}},B.$getImageType=t=>255===t[0]&&216===t[1]?"jpeg":71===t[0]&&73===t[1]&&70===t[2]?"gif":137===t[0]&&80===t[1]&&78===t[2]&&71===t[3]&&13===t[4]&&10===t[5]&&26===t[6]&&10===t[7]?"png":66===t[0]&&77===t[1]?"bmp":null,B.$resizeTimerId=0,B.$resize=()=>{x(B.$resizeTimerId);const t=y;B.$resizeTimerId=t(B.$resizeExecute,300)},B.$resizeExecute=()=>{const t=B.$currentPlayer();if(t._$loadStatus===De.LOAD_END){t._$resize();const e=t._$stage;e.willTrigger(O.RESIZE)&&e.dispatchEvent(new O(O.RESIZE))}},s.addEventListener("resize",B.$resize),B.$resetContext=t=>{const e=t._$contextStyle;switch(e._$fillStyle.constructor){case xe:case be:e._$fillStyle=B.$getFloat32Array4(1,1,1,1);break;default:e._$fillStyle[0]=1,e._$fillStyle[1]=1,e._$fillStyle[2]=1,e._$fillStyle[3]=1}switch(e._$strokeStyle.constructor){case xe:case be:e._$strokeStyle=B.$getFloat32Array4(1,1,1,1);break;default:e._$strokeStyle[0]=1,e._$strokeStyle[1]=1,e._$strokeStyle[2]=1,e._$strokeStyle[3]=1}t._$style=e,t._$globalAlpha=1,t._$globalCompositeOperation=it.NORMAL,t._$imageSmoothingEnabled=!1},B.$getPreObject=()=>B.$preObjects.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,blendMode:null,filters:null,layerWidth:null,layerHeight:null},B.$poolPreObject=t=>{t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.blendMode=null,t.filters=null,t.layerWidth=null,t.layerHeight=null,B.$preObjects.push(t)},B.$cross=(t,e,i,r)=>t*r-i*e,B.$linearGradientXY=t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],r=-819.2*t[0]+819.2*t[2]+t[4],s=-819.2*t[1]-819.2*t[3]+t[5],n=819.2*t[1]-819.2*t[3]+t[5];let a=r-e,o=-819.2*t[1]+819.2*t[3]+t[5]-s;const h=$.sqrt(a*a+o*o);h?(a/=h,o/=h):(a=0,o=0);const l=(i-e)*a+(n-s)*o;return B.$getArray(e+l*a,s+l*o,i,n)},B.$ajax=(t=null)=>{t||(t={method:"GET"}),"method"in t||(t.method="GET");let e=null;switch(t.method.toUpperCase()){case zt.GET:if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():e[1]+"&"+t.data.toString(),t.url=e.join("?")}break;case zt.PUT:case zt.POST:e=t.data?t.data.toString():null}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),t.withCredentials&&(i.withCredentials=!0),t.event){const e=Object.keys(t.event),r=e.length;for(let s=0;s<r;++s){const r=e[s];i.addEventListener(r,t.event[r])}B.$poolArray(e)}if(t.format===Ht.ARRAY_BUFFER&&(i.responseType=Ht.ARRAY_BUFFER),t.headers)for(const[e,r]of t.headers)i.setRequestHeader(e,r);i.send(e)},B.$headerToArray=t=>{const e=B.$getArray();if(t){const i=t.trim().split("\n"),r=i.length;for(let t=0;t<r;++t){const r=i[t].split(":");e.push({name:r[0],value:r[1].trim()})}}return e},B.$generateFontStyle=(t,e,i=!1,r=!1)=>{let s="";return i&&(s="italic "),r&&(s+="bold "),`${s}${e}px '${t}','sans-serif'`},B.$getClass=t=>{const e=t.split(".");let i=s;for(let t=0;t<e.length;++t){const r=e[t];if(!(r in i))return null;i=i[r]}return i},B.$imageWorkerActive=!1,B.$imageQueues=[],B.$decodeImage=function(){const t=B.$currentPlayer(),e=this.image.width,i=this.image.height,r=new tt(e,i,!0,4278190080),s=t._$context,n=s.frameBuffer.currentAttachment;r._$texture=s.frameBuffer.createTextureFromImage(this.image);const a=new gt;a.graphics.beginBitmapFill(r,null,!1).drawRect(0,0,e,i);const o=this.scope.contentLoaderInfo;if(o._$content=a,a._$loaderInfo=o,t._$loaders.push(o),n?s._$bind(n):s.frameBuffer.unbind(),B.$imageQueues.length){const t=B.$imageQueues.shift();t.image.decode().then(B.$decodeImage.bind(t)).catch((()=>{throw new Error("image encoding error")}))}else B.$imageWorkerActive=!1},B.$rendererWorker=!B.$isSafari&&"OffscreenCanvas"in t?new Worker(URL.createObjectURL(new Blob(['"use strict";let programId=0;const $Infinity=1/0,$Math=Math,$Array=Array,$Number=Number,$WebGLTexture=WebGLTexture,$Float32Array=Float32Array,$Int16Array=Int16Array,$OffscreenCanvas=OffscreenCanvas,$OffscreenCanvasRenderingContext2D=OffscreenCanvasRenderingContext2D,$CanvasRenderingContext2D=null,$isNaN=isNaN,$requestAnimationFrame=requestAnimationFrame,$cancelAnimationFrame=cancelAnimationFrame,$performance=performance,$setTimeout=setTimeout,$clearTimeout=clearTimeout,Util={};Util.$MATRIX_ARRAY_IDENTITY=new $Float32Array([1,0,0,1,0,0]),Util.$COLOR_ARRAY_IDENTITY=new $Float32Array([1,1,1,1,0,0,0,0]),Util.$SHORT_INT_MIN=-32768,Util.$SHORT_INT_MAX=32767,Util.$Deg2Rad=$Math.PI/180,Util.$bezierConverterBuffer=new Array(32);let $devicePixelRatio=2;Util.$preObjects=[],Util.$shapes=[],Util.$textFields=[],Util.$containers=[],Util.$videos=[],Util.$float32Array4=[],Util.$float32Array6=[],Util.$float32Array8=[],Util.$float32Array9=[],Util.$arrays=[],Util.$maps=[],Util.$bounds=[],Util.$useCache=!0,Util.$colorContext=new $OffscreenCanvas(1,1).getContext("2d"),Util.$getBoundsObject=(t=0,e=0,i=0,r=0)=>{const s=Util.$bounds.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return s.xMin=t,s.xMax=e,s.yMin=i,s.yMax=r,s},Util.$poolBoundsObject=t=>{Util.$bounds.push(t)},Util.$getDisplayObjectContainer=()=>Util.$containers.length?Util.$containers.pop():new RenderDisplayObjectContainer,Util.$getTextField=()=>Util.$textFields.length?Util.$textFields.pop():new RenderTextField,Util.$getVideo=()=>Util.$videos.length?Util.$videos.pop():new RenderVideo,Util.$getShape=()=>Util.$shapes.length?Util.$shapes.pop():new RenderShape,Util.$getFloat32Array4=(t=0,e=0,i=0,r=0)=>{const s=Util.$float32Array4.pop()||new $Float32Array(4);return s[0]=t,s[1]=e,s[2]=i,s[3]=r,s},Util.$poolFloat32Array4=t=>{Util.$float32Array4.push(t)},Util.$getFloat32Array6=(t=0,e=0,i=0,r=0,s=0,n=0)=>{const a=Util.$float32Array6.pop()||new $Float32Array(6);return a[0]=t,a[1]=e,a[2]=i,a[3]=r,a[4]=s,a[5]=n,a},Util.$poolFloat32Array6=t=>{Util.$float32Array6.push(t)},Util.$getFloat32Array8=(t=1,e=1,i=1,r=1,s=0,n=0,a=0,l=0)=>{const o=Util.$float32Array8.pop()||new $Float32Array(8);return o[0]=t,o[1]=e,o[2]=i,o[3]=r,o[4]=s,o[5]=n,o[6]=a,o[7]=l,o},Util.$poolFloat32Array8=t=>{Util.$float32Array8.push(t)},Util.$getFloat32Array9=(t=0,e=0,i=0,r=0,s=0,n=0,a=0,l=0,o=0)=>{const h=Util.$float32Array9.pop()||new $Float32Array(9);return h[0]=t,h[1]=e,h[2]=i,h[3]=r,h[4]=s,h[5]=n,h[6]=a,h[7]=l,h[8]=o,h},Util.$poolFloat32Array9=t=>{Util.$float32Array9.push(t)},Util.$getArray=(...t)=>{const e=Util.$arrays.pop()||[];return t.length&&e.push.apply(e,t),e},Util.$poolArray=t=>{t.length&&(t.length=0),Util.$arrays.push(t)},Util.$poolMap=t=>{t.size&&t.clear(),Util.$maps.push(t)},Util.$getMap=()=>Util.$maps.pop()||new Map,Util.$upperPowerOfTwo=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),Util.$resetContext=t=>{const e=t._$contextStyle;switch(e._$fillStyle.constructor){case CanvasGradientToWebGL:{const t=e._$fillStyle._$stops;for(let e=0;e<t.length;++e)Util.$poolFloat32Array4(t[e]);e._$fillStyle=Util.$getFloat32Array4(1,1,1,1)}break;case CanvasPatternToWebGL:t._$frameBufferManager.releaseTexture(e._$fillStyle._$texture),e._$fillStyle=Util.$getFloat32Array4(1,1,1,1);break;default:e._$fillStyle.fill(1)}switch(e._$strokeStyle.constructor){case CanvasGradientToWebGL:{const t=e._$strokeStyle._$stops;for(let e=0;e<t.length;++e)Util.$poolFloat32Array4(t[e]);e._$strokeStyle=Util.$getFloat32Array4(1,1,1,1)}break;case CanvasPatternToWebGL:t._$frameBufferManager.releaseTexture(e._$strokeStyle._$texture),e._$strokeStyle=Util.$getFloat32Array4(1,1,1,1);break;default:e._$strokeStyle.fill(1)}t._$style=e,t._$globalAlpha=1,t._$globalCompositeOperation=BlendMode.NORMAL,t._$imageSmoothingEnabled=!1},Util.$linearGradientXY=t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],r=-819.2*t[0]+819.2*t[2]+t[4],s=-819.2*t[1]-819.2*t[3]+t[5],n=819.2*t[1]-819.2*t[3]+t[5];let a=r-e,l=-819.2*t[1]+819.2*t[3]+t[5]-s;const o=$Math.sqrt(a*a+l*l);o?(a/=o,l/=o):(a=0,l=0);const h=(i-e)*a+(n-s)*l;return Util.$getArray(e+h*a,s+h*l,i,n)},Util.$inverseMatrix=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],r=t[1]*t[6]-t[0]*t[7];return Util.$getFloat32Array9(t[4]*e,0-t[1]*e,0,0-t[3]*e,t[0]*e,0,i*e,r*e,1)},Util.$clamp=(t,e,i,r=null)=>{const s=+t;return $isNaN(s)&&null!==r?r:$Math.min($Math.max(e,$isNaN(s)?0:s),i)},Util.$cross=(t,e,i,r)=>t*r-i*e,Util.$multiplicationMatrix=(t,e)=>Util.$getFloat32Array6(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),Util.$multiplicationColor=(t,e)=>Util.$getFloat32Array8(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),Util.$boundsMatrix=(t,e)=>{const i=t.xMax*e[0]+t.yMax*e[2]+e[4],r=t.xMax*e[0]+t.yMin*e[2]+e[4],s=t.xMin*e[0]+t.yMax*e[2]+e[4],n=t.xMin*e[0]+t.yMin*e[2]+e[4],a=t.xMax*e[1]+t.yMax*e[3]+e[5],l=t.xMax*e[1]+t.yMin*e[3]+e[5],o=t.xMin*e[1]+t.yMax*e[3]+e[5],h=t.xMin*e[1]+t.yMin*e[3]+e[5],_=$Math.min($Number.MAX_VALUE,i,r,s,n),$=$Math.max(0-$Number.MAX_VALUE,i,r,s,n),c=$Math.min($Number.MAX_VALUE,a,l,o,h),u=$Math.max(0-$Number.MAX_VALUE,a,l,o,h);return Util.$getBoundsObject(_,$,c,u)},Util.$toColorInt=t=>$isNaN(+t)?Util.$colorStringToInt(t):+t,Util.$uintToRGBA=t=>({A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}),Util.$colorStringToInt=t=>{Util.$colorContext.fillStyle=t;const e=Util.$colorContext.fillStyle.slice(1);return Util.$colorContext.fillStyle="rgba(0, 0, 0, 1)",0|`0x${e}`},Util.$intToR=(t,e,i)=>(t>>16)*(i?e:1)/255,Util.$intToG=(t,e,i)=>(t>>8&255)*(i?e:1)/255,Util.$intToB=(t,e,i)=>(255&t)*(i?e:1)/255,Util.$intToRGBA=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),Util.$generateFontStyle=(t,e,i=!1,r=!1)=>{let s="";return i&&(s="italic "),r&&(s+="bold "),`${s}${e}px \'${t}\',\'sans-serif\'`},Util.$cacheStore=()=>Util.$renderPlayer._$cacheStore,Util.$getPreObject=()=>Util.$preObjects.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,blendMode:null,filters:null,layerWidth:null,layerHeight:null},Util.$poolPreObject=t=>{t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.blendMode=null,t.filters=null,t.layerWidth=null,t.layerHeight=null,Util.$preObjects.push(t)};class CacheStore{constructor(){this._$pool=[],this._$store=new Map,this._$timerMap=new Map,this._$context=null,this._$delayBitmapLifeCheck=this.bitmapLifeCheck.bind(this)}reset(){const t=this._$store.values();for(const e of t){const t=e.values();for(const e of t)this.destroy(e);Util.$poolMap(e)}this._$store.clear()}destroy(t){if(t)switch(t.constructor){case $WebGLTexture:if(!this._$context)return;$requestAnimationFrame((()=>{const e=t._$bitmapData;if(e&&!e._$buffer){e._$getPixelsAsync(0,0,e.width,e.height,"RGBA"),t._$bitmapData=!1;$setTimeout(this._$delayBitmapLifeCheck,2e3,e)}this._$context.frameBuffer.releaseTexture(t)}));break;case null:{const e=t.canvas,i=e.width,r=e.height;t.clearRect(0,0,i+1,r+1),e.width=e.height=1,this._$pool.push(e)}}}getCanvas(){return this._$pool.pop()||$document.createElement("canvas")}remove(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t);i.has(e)&&(i.delete(e),i.size||(Util.$poolMap(i),this._$store.delete(t)))}clearTimer(t){if(t=`${t}`,this._$timerMap.has(t)){$clearTimeout(this._$timerMap.get(t)),this._$timerMap.delete(t)}}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const t of e.values())this.destroy(t);e.clear(),Util.$poolMap(e),this._$store.delete(t)}this.clearTimer(t)}setRemoveTimer(t){if(t=`${t}`,this.clearTimer(t),this._$store.has(t)){const e=$setTimeout((()=>{this.removeCache(t)}),5e3);this._$timerMap.set(t,e)}}generateLifeKey(t,e){return`${t}:${e}`}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){this._$timerMap.has(e)&&this.clearTimer(e);const t=this._$store.get(e);if(t.has(i))return t.get(i)}return null}set(t,e=null){const i=`${t[0]}`,r=`${t[1]}`;this._$store.has(i)||this._$store.set(i,Util.$getMap());const s=this._$store.get(i);if(!e)return s.delete(r),void(s.size||(Util.$poolMap(s),this._$store.delete(i)));const n=s.get(r);n&&n!==e&&this.destroy(n),s.set(r,e)}has(t){const e=`${t[0]}`;return!!this._$store.has(e)&&this._$store.get(e).has(`${t[1]}`)}bitmapLifeCheck(t){if(!t._$pixelBuffer)return;const e=this._$context;e&&(t._$buffer=e.pbo.getBufferSubDataAsync(t._$pixelBuffer),t._$pixelBuffer=null)}generateKeys(t,e=null,i=null){let r="";e&&(r+=`${e.join("_")}`),i&&(r+=this.colorToString(i));const s=Util.$getArray();return s[1]=r?this.generateHash(r):"_0",s[0]=`${t}`,s}colorToString(t=null){return t&&0!==t[7]?`_${t[7]}`:""}generateHash(t){let e=0;const i=t.length;for(let r=0;r<i;r++){e=(e<<5)-e+t.charCodeAt(r),e|=0}return`_${e}`}}class Rectangle{constructor(t=0,e=0,i=0,r=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,r)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new Point(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=Util.$clamp(+t,Util.$SHORT_INT_MIN,Util.$SHORT_INT_MAX,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new Point(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new Point(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=Util.$clamp(+t,Util.$SHORT_INT_MIN,Util.$SHORT_INT_MAX,0)}get x(){return this._$x}set x(t){this._$x=Util.$clamp(+t,Util.$SHORT_INT_MIN,Util.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=Util.$clamp(+t,Util.$SHORT_INT_MIN,Util.$SHORT_INT_MAX,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=$Math.max(this.x,t.x),i=$Math.max(this.y,t.y),r=$Math.min(this.right,t.right)-e,s=$Math.min(this.bottom,t.bottom)-i;return r>0&&s>0?new Rectangle(e,i,r,s):new Rectangle(0,0,0,0)}intersects(t){const e=$Math.max(this.x,t.x),i=$Math.max(this.y,t.y),r=$Math.min(this.right,t.right),s=$Math.min(this.bottom,t.bottom);return r-e>0&&s-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,r){this.x=t,this.y=e,this.width=i,this.height=r}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new Rectangle($Math.min(this.x,t.x),$Math.min(this.y,t.y),$Math.max(this.right-t.left,t.right-this.left),$Math.max(this.bottom-t.top,t.bottom-this.top))}}class BlendMode{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}}class InterpolationMethod{static toString(){return"[class InterpolationMethod]"}static get namespace(){return"next2d.display.InterpolationMethod"}toString(){return"[object InterpolationMethod]"}get namespace(){return"next2d.display.InterpolationMethod"}static get LINEAR_RGB(){return"linearRGB"}static get RGB(){return"rgb"}}class SpreadMethod{static toString(){return"[class SpreadMethod]"}static get namespace(){return"next2d.display.SpreadMethod"}toString(){return"[object SpreadMethod]"}get namespace(){return"next2d.display.SpreadMethod"}static get PAD(){return"pad"}static get REFLECT(){return"reflect"}static get REPEAT(){return"repeat"}}class GradientType{static toString(){return"[class GradientType]"}static get namespace(){return"next2d.display.GradientType"}toString(){return"[object GradientType]"}get namespace(){return"next2d.display.GradientType"}static get LINEAR(){return"linear"}static get RADIAL(){return"radial"}}class JointStyle{static toString(){return"[class JointStyle]"}static get namespace(){return"next2d.display.JointStyle"}toString(){return"[object JointStyle]"}get namespace(){return"next2d.display.JointStyle"}static get BEVEL(){return"bevel"}static get MITER(){return"miter"}static get ROUND(){return"round"}}class CapsStyle{static toString(){return"[class CapsStyle]"}static get namespace(){return"next2d.display.CapsStyle"}toString(){return"[object CapsStyle]"}get namespace(){return"next2d.display.CapsStyle"}static get NONE(){return"none"}static get ROUND(){return"round"}static get SQUARE(){return"square"}}class TextMode{static get TEXT(){return"text"}static get BREAK(){return"break"}static get WRAP(){return"wrap"}static get IMAGE(){return"image"}}class TextFormatAlign{static toString(){return"[class TextFormatAlign]"}static get namespace(){return"next2d.text.TextFormatAlign"}toString(){return"[object TextFormatAlign]"}get namespace(){return"next2d.text.TextFormatAlign"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get RIGHT(){return"right"}}class TextFieldAutoSize{static toString(){return"[class TextFieldAutoSize]"}static get namespace(){return"next2d.text.TextFieldAutoSize"}toString(){return"[object TextFieldAutoSize]"}get namespace(){return"next2d.text.TextFieldAutoSize"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get NONE(){return"none"}static get RIGHT(){return"right"}}class TextFormatVerticalAlign{static toString(){return"[class TextFormatVerticalAlign]"}static get namespace(){return"next2d.text.TextFormatVerticalAlign"}toString(){return"[object TextFormatVerticalAlign]"}get namespace(){return"next2d.text.TextFormatVerticalAlign"}static get TOP(){return"top"}static get MIDDLE(){return"middle"}static get BOTTOM(){return"bottom"}}class BitmapFilter{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,Util.$isUpdated=!0}}class BitmapFilterType{static toString(){return"[class BitmapFilterType]"}static get namespace(){return"next2d.filters.BitmapFilterType"}toString(){return"[object BitmapFilterType]"}get namespace(){return"next2d.filters.BitmapFilterType"}static get FULL(){return"full"}static get INNER(){return"inner"}static get OUTER(){return"outer"}}class BitmapFilterQuality{static toString(){return"[class BitmapFilterQuality]"}static get namespace(){return"next2d.filters.BitmapFilterQuality"}toString(){return"[object BitmapFilterQuality]"}get namespace(){return"next2d.filters.BitmapFilterQuality"}static get LOW(){return 1}static get MEDIUM(){return 2}static get HIGH(){return 3}}class DisplacementMapFilterMode{static toString(){return"[class DisplacementMapFilterMode]"}static get namespace(){return"next2d.filters.DisplacementMapFilterMode"}toString(){return"[object DisplacementMapFilterMode]"}get namespace(){return"next2d.filters.DisplacementMapFilterMode"}static get CLAMP(){return"clamp"}static get COLOR(){return"color"}static get IGNORE(){return"ignore"}static get WRAP(){return"wrap"}}class BlurFilter extends BitmapFilter{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=Util.$clamp(+t,0,255,0))!==this._$blurX&&this._$doChanged(),this._$blurX=t}get blurY(){return this._$blurY}set blurY(t){(t=Util.$clamp(+t,0,255,0))!==this._$blurY&&this._$doChanged(),this._$blurY=t}get quality(){return this._$quality}set quality(t){(t=Util.$clamp(0|t,0,15,BitmapFilterQuality.LOW))!==this._$quality&&this._$doChanged(),this._$quality=t}clone(){return new BlurFilter(this._$blurX,this._$blurY,this._$quality)}_$toArray(){return Util.$getArray(1,this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=null,i=null){const r=t.clone();if(!this._$quality)return r;const s=BlurFilter.STEP[this._$quality-1];let n=0>=this._$blurX?1:this._$blurX*s,a=0>=this._$blurY?1:this._$blurY*s;switch(!0){case"number"==typeof e:case"number"==typeof i:n*=e,a*=i;break;default:n=$Math.round(n),a=$Math.round(a)}return r.x-=n,r.width+=2*n,r.y-=a,r.height+=2*a,r}_$isSame(t){return this._$quality===t._$quality&&this._$blurX===t._$blurX&&this._$blurY===t._$blurY}_$canApply(){return this._$quality&&this._$blurX&&this._$blurY}_$applyFilter(t,e,i=!0){this._$updated=!1;const r=t._$frameBufferManager,s=r.currentAttachment,n=r.getTextureFromCurrentAttachment();if(!this._$canApply())return i?n:r.createTextureFromCurrentAttachment();const a=$Math.sqrt(e[0]*e[0]+e[1]*e[1]),l=$Math.sqrt(e[2]*e[2]+e[3]*e[3]),o=new Rectangle(0,0,n.width,n.height),h=this._$generateFilterRect(o,a,l),_=0|$Math.ceil(h.width),$=0|$Math.ceil(h.height),c=$Math.ceil($Math.abs(h.x)+.5*$Math.abs(_-h.width)),u=$Math.ceil($Math.abs(h.y)+.5*$Math.abs($-h.height));t._$offsetX=+(c+t._$offsetX),t._$offsetY=+(u+t._$offsetY);const d=this._$blurX*a,g=this._$blurY*l;let p=1,m=1;d>128?p=.0625:d>64?p=.125:d>32?p=.25:d>16&&(p=.5),g>128?m=.0625:g>64?m=.125:g>32?m=.25:g>16&&(m=.5);const f=d*p,x=g*m;let b=$Math.ceil(_*p),v=$Math.ceil($*m);const M=r.createTextureAttachment(b,v),y=[M,r.createTextureAttachment(b,v)];let T=0;t._$bind(M),Util.$resetContext(t),t.setTransform(p,0,0,m,0,0),t.drawImage(n,c,u,n.width,n.height),t.blend.toOneZero();let A=r.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){T=(T+1)%2;const e=y[T];t._$bind(e),t._$applyBlurFilter(A,!0,f),A=r.getTextureFromCurrentAttachment()}if(this._$blurY>0){T=(T+1)%2;const e=y[T];t._$bind(e),t._$applyBlurFilter(A,!1,x),A=r.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==p||1!==m){const e=r.createTextureAttachment(_,$);t._$bind(e),Util.$resetContext(t),t._$imageSmoothingEnabled=!0,t.setTransform(1/p,0,0,1/m,0,0),t.drawImage(A,0,0,b,v),A=r.getTextureFromCurrentAttachment(),Util.$resetContext(t),t.setTransform(1,0,0,1,0,0),r.releaseAttachment(y[0],!0),r.releaseAttachment(y[1],!0),i?r.releaseAttachment(s,!0):r.releaseAttachment(e,!1)}else r.releaseAttachment(y[(T+1)%2],!0),i?r.releaseAttachment(s,!0):r.releaseAttachment(y[T],!1);return A}}class BevelFilter extends BitmapFilter{constructor(t=4,e=45,i=16777215,r=1,s=0,n=1,a=4,l=4,o=1,h=1,_="inner",$=!1){super(),this._$blurFilter=new BlurFilter(a,l,h),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type=BitmapFilterType.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=r,this.shadowColor=s,this.shadowAlpha=n,this.strength=o,this.type=_,this.knockout=!!$}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(),this._$angle=Util.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=Util.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(),this._$distance=t}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=Util.$clamp(+t,0,1,0))!==this._$highlightAlpha&&this._$doChanged(),this._$highlightAlpha=t}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=Util.$clamp(Util.$toColorInt(t),0,16777215,16777215))!==this._$highlightColor&&this._$doChanged(),this._$highlightColor=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=Util.$clamp(+t,0,1,0))!==this._$shadowAlpha&&this._$doChanged(),this._$shadowAlpha=t}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=Util.$clamp(Util.$toColorInt(t),0,16777215,0))!==this._$shadowColor&&this._$doChanged(),this._$shadowColor=t}get strength(){return this._$strength}set strength(t){(t=Util.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(),t){case BitmapFilterType.OUTER:case BitmapFilterType.INNER:this._$type=t;break;default:this._$type=BitmapFilterType.FULL}}clone(){return new BevelFilter(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$toArray(){return Util.$getArray(0,this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const s=this._$angle*Util.$Deg2Rad,n=$Math.abs($Math.cos(s)*this._$distance),a=$Math.abs($Math.sin(s)*this._$distance);return r.x+=-n,r.width+=n,r.y+=-a,r.height+=2*a,r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$highlightColor===t._$highlightColor&&(this._$highlightAlpha===t._$highlightAlpha&&(this._$shadowColor===t._$shadowColor&&(this._$shadowAlpha===t._$shadowAlpha&&(this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))))))}_$canApply(){return this._$strength&&this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const s=i.width,n=i.height,a=t._$offsetX,l=t._$offsetY,o=$Math.sqrt(e[0]*e[0]+e[1]*e[1]),h=$Math.sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*Util.$Deg2Rad,$=+$Math.cos(_)*this._$distance*o,c=+$Math.sin(_)*this._$distance*h;let u=t.frameBuffer.createTextureAttachment(s,n);t._$bind(u),Util.$resetContext(t),t.drawImage(r,0,0,s,n),t.globalCompositeOperation=BlendMode.ERASE,t.drawImage(r,2*$,2*c,s,n);const d=this._$blurFilter._$applyFilter(t,e,!1),g=d.width,p=d.height,m=$Math.ceil(g+2*$Math.abs($)),f=$Math.ceil(p+2*$Math.abs(c)),x=this._$type===BitmapFilterType.INNER,b=x?s:m,v=x?n:f,M=$Math.abs($),y=$Math.abs(c),T=(g-s)/2,A=(p-n)/2;let C,U,S,E;return x?(C=0,U=0,S=-T-$,E=-A-c):(C=M+T,U=y+A,S=M-$,E=y-c),t._$bind(i),t._$applyBitmapFilter(d,b,v,s,n,C,U,g,p,S,E,!1,this._$type,this._$knockout,this._$strength,null,null,null,Util.$intToR(this._$highlightColor,this._$highlightAlpha,!0),Util.$intToG(this._$highlightColor,this._$highlightAlpha,!0),Util.$intToB(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,Util.$intToR(this._$shadowColor,this._$shadowAlpha,!0),Util.$intToG(this._$shadowColor,this._$shadowAlpha,!0),Util.$intToB(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=a+C,t._$offsetY=l+U,t.frameBuffer.releaseTexture(d),t.frameBuffer.getTextureFromCurrentAttachment()}}class ColorMatrixFilter extends BitmapFilter{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this._$doApply=!1,this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if($Array.isArray(t)&&20===t.length){if(this._$matrix){const e=t.length;for(let i=0;i<e;++i)if(t[i]!==this._$matrix[i]){this._$doChanged(),this._$doApply=!0;break}}this._$matrix=t}}clone(){return new ColorMatrixFilter(this._$matrix)}_$toArray(){return Util.$getArray(2,this._$matrix)}_$generateFilterRect(t){return t}_$isSame(t){const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$doApply}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment(),r=i.width,s=i.height,n=t.frameBuffer.createTextureAttachment(r,s);return t._$bind(n),Util.$resetContext(t),t._$applyColorMatrixFilter(i,this._$matrix),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class ConvolutionFilter extends BitmapFilter{constructor(t=0,e=0,i=null,r=1,s=0,n=!0,a=!0,l=0,o=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=r,this.bias=s,this.preserveAlpha=n,this.clamp=a,this.color=l,this.alpha=o}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Util.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(),this._$alpha=t}get bias(){return this._$bias}set bias(t){(t=+t)!==this._$bias&&this._$doChanged(),this._$bias=t}get clamp(){return this._$clamp}set clamp(t){(t=!!t)!==this._$clamp&&this._$doChanged(),this._$clamp=t}get color(){return this._$color}set color(t){(t=Util.$clamp(Util.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(),this._$color=t}get divisor(){return this._$divisor}set divisor(t){(t=+t)!==this._$divisor&&this._$doChanged(),this._$divisor=t}get matrix(){return this._$matrix}set matrix(t){this._$doChanged(),this._$matrix&&Util.$poolArray(this._$matrix),this._$matrix=Util.$getArray(),$Array.isArray(t)&&(this._$matrix=t.slice(0))}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|Util.$clamp(0|t,0,15,0))!==this._$matrixX&&this._$doChanged(),this._$matrixX=t}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|Util.$clamp(0|t,0,15,0))!==this._$matrixY&&this._$doChanged(),this._$matrixY=t}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){(t=!!t)!==this._$preserveAlpha&&this._$doChanged(),this._$preserveAlpha=t}clone(){return new ConvolutionFilter(this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$toArray(){return Util.$getArray(3,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){if(this._$matrixX!==t._$matrixX)return!1;if(this._$matrixY!==t._$matrixY)return!1;if(this._$divisor!==t._$divisor)return!1;if(this._$bias!==t._$bias)return!1;if(this._$preserveAlpha!==t._$preserveAlpha)return!1;if(this._$clamp!==t._$clamp)return!1;if(this._$color!==t._$color)return!1;if(this._$alpha!==t._$alpha)return!1;const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment();return this._$canApply()?(t._$applyConvolutionFilter(i,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,Util.$intToR(this._$color,this._$alpha,!1),Util.$intToG(this._$color,this._$alpha,!1),Util.$intToB(this._$color,this._$alpha,!1),this._$alpha),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()):i}}class DisplacementMapFilter extends BitmapFilter{constructor(t=null,e=null,i=0,r=0,s=0,n=0,a="wrap",l=0,o=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode=DisplacementMapFilterMode.WRAP,this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=r,this.scaleX=s,this.scaleY=n,this.mode=a,this.color=l,this.alpha=o}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Util.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(),this._$alpha=t}get color(){return this._$color}set color(t){(t=Util.$clamp(Util.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(),this._$color=t}get componentX(){return this._$componentX}set componentX(t){switch((t|=0)!==this._$componentX&&this._$doChanged(),this._$componentX=0,t){case BitmapDataChannel.ALPHA:case BitmapDataChannel.BLUE:case BitmapDataChannel.GREEN:case BitmapDataChannel.RED:this._$componentX=t}}get componentY(){return this._$componentY}set componentY(t){switch((t|=0)!==this._$componentY&&this._$doChanged(),this._$componentY=0,t){case BitmapDataChannel.ALPHA:case BitmapDataChannel.BLUE:case BitmapDataChannel.GREEN:case BitmapDataChannel.RED:this._$componentY=t}}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&this._$doChanged(),this._$mapBitmap=null,t instanceof BitmapData&&(this._$mapBitmap=t)}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&this._$doChanged(),this._$mapPoint=null,t instanceof Point&&(this._$mapPoint=t)}get mode(){return this._$mode}set mode(t){switch((t+="")!==this._$mode&&this._$doChanged(),this._$mode=DisplacementMapFilterMode.WRAP,t){case DisplacementMapFilterMode.CLAMP:case DisplacementMapFilterMode.COLOR:case DisplacementMapFilterMode.IGNORE:this._$mode=t}}get scaleX(){return this._$scaleX}set scaleX(t){(t=Util.$clamp(+t,-65535,65535,0))!==this._$scaleX&&this._$doChanged(),this._$scaleX=t}get scaleY(){return this._$scaleY}set scaleY(t){(t=Util.$clamp(+t,-65535,65535,0))!==this._$scaleY&&this._$doChanged(),this._$scaleY=t}clone(){return new DisplacementMapFilter(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$toArray(){return Util.$getArray(4,this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){return this._$mapBitmap===t._$mapBitmap&&(this._$mapPoint.x===t._$mapPoint.x&&(this._$mapPoint.y===t._$mapPoint.y&&(this._$componentX===t._$componentX&&(this._$componentY===t._$componentY&&(this._$scaleX===t._$scaleX&&(this._$scaleY===t._$scaleY&&(this._$mode===t._$mode&&(this._$color===t._$color&&this._$alpha===t._$alpha))))))))}_$canApply(){return this._$mapBitmap&&this._$componentX&&this._$componentY&&this._$scaleX&&this._$scaleY}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const s=$Math.sqrt(e[0]*e[0]+e[1]*e[1]),n=$Math.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(r,this._$mapBitmap._$texture,r.width/s,r.height/n,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,Util.$intToR(this._$color,this._$alpha,!0),Util.$intToG(this._$color,this._$alpha,!0),Util.$intToB(this._$color,this._$alpha,!0),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class DropShadowFilter extends BitmapFilter{constructor(t=4,e=45,i=0,r=1,s=4,n=4,a=1,l=1,o=!1,h=!1,_=!1){super(),this._$blurFilter=new BlurFilter(s,n,l),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=r,this.strength=a,this.inner=o,this.knockout=h,this.hideObject=_}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Util.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=Util.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=Util.$clamp(Util.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get distance(){return this._$distance}set distance(t){(t=Util.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get hideObject(){return this._$hideObject}set hideObject(t){(t=!!t)!==this._$hideObject&&this._$doChanged(!0),this._$hideObject=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=Util.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new DropShadowFilter(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$toArray(){return Util.$getArray(5,this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const s=this._$angle*Util.$Deg2Rad,n=$Math.cos(s)*this._$distance*2,a=$Math.sin(s)*this._$distance*2;return r.x=$Math.min(r.x,n),r.width+=$Math.abs(n),r.y=$Math.min(r.y,a),r.height+=$Math.abs(a),r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&(this._$hideObject===t._$hideObject&&this._$blurFilter._$isSame(t._$blurFilter))))))))}_$canApply(){return this._$alpha&&this._$strength&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t._$frameBufferManager,r=i.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const s=r.width,n=r.height,a=t._$offsetX,l=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),h=o.width,_=o.height,$=t._$offsetX,c=t._$offsetY,u=$-a,d=c-l,g=$Math.sqrt(e[0]*e[0]+e[1]*e[1]),p=$Math.sqrt(e[2]*e[2]+e[3]*e[3]),m=this._$angle*Util.$Deg2Rad,f=$Math.cos(m)*this._$distance*2*g/$devicePixelRatio,x=$Math.sin(m)*this._$distance*2*p/$devicePixelRatio,b=this._$inner?s:h+$Math.max(0,$Math.abs(f)-u),v=this._$inner?n:_+$Math.max(0,$Math.abs(x)-d),M=$Math.ceil(b),y=$Math.ceil(v),T=(M-b)/2,A=(y-v)/2;let C,U,S,E,B,F;return this._$inner?(C=0,U=0,S=f-$,E=x-c):(C=$Math.max(0,u-f)+T,U=$Math.max(0,d-x)+A,S=(f>0?$Math.max(0,f-u):0)+T,E=(x>0?$Math.max(0,x-d):0)+A),this._$inner?(B=BitmapFilterType.INNER,F=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(B=BitmapFilterType.FULL,F=!0):(B=BitmapFilterType.OUTER,F=this._$knockout),t._$bind(r),t._$applyBitmapFilter(o,M,y,s,n,C,U,h,_,S,E,!0,B,F,this._$strength,null,null,null,Util.$intToR(this._$color,this._$alpha,!0),Util.$intToG(this._$color,this._$alpha,!0),Util.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+C,t._$offsetY=l+U,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class GlowFilter extends BitmapFilter{constructor(t=0,e=1,i=4,r=4,s=1,n=1,a=!1,l=!1){super(),this._$blurFilter=new BlurFilter(i,r,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=s,this.inner=a,this.knockout=l}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Util.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(),this._$alpha=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=Util.$clamp(Util.$toColorInt(t),0,16777215,4))!==this._$color&&this._$doChanged(),this._$color=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=Util.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}clone(){return new GlowFilter(this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$toArray(){return Util.$getArray(6,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){const r=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(r,e,i):r}_$isSame(t){return this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))}_$canApply(){return this._$alpha&&this._$strength&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,s=i.height,n=t._$offsetX,a=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),o=l.width,h=l.height,_=t._$offsetX,$=t._$offsetY,c=this._$inner?r:o,u=this._$inner?s:h;let d,g,p,m;this._$inner?(d=0,g=0,p=-_,m=-$):(d=_-n,g=$-a,p=0,m=0);const f=this._$inner?BitmapFilterType.INNER:BitmapFilterType.OUTER;return t._$bind(i),t._$applyBitmapFilter(l,c,u,r,s,d,g,o,h,p,m,!0,f,this._$knockout,this._$strength,null,null,null,Util.$intToR(this._$color,this._$alpha,!0),Util.$intToG(this._$color,this._$alpha,!0),Util.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=n+d,t._$offsetY=a+g,t.frameBuffer.releaseTexture(l),t.frameBuffer.getTextureFromCurrentAttachment()}}class GradientBevelFilter extends BitmapFilter{constructor(t=4,e=45,i=null,r=null,s=null,n=4,a=4,l=1,o=1,h="inner",_=!1){super(),this._$blurFilter=new BlurFilter(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=BitmapFilterType.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=r,this.ratios=s,this.strength=l,this.type=h,this.knockout=_}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,$Array.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=Util.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(),this._$angle=Util.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,$Array.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){let e=0|Util.$toColorInt(t[i]);e<0&&(e=16777216-$Math.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=Util.$clamp($Math.abs(e),0,16777215)}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=Util.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,$Array.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i)t[i]=Util.$clamp(+t[i],0,255,0);this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=Util.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(),t){case BitmapFilterType.OUTER:case BitmapFilterType.FULL:this._$type=t;break;default:this._$type=BitmapFilterType.INNER}}clone(){return new GradientBevelFilter(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$toArray(){return Util.$getArray(7,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t){let e=t.clone();if(!this._$canApply())return e;e=this._$blurFilter._$generateFilterRect(e);const i=this._$angle*Util.$Deg2Rad,r=$Math.abs($Math.cos(i)*this._$distance),s=$Math.abs($Math.sin(i)*this._$distance);return e.x+=-r,e.width+=r,e.y+=-s,e.height+=2*s,e}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$canApply(){return this._$strength&&this._$distance&&this._$alphas&&this._$ratios&&this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const s=i.width,n=i.height,a=t._$offsetX,l=t._$offsetY,o=$Math.sqrt(e[0]*e[0]+e[1]*e[1]),h=$Math.sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*Util.$Deg2Rad,$=+$Math.cos(_)*this._$distance*o,c=+$Math.sin(_)*this._$distance*h;let u=t.frameBuffer.createTextureAttachment(s,n);t._$bind(u),Util.$resetContext(t),t.drawImage(r,0,0,s,n),t.globalCompositeOperation=BlendMode.ERASE,t.drawImage(r,2*$,2*c,s,n);const d=this._$blurFilter._$applyFilter(t,e,!1),g=d.width,p=d.height,m=$Math.ceil(g+2*$Math.abs($)),f=$Math.ceil(p+2*$Math.abs(c)),x=this._$type===BitmapFilterType.INNER,b=x?s:m,v=x?n:f,M=$Math.abs($),y=$Math.abs(c),T=(g-s)/2,A=(p-n)/2;let C,U,S,E;return x?(C=0,U=0,S=-T-$,E=-A-c):(C=M+T,U=y+A,S=M-$,E=y-c),t._$bind(i),t._$applyBitmapFilter(d,b,v,s,n,C,U,g,p,S,E,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=a+C,t._$offsetY=l+U,t.frameBuffer.releaseTexture(d),t.frameBuffer.getTextureFromCurrentAttachment()}}class GradientGlowFilter extends BitmapFilter{constructor(t=4,e=45,i=null,r=null,s=null,n=4,a=4,l=1,o=1,h="inner",_=!1){super(),this._$blurFilter=new BlurFilter(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=BitmapFilterType.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=r,this.ratios=s,this.strength=l,this.type=h,this.knockout=_}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,$Array.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=Util.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(),this._$angle=Util.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,$Array.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){let e=0|Util.$toColorInt(t[i]);e<0&&(e=16777216-$Math.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=Util.$clamp($Math.abs(e),0,16777215)}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=Util.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,$Array.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){const e=Util.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=Util.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(),t){case BitmapFilterType.OUTER:case BitmapFilterType.FULL:this._$type=t;break;default:this._$type=BitmapFilterType.INNER}}clone(){return new GradientGlowFilter(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$toArray(){return Util.$getArray(8,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const s=this._$angle*Util.$Deg2Rad,n=$Math.cos(s)*this._$distance,a=$Math.sin(s)*this._$distance;return r.x=$Math.min(r.x,n),r.width+=$Math.abs(n),r.y=$Math.min(r.y,a),r.height+=$Math.abs(a),r}_$canApply(){return this._$strength&&this._$alphas&&this._$ratios&&this._$colors&&this._$blurFilter._$canApply()}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,s=i.height,n=t._$offsetX,a=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),o=l.width,h=l.height,_=t._$offsetX,$=t._$offsetY,c=_-n,u=$-a,d=$Math.sqrt(e[0]*e[0]+e[1]*e[1]),g=$Math.sqrt(e[2]*e[2]+e[3]*e[3]),p=+this._$angle*Util.$Deg2Rad,m=+$Math.cos(p)*this._$distance*d,f=+$Math.sin(p)*this._$distance*g,x=this.type===BitmapFilterType.INNER,b=x?r:o+$Math.max(0,$Math.abs(m)-c),v=x?s:h+$Math.max(0,$Math.abs(f)-u),M=$Math.ceil(b),y=$Math.ceil(v),T=(M-b)/2,A=(y-v)/2;let C,U,S,E;return x?(C=0,U=0,S=m-_,E=f-$):(C=$Math.max(0,c-m)+T,U=$Math.max(0,u-f)+A,S=(m>0?$Math.max(0,m-c):0)+T,E=(f>0?$Math.max(0,f-u):0)+A),t._$bind(i),t._$applyBitmapFilter(l,M,y,r,s,C,U,o,h,S,E,!0,this.type,this.knockout,this._$strength,this.ratios,this.colors,this.alphas,0,0,0,0,0,0,0,0),t._$offsetX=n+C,t._$offsetY=a+U,t.frameBuffer.releaseTexture(l),t.frameBuffer.getTextureFromCurrentAttachment()}}class BezierConverter{static cubicToQuad(t,e,i,r,s,n,a,l){this._$split2Cubic(t,e,i,r,s,n,a,l,0,16),this._$split2Cubic(Util.$bezierConverterBuffer[0],Util.$bezierConverterBuffer[1],Util.$bezierConverterBuffer[2],Util.$bezierConverterBuffer[3],Util.$bezierConverterBuffer[4],Util.$bezierConverterBuffer[5],Util.$bezierConverterBuffer[6],Util.$bezierConverterBuffer[7],0,8),this._$split2Cubic(Util.$bezierConverterBuffer[16],Util.$bezierConverterBuffer[17],Util.$bezierConverterBuffer[18],Util.$bezierConverterBuffer[19],Util.$bezierConverterBuffer[20],Util.$bezierConverterBuffer[21],Util.$bezierConverterBuffer[22],Util.$bezierConverterBuffer[23],16,24),this._$split2Quad(Util.$bezierConverterBuffer[0],Util.$bezierConverterBuffer[1],Util.$bezierConverterBuffer[2],Util.$bezierConverterBuffer[3],Util.$bezierConverterBuffer[4],Util.$bezierConverterBuffer[5],Util.$bezierConverterBuffer[6],Util.$bezierConverterBuffer[7],0),this._$split2Quad(Util.$bezierConverterBuffer[8],Util.$bezierConverterBuffer[9],Util.$bezierConverterBuffer[10],Util.$bezierConverterBuffer[11],Util.$bezierConverterBuffer[12],Util.$bezierConverterBuffer[13],Util.$bezierConverterBuffer[14],Util.$bezierConverterBuffer[15],8),this._$split2Quad(Util.$bezierConverterBuffer[16],Util.$bezierConverterBuffer[17],Util.$bezierConverterBuffer[18],Util.$bezierConverterBuffer[19],Util.$bezierConverterBuffer[20],Util.$bezierConverterBuffer[21],Util.$bezierConverterBuffer[22],Util.$bezierConverterBuffer[23],16),this._$split2Quad(Util.$bezierConverterBuffer[24],Util.$bezierConverterBuffer[25],Util.$bezierConverterBuffer[26],Util.$bezierConverterBuffer[27],Util.$bezierConverterBuffer[28],Util.$bezierConverterBuffer[29],Util.$bezierConverterBuffer[30],Util.$bezierConverterBuffer[31],24)}static _$split2Cubic(t,e,i,r,s,n,a,l,o,h){const _=.125*(t+3*(i+s)+a),$=.125*(e+3*(r+n)+l),c=.125*(a+s-i-t),u=.125*(l+n-r-e);Util.$bezierConverterBuffer[o]=t,Util.$bezierConverterBuffer[o+1]=e,Util.$bezierConverterBuffer[o+2]=.5*(t+i),Util.$bezierConverterBuffer[o+3]=.5*(e+r),Util.$bezierConverterBuffer[o+4]=_-c,Util.$bezierConverterBuffer[o+5]=$-u,Util.$bezierConverterBuffer[o+6]=_,Util.$bezierConverterBuffer[o+7]=$,Util.$bezierConverterBuffer[h]=_,Util.$bezierConverterBuffer[h+1]=$,Util.$bezierConverterBuffer[h+2]=_+c,Util.$bezierConverterBuffer[h+3]=$+u,Util.$bezierConverterBuffer[h+4]=.5*(s+a),Util.$bezierConverterBuffer[h+5]=.5*(n+l),Util.$bezierConverterBuffer[h+6]=a,Util.$bezierConverterBuffer[h+7]=l}static _$split2Quad(t,e,i,r,s,n,a,l,o){const h=.125*(t+3*(i+s)+a),_=.125*(e+3*(r+n)+l);Util.$bezierConverterBuffer[o]=.25*t+.75*i,Util.$bezierConverterBuffer[o+1]=.25*e+.75*r,Util.$bezierConverterBuffer[o+2]=h,Util.$bezierConverterBuffer[o+3]=_,Util.$bezierConverterBuffer[o+4]=.75*s+.25*a,Util.$bezierConverterBuffer[o+5]=.75*n+.25*l,Util.$bezierConverterBuffer[o+6]=a,Util.$bezierConverterBuffer[o+7]=l}}class CanvasGradientToWebGL{constructor(){this._$rgb=InterpolationMethod.RGB,this._$mode=SpreadMethod.PAD,this._$focalPointRatio=0,this._$points=Util.$getFloat32Array6(),this._$stops=Util.$getArray(),this._$type=null}linear(t,e,i,r,s=InterpolationMethod.RGB,n=SpreadMethod.PAD){return this._$type=GradientType.LINEAR,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=r,this._$rgb=s,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,r,s,n,a=InterpolationMethod.RGB,l=SpreadMethod.PAD,o=0){return this._$type=GradientType.RADIAL,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=r,this._$points[4]=s,this._$points[5]=n,this._$rgb=a,this._$mode=l,this._$focalPointRatio=Util.$clamp(o,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push([t,e]),this._$stops.sort((function(t,e){switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}}))}}class CanvasPatternToWebGL{constructor(t=null,e="",i=null){this._$initialization(t,e,i)}_$initialization(t=null,e="",i=null){return this._$texture=t,this._$repeat=e,this._$colorTransform=i,this}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$colorTransform}}class CanvasToWebGLContext{constructor(t,e){this._$gl=t;const i=$Math.min(e,t.getParameter(t.MAX_SAMPLES));this._$maxTextureSize=$Math.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new CanvasToWebGLContextStyle,this._$style=this._$contextStyle,this._$fillBuffer=null,this._$strokeBuffer=null,this._$cacheCurrentBounds={x:0,y:0,w:0,h:0},this._$cacheCurrentBuffer=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation=BlendMode.NORMAL,this._$matrix=Util.$getFloat32Array9(1,0,0,0,1,0,0,0,1),this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new FrameBufferManager(t,i),this._$path=new CanvasToWebGLContextPath,this._$grid=new CanvasToWebGLContextGrid,this._$offsetX=0,this._$offsetY=0,this._$blends=[],this._$positions=[],this._$isLayer=!1,this._$shaderList=new CanvasToWebGLShaderList(this,t),this._$gradientLUT=new GradientLUTGenerator(this,t),this._$vao=new VertexArrayObjectManager(t),this._$pbo=new PixelBufferObjectManager(t),this._$mask=new CanvasToWebGLContextMask(this,t),this._$blend=new CanvasToWebGLContextBlend(this,t),this._$canvasPatternToWebGL=new CanvasPatternToWebGL,this._$canvasGradientToWebGL=new CanvasGradientToWebGL,this._$maskBufferArray=[],this._$maskBoundsArray=[],this._$attachmentArray=[]}get canvas(){return this._$gl.canvas}get fillStyle(){return this._$style._$fillStyle}set fillStyle(t){this._$style._$fillStyle.constructor===$Float32Array&&Util.$poolFloat32Array4(this._$style._$fillStyle),this._$style._$fillStyle=t}get strokeStyle(){return this._$style._$strokeStyle}set strokeStyle(t){this._$style._$strokeStyle.constructor===Float32Array&&Util.$poolFloat32Array4(this._$style._$strokeStyle),this._$style._$strokeStyle=t}get lineWidth(){return this._$style._$lineWidth}set lineWidth(t){this._$style._$lineWidth=t}get lineCap(){return this._$style._$lineCap}set lineCap(t){switch(t){case CapsStyle.NONE:case CapsStyle.SQUARE:this._$style._$lineCap=t;break;default:this._$style._$lineCap=CapsStyle.ROUND}}get lineJoin(){return this._$style._$lineJoin}set lineJoin(t){switch(t){case JointStyle.BEVEL:case JointStyle.MITER:this._$style._$lineJoin=t;break;default:this._$style._$lineJoin=JointStyle.ROUND}}get miterLimit(){return this._$style._$miterLimit}set miterLimit(t){this._$style._$miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=Util.$clamp(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=!!t}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get pbo(){return this._$pbo}get blend(){return this._$blend}_$getTextureScale(t,e){const i=Math.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}_$bind(t){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,r=t.width,s=t.height;this._$viewportWidth===r&&this._$viewportHeight===s||(this._$viewportWidth=r,this._$viewportHeight=s,this._$gl.viewport(0,0,r,s)),(e.dirty||i&&i.dirty)&&(e.dirty=!1,i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}fillRect(t,e,i,r){if(!i||!r)return;this._$viewportWidth=i,this._$viewportHeight=r;let s=!1;if(!this._$fillBuffer){s=!0;const n=this._$path.createRectVertices(t,e,i,r);this._$fillBuffer=this._$vao.createFill(n),Util.$poolArray(n.pop()),Util.$poolArray(n)}const n=this._$grid.enabled,a=this._$shaderList.shapeShaderVariants,l=a.getSolidColorShapeShader(!1,n),o=l.uniform;a.setSolidColorShapeUniform(o,!1,0,0,0,n,this._$matrix,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha),l._$fill(this._$fillBuffer),s&&(this._$vao.release(this._$fillBuffer),Util.$poolArray(this._$fillBuffer.indexRanges)),this.beginPath()}setTransform(t,e,i,r,s,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=r,this._$matrix[6]=s,this._$matrix[7]=n}transform(t,e,i,r,s,n){const a=this._$matrix[0],l=this._$matrix[1],o=this._$matrix[3],h=this._$matrix[4],_=this._$matrix[6],$=this._$matrix[7];this._$matrix[0]=t*a+e*o,this._$matrix[1]=t*l+e*h,this._$matrix[3]=i*a+r*o,this._$matrix[4]=i*l+r*h,this._$matrix[6]=s*a+n*o+_,this._$matrix[7]=s*l+n*h+$}drawImage(t,e,i,r,s,n=null){let a=1,l=1,o=1,h=this._$globalAlpha,_=0,$=0,c=0;n&&(a=n[0],l=n[1],o=n[2],_=n[4]/255,$=n[5]/255,c=n[6]/255),this._$blend.drawImage(t,e,i,r,s,a,l,o,h,_,$,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,r=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=r,this._$gl.clearColor(t,e,i,r)}clearRect(t,e,i,r){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,r),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,r){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,r),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin(),this._$isGraphics&&(this._$fillBuffer&&(this.vao.release(this._$fillBuffer),this.vao.release(this._$fillBuffer.boundObject),Util.$poolArray(this._$fillBuffer.indexRanges),Util.$poolArray(this._$fillBuffer.boundObject.indexRanges)),this._$strokeBuffer&&this.vao.release(this._$strokeBuffer)),this._$isGraphics=!1,this._$fillBuffer=null,this._$strokeBuffer=null}quadraticCurveTo(t,e,i,r){this._$path.quadTo(t,e,i,r)}bezierCurveTo(t,e,i,r,s,n){this._$path.cubicTo(t,e,i,r,s,n)}_$getVertices(){return this._$path.vertices}fill(){const t=this.fillStyle;let e,i,r,s=this._$matrix;switch(!0){case t.constructor===CanvasGradientToWebGL:if(this.fillStyle._$type===GradientType.LINEAR);else s=this._$stack[this._$stack.length-1];break;case t.constructor===CanvasPatternToWebGL:s=this._$stack[this._$stack.length-1]}const n=this._$grid.enabled;switch(!0){case t.constructor===CanvasGradientToWebGL:{const t=this.fillStyle,a=t._$stops,l="linearRGB"===t._$rgb;if(e=this._$gradientLUT.generateForShape(a,l),this._$frameBufferManager._$textureManager.bind0(e,!0),i=this._$shaderList.gradientShapeShaderVariants,t._$type===GradientType.LINEAR)r=i.getGradientShapeShader(!1,n,!1,!1,t._$mode),i.setGradientShapeUniform(r.uniform,!1,0,0,0,n,s,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,t._$points,0);else{const e=0!==t._$focalPointRatio;r=i.getGradientShapeShader(!1,n,!0,e,t._$mode),i.setGradientShapeUniform(r.uniform,!1,0,0,0,n,s,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,t._$points,t._$focalPointRatio)}}break;case t.constructor===CanvasPatternToWebGL:{const t=this.fillStyle,a=t.colorTransform;e=t.texture,this._$frameBufferManager._$textureManager.bind0(e,this._$imageSmoothingEnabled),i=this._$shaderList.shapeShaderVariants,r=i.getBitmapShapeShader(!1,""!==t.repeat,n),a?i.setBitmapShapeUniform(r.uniform,!1,0,0,0,n,s,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,e.width,e.height,a[0],a[1],a[2],this._$globalAlpha,a[4]/255,a[5]/255,a[6]/255,0):i.setBitmapShapeUniform(r.uniform,!1,0,0,0,n,s,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,e.width,e.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:i=this._$shaderList.shapeShaderVariants,r=i.getSolidColorShapeShader(!1,this._$grid.enabled),i.setSolidColorShapeUniform(r.uniform,!1,0,0,0,n,s,this._$viewportWidth,this._$viewportHeight,this._$grid,t,this._$globalAlpha)}const a=this._$shaderList.shapeShaderVariants,l=a.getMaskShapeShader(!1,n);if(a.setMaskShapeUniform(l.uniform,n,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],this._$viewportWidth,this._$viewportHeight,this._$grid),!this._$fillBuffer){const t=this._$getVertices();if(!t.length)return;const e=Util.$getArray();for(let i=0;i<t.length;++i){const r=t[i];9>r.length||e.push(r)}if(!e.length)return;this._$isGraphics=!0,this._$fillBuffer=this._$vao.createFill(e);const i=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(i),Util.$poolArray(i.pop()),Util.$poolArray(i)}this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),l._$fill(this._$fillBuffer),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),r._$fill(this._$fillBuffer.boundObject),this._$gl.disable(this._$gl.STENCIL_TEST)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$updateContainerClipFlag(t){this._$mask._$containerClip=!!t}_$startClip(t,e){let i=e.xMin,r=e.yMin,s=Math.abs(e.xMax-e.xMin),n=Math.abs(e.yMax-e.yMin);const a=this._$frameBufferManager,l=a.currentAttachment;if(s+i>l.texture.width&&(s-=s-l.texture.width+i),n+r>l.texture.height&&(n-=n-l.texture.height+r),0>i&&(s+=i,i=0),0>r&&(n+=r,r=0),0>=s||0>=n)return null;s=Math.ceil(s),n=Math.ceil(n),this._$cacheCurrentBounds.x=i,this._$cacheCurrentBounds.y=r,this._$cacheCurrentBounds.w=s,this._$cacheCurrentBounds.h=n,this._$cacheCurrentBuffer=l;const o=l.texture;return this._$bind(a.createCacheAttachment(s,n,!0)),Util.$resetContext(this),this.setTransform(1,0,0,1,0,0),this.drawImage(o,-i,-r,o.width,o.height),Util.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]-i,t[5]-r)}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}_$unionStencilMask(t,e,i){this._$mask._$unionStencilMask(t,e,i)}closePath(){this._$path.close()}stroke(){if(!this._$strokeBuffer){const t=this._$getVertices();if(!t.length)return;const e=Util.$getArray();for(let i=0;i<t.length;++i){const r=t[i];6>r.length||e.push(r)}if(!e.length)return;this._$isGraphics=!0,this._$strokeBuffer=this._$vao.createStroke(t,this.lineCap,this.lineJoin)}let t=this._$matrix;switch(!0){case this.strokeStyle.constructor===CanvasGradientToWebGL:if(this.strokeStyle._$type===GradientType.LINEAR);else t=this._$stack[this._$stack.length-1];break;case this.strokeStyle.constructor===CanvasPatternToWebGL:t=this._$stack[this._$stack.length-1]}let e=$Math.sign(t[0]*t[4]);e>0&&0!==t[1]&&0!==t[3]&&(e=-$Math.sign(t[1]*t[3]));let i,r,s=.5*this.lineWidth;this._$grid.enabled?(s*=Util.$getSameScaleBase(),i=$Math.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),r=$Math.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(i=$Math.abs(t[0]+t[3]),r=$Math.abs(t[1]+t[4]));const n=$Math.min(i,r),a=$Math.max(i,r);let l,o,h;s*=a*(1-.3*$Math.cos(.5*$Math.PI*(n/a))),s=$Math.max(1,s);const _=this._$grid.enabled;switch(!0){case this.strokeStyle.constructor===CanvasGradientToWebGL:{const i=this.strokeStyle,r=i._$stops,n="linearRGB"===i._$rgb;if(l=this._$gradientLUT.generateForShape(r,n),this._$frameBufferManager._$textureManager.bind0(l,!0),o=this._$shaderList.gradientShapeShaderVariants,i._$type===GradientType.LINEAR)h=o.getGradientShapeShader(!0,_,!1,!1,i._$mode),o.setGradientShapeUniform(h.uniform,!0,s,e,this.miterLimit,_,t,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,i._$points,0);else{const r=0!==i._$focalPointRatio;h=o.getGradientShapeShader(!0,_,!0,r,i._$mode),o.setGradientShapeUniform(h.uniform,!0,s,e,this.miterLimit,_,t,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,i._$points,i._$focalPointRatio)}}break;case this.strokeStyle.constructor===CanvasPatternToWebGL:{const i=this.strokeStyle,r=i.colorTransform;l=i.texture,this._$frameBufferManager._$textureManager.bind0(l),o=this._$shaderList.shapeShaderVariants,h=o.getBitmapShapeShader(!0,""!==i.repeat,this._$grid.enabled),r?o.setBitmapShapeUniform(h.uniform,!0,s,e,this.miterLimit,_,t,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,l.width,l.height,r[0],r[1],r[2],this._$globalAlpha,r[4]/255,r[5]/255,r[6]/255,0):o.setBitmapShapeUniform(h.uniform,!0,s,e,this.miterLimit,_,t,Util.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,l.width,l.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:o=this._$shaderList.shapeShaderVariants,h=o.getSolidColorShapeShader(!0,this._$grid.enabled),o.setSolidColorShapeUniform(h.uniform,!0,s,e,this.miterLimit,_,t,this._$viewportWidth,this._$viewportHeight,this._$grid,this.strokeStyle,this._$globalAlpha)}h._$stroke(this._$strokeBuffer)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(t=!1){const e=this._$shaderList.shapeShaderVariants,i=e.getMaskShapeShader(!1,!1),r=i.uniform;if(e.setMaskShapeUniform(r,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),!this._$fillBuffer){this._$fillBuffer=this._$vao.createFill(this._$getVertices());const t=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(t),Util.$poolArray(t.pop()),Util.$poolArray(t)}this._$mask._$onClip(this._$matrix,this._$viewportWidth,this._$viewportHeight)||(i._$fill(this._$fillBuffer),t&&(this._$vao.release(this._$fillBuffer),this._$vao.release(this._$fillBuffer.boundObject),Util.$poolArray(this._$fillBuffer.indexRanges),Util.$poolArray(this._$fillBuffer.boundObject.indexRanges),this._$fillBuffer=null),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(Util.$getFloat32Array9(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){this._$stack.length&&(Util.$poolFloat32Array9(this._$matrix),this._$matrix=this._$stack.pop()),this._$mask._$onRestore()}createPattern(t,e,i){return this._$canvasPatternToWebGL._$initialization(t,e,i)}createLinearGradient(t,e,i,r,s=InterpolationMethod.RGB,n=SpreadMethod.PAD){return this._$canvasGradientToWebGL.linear(t,e,i,r,s,n)}createRadialGradient(t,e,i,r,s,n,a=InterpolationMethod.RGB,l=SpreadMethod.PAD,o=0){return this._$canvasGradientToWebGL.radial(t,e,i,r,s,n,a,l,o)}_$applyBlurFilter(t,e,i){const r=this._$frameBufferManager,s=r.currentAttachment,n=s.width,a=s.height;r._$textureManager.bind0(t,!0);const l=$Math.ceil(.5*i),o=1-(l-.5*i),h=1+i,_=this._$shaderList.filterShaderVariants,$=_.getBlurFilterShader(l);_.setBlurFilterUniform($.uniform,n,a,e,o,h),$._$drawImage()}_$applyBitmapFilter(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p,m,f,x,b,v,M,y,T,A){const C=this._$frameBufferManager,U=c===BitmapFilterType.INNER,S=C.currentAttachment,E=C.getTextureFromCurrentAttachment();let B;const F=null!==g;let R;F&&(B=this._$gradientLUT.generateForFilter(g,p,m)),U?F?C._$textureManager.bind02(t,B,!0):C._$textureManager.bind0(t):(R=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(R),F?C._$textureManager.bind012(t,E,B,!0):C._$textureManager.bind01(t,E));const w=!(U||c===BitmapFilterType.FULL&&u),I=!(e===l&&i===o&&0===h&&0===_),P=!(1===d),L=this._$shaderList.filterShaderVariants,N=L.getBitmapFilterShader(w,I,$,c,u,P,F);L.setBitmapFilterUniform(N.uniform,e,i,r,s,n,a,l,o,h,_,$,d,f,x,b,v,M,y,T,A,w,I,P,F),U?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),N._$drawImage(),U||C.releaseAttachment(S,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager._$textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,r=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(r.uniform,e),this.blend.reset(),r._$drawImage()}_$applyConvolutionFilter(t,e,i,r,s,n,a,l,o,h,_,$){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager._$textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,p=g.getConvolutionFilterShader(e,i,a,l);g.setConvolutionFilterUniform(p.uniform,c,u,r,s,n,l,o,h,_,$),this.blend.reset(),p._$drawImage()}_$applyDisplacementMapFilter(t,e,i,r,s,n,a,l,o,h,_,$,c,u){const d=t.width,g=t.height,p=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(p),s||(s={x:0,y:0}),this._$frameBufferManager._$textureManager.bind01(t,e);const m=this._$shaderList.filterShaderVariants,f=m.getDisplacementMapFilterShader(n,a,h);m.setDisplacementMapFilterUniform(f.uniform,e.width,e.height,i,r,s.x,s.y,l,o,h,_,$,c,u),this.blend.reset(),f._$drawImage()}getImageData(t,e,i,r){const s=i*r*4,n=Util.$getUint8Array(s);this._$gl.readPixels(t,r-(r-e),i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,n);for(let t=0;t<s;t+=4){const e=n[t+3];e&&(n[t]=255&$Math.min(255*n[t]/e,255),n[t+1]=255&$Math.min(255*n[t+1]/e,255),n[t+2]=255&$Math.min(255*n[t+2]/e,255))}return n}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){Util.$poolBoundsObject(this._$positions.pop()),this._$isLayer=!!this._$blends.pop()}_$saveCurrentMask(){this._$maskBufferArray.push(this._$cacheCurrentBuffer),this._$cacheCurrentBuffer=null;const t=this._$cacheCurrentBounds;this._$maskBoundsArray.push(Util.$getBoundsObject(t.x,t.w,t.y,t.h))}_$saveAttachment(t,e,i=!1){const r=this._$frameBufferManager;this._$attachmentArray.push(r.currentAttachment),this._$bind(r.createCacheAttachment(t,e,i))}_$restoreAttachment(t=!1){const e=this._$frameBufferManager;e.releaseAttachment(e.currentAttachment,t),this._$bind(this._$attachmentArray.pop())}_$restoreCurrentMask(){this._$cacheCurrentBuffer=this._$maskBufferArray.pop(),this._$cacheCurrentBounds=this._$maskBoundsArray.pop()}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$textureScale(t,e){const i=$Math.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}changeSamples(t=4){t=$Math.min(t,this._$gl.getParameter(this._$gl.MAX_SAMPLES));const e=this._$frameBufferManager;e._$objectPool=[],e._$colorBufferPool._$objectPool=[],e._$stencilBufferPool._$objectPool=[],e._$colorBufferPool._$samples=t}}class CanvasToWebGLContextBlend{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case BlendMode.ADD:this.toAdd();break;case BlendMode.SCREEN:this.toScreen();break;case BlendMode.ALPHA:this.toAlpha();break;case BlendMode.ERASE:this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p,m){const f=this._$context._$frameBufferManager,x=f.currentAttachment,b=1!==n||1!==a||1!==l||1!==o||0!==h||0!==_||0!==$||0!==c,v=this._$context._$shaderList.blendShaderVariants;switch(u){case BlendMode.NORMAL:case BlendMode.LAYER:case BlendMode.ADD:case BlendMode.SCREEN:case BlendMode.ALPHA:case BlendMode.ERASE:case"copy":{f._$textureManager.bind0(t,m);const x=v.getNormalBlendShader(b);v.setNormalBlendUniform(x.uniform,e,i,r,s,p,d,g,b,n,a,l,o,h,_,$,c);const M=p[0],y=p[1],T=p[3],A=p[4],C=p[6],U=p[7];if(1!==M||0!==y||0!==T||1!==A){const t=e+r,n=i+s,a=+(t*M+n*T+C),l=+(t*M+i*T+C),o=+(e*M+n*T+C),h=+(e*M+i*T+C),_=+(t*y+n*A+U),$=+(t*y+i*A+U),c=+(e*y+n*A+U),u=+(e*y+i*A+U),p=$Number.MAX_VALUE,m=+$Math.min($Math.min($Math.min($Math.min(p,a),l),o),h),f=+$Math.max($Math.max($Math.max($Math.max(-p,a),l),o),h),x=+$Math.min($Math.min($Math.min($Math.min(p,_),$),c),u),b=+$Math.max($Math.max($Math.max($Math.max(-p,_),$),c),u),v=$Math.max(0,m),S=$Math.max(0,x),E=$Math.min($Math.max(0,d-v),$Math.ceil($Math.abs(f-m))),B=$Math.min($Math.max(0,g-S),$Math.ceil($Math.abs(b-x)));if(!E||!B)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(v,$Math.max(0,g-(S+B)),E+1,B+1)}else{const t=$Math.max(0,e+C),n=$Math.max(0,i+U),a=$Math.min($Math.max(0,d-t),r),l=$Math.min($Math.max(0,g-n),s);if(!a||!l)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,Math.max(0,g-(n+l)),a+1,l+1)}this.toOperation(u),x._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const M=Math.max(0,e+p[6]),y=Math.max(0,i+p[7]),T=Math.min(Math.max(0,d-M),r),A=Math.min(Math.max(0,g-y),s);if(!T||!A)return;const C=f.getTextureFromCurrentAttachment(),U=this._$context._$frameBufferManager.createTextureAttachment(r,s);this._$context._$bind(U),f._$textureManager.bind0(C);const S=v.getClipShader(),E=S.uniform;v.setClipUniform(E,e,i,r,s,Util.$inverseMatrix(p),d,g),this.reset(),S._$drawImage();const B=f.getTextureFromCurrentAttachment();this._$context._$bind(x),f._$textureManager.bind01(B,t,m);const F=v.getBlendShader(u,b);v.setBlendUniform(F.uniform,e,i,r,s,p,d,g,b,n,a,l,o,h,_,$,c),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(M,Math.max(0,g-(y+A)),T,A),this.toOneZero(),F._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),f.releaseAttachment(U,!0)}}}}class CanvasToWebGLContextGrid{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p,m,f){const x=s.xMax-s.xMin,b=s.yMax-s.yMin,v=n.width,M=n.height,y=$Math.abs($Math.ceil(x*a)),T=$Math.abs($Math.ceil(b*a)),A=v>0?(n.x-s.xMin)/x:1e-5,C=M>0?(n.y-s.yMin)/b:1e-5,U=v>0?(n.x+n.width-s.xMin)/x:.99999,S=M>0?(n.y+n.height-s.yMin)/b:.99999;let E=y*A/i,B=T*C/r,F=(i-y*(1-U))/i,R=(r-T*(1-S))/r;if(E>=F){const t=A/(A+(1-U));E=$Math.max(t-1e-5,0),F=$Math.min(t+1e-5,1)}if(B>=R){const t=C/(C+(1-S));B=$Math.max(t-1e-5,0),R=$Math.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=l,this.parentMatrixB=o,this.parentMatrixD=h,this.parentMatrixE=_,this.parentMatrixG=$,this.parentMatrixH=c,this.ancestorMatrixA=u,this.ancestorMatrixB=d,this.ancestorMatrixD=g,this.ancestorMatrixE=p,this.ancestorMatrixG=m,this.ancestorMatrixH=f,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=i,this.parentViewportH=r,this.minXST=A,this.minYST=C,this.minXPQ=E,this.minYPQ=B,this.maxXST=U,this.maxYST=S,this.maxXPQ=F,this.maxYPQ=R}disable(){this.enabled=!1}}class CanvasToWebGLContextMask{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$clipStatus=!1,this._$containerClip=!1,this._$poolClip=[],this._$currentClip=!1}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context._$frameBufferManager,e=t.getTextureFromCurrentAttachment(),i=t.currentAttachment;this._$context._$bind(this._$context._$cacheCurrentBuffer),this._$context._$cacheCurrentBuffer=null,this._$context._$blend.disable();const r=this._$context._$cacheCurrentBounds.x,s=this._$context._$cacheCurrentBounds.y;Util.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(e,r,s,e.width,e.height),this._$context._$blend.enable(),t.releaseAttachment(i,!0)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context._$frameBufferManager.currentAttachment;t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context._$frameBufferManager.currentAttachment;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context._$frameBufferManager.currentAttachment.clipLevel;let e=0;for(let i=0;i<t;++i)e|=(1<<t-i)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&e,e),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context._$frameBufferManager.currentAttachment;if(--t.clipLevel,t.mask=!!t.clipLevel,!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context._$cacheCurrentBuffer&&this._$endClip());const e=t.width,i=t.height,r=this._$context._$path.createRectVertices(0,0,e,i),s=this._$context._$vao.createFill(r);Util.$poolArray(r.pop()),Util.$poolArray(r);const n=this._$context._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),l=a.uniform;n.setMaskShapeUniformIdentity(l,e,i);const o=s.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(s,o.first,o.count),this._$context._$vao.release(s),Util.$poolArray(s.indexRanges),this._$context._$endClipDef()}_$drawContainerClip(){const t=this._$context._$frameBufferManager.currentAttachment,e=t.clipLevel,i=this._$poolClip.length,r=this._$context._$shaderList.shapeShaderVariants,s=r.getMaskShapeShader(!1,!1),n=s.uniform;let a=e;const l=t.width,o=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);for(let t=0;t<i;++t){const t=this._$poolClip.shift();r.setMaskShapeUniform(n,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const i=t.fillBuffer.indexRanges.length;for(let e=0;e<i;++e){const i=t.fillBuffer.indexRanges[e];this._$gl.stencilMask(1<<a-1),s._$containerClip(t.fillBuffer,i.first,i.count)}++a,a>7&&(this._$context._$unionStencilMask(e,l,o),a=e)}a>e+1&&this._$context._$unionStencilMask(e,l,o)}_$unionStencilMask(t,e,i){const r=this._$context._$path.createRectVertices(0,0,e,i),s=this._$context._$vao.createFill(r);Util.$poolArray(r.pop()),Util.$poolArray(r);const n=this._$context._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),l=a.uniform;n.setMaskShapeUniformIdentity(l,e,i);const o=s.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(s,o.first,o.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT)),this._$context._$vao.release(s),Util.$poolArray(s.indexRanges)}_$onClip(t,e,i){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip[this._$poolClip.length]={fillBuffer:this._$context._$fillBuffer,matrixA:t[0],matrixB:t[1],matrixC:t[2],matrixD:t[3],matrixE:t[4],matrixF:t[5],matrixG:t[6],matrixH:t[7],matrixI:t[8],viewportWidth:e,viewportHeight:i},!0)}_$onSave(){this._$clips[this._$clips.length]=this._$clipStatus}_$onRestore(){this._$clips.length&&(this._$clipStatus=!!this._$clips.pop())}}class CanvasToWebGLContextPath{constructor(){this._$currentPath=[],this._$vertices=[],this._$bounds={xMin:0,xMax:0,yMin:0,yMax:0},this._$resetBounds()}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)Util.$poolArray(this._$vertices.pop());this._$resetBounds()}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,r){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,r)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,r,!1))}cubicTo(t,e,i,r,s,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(s,n))return;const a=this._$currentPath[this._$currentPath.length-3],l=this._$currentPath[this._$currentPath.length-2];BezierConverter.cubicToQuad(a,l,t,e,i,r,s,n);const o=Util.$bezierConverterBuffer.length;for(let t=0;t<o;)this.quadTo(Util.$bezierConverterBuffer[t++],Util.$bezierConverterBuffer[t++],Util.$bezierConverterBuffer[t++],Util.$bezierConverterBuffer[t++])}drawCircle(t,e,i){const r=i,s=.5522847498307936*i;this.cubicTo(t+r,e+s,t+s,e+r,t,e+r),this.cubicTo(t-s,e+r,t-r,e+s,t-r,e),this.cubicTo(t-r,e-s,t-s,e-r,t,e-r),this.cubicTo(t+s,e-r,t+r,e-s,t+r,e)}close(){if(this._$currentPath.length<=6)return;const t=this._$currentPath[0],e=this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=this._$currentPath[this._$currentPath.length-3],r=this._$currentPath[this._$currentPath.length-2];return t===i&&e===r}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t),this._$currentPath.push(e),this._$currentPath.push(i),this._$bounds.xMin=$Math.min(t,this._$bounds.xMin),this._$bounds.xMax=$Math.max(t,this._$bounds.xMax),this._$bounds.yMin=$Math.min(e,this._$bounds.yMin),this._$bounds.yMax=$Math.max(e,this._$bounds.yMax)}_$pushCurrentPathToVertices(){this._$currentPath.length<=3?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=Util.$getArray())}_$resetBounds(){const t=Number.MAX_VALUE;this._$bounds.xMin=t,this._$bounds.xMax=-t,this._$bounds.yMin=t,this._$bounds.yMax=-t}getBoundsVertices(){return Util.$getArray(Util.$getArray(this._$bounds.xMin,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMax,!1,this._$bounds.xMin,this._$bounds.yMax,!1))}createRectVertices(t,e,i,r){return Util.$getArray(Util.$getArray(t,e,!1,t+i,e,!1,t+i,e+r,!1,t,e+r,!1))}}class CanvasToWebGLContextStyle{constructor(){this._$fillStyle=new $Float32Array([1,1,1,1]),this._$strokeStyle=new $Float32Array([1,1,1,1]),this._$lineWidth=1,this._$lineCap=0,this._$lineJoin=0,this._$miterLimit=5}}class ColorBufferPool{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=[]}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();return t.stencil=this._$gl.createRenderbuffer(),t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}return this._$objectPool.shift()}create(t,e,i=0){t=$Math.max(256,Util.$upperPowerOfTwo(t)),e=$Math.max(256,Util.$upperPowerOfTwo(e));const r=this._$getColorBuffer(t*e);return(r.width<t||r.height<e||i&&r.samples!==i)&&(t=$Math.max(t,r.width),e=$Math.max(e,r.height),r.samples=i||this._$samples,r.width=t,r.height=e,r.area=t*e,r.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.STENCIL_INDEX8,t,e)),r}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;$Math.abs(i-e)>1;){const r=$Math.floor((i+e)/2);t<=this._$objectPool[r].area?i=r:e=r}return i}}const ConvexHullVars={vertices:null};ConvexHullVars.subhulls=new Array(512),ConvexHullVars.subhullsIndex=0,ConvexHullVars.extremePoints=new Array(32),ConvexHullVars.extremePointsIndex=0,ConvexHullVars.t=0,ConvexHullVars.hulls=[new Array(16),new Array(64),new Array(256)],ConvexHullVars.hullsIndex=0;class ConvexHull{static compute(t){if(t.length<=9)return t;ConvexHullVars.vertices=t,this.chansAlgorithm();const e=new Array(3*ConvexHullVars.hullsIndex);for(let i=0;i<ConvexHullVars.hullsIndex;i++)e[3*i]=t[ConvexHullVars.subhulls[ConvexHullVars.hulls[ConvexHullVars.t][i]]],e[3*i+1]=t[ConvexHullVars.subhulls[ConvexHullVars.hulls[ConvexHullVars.t][i]]+1],e[3*i+2]=!1;return ConvexHullVars.vertices=null,e}static chansAlgorithm(){for(let t=0;t<3;t++){ConvexHullVars.t=t;const e=16*$Math.pow(4,t),i=3*e;this.clearSubhulls(),this.clearExtremePoints();const r=ConvexHullVars.vertices.length;for(let t=0;t<r;t+=i)this.calcSubhulls(t,$Math.min(t+i,r));this.addExtremePoint(ConvexHullVars.subhullsIndex),this.clearHulls();const s=this.getExtremeSubhullsIndex();let n=s,a=!1;for(;ConvexHullVars.hulls[ConvexHullVars.t][ConvexHullVars.hullsIndex++]=n,!(ConvexHullVars.hullsIndex>=e);){const t=this.getCurrentExtremePointsIndex(n);let e=this.getNextSubhullsIndex(n,t);const i=ConvexHullVars.extremePointsIndex-1;for(let t=0;t<i;t++){const i=this.binarySearch(t,n),r=ConvexHullVars.subhulls[e],s=ConvexHullVars.subhulls[i],a=ConvexHullVars.subhulls[n];this.clockwise(r,s,a)>0&&(e=i)}if(n=e,n===s){a=!0;break}}if(a)break}}static calcSubhulls(t,e){const i=e-t;if(this.addExtremePoint(ConvexHullVars.subhullsIndex),i<=3)return void this.addSubhull(t);this.clearHulls();for(let e=0;e<i;e+=3)ConvexHullVars.hulls[ConvexHullVars.t][e]=t+e,ConvexHullVars.hullsIndex++;ConvexHullVars.hulls[ConvexHullVars.t].sort(this.compare);const r=ConvexHullVars.subhullsIndex;for(let t=0;t<ConvexHullVars.hullsIndex;t++){const e=ConvexHullVars.hulls[ConvexHullVars.t][t];for(;ConvexHullVars.subhullsIndex-r>=2;){const t=ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex-1],i=ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex-2];if(this.clockwise(t,e,i)<0)break;ConvexHullVars.subhullsIndex--}if(ConvexHullVars.subhullsIndex-r>0){const t=ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex-1];this.almostEquals(t,e)&&ConvexHullVars.subhullsIndex--}this.addSubhull(ConvexHullVars.hulls[ConvexHullVars.t][t])}ConvexHullVars.subhullsIndex--;const s=ConvexHullVars.subhullsIndex;for(let t=ConvexHullVars.hullsIndex-1;t>=0;t--){const e=ConvexHullVars.hulls[ConvexHullVars.t][t];for(;ConvexHullVars.subhullsIndex-s>=2;){const t=ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex-1],i=ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex-2];if(this.clockwise(t,e,i)<0)break;ConvexHullVars.subhullsIndex--}if(ConvexHullVars.subhullsIndex-s>0){const t=ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex-1];this.almostEquals(t,e)&&ConvexHullVars.subhullsIndex--}this.addSubhull(ConvexHullVars.hulls[ConvexHullVars.t][t])}ConvexHullVars.subhullsIndex--}static addSubhull(t){ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex++]=t,ConvexHullVars.subhullsIndex>ConvexHullVars.subhulls.length&&(ConvexHullVars.subhulls.length*=2)}static addExtremePoint(t){ConvexHullVars.extremePoints[ConvexHullVars.extremePointsIndex++]=t,ConvexHullVars.extremePointsIndex>ConvexHullVars.extremePoints.length&&(ConvexHullVars.extremePoints.length*=2)}static compare(t,e){if(t<0&&e<0)return 0;if(t<0)return 1;if(e<0)return-1;const i=ConvexHullVars.vertices[t],r=ConvexHullVars.vertices[t+1],s=ConvexHullVars.vertices[e],n=ConvexHullVars.vertices[e+1];return i-s||r-n}static clockwise(t,e,i){const r=ConvexHullVars.vertices[t],s=ConvexHullVars.vertices[t+1],n=ConvexHullVars.vertices[e],a=ConvexHullVars.vertices[e+1],l=ConvexHullVars.vertices[i],o=ConvexHullVars.vertices[i+1];return Util.$cross(r-l,s-o,n-l,a-o)}static almostEquals(t,e){const i=ConvexHullVars.vertices[t],r=ConvexHullVars.vertices[t+1],s=ConvexHullVars.vertices[e],n=ConvexHullVars.vertices[e+1],a=$Math.abs(i-s),l=$Math.abs(r-n);return a<.001&&l<.001}static getExtremeSubhullsIndex(){let t=0;for(let e=0;e<ConvexHullVars.extremePoints.length;e++){const i=ConvexHullVars.extremePoints[e];if(i<0)break;ConvexHullVars.vertices[ConvexHullVars.subhulls[i]]<ConvexHullVars.vertices[ConvexHullVars.subhulls[t]]&&(t=i)}return t}static getCurrentExtremePointsIndex(t){for(let e=0;e<ConvexHullVars.extremePoints.length;e++){if(t<ConvexHullVars.extremePoints[e+1])return e}}static getNextSubhullsIndex(t,e){const i=ConvexHullVars.extremePoints[e],r=ConvexHullVars.extremePoints[e+1];if(r-i>2){const e=t+1;return e<r?e:i}return r<ConvexHullVars.extremePointsIndex-1?r:0}static binarySearch(t,e){const i=ConvexHullVars.extremePoints[t],r=ConvexHullVars.extremePoints[t+1];let s=i,n=r;for(;s<n;){let t=s-1,a=s+1;if(t<i&&(t=r-1),a>=r&&(a=i),this.almostEquals(ConvexHullVars.subhulls[s],ConvexHullVars.subhulls[e]))return a;const l=this.clockwise(ConvexHullVars.subhulls[s],ConvexHullVars.subhulls[t],ConvexHullVars.subhulls[e]),o=this.clockwise(ConvexHullVars.subhulls[s],ConvexHullVars.subhulls[a],ConvexHullVars.subhulls[e]),h=$Math.floor((s+n)/2);let _=h-1,$=h+1;if(_<i&&(_=r-1),$>=r&&($=i),this.almostEquals(ConvexHullVars.subhulls[h],ConvexHullVars.subhulls[e]))return $;const c=this.clockwise(ConvexHullVars.subhulls[h],ConvexHullVars.subhulls[_],ConvexHullVars.subhulls[e]),u=this.clockwise(ConvexHullVars.subhulls[h],ConvexHullVars.subhulls[$],ConvexHullVars.subhulls[e]);if(c<=0&&u<=0)return h;const d=this.clockwise(ConvexHullVars.subhulls[s],ConvexHullVars.subhulls[h],ConvexHullVars.subhulls[e]);d<0&&l<=0&&o<=0||d<0&&(l<0||o>0)||d>0&&(c>0||u<0)||0===d&&(c>0||u<0)?n=h:s=h+1}return s}static clearSubhulls(){for(let t=0;t<ConvexHullVars.subhulls.length;t++)ConvexHullVars.subhulls[t]=-1;ConvexHullVars.subhullsIndex=0}static clearExtremePoints(){for(let t=0;t<ConvexHullVars.extremePoints.length;t++)ConvexHullVars.extremePoints[t]=-1;ConvexHullVars.extremePointsIndex=0}static clearHulls(){const t=ConvexHullVars.hulls[ConvexHullVars.t];for(let e=0;e<t.length;e++)t[e]=-1;ConvexHullVars.hullsIndex=0}}class FrameBufferManager{constructor(t,e){this._$gl=t,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),this._$frameBufferTexture=null,this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new TextureManager(t),this._$colorBufferPool=null,this._$stencilBufferPool=new StencilBufferPool(t),this._$frameBufferTexture=t.createFramebuffer(),this._$colorBufferPool=new ColorBufferPool(t,e),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer)}get currentAttachment(){return this._$currentAttachment}createCacheAttachment(t,e,i=!1,r=0){const s=this._$objectPool.length?this._$objectPool.pop():{},n=this._$textureManager.create(t,e);return s.width=t,s.height=e,i?(s.color=this._$colorBufferPool.create(t,e,r),s.texture=n,s.msaa=!0,s.stencil=s.color.stencil):(s.color=n,s.texture=n,s.msaa=!1,s.stencil=this._$stencilBufferPool.create(n.width,n.height)),s.mask=!1,s.clipLevel=0,s.isActive=!0,s}createTextureAttachment(t,e){const i=this._$objectPool.length?this._$objectPool.pop():{},r=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=r,i.texture=r,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.length?this._$objectPool.pop():{};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t,e=!1){t.isActive&&(t.msaa?this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):(this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment.msaa)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,r=!1,s=!0){return this._$textureManager.create(t,e,i,r,s)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t,e=!1){return this._$textureManager.createFromImage(t,e)}createAlphaTextureFromPixels(t,e,i){return this._$textureManager.createAlpha(t,e,i)}createTextureFromVideo(t,e=!1,i=null){return this._$textureManager.createFromVideo(t,e,i)}createTextureFromCurrentAttachment(){const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class PixelBufferObjectManager{constructor(t){this._$gl=t,this._$objectPool=[],this._$maxWidth=0,this._$maxHeight=0,this._$cacheSize=0}_$getPixelBufferObject(t){if(!this._$objectPool.length){const t=this._$gl.createBuffer();return t.size=0,t}for(let e=0;e<this._$objectPool.length;e++){const i=this._$objectPool[e];if(i.size===t)return this._$objectPool.splice(e,1),this._$cacheSize-=i.size/4,i}const e=this._$objectPool.shift();return this._$cacheSize-=e.size/4,e}readPixelsAsync(t,e,i,r){const s=i*r*4,n=this._$getPixelBufferObject(s);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,n),n.size!==s&&(n.size=s,this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER,s,this._$gl.DYNAMIC_COPY)),this._$gl.readPixels(t,e,i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,0),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),n}getBufferSubDataAsync(t){const e=new Uint8Array(t.size);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,t),this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER,0,e),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),this.release(t),e}release(t){if(t.size>this._$maxWidth*this._$maxHeight*4)this._$gl.deleteBuffer(t);else if(this._$objectPool.push(t),this._$cacheSize+=t.size/4,this._$cacheSize>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$cacheSize-=t.size/4,this._$gl.deleteBuffer(t)}}}class StencilBufferPool{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let r=0;r<i;r++){const i=this._$objectPool[r];if(i.width===t&&i.height===e)return this._$objectPool.splice(r,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t)}}}class TextureManager{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(t,e){const i=this._$gl.createTexture();return i.width=0,i.height=0,i.area=0,i.dirty=!0,i.smoothing=!0,i._$offsetX=0,i._$offsetY=0,this.bind0(i,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,t,e),i}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const r=this._$objectPool[i];if(r.width===t&&r.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=r.area,this.bind0(r,!1),r}return this._$createTexture(t,e)}createAlpha(t,e,i){return this._$alphaTexture?this.bind0(this._$alphaTexture):(this._$alphaTexture=this._$gl.createTexture(),this.bind0(this._$alphaTexture),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST)),this._$alphaTexture.width=t,this._$alphaTexture.height=e,this._$alphaTexture.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.ALPHA,t,e,0,this._$gl.ALPHA,this._$gl.UNSIGNED_BYTE,i),this._$alphaTexture}create(t,e,i=null,r=!1,s=!0){const n=this._$getTexture(t,e);return r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),s||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,t,e,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):i&&(n.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,t,e,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)),r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),s||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),n}createFromImage(t,e=!1){return this._$createFromElement(t.width,t.height,t,e,null)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromVideo(t,e=!1,i=null){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e,i)}_$createFromElement(t,e,i,r=!1,s=null){const n=s||this._$getTexture(t,e);return n.dirty=!1,this.bind0(n,r),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,r=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,r),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i,r){const s=i!==this._$boundTextures[t],n=null!==r&&r!==i.smoothing;if((s||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),s&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i.smoothing=r;const t=r?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class VertexArrayObjectManager{constructor(t){this._$gl=t,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new $Float32Array([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$getVertexArray(t,e){const i=this._$gl.createVertexArray();this.bind(i);const r=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,r),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length)return this._$fillVertexArrayPool.pop();const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length)return this._$strokeVertexArrayPool.pop();const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=WebGLFillMeshGenerator.generate(t),i=e.vertexBufferData,r=this._$getFillVertexArray();return r.indexRanges=e.indexRanges,this.bind(r),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,r.vertexBuffer),r.vertexLength<i.length&&(r.vertexLength=Util.$upperPowerOfTwo(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*r.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),r}createStroke(t,e,i){const r=WebGLStrokeMeshGenerator.generate(t,e,i),s=r.vertexBufferData,n=r.indexBufferData,a=this._$getStrokeVertexArray();return a.indexCount=n.length,this.bind(a),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,a.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,a.indexBuffer),a.vertexLength<s.length&&(a.vertexLength=Util.$upperPowerOfTwo(s.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*a.vertexLength,this._$gl.DYNAMIC_DRAW)),a.indexLength<n.length&&(a.indexLength=Util.$upperPowerOfTwo(n.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*a.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,s),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,n),a}release(t){t.indexBuffer?this._$strokeVertexArrayPool.push(t):this._$fillVertexArrayPool.push(t)}bind(t){if(t){if(t===this._$boundVertexArray)return;this._$boundVertexArray=t}else this._$boundVertexArray=null;this._$gl.bindVertexArray(t)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class WebGLFillMeshGenerator{static generate(t){let e=0;for(let i=0;i<t.length;i++)e+=12*(t[i].length/3-2);this._$vertexBufferData=new $Float32Array(e),this._$indexRanges=Util.$getArray(),this._$currentIndex=0;for(let e=0;e<t.length;e++){const i=this._$currentIndex;this._$generateMesh(t[e]);const r=this._$currentIndex-i;this._$indexRanges.push({first:i,count:r})}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const r=t.length-5;for(let s=3;s<r;s+=3){let r=4*i;t[s+2]?(e[r++]=t[s-3],e[r++]=t[s-2],e[r++]=0,e[r++]=0,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=0,e[r++]=t[s+3],e[r++]=t[s+4],e[r++]=1,e[r++]=1):t[s+5]?(e[r++]=t[0],e[r++]=t[1],e[r++]=.5,e[r++]=.5,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=.5,e[r++]=t[s+6],e[r++]=t[s+7],e[r++]=.5,e[r++]=.5):(e[r++]=t[0],e[r++]=t[1],e[r++]=.5,e[r++]=.5,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=.5,e[r++]=t[s+3],e[r++]=t[s+4],e[r++]=.5,e[r++]=.5),i+=3}this._$currentIndex=i}}class WebGLStrokeMeshGenerator{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new Float32Array(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const r=this._$vertexBufferPos;this._$generateLineJoin(i,r),this._$generateLineCap(i,r)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new $Float32Array(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new $Int16Array(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,r,s,n){let a=t,l=e;for(let o=1;o<11;o++){const h=o/11,_=1-h,$=(t*_+i*h)*_+(i*_+s*h)*h,c=(e*_+r*h)*_+(r*_+n*h)*h;this._$addLineSegmentMesh(a,l,$,c,2),a=$,l=c}this._$addLineSegmentMesh(a,l,s,n)}static _$addLineSegmentMesh(t,e,i,r,s=1){const n=this._$vertexBufferPos/7,a=n+1,l=n+2,o=n+3;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let _=this._$indexBufferPos;h[_++]=n,h[_++]=a,h[_++]=o,h[_++]=o,h[_++]=l,h[_++]=n,this._$indexBufferPos=_,this._$expandVertexBufferIfNeeded(28);const $=this._$vertexBufferData;let c=this._$vertexBufferPos;$[c++]=t,$[c++]=e,$[c++]=i,$[c++]=r,$[c++]=1,$[c++]=1,$[c++]=1,$[c++]=t,$[c++]=e,$[c++]=i,$[c++]=r,$[c++]=-1,$[c++]=-1,$[c++]=1,$[c++]=i,$[c++]=r,$[c++]=t,$[c++]=e,$[c++]=-1,$[c++]=-1,$[c++]=s,$[c++]=i,$[c++]=r,$[c++]=t,$[c++]=e,$[c++]=1,$[c++]=1,$[c++]=s,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,r=e-55;for(let e=t;e<r;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,r,s,n,a,l,o,h,_){const $=i-t,c=r-e,u=n-i,d=a-r,g=Util.$cross($,c,u,d);if(!($Math.abs(g)<1e-4))if(2!==s)switch(this._$lineJoin){case JointStyle.ROUND:this._$addRoundJoinMesh(i,r);break;case JointStyle.MITER:this._$addMiterJoinMesh(i,r,t,e,n,a,h,l,o,_);break;default:this._$addBevelJoinMesh(i,r,h,l,o,_)}else this._$addBevelJoinMesh(i,r,h,l,o,_)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const r=this._$indexBufferData;let s=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;r[s++]=i,r[s++]=e,r[s++]=e+1}r[s++]=i,r[s++]=i+18,r[s++]=i+1,this._$indexBufferPos=s,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,r,s,n,a,l,o,h){const _=this._$vertexBufferPos/7,$=_+1,c=_+2,u=_+3,d=_+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let p=this._$indexBufferPos;g[p++]=_,g[p++]=a,g[p++]=$,g[p++]=_,g[p++]=$,g[p++]=c,g[p++]=_,g[p++]=c,g[p++]=l,g[p++]=_,g[p++]=o,g[p++]=u,g[p++]=_,g[p++]=u,g[p++]=d,g[p++]=_,g[p++]=d,g[p++]=h,this._$indexBufferPos=p,this._$expandVertexBufferIfNeeded(35);const m=this._$vertexBufferData;let f=this._$vertexBufferPos;m[f++]=t,m[f++]=e,m[f++]=i,m[f++]=r,m[f++]=s,m[f++]=n,m[f++]=0,m[f++]=t,m[f++]=e,m[f++]=i,m[f++]=r,m[f++]=s,m[f++]=n,m[f++]=21,m[f++]=t,m[f++]=e,m[f++]=i,m[f++]=r,m[f++]=s,m[f++]=n,m[f++]=22,m[f++]=t,m[f++]=e,m[f++]=i,m[f++]=r,m[f++]=s,m[f++]=n,m[f++]=23,m[f++]=t,m[f++]=e,m[f++]=i,m[f++]=r,m[f++]=s,m[f++]=n,m[f++]=24,this._$vertexBufferPos=f}static _$addBevelJoinMesh(t,e,i,r,s,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let o=this._$indexBufferPos;l[o++]=a,l[o++]=i,l[o++]=r,l[o++]=a,l[o++]=s,l[o++]=n,this._$indexBufferPos=o,this._$expandVertexBufferIfNeeded(7);const h=this._$vertexBufferData;let _=this._$vertexBufferPos;h[_++]=t,h[_++]=e,h[_++]=0,h[_++]=0,h[_++]=0,h[_++]=0,h[_++]=0,this._$vertexBufferPos=_}static _$generateLineCap(t,e){const i=this._$vertexBufferData,r=i[t],s=i[t+1],n=i[t+2],a=i[t+3],l=i[e-7],o=i[e-6],h=i[e-5],_=i[e-4],$=t/7,c=e/7;r!==l||s!==o?(this._$addLineCapMesh(r,s,n,a,$,$+1),this._$addLineCapMesh(l,o,h,_,c-1,c-2)):this._$addLineJoinMesh(h,_,r,s,n,a,c-2,c-1,$,$+1)}static _$addLineCapMesh(t,e,i,r,s,n){switch(this._$lineCap){case CapsStyle.ROUND:this._$addRoundJoinMesh(t,e);break;case CapsStyle.SQUARE:this._$addSquareCapMesh(t,e,i,r,s,n)}}static _$addSquareCapMesh(t,e,i,r,s,n){const a=this._$vertexBufferPos/7,l=a+1;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let h=this._$indexBufferPos;o[h++]=s,o[h++]=a,o[h++]=l,o[h++]=l,o[h++]=n,o[h++]=s,this._$indexBufferPos=h,this._$expandVertexBufferIfNeeded(14);const _=this._$vertexBufferData;let $=this._$vertexBufferPos;_[$++]=t,_[$++]=e,_[$++]=i,_[$++]=r,_[$++]=-1,_[$++]=-1,_[$++]=10,_[$++]=t,_[$++]=e,_[$++]=i,_[$++]=r,_[$++]=1,_[$++]=1,_[$++]=10,this._$vertexBufferPos=$}}class CanvasToWebGLShader{constructor(t,e,i,r){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,r),this._$uniform=new WebGLShaderUniform(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(t,e){const i=this._$gl.createProgram();i.id=programId++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);this._$gl.shaderSource(r,t),this._$gl.compileShader(r);const s=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);return this._$gl.shaderSource(s,e),this._$gl.compileShader(s),this._$gl.attachShader(i,r),this._$gl.attachShader(i,s),this._$gl.linkProgram(i),this._$gl.detachShader(i,r),this._$gl.detachShader(i,s),this._$gl.deleteShader(r),this._$gl.deleteShader(s),i}_$attachProgram(){this._$context._$shaderList._$currentProgramId!==this._$program.id&&(this._$context._$shaderList._$currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(t,e){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(t,e),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawElements(this._$gl.TRIANGLES,t.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t);const e=t.indexRanges[t.indexRanges.length-1],i=e.first+e.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,i)}_$containerClip(t,e,i){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.TRIANGLES,e,i)}_$drawPoints(t,e,i){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.POINTS,e,i)}}class CanvasToWebGLShaderList{constructor(t,e){this._$currentProgramId=-1,this._$shapeShaderVariants=new ShapeShaderVariantCollection(t,e),this._$bitmapShaderVariants=new BitmapShaderVariantCollection(t,e),this._$gradientShapeShaderVariants=new GradientShapeShaderVariantCollection(t,e),this._$gradientLUTShaderVariants=new GradientLUTShaderVariantCollection(t,e),this._$filterShaderVariants=new FilterShaderVariantCollection(t,e),this._$blendShaderVariants=new BlendShaderVariantCollection(t,e)}get shapeShaderVariants(){return this._$shapeShaderVariants}get bitmapShaderVariants(){return this._$bitmapShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class GradientLUTGenerator{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=$Math.floor(.75*e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new $Float32Array(256),this._$rgbIdentityTable=new $Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=$Math.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,s=this._$context._$shaderList.gradientLUTShaderVariants,n=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<r;i+=this._$maxLength-1){const a=$Math.min(i+this._$maxLength,r),l=s.getGradientLUTShader(a-i,e),o=l.uniform;s.setGradientLUTUniformForShape(o,t,i,a,n),l._$drawGradient(0===i?0:t[i][0],a===r?1:t[a-1][0])}return this._$context._$bind(i),this._$attachment.texture}generateForFilter(t,e,i){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const s=t.length,n=this._$context._$shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<s;r+=this._$maxLength-1){const a=$Math.min(r+this._$maxLength,s),l=n.getGradientLUTShader(a-r,!1),o=l.uniform;n.setGradientLUTUniformForFilter(o,t,e,i,r,a),l._$drawGradient(0===r?0:t[r],a===s?1:t[a-1])}return this._$context._$bind(r),this._$attachment.texture}}class WebGLShaderProxy{constructor(t,e,i,r){this._$context=t,this._$gl=e,this._$vertexSource=i,this._$fragmentSource=r,this._$instance=null}get instance(){return this._$instance||(this._$instance=new CanvasToWebGLShader(this._$gl,this._$context,this._$vertexSource(),this._$fragmentSource())),this._$instance}}class WebGLShaderUniform{constructor(t,e){this._$gl=t,this._$array=[],this._$map=new Map;const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),r=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,s={},n=this._$gl.getUniformLocation(e,r);if(i.type!==this._$gl.SAMPLER_2D||1!==i.size){switch(i.type){case this._$gl.FLOAT_VEC4:s.method=this._$gl.uniform4fv.bind(this._$gl,n),s.array=new $Float32Array(4*i.size),s.assign=-1;break;case this._$gl.INT_VEC4:s.method=this._$gl.uniform4iv.bind(this._$gl,n),s.array=new Int32Array(4*i.size),s.assign=-1;break;case this._$gl.SAMPLER_2D:s.method=this._$gl.uniform1iv.bind(this._$gl,n),s.array=new Int32Array(i.size),s.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(s),this._$map.set(r,s)}}}getArray(t){return this._$map.get(t).array}get textures(){return this._$map.get("u_textures").array}get highp(){return this._$map.get("u_highp").array}get mediump(){return this._$map.get("u_mediump").array}get integer(){return this._$map.get("u_integer").array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array))}}}class FragmentShaderLibrary{static FUNCTION_IS_INSIDE(){return"\\n\\nfloat isInside(in vec2 uv) {\\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\\n}\\n\\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\\n    vec4 mul = u_mediump[${t}];\\n    vec4 add = u_mediump[${t+1}];\\n\\n    src.rgb /= max(0.0001, src.a);\\n    src = clamp(src * mul + add, 0.0, 1.0);\\n    src.rgb *= src.a;\\n`}}class FragmentShaderSource{static SOLID_COLOR(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump;\\n\\nout vec4 o_color;\\n\\nvoid main() {\\n    o_color = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\\n}\\n\\n"}static BITMAP_CLIPPED(){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[3];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\\n\\n    vec4 src = texture(u_texture, uv);\\n    ${FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(1)}\\n    o_color = src;\\n}`}static BITMAP_PATTERN(){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[3];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\\n    \\n    vec4 src = texture(u_texture, uv);\\n    ${FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(1)}\\n    o_color = src;\\n}`}static MASK(){return"#version 300 es\\nprecision mediump float;\\n\\nin vec2 v_bezier;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 px = dFdx(v_bezier);\\n    vec2 py = dFdy(v_bezier);\\n\\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\\n\\n    if (alpha > 0.0) {\\n        o_color = vec4(min(alpha, 1.0));\\n    } else {\\n        discard;\\n    }    \\n}\\n\\n"}}class FragmentShaderSourceBitmapData{static FILL_COLOR(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump;\\n\\nout vec4 o_color;\\n\\nvoid main() {\\n    o_color = u_mediump;\\n}\\n\\n"}static COPY_SRC_TEX(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    o_color = texture(u_src_tex, v_src_tex_coord);\\n}\\n\\n"}static COPY_CHANNEL(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\nuniform vec4 u_mediump[2];\\n\\nin vec2 v_src_tex_coord;\\nin vec2 v_dst_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src_ch = u_mediump[0];\\n    vec4 dst_ch = u_mediump[1];\\n\\n    vec4 src_color = texture(u_textures[0], v_src_tex_coord);\\n    vec4 dst_color = texture(u_textures[1], v_dst_tex_coord);\\n\\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\\n\\n    // src_color から必要なチャンネルのスカラー値を取り出したもの\\n    float src_value = dot(src_color, src_ch);\\n\\n    // コピー先の他のチャンネルと合成\\n    vec4 mixed = mix(dst_color, vec4(src_value), dst_ch);\\n\\n#if ${t|=0}\\n    o_color = vec4(mixed.rgb * mixed.a, mixed.a);\\n#else\\n    o_color = vec4(mixed.rgb, 1.0);\\n#endif\\n}\\n\\n`}static MERGE(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\nuniform vec4 u_mediump;\\n\\nin vec2 v_src_tex_coord;\\nin vec2 v_dst_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src_color = texture(u_textures[0], v_src_tex_coord);\\n    vec4 dst_color = texture(u_textures[1], v_dst_tex_coord);\\n\\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\\n\\n    vec4 merged = mix(dst_color, src_color, u_mediump);\\n\\n#if ${t|=0}\\n    o_color = vec4(merged.rgb * merged.a, merged.a);\\n#else\\n    o_color = vec4(merged.rgb, 1.0);\\n#endif\\n}\\n\\n`}static COPY_PIXELS_WITH_ALPHA_BITMAP_DATA(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\n\\nin vec2 v_src_tex_coord;\\nin vec2 v_alpha_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src_color = texture(u_textures[0], v_src_tex_coord);\\n    float alpha = texture(u_textures[1], v_alpha_tex_coord).a;\\n\\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\\n    alpha *= src_color.a;\\n\\n    o_color = vec4(src_color.rgb * alpha, alpha);\\n}\\n\\n"}static PALETTE_MAP(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src_color = texture(u_textures[0], v_src_tex_coord);\\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\\n\\n                                                // ↓ 256*4のテクスチャの画素の中心をサンプリング\\n    vec4 map_r = texture(u_textures[1], vec2((0.5+src_color.r*255.0)/256.0, 0.125));\\n    vec4 map_g = texture(u_textures[1], vec2((0.5+src_color.g*255.0)/256.0, 0.375));\\n    vec4 map_b = texture(u_textures[1], vec2((0.5+src_color.b*255.0)/256.0, 0.625));\\n    vec4 map_a = texture(u_textures[1], vec2((0.5+src_color.a*255.0)/256.0, 0.875));\\n\\n    // u_plt_tex(u_textures[1]) のパレットデータは BGRA で格納されているので、これを取り出すには .bgra\\n    // TODO プラットフォームのバイトオーダーがビッグエンディアンの場合は ARGB で格納されるので、これを取り出すには .gbar\\n    vec4 color = (map_r + map_g + map_b + map_a).bgra;\\n\\n    // fract は 1.0, 2.0, ... のときに 0.0 を返すが 1.0 が欲しい\\n    vec4 color_fract = fract(color);\\n    color = color_fract + sign(color) - sign(color_fract);\\n\\n#if ${t|=0}\\n    o_color = vec4(color.rgb * color.a, color.a);\\n#else\\n    o_color = vec4(color.rgb, 1.0);\\n#endif\\n}\\n\\n`}static PIXEL_DISSOLVE_TEXTURE(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src_color = texture(u_src_tex, v_src_tex_coord);\\n\\n#if ${t|=0}\\n    o_color = src_color;\\n#else\\n    o_color = vec4(src_color.rgb, 1.0);\\n#endif\\n}\\n\\n`}static COLOR_TRANSFORM(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\nuniform vec4 u_mediump[2];\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 ct_mul = u_mediump[0];\\n    vec4 ct_add = u_mediump[1];\\n\\n    vec4 src_color = texture(u_src_tex, v_src_tex_coord);\\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\\n\\n    vec4 color = clamp(ct_mul * src_color + ct_add, 0.0, 1.0);\\n\\n    color = vec4(color.rgb * color.a, color.a);\\n\\n#if !${t|=0}\\n    color.a = 1.0;\\n#endif\\n\\n    o_color = color * sign(src_color.a);  // 元の色が無色透明の場合、結果も常に無色透明になる。\\n}\\n\\n`}static bitwiseAnd(){return"\\n#if __VERSION__ < 130\\n// 8bitまでの整数どうしのビット積\\nint bitwiseAnd(int a, int b) {\\n    //ivec4 c1 = ivec4(1,2,4,8);\\n    //ivec4 c2 = ivec4(16,32,64,128);\\n\\n    //ivec4 a1 = ivec4(a) / c1;\\n    //ivec4 a2 = ivec4(a) / c2;\\n    //ivec4 b1 = ivec4(b) / c1;\\n    //ivec4 b2 = ivec4(b) / c2;\\n\\n    //ivec4 r = (a1-a1/2*2) * (b1-b1/2*2) * c1\\n    //        + (a2-a2/2*2) * (b2-b2/2*2) * c2;\\n\\n    //return r.x + r.y + r.z + r.w;\\n\\n    // ↑ intのままで計算した場合（rakusanの開発環境ではintの方が遅かった）\\n    // ↓ floatに変換してから計算した場合\\n\\n    vec4 a0 = vec4(float(a));\\n    vec4 b0 = vec4(float(b));\\n    vec4 a1 = floor(a0 * vec4(1.0, 0.5, 0.25, 0.125));\\n    vec4 a2 = floor(a0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\\n    vec4 b1 = floor(b0 * vec4(1.0, 0.5, 0.25, 0.125));\\n    vec4 b2 = floor(b0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\\n\\n    return int(dot((a1-floor(a1*0.5)*2.0)*(b1-floor(b1*0.5)*2.0), vec4(1.0,2.0,4.0,8.0))\\n             + dot((a2-floor(a2*0.5)*2.0)*(b2-floor(b2*0.5)*2.0), vec4(16.0,32.0,64.0,128.0)));\\n}\\n\\nivec4 bitwiseAnd(ivec4 a, ivec4 b) {\\n    return ivec4(bitwiseAnd(a.r, b.r),\\n                 bitwiseAnd(a.g, b.g),\\n                 bitwiseAnd(a.b, b.b),\\n                 bitwiseAnd(a.a, b.a));\\n}\\n#else\\n#define bitwiseAnd(a, b) ((a)&(b))\\n#endif\\n"}static THRESHOLD(t,e,i){return e|=0,i|=0,`#version 300 es\\n#if __VERSION__ < 130\\n#extension GL_EXT_draw_buffers : require\\n#endif\\n\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\nuniform vec4 u_mediump[2]; // u_threshold(u_mediump[0]) はJS側でマスク済み\\nuniform ivec4 u_integer;\\n\\nin vec2 v_src_tex_coord;\\n\\n#if __VERSION__ < 130\\n#define outColor0 gl_FragData[0]\\n#define outColor1 gl_FragData[1]\\n#else\\nlayout (location = 0) out vec4 outColor0;\\nlayout (location = 1) out vec4 outColor1;\\n#endif\\n\\n${FragmentShaderSourceBitmapData.bitwiseAnd()}\\n\\nbool less(vec4 x) {\\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) < 0.0;\\n}\\n\\nbool greater(vec4 x) {\\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) > 0.0;\\n}\\n\\nbool lessEqual(vec4 x) {\\n    return !greater(x);\\n}\\n\\nbool greaterEqual(vec4 x) {\\n    return !less(x);\\n}\\n\\n// 組込関数に equal があるので thresholdEqual にしている。\\nbool thresholdEqual(vec4 x) {\\n    return all(equal(x, u_mediump[0]));\\n}\\n\\n// 組込関数に notEqual があるので thresholdNotEqual にしている。\\nbool thresholdNotEqual(vec4 x) {\\n    return any(notEqual(x, u_mediump[0]));\\n}\\n\\nvoid main() {\\n    // 乗算済みのままで比較するとFlash Playerと一致する。\\n\\n    vec4 src_color = texture(u_src_tex, v_src_tex_coord);\\n    ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), u_integer);\\n\\n    if (${t}(vec4(masked))) {\\n        outColor0 = u_mediump[1];\\n        outColor1 = vec4(1.0);\\n    } else {\\n#if ${e}\\n    #if ${i}\\n        outColor0 = src_color;\\n    #else\\n        outColor0 = vec4(src_color.rgb, 1.0);\\n    #endif\\n        outColor1 = vec4(0.0);\\n#else\\n        discard;\\n#endif\\n    }\\n}\\n\\n`}static THRESHOLD_SUBTOTAL(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\nuniform vec4 u_mediump;\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 src_tex_step   = u_mediump.xy;\\n    float subtotal_loop = u_mediump.z;\\n\\n    float subtotal = 0.0;\\n\\n#if __VERSION__ < 130\\n    float j = 0.0;\\n    for (float i = 0.0; i < 4095.0; ++i) {      // この 4095.0 というマジックナンバーについては\\n        if (j++ >= subtotal_loop) {           // BitmapData.prototype.threshold のコメントを見てください。\\n            break;\\n        }\\n#else\\n    for (float i = 0.0; i < subtotal_loop; ++i) {\\n#endif\\n        subtotal += texture(u_src_tex, v_src_tex_coord + src_tex_step * i).a;\\n    }\\n\\n    vec4 v1 = floor(subtotal * vec4(1.0, 0.00390625, 0.0000152587890625, 5.960464477539063e-8));  // vec4(1.0, 1.0/256.0, 1.0/65536.0, 1.0/16777216.0)\\n    vec4 v2 = vec4(v1.yzw, 0.0);\\n    o_color = (v1 - v2*256.0) * 0.00392156862745098;  // 1.0/255.0\\n}\\n\\n"}static GET_COLOR_BOUNDS_RECT(t){return t|=0,`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\nuniform vec4 u_mediump;\\nuniform ivec4 u_integer[2];\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\n${FragmentShaderSourceBitmapData.bitwiseAnd()}\\n\\nvoid main() {\\n    vec2 src_tex_step = u_mediump.xy;\\n    float scan_loop   = u_mediump.z;\\n    ivec4 mask  = u_integer[0];\\n    ivec4 color = u_integer[1];\\n\\n    float found = 0.0;\\n\\n#if __VERSION__ < 130\\n    float j = 0.0;\\n    for (float i = 0.0; i < 8191.0; ++i) {      // BitmapData の幅または高さの最大サイズは 8191 ピクセル\\n        if (j++ >= scan_loop) {\\n            break;\\n        }\\n#else\\n    for (float i = 0.0; i < scan_loop; ++i) {\\n#endif\\n        vec4 src_color = texture(u_src_tex, v_src_tex_coord + src_tex_step * i);\\n        ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), mask);\\n\\n#if ${t}\\n        if (all(equal(masked, color))) {\\n#else\\n        if (any(notEqual(masked, color))) {\\n#endif\\n            found = 1.0;\\n            break;\\n        }\\n    }\\n\\n    o_color = vec4(found);\\n}\\n\\n`}static NOISE(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump[3];\\n\\nout vec4 o_color;\\n\\n// https://stackoverflow.com/a/28095165\\n//\\n// Gold Noise ©2015 dcerisano@standard3d.com\\n// - based on the Golden Ratio\\n// - uniform normalized distribution\\n// - fastest static noise generator function (also runs at low precision)\\n\\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio\\n\\nvec4 gold_noise(vec2 xy, vec4 seed) {\\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\\n}\\n\\nvoid main() {\\n    vec4 seed = u_mediump[0];\\n    vec4 amp  = u_mediump[1];\\n    vec4 low  = u_mediump[2];\\n\\n    vec4 noise = gold_noise(gl_FragCoord.xy, seed);\\n    vec4 color = noise * amp + low;\\n    o_color = vec4(color.rgb * color.a, color.a);\\n}\\n\\n"}static GET_PIXELS(t){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 color = texture(u_src_tex, v_src_tex_coord);\\n\\n#if ${t} == 1  // RGBA\\n    o_color = vec4(color.rgb / max(0.0001, color.a), color.a);\\n#elif ${t} == 2  // BGRA\\n    o_color = vec4(color.bgr / max(0.0001, color.a), color.a);\\n#else  // ARGB\\n    o_color = vec4(color.a, color.rgb / max(0.0001, color.a));\\n#endif\\n}\\n\\n`}static SET_PIXELS(t){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_src_tex;\\n\\nin vec2 v_src_tex_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 color = texture(u_src_tex, v_src_tex_coord);\\n\\n#if ${t} == 1  // RGBA\\n    o_color = vec4(color.rgb * color.a, color.a);\\n#elif ${t} == 2  // BGRA\\n    o_color = vec4(color.bgr * color.a, color.a);\\n#else  // ARGB\\n    o_color = vec4(color.gba * color.r, color.r);\\n#endif\\n}\\n\\n`}static SET_PIXEL_QUEUE(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_dst_tex;\\n\\nin vec2 v_dst_tex_coord;\\nin vec4 v_color;\\nout vec4 o_color;\\n\\nvoid main() {\\n    float da = texture(u_dst_tex, v_dst_tex_coord).a;\\n    float a = v_color.a;\\n\\n    o_color = max( a, 0.0) * v_color\\n                     + max(-a, 0.0) * vec4(v_color.rgb * da, da);\\n}\\n\\n"}}class FragmentShaderSourceBlend{static TEMPLATE(t,e){let i;switch(t){case BlendMode.SUBTRACT:i=this.FUNCTION_SUBTRACT();break;case BlendMode.MULTIPLY:i=this.FUNCTION_MULTIPLY();break;case BlendMode.LIGHTEN:i=this.FUNCTION_LIGHTEN();break;case BlendMode.DARKEN:i=this.FUNCTION_DARKEN();break;case BlendMode.OVERLAY:i=this.FUNCTION_OVERLAY();break;case BlendMode.HARDLIGHT:i=this.FUNCTION_HARDLIGHT();break;case BlendMode.DIFFERENCE:i=this.FUNCTION_DIFFERENCE();break;case BlendMode.INVERT:i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\n${e?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${i}\\n\\nvoid main() {\\n    vec4 dst = texture(u_textures[0], v_coord);\\n    vec4 src = texture(u_textures[1], v_coord);\\n    ${e?FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = blend(src, dst);\\n}\\n\\n`}static FUNCTION_NORMAL(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    return src + dst - dst * src.a;\\n}\\n\\n"}static FUNCTION_SUBTRACT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_MULTIPLY(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n    vec4 c = src * dst;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_LIGHTEN(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_DARKEN(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_OVERLAY(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 mul = src * dst;\\n    vec3 c1 = 2.0 * mul.rgb;\\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_HARDLIGHT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 mul = src * dst;\\n    vec3 c1 = 2.0 * mul.rgb;\\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_DIFFERENCE(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_INVERT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 b = dst - dst * src.a;\\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\\n\\n    return b + c;\\n}\\n\\n"}}class FragmentShaderSourceGradient{static TEMPLATE(t,e,i,r,s){const n=i?this.STATEMENT_GRADIENT_TYPE_RADIAL(e,r):this.STATEMENT_GRADIENT_TYPE_LINEAR(e);let a;switch(s){case"reflect":a="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":a="fract(t)";break;default:a="clamp(t, 0.0, 1.0)"}return`#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_highp[${t}];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 p = v_uv;\\n    ${n}\\n    t = ${a};\\n    o_color = texture(u_texture, vec2(t, 0.5));\\n}\\n\\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\\n    vec2 a = u_highp[${t}].xy;\\n    vec2 b = u_highp[${t}].zw;\\n\\n    vec2 ab = b - a;\\n    vec2 ap = p - a;\\n\\n    float t = dot(ab, ap) / dot(ab, ab);\\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\\n    float radius = u_highp[${t}][0];\\n\\n    vec2 coord = p / radius;\\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\\n    float t = length(coord);\\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\\n\\n    vec2 dir = normalize(coord - focal);\\n\\n    float a = dot(dir, dir);\\n    float b = 2.0 * dot(dir, focal);\\n    float c = dot(focal, focal) - 1.0;\\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\\n\\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\\n`}}class FragmentShaderSourceGradientLUT{static TEMPLATE(t,e,i){let r="";for(let t=1;t<e;t++){const i=t-1,s=t,n=`u_mediump[${e+$Math.floor(i/4)}][${i%4}]`,a=`u_mediump[${e+$Math.floor(s/4)}][${s%4}]`;r+=`\\n    if (t <= ${a}) {\\n        return mix(${`u_mediump[${i}]`}, ${`u_mediump[${s}]`}, (t - ${n}) / (${a} - ${n}));\\n    }\\n`}return`#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvec4 getGradientColor(in float t) {\\n    if (t <= u_mediump[${e}][0]) {\\n        return u_mediump[0];\\n    }\\n    ${r}\\n    return u_mediump[${e-1}];\\n}\\n\\nvoid main() {\\n    vec4 color = getGradientColor(v_coord.x);\\n    ${i?"color = pow(color, vec4(0.45454545));":""}\\n    color.rgb *= color.a;\\n\\n    o_color = color;\\n}\\n\\n`}}class FragmentShaderSourceTexture{static TEMPLATE(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\n${t?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src = texture(u_texture, v_coord);\\n    ${t?FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = src;\\n}\\n\\n`}}class BitmapShaderVariantCollection{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getBitmapShader(){return this._$collection.has("b")||this._$collection.set("b",new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceTexture.TEMPLATE(0,0,!1))),this._$collection.get("b")}setBitmapUniform(){}setGetPixelsUniform(t,e,i,r,s){const n=t.highp;n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n[12]=e,n[13]=0,n[14]=0,n[16]=0,n[17]=i,n[18]=0,n[3]=r,n[7]=s,n[11]=1}setSetPixelsUniform(t,e,i,r,s,n,a,l,o){const h=t.highp;h[0]=e,h[1]=0,h[2]=0,h[4]=0,h[5]=i,h[6]=0,h[8]=r,h[9]=s,h[10]=1,h[12]=n,h[13]=0,h[14]=0,h[16]=0,h[17]=a,h[18]=0,h[3]=l,h[7]=o,h[11]=1}setColorTransformUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4]/255,i[5]=e[5]/255,i[6]=e[6]/255,i[7]=e[7]/255}setManipulatePixelsUniform(t,e,i,r,s,n){const a=t.highp;a[0]=e[0],a[1]=e[1],a[2]=e[2],a[4]=e[3],a[5]=e[4],a[6]=e[5],a[8]=e[6],a[9]=e[7],a[10]=e[8],s?(a[12]=r[0],a[13]=r[1],a[14]=r[2],a[16]=r[3],a[17]=r[4],a[18]=r[5],a[20]=r[6],a[21]=r[7],a[22]=r[8],a[24]=n[0],a[25]=n[1],a[26]=n[2],a[3]=n[3],a[7]=n[4],a[11]=n[5],a[15]=n[6],a[19]=n[7],a[23]=n[8]):i&&(a[12]=r[0],a[13]=r[1],a[14]=r[2],a[16]=r[3],a[17]=r[4],a[18]=r[5],a[3]=r[6],a[7]=r[7],a[11]=r[8])}setCopyChannelUniform(t,e,i){const r=t.textures;r[0]=0,r[1]=1;const s=t.mediump;s[0]=1&e,s[1]=e>>1&1,s[2]=e>>2&1,s[3]=e>>3&1,s[4]=1&i,s[5]=i>>1&1,s[6]=i>>2&1,s[7]=i>>3&1}setCopyPixelsUniform(t,e){if(e){const e=t.textures;e[0]=0,e[1]=1}}setFillRectUniform(t,e,i,r,s){const n=t.mediump;n[0]=e,n[1]=i,n[2]=r,n[3]=s}setGetColorBoundsRectUniform(t,e,i,r,s,n){const a=t.highp;a[0]=1,a[1]=0,a[2]=0,a[4]=0,a[5]=1,a[6]=0,a[8]=0,a[9]=0,a[10]=1,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[16]=e[3],a[17]=e[4],a[18]=e[5],a[3]=e[6],a[7]=e[7],a[11]=e[8];const l=t.mediump;l[0]=i[0],l[1]=i[1],l[2]=r;const o=t.integer;o[0]=s[0],o[1]=s[1],o[2]=s[2],o[3]=s[3],o[4]=n[0],o[5]=n[1],o[6]=n[2],o[7]=n[3]}setMergeUniform(t,e,i,r,s){const n=t.textures;n[0]=0,n[1]=1;const a=t.mediump;a[0]=e,a[1]=i,a[2]=r,a[3]=s}setNoiseUniform(t,e,i,r,s,n,a,l,o,h,_,$,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=r,u[3]=s,u[4]=n,u[5]=a,u[6]=l,u[7]=o,u[8]=h,u[9]=_,u[10]=$,u[11]=c}setPaletteMapUniform(t){const e=t.textures;e[0]=0,e[1]=2}setPixelDissolveUniform(t,e,i,r,s){const n=t.mediump;n[0]=e,n[1]=i,n[2]=r,n[3]=s}setFlushSetPixelQueueUniform(t){const e=t.highp;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=-1,e[5]=0,e[6]=0,e[7]=1,e[8]=1}setThresholdUniform(t,e,i,r,s,n,a,l,o,h,_,$,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=r,u[3]=s,u[4]=n,u[5]=a,u[6]=l,u[7]=o;const d=t.integer;d[0]=h,d[1]=_,d[2]=$,d[3]=c}}class BlendShaderVariantCollection{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getNormalBlendShader(t){const e="n"+(t?"y":"n");return this._$collection.has(e)||this._$collection.set(e,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.BLEND(),FragmentShaderSourceTexture.TEMPLATE(t))),this._$collection.get(e)}getClipShader(){return this._$collection.has("c")||this._$collection.set("c",new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.BLEND_CLIP(),FragmentShaderSourceTexture.TEMPLATE(!1))),this._$collection.get("c")}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;return this._$collection.has(i)||this._$collection.set(i,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.BLEND(),FragmentShaderSourceBlend.TEMPLATE(t,e))),this._$collection.get(i)}setNormalBlendUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p){const m=t.highp;if(m[0]=e,m[1]=i,m[2]=r,m[3]=s,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=l,o){const e=t.mediump;e[0]=h,e[1]=_,e[2]=$,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=p}}setClipUniform(t,e,i,r,s,n,a,l){const o=t.highp;o[0]=e,o[1]=i,o[2]=r,o[3]=s,o[4]=n[0],o[5]=n[1],o[6]=n[2],o[8]=n[3],o[9]=n[4],o[10]=n[5],o[12]=n[6],o[13]=n[7],o[14]=n[8],o[7]=a,o[11]=l}setBlendUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p){const m=t.textures;m[0]=0,m[1]=1;const f=t.highp;if(f[0]=e,f[1]=i,f[2]=r,f[3]=s,f[4]=n[0],f[5]=n[1],f[6]=n[2],f[8]=n[3],f[9]=n[4],f[10]=n[5],f[12]=n[6],f[13]=n[7],f[14]=n[8],f[7]=a,f[11]=l,o){const e=t.mediump;e[0]=h,e[1]=_,e[2]=$,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=p}}}class FilterShaderVariantCollection{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getBlurFilterShader(t){const e=`b${t}`;return this._$collection.has(e)||this._$collection.set(e,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceBlurFilter.TEMPLATE(t))),this._$collection.get(e)}getBitmapFilterShader(t,e,i,r,s,n,a){const l=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${r}${s?"y":"n"}${n?"y":"n"}`;if(!this._$collection.has(l)){let o=1;t&&o++,a&&o++;let h=(t?4:0)+(e?4:0)+(n?1:0);a||(h+=i?4:8),h=$Math.ceil(h/4),this._$collection.set(l,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceFilter.TEMPLATE(o,h,t,e,i,r,s,n,a)))}return this._$collection.get(l)}getColorMatrixFilterShader(){return this._$collection.has("m")||this._$collection.set("m",new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceColorMatrixFilter.TEMPLATE())),this._$collection.get("m")}getConvolutionFilterShader(t,e,i,r){const s=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${r?"y":"n"}`;if(!this._$collection.has(s)){const n=(r?1:2)+$Math.ceil(t*e/4);this._$collection.set(s,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceConvolutionFilter.TEMPLATE(n,t,e,i,r)))}return this._$collection.get(s)}getDisplacementMapFilterShader(t,e,i){const r=`d${t}${e}${i}`;if(!this._$collection.has(r)){const s=i===DisplacementMapFilterMode.COLOR?3:2;this._$collection.set(r,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceDisplacementMapFilter.TEMPLATE(s,t,e,i)))}return this._$collection.get(r)}setBlurFilterUniform(t,e,i,r,s,n){const a=t.mediump;r?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=s,a[3]=n}setBitmapFilterUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p,m,f,x,b,v,M,y,T){let A;v?(A=t.textures,A[0]=0,A[1]=1,T&&(A[2]=2)):T&&(A=t.textures,A[0]=0,A[1]=2);const C=t.mediump;let U=0;v&&(C[U]=e/r,C[U+1]=i/s,C[U+2]=n/r,C[U+3]=(i-s-a)/s,U+=4),M&&(C[U]=e/l,C[U+1]=i/o,C[U+2]=h/l,C[U+3]=(i-o-_)/o,U+=4),T||($?(C[U]=u,C[U+1]=d,C[U+2]=g,C[U+3]=p,U+=4):(C[U]=u,C[U+1]=d,C[U+2]=g,C[U+3]=p,C[U+4]=m,C[U+5]=f,C[U+6]=x,C[U+7]=b,U+=8)),y&&(C[U++]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,r,s,n,a,l,o,h,_){const $=t.mediump;$[0]=1/e,$[1]=1/i,$[2]=1/s,$[3]=n/255;let c=4;a||($[c]=l,$[c+1]=o,$[c+2]=h,$[c+3]=_,c+=4);const u=r.length;for(let t=0;t<u;t++)$[c++]=r[t]}setDisplacementMapFilterUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=r/e,g[1]=s/i,g[2]=n/e,g[3]=(s-i-a)/i,g[4]=l/r,g[5]=-o/s,h===DisplacementMapFilterMode.COLOR&&(g[8]=_,g[9]=$,g[10]=c,g[11]=u)}}class GradientLUTShaderVariantCollection{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=$Math.ceil(5*t/4);this._$collection.set(i,new CanvasToWebGLShader(this._$gl,this._$context,VertexShaderSource.TEXTURE(),FragmentShaderSourceGradientLUT.TEMPLATE(r,t,e)))}return this._$collection.get(i)}setGradientLUTUniformForShape(t,e,i,r,s){let n=0;const a=t.mediump;for(let t=i;t<r;t++){const i=e[t][1];a[n++]=s[i[0]],a[n++]=s[i[1]],a[n++]=s[i[2]],a[n++]=s[i[3]]}for(let t=i;t<r;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,r,s,n){let a=0;const l=t.mediump;for(let t=s;t<n;t++){const e=i[t];l[a++]=(e>>16)/255,l[a++]=(e>>8&255)/255,l[a++]=(255&e)/255,l[a++]=r[t]}for(let t=s;t<n;t++)l[a++]=e[t]}}class GradientShapeShaderVariantCollection{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getGradientShapeShader(t,e,i,r,s){const n=this.createCollectionKey(t,e,i,r,s);if(!this._$collection.has(n)){let a=(e?13:5)+(t?1:0)+1;const l=a-1;let o;o=t?VertexShaderSourceStroke.TEMPLATE(a,l,!0,e):VertexShaderSourceFill.TEMPLATE(a,!0,!1,e),this._$collection.set(n,new CanvasToWebGLShader(this._$gl,this._$context,o,FragmentShaderSourceGradient.TEMPLATE(a,l,i,r,s)))}return this._$collection.get(n)}createCollectionKey(t,e,i,r,s){const n=t?"y":"n",a=e?"y":"n",l=i?"y":"n",o=i&&r?"y":"n";let h=0;switch(s){case"reflect":h=1;break;case"repeat":h=2}return`${n}${a}${l}${o}${h}`}setGradientShapeUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=l[0],d[13]=l[1],d[14]=l[2],d[16]=l[3],d[17]=l[4],d[18]=l[5],d[11]=l[6],d[15]=l[7],d[19]=l[8],d[3]=o,d[7]=h;let g=20;n&&(d[g]=_.parentMatrixA,d[g+1]=_.parentMatrixB,d[g+2]=_.parentMatrixC,d[g+4]=_.parentMatrixD,d[g+5]=_.parentMatrixE,d[g+6]=_.parentMatrixF,d[g+8]=_.parentMatrixG,d[g+9]=_.parentMatrixH,d[g+10]=_.parentMatrixI,d[g+12]=_.ancestorMatrixA,d[g+13]=_.ancestorMatrixB,d[g+14]=_.ancestorMatrixC,d[g+16]=_.ancestorMatrixD,d[g+17]=_.ancestorMatrixE,d[g+18]=_.ancestorMatrixF,d[g+20]=_.ancestorMatrixG,d[g+21]=_.ancestorMatrixH,d[g+22]=_.ancestorMatrixI,d[g+11]=_.parentViewportX,d[g+15]=_.parentViewportY,d[g+19]=_.parentViewportW,d[g+23]=_.parentViewportH,d[g+24]=_.minXST,d[g+25]=_.minYST,d[g+26]=_.minXPQ,d[g+27]=_.minYPQ,d[g+28]=_.maxXST,d[g+29]=_.maxYST,d[g+30]=_.maxXPQ,d[g+31]=_.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=r,d[g+2]=s,g+=4),$?(d[g]=c[5],d[g+1]=u):(d[g]=c[0],d[g+1]=c[1],d[g+2]=c[2],d[g+3]=c[3])}}class ShapeShaderVariantCollection{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=(e?8:3)+(t?1:0),s=r;let n;n=t?VertexShaderSourceStroke.TEMPLATE(r,s,!1,!1,e):VertexShaderSourceFill.TEMPLATE(r,!1,!1,e),this._$collection.set(i,new CanvasToWebGLShader(this._$gl,this._$context,n,FragmentShaderSource.SOLID_COLOR()))}return this._$collection.get(i)}getBitmapShapeShader(t,e,i){const r=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(!this._$collection.has(r)){const s=(i?13:5)+(t?1:0),n=s;let a;a=t?VertexShaderSourceStroke.TEMPLATE(s,n,!0,!1,i):VertexShaderSourceFill.TEMPLATE(s,!0,!1,i);const l=e?FragmentShaderSource.BITMAP_PATTERN():FragmentShaderSource.BITMAP_CLIPPED();this._$collection.set(r,new CanvasToWebGLShader(this._$gl,this._$context,a,l))}return this._$collection.get(r)}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=(e?8:3)+(t?1:0),s=r;let n;n=t?VertexShaderSourceStroke.TEMPLATE(r,s,!1,!0,e):VertexShaderSourceFill.TEMPLATE(r,!1,!0,e),this._$collection.set(i,new CanvasToWebGLShader(this._$gl,this._$context,n,FragmentShaderSource.MASK()))}return this._$collection.get(i)}setSolidColorShapeUniform(t,e,i,r,s,n,a,l,o,h,_,$){const c=t.highp;let u;n?(c[0]=h.parentMatrixA,c[1]=h.parentMatrixB,c[2]=h.parentMatrixC,c[4]=h.parentMatrixD,c[5]=h.parentMatrixE,c[6]=h.parentMatrixF,c[8]=h.parentMatrixG,c[9]=h.parentMatrixH,c[10]=h.parentMatrixI,c[12]=h.ancestorMatrixA,c[13]=h.ancestorMatrixB,c[14]=h.ancestorMatrixC,c[16]=h.ancestorMatrixD,c[17]=h.ancestorMatrixE,c[18]=h.ancestorMatrixF,c[20]=h.ancestorMatrixG,c[21]=h.ancestorMatrixH,c[22]=h.ancestorMatrixI,c[3]=l,c[7]=o,c[11]=h.parentViewportX,c[15]=h.parentViewportY,c[19]=h.parentViewportW,c[23]=h.parentViewportH,c[24]=h.minXST,c[25]=h.minYST,c[26]=h.minXPQ,c[27]=h.minYPQ,c[28]=h.maxXST,c[29]=h.maxYST,c[30]=h.maxXPQ,c[31]=h.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=l,c[7]=o,u=12),e&&(c[u]=i,c[u+1]=r,c[u+2]=s);const d=t.mediump;d[0]=_[0],d[1]=_[1],d[2]=_[2],d[3]=_[3]*$}setBitmapShapeUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u,d,g,p,m,f,x,b){const v=t.highp;let M;v[0]=a[0],v[1]=a[1],v[2]=a[2],v[4]=a[3],v[5]=a[4],v[6]=a[5],v[8]=a[6],v[9]=a[7],v[10]=a[8],v[12]=l[0],v[13]=l[1],v[14]=l[2],v[16]=l[3],v[17]=l[4],v[18]=l[5],v[11]=l[6],v[15]=l[7],v[19]=l[8],v[3]=o,v[7]=h,M=20,n&&(v[M]=_.parentMatrixA,v[M+1]=_.parentMatrixB,v[M+2]=_.parentMatrixC,v[M+4]=_.parentMatrixD,v[M+5]=_.parentMatrixE,v[M+6]=_.parentMatrixF,v[M+8]=_.parentMatrixG,v[M+9]=_.parentMatrixH,v[M+10]=_.parentMatrixI,v[M+12]=_.ancestorMatrixA,v[M+13]=_.ancestorMatrixB,v[M+14]=_.ancestorMatrixC,v[M+16]=_.ancestorMatrixD,v[M+17]=_.ancestorMatrixE,v[M+18]=_.ancestorMatrixF,v[M+20]=_.ancestorMatrixG,v[M+21]=_.ancestorMatrixH,v[M+22]=_.ancestorMatrixI,v[M+11]=_.parentViewportX,v[M+15]=_.parentViewportY,v[M+19]=_.parentViewportW,v[M+23]=_.parentViewportH,v[M+24]=_.minXST,v[M+25]=_.minYST,v[M+26]=_.minXPQ,v[M+27]=_.minYPQ,v[M+28]=_.maxXST,v[M+29]=_.maxYST,v[M+30]=_.maxXPQ,v[M+31]=_.maxYPQ,M=52),e&&(v[M]=i,v[M+1]=r,v[M+2]=s);const y=t.mediump;y[0]=$,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=p,y[8]=m,y[9]=f,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,r,s,n,a,l,o,h,_,$,c,u){const d=t.highp;e?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=$,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=r,d[2]=s,d[4]=n,d[5]=a,d[6]=l,d[8]=o,d[9]=h,d[10]=_,d[3]=$,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const r=t.highp;r[0]=1,r[1]=0,r[2]=0,r[4]=0,r[5]=1,r[6]=0,r[8]=0,r[9]=0,r[10]=1,r[3]=e,r[7]=i}}class VertexShaderLibrary{static FUNCTION_GRID_OFF(){return"\\n\\nvec2 applyMatrix(in vec2 vertex) {\\n    mat3 matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n\\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\\n\\n    return position;\\n}\\n\\n"}static FUNCTION_GRID_ON(t){return`\\n\\nvec2 applyMatrix(in vec2 vertex) {\\n    mat3 parent_matrix = mat3(\\n        u_highp[${t}].xyz,\\n        u_highp[${t+1}].xyz,\\n        u_highp[${t+2}].xyz\\n    );\\n    mat3 ancestor_matrix = mat3(\\n        u_highp[${t+3}].xyz,\\n        u_highp[${t+4}].xyz,\\n        u_highp[${t+5}].xyz\\n    );\\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\\n    vec4 grid_min = u_highp[${t+6}];\\n    vec4 grid_max = u_highp[${t+7}];\\n\\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\\n    position = (position - parent_offset) / parent_size;\\n\\n    vec4 ga = grid_min;\\n    vec4 gb = grid_max  - grid_min;\\n    vec4 gc = vec4(1.0) - grid_max;\\n\\n    vec2 pa = position;\\n    vec2 pb = position - grid_min.st;\\n    vec2 pc = position - grid_max.st;\\n\\n    position = (ga.pq / ga.st) * min(pa, ga.st)\\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\\n\\n    position = position * parent_size + parent_offset;\\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\\n\\n    return position;\\n}\\n\\n`}}class VertexShaderSource{static TEXTURE(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 position = a_vertex * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static BLEND(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[4];\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 offset   = u_highp[0].xy;\\n    vec2 size     = u_highp[0].zw;\\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position = position * size + offset;\\n    position = (matrix * vec3(position, 1.0)).xy;\\n    position /= viewport;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}static BLEND_CLIP(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[4];\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 offset     = u_highp[0].xy;\\n    vec2 size       = u_highp[0].zw;\\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position *= viewport;\\n    position = (inv_matrix * vec3(position, 1.0)).xy;\\n    position = (position - offset) / size;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}}class VertexShaderSourceBitmapData{static POSITION_ONLY(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[3];\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n\\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static SRC_AND_DST_TEX_COORD(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[5];\\n\\nout vec2 v_src_tex_coord;\\nout vec2 v_dst_tex_coord;\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n    mat3 src_tex_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\\n    );\\n\\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n\\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static SRC_TEX_COORD(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[5];\\n\\nout vec2 v_src_tex_coord;\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n    mat3 src_tex_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\\n    );\\n\\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\\n\\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static SRC_AND_ALPHA_TEX_COORD(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[7];\\n\\nout vec2 v_src_tex_coord;\\nout vec2 v_alpha_tex_coord;\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n    mat3 src_tex_matrix = mat3(u_highp[3].xyz, u_highp[4].xyz, u_highp[5].xyz);\\n    mat3 alpha_tex_matrix = mat3(\\n        u_highp[6].xyz,\\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w),\\n        vec3(u_highp[3].w, u_highp[4].w, u_highp[5].w)\\n    );\\n\\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\\n    v_alpha_tex_coord = (alpha_tex_matrix * vec3(a_vertex, 1.0)).xy;\\n\\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static PIXEL_DISSOLVE_COLOR(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform mat3 u_highp[3];\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n\\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n\\n    gl_PointSize = 1.0;\\n}\\n\\n"}static PIXEL_DISSOLVE_TEXTURE(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform mat3 u_highp[5];\\n\\nout vec2 v_src_tex_coord;\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n    mat3 src_tex_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\\n    );\\n\\n    v_src_tex_coord = (u_src_tex_matrix * vec3(a_vertex, 1.0)).xy;\\n\\n    vec2 position = (u_matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n\\n    gl_PointSize = 1.0;\\n}\\n\\n"}static SET_PIXEL_QUEUE(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\nlayout (location = 1) in vec4 a_color;\\n\\nuniform mat3 u_highp[3];\\n\\nout vec2 v_dst_tex_coord;\\nout vec4 v_color;\\n\\nvoid main() {\\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\\n\\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    v_color = a_color;\\n\\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}}class VertexShaderSourceFill{static TEMPLATE(t,e,i,r){const s=i?this.ATTRIBUTE_BEZIER_ON():"",n=i?this.VARYING_BEZIER_ON():e?this.VARYING_UV_ON():"",a=i?this.STATEMENT_BEZIER_ON():e?this.STATEMENT_UV_ON():"";return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n${s}\\n\\nuniform vec4 u_highp[${t}];\\n\\n${n}\\n\\n${r?VertexShaderLibrary.FUNCTION_GRID_ON(e?5:0):VertexShaderLibrary.FUNCTION_GRID_OFF()}\\n\\nvoid main() {\\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\\n\\n    ${a}\\n\\n    vec2 pos = applyMatrix(a_vertex) / viewport;\\n    pos = pos * 2.0 - 1.0;\\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\\n}\\n\\n`}static ATTRIBUTE_BEZIER_ON(){return"\\nlayout (location = 1) in vec2 a_bezier;\\n"}static VARYING_UV_ON(){return"\\nout vec2 v_uv;\\n"}static VARYING_BEZIER_ON(){return"\\nout vec2 v_bezier;\\n"}static STATEMENT_UV_ON(){return"\\n    mat3 uv_matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n    mat3 inverse_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\\n    );\\n\\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\\n"}static STATEMENT_BEZIER_ON(){return"\\n    v_bezier = a_bezier;\\n"}}class VertexShaderSourceStroke{static TEMPLATE(t,e,i,r){const s=e-1,n=i?this.VARYING_UV_ON():"",a=i?this.STATEMENT_UV_ON():"";return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\nlayout (location = 1) in vec2 a_option1;\\nlayout (location = 2) in vec2 a_option2;\\nlayout (location = 3) in float a_type;\\n\\nuniform vec4 u_highp[${t}];\\n\\n${n}\\n\\n${r?VertexShaderLibrary.FUNCTION_GRID_ON(i?5:0):VertexShaderLibrary.FUNCTION_GRID_OFF()}\\n\\nfloat crossVec2(in vec2 v1, in vec2 v2) {\\n    return v1.x * v2.y - v2.x * v1.y;\\n}\\n\\nvec2 perpendicularVec2(in vec2 v1) {\\n    float face = u_highp[${s}][1];\\n\\n    return face * vec2(v1.y, -v1.x);\\n}\\n\\nvec2 calculateNormal(in vec2 direction) {\\n    vec2 normalized = normalize(direction);\\n    return perpendicularVec2(normalized);\\n}\\n\\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\\n    return (o1 + t * v1);\\n}\\n\\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\\n    float miter_limit = u_highp[${s}][2];\\n\\n    vec2 a = applyMatrix(a_option1);\\n    vec2 b = applyMatrix(a_option2);\\n\\n    v1 = convex * (position - a);\\n    v2 = convex * (b - position);\\n    o1 = calculateNormal(v1) + a;\\n    o2 = calculateNormal(v2) + position;\\n\\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\\n    return normalize(anchor) * min(length(anchor), miter_limit);\\n}\\n\\nvoid main() {\\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\\n    float half_width = u_highp[${s}][0];\\n\\n    vec2 position = applyMatrix(a_vertex);\\n    vec2 offset = vec2(0.0);\\n    vec2 v1, v2, o1, o2;\\n\\n    if (a_type == 1.0 || a_type == 2.0) { // 線分\\n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\\n    } else if (a_type == 10.0) { // スクエア線端\\n        offset = normalize(position - applyMatrix(a_option1));\\n        offset += a_option2 * perpendicularVec2(offset);\\n    } else if (a_type == 21.0) { // マイター結合（線分Bの凸側）\\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\\n    } else if (a_type == 22.0) { // マイター結合（線分Aの凸側）\\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\\n    } else if (a_type == 23.0) { // マイター結合（線分Aの凹側）\\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\\n    } else if (a_type == 24.0) { // マイター結合（線分Bの凹側）\\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\\n    } else if (a_type >= 30.0) { // ラウンド結合\\n        float face = u_highp[${s}][1];\\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\\n    }\\n    \\n    offset *= half_width;\\n    position += offset;\\n    ${a}\\n\\n    position /= viewport;\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n`}static VARYING_UV_ON(){return"\\nout vec2 v_uv;\\n"}static STATEMENT_UV_ON(){return"\\n    mat3 uv_matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n    mat3 inverse_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\\n    );\\n\\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\\n    v_uv += offset;\\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\\n"}}class FragmentShaderSourceBlurFilter{static TEMPLATE(t){const e=t.toFixed(1);return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump;\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2  offset   = u_mediump.xy;\\n    float fraction = u_mediump.z;\\n    float samples  = u_mediump.w;\\n    \\n    vec4 color = texture(u_texture, v_coord);\\n\\n    for (float i = 1.0; i < ${e}; i += 1.0) {\\n        color += texture(u_texture, v_coord + offset * i);\\n        color += texture(u_texture, v_coord - offset * i);\\n    }\\n    color += texture(u_texture, v_coord + offset * ${e}) * fraction;\\n    color += texture(u_texture, v_coord - offset * ${e}) * fraction;\\n    color /= samples;\\n\\n    o_color = color;\\n}\\n\\n`}}class FragmentShaderSourceColorMatrixFilter{static TEMPLATE(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[5];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\\n    vec4 add = u_mediump[4];\\n    \\n    vec4 color = texture(u_texture, v_coord);\\n\\n    color.rgb /= max(0.0001, color.a);\\n    color = clamp(color * mul + add, 0.0, 1.0);\\n    color.rgb *= color.a;\\n\\n    o_color = color;\\n}\\n\\n"}}class FragmentShaderSourceConvolutionFilter{static TEMPLATE(t,e,i,r,s){const n=$Math.floor(.5*e),a=$Math.floor(.5*i),l=e*i;let o="";const h=s?1:2;for(let t=0;t<l;++t){o+=`\\n    result += getWeightedColor(${t}, u_mediump[${h+$Math.floor(t/4)}][${t%4}]);\\n`}const _=r?"result.a = texture(u_texture, v_coord).a;":"",$=s?"":"\\n    vec4 substitute_color = u_mediump[1];\\n    color = mix(substitute_color, color, isInside(uv));\\n";return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${FragmentShaderLibrary.FUNCTION_IS_INSIDE()}\\n\\nvec4 getWeightedColor (in int i, in float weight) {\\n    vec2 rcp_size = u_mediump[0].xy;\\n\\n    int i_div_x = i / ${e};\\n    int i_mod_x = i - ${e} * i_div_x;\\n    vec2 offset = vec2(i_mod_x - ${n}, ${a} - i_div_x);\\n    vec2 uv = v_coord + offset * rcp_size;\\n\\n    vec4 color = texture(u_texture, uv);\\n    color.rgb /= max(0.0001, color.a);\\n    ${$}\\n\\n    return color * weight;\\n}\\n\\nvoid main() {\\n    float rcp_divisor = u_mediump[0].z;\\n    float bias        = u_mediump[0].w;\\n\\n    vec4 result = vec4(0.0);\\n    ${o}\\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\\n    ${_}\\n\\n    result.rgb *= result.a;\\n    o_color = result;\\n}\\n\\n`}}class FragmentShaderSourceDisplacementMapFilter{static TEMPLATE(t,e,i,r){let s,n,a;switch(e){case BitmapDataChannel.RED:s="map_color.r";break;case BitmapDataChannel.GREEN:s="map_color.g";break;case BitmapDataChannel.BLUE:s="map_color.b";break;case BitmapDataChannel.ALPHA:s="map_color.a";break;default:s="0.5"}switch(i){case BitmapDataChannel.RED:n="map_color.r";break;case BitmapDataChannel.GREEN:n="map_color.g";break;case BitmapDataChannel.BLUE:n="map_color.b";break;case BitmapDataChannel.ALPHA:n="map_color.a";break;default:n="0.5"}switch(r){case DisplacementMapFilterMode.CLAMP:a="\\n    vec4 source_color = texture(u_textures[0], uv);\\n";break;case DisplacementMapFilterMode.IGNORE:a="\\n    vec4 source_color =texture(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\\n";break;case DisplacementMapFilterMode.COLOR:a="\\n    vec4 substitute_color = u_mediump[2];\\n    vec4 source_color = mix(substitute_color, texture(u_textures[0], uv), isInside(uv));\\n";break;case DisplacementMapFilterMode.WRAP:default:a="\\n    vec4 source_color = texture(u_textures[0], fract(uv));\\n"}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${FragmentShaderLibrary.FUNCTION_IS_INSIDE()}\\n\\nvoid main() {\\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\\n    vec2 uv_to_st_offset = u_mediump[0].zw;\\n    vec2 scale           = u_mediump[1].xy;\\n\\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\\n    vec4 map_color = texture(u_textures[1], st);\\n\\n    vec2 offset = vec2(${s}, ${n}) - 0.5;\\n    vec2 uv = v_coord + offset * scale;\\n    ${a}\\n\\n    o_color = mix(texture(u_textures[0], v_coord), source_color, isInside(st));\\n}\\n\\n`}}class FragmentShaderSourceFilter{static TEMPLATE(t,e,i,r,s,n,a,l,o){let h=0;const _=i?this.STATEMENT_BASE_TEXTURE_TRANSFORM(h++):"",$=r?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(h++):this.STATEMENT_BLUR_TEXTURE(),c=n===BitmapFilterType.INNER,u=h;let d,g,p=4*h;switch(o?d=s?this.STATEMENT_GLOW(!1,i,l,o,u,p):this.STATEMENT_BEVEL(i,r,l,o,u,p):s?(p+=4,d=this.STATEMENT_GLOW(c,i,l,o,u,p)):(p+=8,d=this.STATEMENT_BEVEL(i,r,l,o,u,p)),n){case BitmapFilterType.OUTER:g=a?"blur - blur * base.a":"base + blur - blur * base.a";break;case BitmapFilterType.FULL:g=a?"blur":"base - base * blur.a + blur";break;case BitmapFilterType.INNER:default:g="blur"}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[${t}];\\nuniform vec4 u_mediump[${e}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${FragmentShaderLibrary.FUNCTION_IS_INSIDE()}\\n\\nvoid main() {\\n    ${_}\\n    ${$}\\n    ${d}\\n    o_color = ${g};\\n}\\n\\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t){return`\\n    vec2 base_scale  = u_mediump[${t}].xy;\\n    vec2 base_offset = u_mediump[${t}].zw;\\n\\n    vec2 uv = v_coord * base_scale - base_offset;\\n    vec4 base = mix(vec4(0.0), texture(u_textures[1], uv), isInside(uv));\\n`}static STATEMENT_BLUR_TEXTURE(){return"\\n    vec4 blur = texture(u_textures[0], v_coord);\\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t){return`\\n    vec2 blur_scale  = u_mediump[${t}].xy;\\n    vec2 blur_offset = u_mediump[${t}].zw;\\n\\n    vec2 st = v_coord * blur_scale - blur_offset;\\n    vec4 blur = mix(vec4(0.0), texture(u_textures[0], st), isInside(st));\\n`}static STATEMENT_GLOW(t,e,i,r,s,n){return`\\n    ${t?"blur.a = 1.0 - blur.a;":""}\\n    ${i?this.STATEMENT_GLOW_STRENGTH(n):""}\\n    ${r?this.STATEMENT_GLOW_GRADIENT_COLOR(e):this.STATEMENT_GLOW_SOLID_COLOR(s)}\\n`}static STATEMENT_GLOW_STRENGTH(t){return`\\n    float strength = u_mediump[${$Math.floor(t/4)}][${t%4}];\\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\\n    vec4 color = u_mediump[${t}];\\n    blur = color * blur.a;\\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t){return`\\n    blur = texture(u_textures[${t?2:1}], vec2(blur.a, 0.5));\\n`}static STATEMENT_BEVEL(t,e,i,r,s,n){return`\\n    ${e?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2():this.STATEMENT_BLUR_TEXTURE_2()}\\n    float highlight_alpha = blur.a - blur2.a;\\n    float shadow_alpha    = blur2.a - blur.a;\\n    ${i?this.STATEMENT_BEVEL_STRENGTH(n):""}\\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\\n    ${r?this.STATEMENT_BEVEL_GRADIENT_COLOR(t):this.STATEMENT_BEVEL_SOLID_COLOR(s)}\\n`}static STATEMENT_BLUR_TEXTURE_2(){return"\\n    vec4 blur2 = texture(u_textures[0], 1.0 - v_coord);\\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(){return"\\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\\n    vec4 blur2 = mix(vec4(0.0), texture(u_textures[0], pq), isInside(pq));\\n"}static STATEMENT_BEVEL_STRENGTH(t){return`\\n    float strength = u_mediump[${$Math.floor(t/4)}][${t%4}];\\n    highlight_alpha *= strength;\\n    shadow_alpha    *= strength;\\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\\n    vec4 highlight_color = u_mediump[${t}];\\n    vec4 shadow_color    = u_mediump[${t+1}];\\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t){return`\\n    blur = texture(u_textures[${t?2:1}], vec2(\\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\\n        0.5\\n    ));\\n`}}class RenderDisplayObject{constructor(){this._$instanceId=-1,this._$loaderInfoId=-1,this._$characterId=-1,this._$clipDepth=0,this._$depth=0,this._$isMask=!1,this._$updated=!0,this._$matrix=Util.$getFloat32Array6(1,0,0,1,0,0),this._$colorTransform=Util.$getFloat32Array8(1,1,1,1,0,0,0,0),this._$blendMode=BlendMode.NORMAL,this._$filters=null,this._$visible=!0,this._$maskId=-1,this._$maskMatrix=null,this._$isMask=!1,this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$scale9Grid=null,this._$matrixBase=null}_$shouldClip(t){if(this instanceof RenderTextField)return!(!this._$textWidth||!this._$textHeight);const e=this._$getBounds(t),i=$Math.abs(e.xMax-e.xMin),r=$Math.abs(e.yMax-e.yMin);return Util.$poolBoundsObject(e),!(!i||!r)}_$getLayerBounds(t=null){const e=this._$getBounds(t),i=this._$filters;if(!i)return e;const r=i.length;if(!r)return e;let s=new Rectangle(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);Util.$poolBoundsObject(e);for(let t=0;t<r;++t)s=i[t]._$generateFilterRect(s,null,null,!0);const n=s._$x,a=s._$x+s._$width,l=s._$y,o=s._$y+s._$height;return Util.$getBoundsObject(n,a,l,o)}_$getBounds(t=null){const e=Util.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax);if(!t)return e;let i=t;const r=this._$matrix;1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(i=Util.$multiplicationMatrix(t,r));const s=Util.$boundsMatrix(e,i);return Util.$poolBoundsObject(e),i!==t&&Util.$poolFloat32Array6(i),s}_$startClip(t,e){let i=null;if(!t._$cacheCurrentBuffer){let r=e;const s=this._$matrix;1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(r=Util.$multiplicationMatrix(e,s));const n=this._$getBounds(null),a=Util.$boundsMatrix(n,r);if(Util.$poolBoundsObject(n),i=t._$startClip(e,a),Util.$poolBoundsObject(a),r!==e&&Util.$poolFloat32Array6(r),!i)return!1}t._$enterClip(),t._$beginClipDef();let r=!1;return this instanceof RenderDisplayObjectContainer&&(r=!0,t._$updateContainerClipFlag(!0)),this._$clip(t,i||e),this._$updated=!1,r&&(t._$updateContainerClipFlag(!1),t._$drawContainerClip()),t._$endClipDef(),i}_$update(t){if(this._$updated=!0,this._$visible=t.visible,this._$isMask=t.isMask,this._$depth=t.depth,this._$clipDepth=t.clipDepth,this._$maskId=t.maskId,this._$maskId>-1&&(this._$maskMatrix=t.maskMatrix),this._$matrix[0]="a"in t?t.a:1,this._$matrix[1]="b"in t?t.b:0,this._$matrix[2]="c"in t?t.c:0,this._$matrix[3]="d"in t?t.d:1,this._$matrix[4]="tx"in t?t.tx:0,this._$matrix[5]="ty"in t?t.ty:0,this._$colorTransform[0]="f0"in t?t.f0:1,this._$colorTransform[1]="f1"in t?t.f1:1,this._$colorTransform[2]="f2"in t?t.f2:1,this._$colorTransform[3]="f3"in t?t.f3:1,this._$colorTransform[4]="f4"in t?t.f4:0,this._$colorTransform[5]="f5"in t?t.f5:0,this._$colorTransform[6]="f6"in t?t.f6:0,this._$colorTransform[7]="f7"in t?t.f7:0,this._$blendMode=t.blendMode||BlendMode.NORMAL,this._$filters=null,t.filters&&t.filters.length){this._$filters=Util.$getArray();for(let e=0;e<t.filters.length;++e){const i=t.filters[e],r=Util.$filters[i[0]];this._$filters.push(new(r.bind.apply(r,i)))}}t.grid&&(this._$scale9Grid=new Rectangle(t.grid.x,t.grid.y,t.grid.w,t.grid.h),this._$matrixBase=t.matrixBase)}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$remove(){const t=Util.$renderPlayer,e=t._$cacheStore;e.setRemoveTimer(this._$instanceId),this._$loaderInfoId>-1&&this._$characterId&&e.setRemoveTimer(`${this._$loaderInfoId}@${this._$characterId}`),t._$instances.delete(this._$instanceId),this._$instanceId=-1,this._$loaderInfoId=-1,this._$characterId=-1,this._$updated=!0,this._$blendMode=BlendMode.NORMAL,this._$filters=null,this._$visible=!0,this._$maskId=-1,this._$isMask=!1,this._$depth=0,this._$clipDepth=0,this._$scale9Grid=null}_$isUpdated(){return this._$updated}_$isFilterUpdated(t,e,i,r=null,s=!1,n=0,a=0){if(this._$isUpdated())return!0;if(s)for(let t=0;t<r.length;++t)if(r[t]._$isUpdated())return!0;const l=Util.$renderPlayer._$cacheStore.get([this._$instanceId,"f"]);switch(!0){case null===l:case l.filterState!==s:case l.layerWidth!==$Math.ceil(t):case l.layerHeight!==$Math.ceil(e):case l.matrix!==i[0]+"_"+i[1]+"_"+i[2]+"_"+i[3]+"_"+n+"_"+a:return!0}return!1}_$applyFilter(t,e,i,r,s,n){const a=+$Math.sqrt(r[0]*r[0]+r[1]*r[1]),l=+$Math.sqrt(r[2]*r[2]+r[3]*r[3]),o=$Math.atan2(r[1],r[0]),h=$Math.atan2(0-r[2],r[3]),_=Util.$getFloat32Array6($Math.cos(o),$Math.sin(o),0-$Math.sin(h),$Math.cos(h),s/2,n/2),$=Util.$getFloat32Array6(1,0,0,1,0-i.width/2,0-i.height/2),c=Util.$multiplicationMatrix(_,$);Util.$poolFloat32Array6(_),Util.$poolFloat32Array6($);const u=t._$frameBufferManager,d=u.currentAttachment,g=u.createCacheAttachment(s,n);t._$bind(g),Util.$resetContext(t),t.setTransform(c[0],c[1],c[2],c[3],c[4],c[5]),Util.$poolFloat32Array6(c),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;const p=Util.$getFloat32Array6(a,0,0,l,0,0);let m=null;for(let i=0;i<e.length;++i)m=e[i]._$applyFilter(t,p);Util.$poolFloat32Array6(p);let f=t._$offsetX,x=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,m._$offsetX=f,m._$offsetY=x,m.matrix=r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3],m.filterState=!0,m.layerWidth=s,m.layerHeight=n,t._$bind(d),u.releaseAttachment(g,!1),m}_$drawFilter(t,e,i,r,s,n){const a=Util.$renderPlayer._$cacheStore,l=[this._$instanceId,"f"];let o=a.get(l);const h=this._$isFilterUpdated(s,n,i,r,!0);let _;return o&&!h||(o&&(a.set(l,null),o.layerWidth=0,o.layerHeight=0,o._$offsetX=0,o._$offsetY=0,o.matrix=null,o.colorTransform=null,t.frameBuffer.releaseTexture(o),o=null),_=this._$applyFilter(t,r,e,i,s,n),a.set(l,_)),o&&(_=o),_}}class RenderGraphics extends RenderDisplayObject{constructor(){super(),this._$recodes=null,this._$maxAlpha=0,this._$canDraw=!1}_$clip(t,e){t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,this._$recodes,null,!0),t.clip()}_$draw(t,e,i,r=BlendMode.NORMAL,s=null){if(!this._$visible)return;const n=Util.$clamp(i[3]+i[7]/255,0,1,0);if(!n||!this._$maxAlpha)return;const a=this._$matrix;let l=null!==this._$scale9Grid;l&&(l=l&&$Math.abs(a[1])<.001&&$Math.abs(a[2])<1e-4);const o=Util.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax),h=Util.$boundsMatrix(o,e),_=h.xMax,$=h.xMin,c=h.yMax,u=h.yMin;Util.$poolBoundsObject(h);const d=$Math.ceil($Math.abs(_-$)),g=$Math.ceil($Math.abs(c-u));switch(!0){case 0===d:case 0===g:case d===-1/0:case g===-1/0:case Infinity===d:case Infinity===g:return}const p=t._$frameBufferManager,m=p.currentAttachment;if($>m.width||u>m.height)return;let f=+$Math.sqrt(e[0]*e[0]+e[1]*e[1]);if(!$Number.isInteger(f)){const t=f.toString(),e=t.indexOf("e");-1!==e&&(f=+t.slice(0,e)),f=+f.toFixed(4)}let x=+$Math.sqrt(e[2]*e[2]+e[3]*e[3]);if(!$Number.isInteger(x)){const t=x.toString(),e=t.indexOf("e");-1!==e&&(x=+t.slice(0,e)),x=+x.toFixed(4)}if(0>$+d||0>u+g){if(!(s&&s.length&&this._$canApply(s)))return;{let t=new Rectangle(0,0,d,g);for(let e=0;e<s.length;++e)t=s[e]._$generateFilterRect(t,f,x);if(0>t.x+t.width||0>t.y+t.height)return}}const b=Util.$getArray(f,x);let v=this._$instanceId;!l&&this._$loaderInfoId>-1&&this._$characterId>-1&&(v=`${this._$loaderInfoId}@${this._$characterId}`);const M=Util.$cacheStore(),y=M.generateKeys(v,b,i);Util.$poolArray(b);let T=M.get(y);if(!T){let r=$Math.ceil($Math.abs(o.xMax-o.xMin)*f),s=$Math.ceil($Math.abs(o.yMax-o.yMin)*x);const n=t._$getTextureScale(r,s);n<1&&(r*=n,s*=n);const h=p.createCacheAttachment(r,s,!0);if(t._$bind(h),Util.$resetContext(t),t.setTransform(f,0,0,x,0-o.xMin*f,0-o.yMin*x),l){const i=Util.$renderPlayer._$matrix[0],r=Util.$getFloat32Array6(i,0,0,i,0,0),s=Util.$multiplicationMatrix(r,a);Util.$poolFloat32Array6(r);const n=this._$matrixBase,l=Util.$getFloat32Array6(n[0],n[1],n[2],n[3],n[4]*i-$,n[5]*i-u),h=Util.$multiplicationMatrix(l,s),_=h[4]-(e[4]-$),c=h[5]-(e[5]-u);Util.$poolFloat32Array6(h);const d=Util.$boundsMatrix(o,s),g=+d.xMax,p=+d.xMin,m=+d.yMax,f=+d.yMin,x=$Math.ceil($Math.abs(g-p)),b=$Math.ceil($Math.abs(m-f));Util.$poolBoundsObject(d),t.grid.enable(p,f,x,b,o,this._$scale9Grid,i,s[0],s[1],s[2],s[3],s[4],s[5],l[0],l[1],l[2],l[3],l[4]-_,l[5]-c),Util.$poolFloat32Array6(s),Util.$poolFloat32Array6(l)}i[3]=1,this._$runCommand(t,this._$recodes,i,!1),l&&t.grid.disable(),T=p.getTextureFromCurrentAttachment(),Util.$useCache&&M.set(y,T),p.releaseAttachment(h,!1),t._$bind(m)}let A=!1,C=0,U=0;s&&s.length&&this._$canApply(s)&&(A=!0,T=this._$drawFilter(t,T,e,s,d,g),C=T._$offsetX,U=T._$offsetY);const S=$Math.atan2(e[1],e[0]),E=$Math.atan2(0-e[2],e[3]);if(A||!S&&!E)t.setTransform(1,0,0,1,$-C,u-U);else{const i=o.xMin*f,r=o.yMin*x,s=$Math.cos(S),n=$Math.sin(S),a=$Math.cos(E),l=$Math.sin(E);t.setTransform(s,n,0-l,a,i*s-r*l+e[4],i*n+r*a+e[5])}Util.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=r,t.drawImage(T,0,0,T.width,T.height,i),Util.$poolArray(y),Util.$poolBoundsObject(o)}setupStroke(t,e,i,r,s){switch(t.lineWidth=e,i){case 0:t.lineCap=CapsStyle.NONE;break;case 1:t.lineCap=CapsStyle.ROUND;break;case 2:t.lineCap=CapsStyle.SQUARE}switch(r){case 0:t.lineJoin=JointStyle.BEVEL;break;case 1:t.lineJoin=JointStyle.MITER;break;case 2:t.lineJoin=JointStyle.ROUND}t.miterLimit=s}createGradientStyle(t,e,i,r,s,n,a,l=null){let o="pad";switch(s){case 0:o="reflect";break;case 1:o="repeat"}let h=null;if(0===e){const e=Util.$linearGradientXY(r);h=t.createLinearGradient(e[0],e[1],e[2],e[3],n?"rgb":"linearRGB",o)}else t.save(),t.transform(r[0],r[1],r[2],r[3],r[4],r[5]),h=t.createRadialGradient(0,0,0,0,0,819.2,n?"rgb":"linearRGB",o,a);for(let t=0;t<i.length;++t){const e=i[t];l?h.addColorStop(e.ratio,Util.$getFloat32Array4($Math.max(0,$Math.min(e.R*l[0]+l[4],255)),$Math.max(0,$Math.min(e.G*l[1]+l[5],255)),$Math.max(0,$Math.min(e.B*l[2]+l[6],255)),$Math.max(0,$Math.min(e.A*l[3]+l[7],255)))):h.addColorStop(e.ratio,Util.$getFloat32Array4($Math.max(0,$Math.min(e.R,255)),$Math.max(0,$Math.min(e.G,255)),$Math.max(0,$Math.min(e.B,255)),$Math.max(0,$Math.min(e.A,255))))}return h}_$runCommand(t,e,i=null,r=!1){Util.$resetContext(t),t.beginPath();const s=e.length;for(let n=0;n<s;)switch(e[n++]){case 9:t.beginPath();break;case 0:t.moveTo(e[n++],e[n++]);break;case 2:t.lineTo(e[n++],e[n++]);break;case 1:t.quadraticCurveTo(e[n++],e[n++],e[n++],e[n++]);break;case 5:{if(r){n+=4;continue}const s=t._$contextStyle;s._$fillStyle[0]=e[n++]/255,s._$fillStyle[1]=e[n++]/255,s._$fillStyle[2]=e[n++]/255,s._$fillStyle[3]=!i||1===i[3]&&0===i[7]?e[n++]/255:$Math.max(0,$Math.min(e[n++]*i[3]+i[7],255))/255,t._$style=s}break;case 7:r||t.fill();break;case 6:{if(r){n+=8;continue}this.setupStroke(t,e[n++],e[n++],e[n++],e[n++]);const s=t._$contextStyle;s._$strokeStyle[0]=e[n++]/255,s._$strokeStyle[1]=e[n++]/255,s._$strokeStyle[2]=e[n++]/255,s._$strokeStyle[3]=!i||1===i[3]&&0===i[7]?e[n++]/255:$Math.max(0,$Math.min(e[n++]*i[3]+i[7],255))/255,t._$style=s}break;case 8:r||t.stroke();break;case 12:t.closePath();break;case 3:t.bezierCurveTo(e[n++],e[n++],e[n++],e[n++],e[n++],e[n++]);break;case 4:t.arc(e[n++],e[n++],e[n++],0,2*$Math.PI);break;case 10:{if(r){n+=1;const t=e[n++];n+=5*t,n+=9;continue}const s=e[n++];let a=e[n++];const l=Util.$getArray();for(;a;)l.push({ratio:e[n++],R:e[n++],G:e[n++],B:e[n++],A:e[n++]}),a--;const o=Util.$getFloat32Array6(e[n++],e[n++],e[n++],e[n++],e[n++],e[n++]);t.fillStyle=this.createGradientStyle(t,s,l,o,e[n++],e[n++],e[n++],i),t.fill(),1===s&&t.restore(),Util.$poolFloat32Array6(o),Util.$poolArray(l)}break;case 11:{if(r){n+=5;const t=e[n++];n+=5*t,n+=9;continue}this.setupStroke(t,e[n++],e[n++],e[n++],e[n++]);const s=e[n++];let a=e[n++];const l=Util.$getArray();for(;a;)l.push({ratio:e[n++],R:e[n++],G:e[n++],B:e[n++],A:e[n++]}),a--;const o=Util.$getFloat32Array6(e[n++],e[n++],e[n++],e[n++],e[n++],e[n++]);t.strokeStyle=this.createGradientStyle(t,s,l,o,e[n++],e[n++],e[n++],i),t.stroke(),1===s&&t.restore(),Util.$poolFloat32Array6(o),Util.$poolArray(l)}break;case 13:{const s=e[n++],a=e[n++],l=e[n++],o=e[n++],h=e[n++];if(r){n+=h,n+=8;continue}const _=new Uint8Array(e.subarray(n,h+n));n+=h;const $=Util.$getFloat32Array6(e[n++],e[n++],e[n++],e[n++],e[n++],e[n++]),c=e[n++]?"repeat":"no-repeat",u=!!e[n++];t.save(),1===$[0]&&0===$[1]&&0===$[2]&&1===$[3]&&0===$[4]&&0===$[5]||t.transform($[0],$[1],$[2],$[3],$[4],$[5]),Util.$poolFloat32Array6($);const d=t._$frameBufferManager,g=d.createTextureFromPixels(s,a,_,!0);"no-repeat"===c&&s===l&&a===o?(t.drawImage(g,0,0,s,a),d.releaseTexture(g)):(t.fillStyle=t.createPattern(g,c,i),t._$imageSmoothingEnabled=u,t.fill()),t.restore(),t._$imageSmoothingEnabled=!1}break;case 14:{if(r){n+=4;const t=e[n++];n+=t,n+=8;continue}t.save(),this.setupStroke(t,e[n++],e[n++],e[n++],e[n++]);const s=e[n++],a=e[n++],l=e[n++],o=new Uint8Array(e.subarray(n,l+n));n+=l;const h=Util.$getFloat32Array6(e[n++],e[n++],e[n++],e[n++],e[n++],e[n++]);1===h[0]&&0===h[1]&&0===h[2]&&1===h[3]&&0===h[4]&&0===h[5]||t.transform(h[0],h[1],h[2],h[3],h[4],h[5]),Util.$poolFloat32Array6(h);const _=e[n++]?"repeat":"no-repeat",$=!!e[n++],c=t._$frameBufferManager.createTextureFromPixels(s,a,o,!0);t.strokeStyle=t.createPattern(c,_,i),t._$imageSmoothingEnabled=$,t.stroke(),t.restore(),t._$imageSmoothingEnabled=!1}}}_$update(t){if(super._$update(t),t.recodes){this._$recodes=t.recodes,this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,this._$maxAlpha=t.maxAlpha,this._$canDraw=t.canDraw;const e=Util.$renderPlayer._$cacheStore;e.removeCache(this._$instanceId),this._$loaderInfoId>-1&&this._$characterId>-1&&e.removeCache(`${this._$loaderInfoId}@${this._$characterId}`)}}}class CommandController{constructor(){this._$wait=!1,this.state="deactivate",this.queue=[]}initialize(t,e=4,i=2,r=!1){$devicePixelRatio=i,Util.$isSafari=!!r;const s=Util.$renderPlayer;s._$samples=e,s._$canvas=t;const n=t.getContext("webgl2",{stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0});if(n){const t=new CanvasToWebGLContext(n,e);s._$context=t,s._$cacheStore._$context=t}}setBackgroundColor(t=null){const e=Util.$renderPlayer._$context;if(e)if(t&&"transparent"!==t){const i=Util.$uintToRGBA(Util.$toColorInt(t));e._$setColor(i.R/255,i.G/255,i.B/255,i.A/255)}else e._$setColor(0,0,0,0)}execute(){for(this.state="active";this.queue.length;){if(this._$wait)continue;const t=this.queue.shift();switch(t.command){case"setProperty":{const e=Util.$renderPlayer._$instances;if(!e.has(t.instanceId))continue;e.get(t.instanceId)._$update(t)}break;case"setChildren":{const e=Util.$renderPlayer._$instances;if(!e.has(t.instanceId))continue;e.get(t.instanceId)._$children=t.children}break;case"doChanged":{const e=Util.$renderPlayer._$instances;if(!e.has(t.instanceId))continue;e.get(t.instanceId)._$updated=!0}break;case"remove":{const e=Util.$renderPlayer._$instances;if(!e.has(t.instanceId))continue;e.get(t.instanceId)._$remove(),e.delete(t.instanceId)}break;case"createShape":Util.$renderPlayer._$createShape(t);break;case"createDisplayObjectContainer":Util.$renderPlayer._$createDisplayObjectContainer(t);break;case"createTextField":Util.$renderPlayer._$createTextField(t);break;case"createVideo":Util.$renderPlayer._$createVideo(t);break;case"resize":Util.$renderPlayer._$resize(t.width,t.height,t.scale,t.tx,t.ty);break;case"initialize":this.initialize(t.canvas,t.samples,t.devicePixelRatio);break;case"setBackgroundColor":this.setBackgroundColor(t.backgroundColor);break;case"setStage":Util.$renderPlayer._$setStage(t.instanceId);break;case"play":Util.$renderPlayer._$frameRate=t.frameRate,Util.$renderPlayer.play();break;case"stop":Util.$renderPlayer.stop();break;case"removeCache":Util.$renderPlayer._$cacheStore.removeCache(t.id);break;case"bitmapDraw":{const e=Util.$renderPlayer,i=e._$stopFlag;i||e.stop();const r=new $OffscreenCanvas(t.width,t.height);e._$bitmapDraw(e._$instances.get(t.sourceId),t.matrix||Util.$MATRIX_ARRAY_IDENTITY,t.colorTransform||Util.$COLOR_ARRAY_IDENTITY,r),i||e.play();const s=r.transferToImageBitmap();globalThis.postMessage({command:"bitmapDraw",sourceId:t.sourceId,imageBitmap:s},[s])}}}this.state="deactivate"}}const command=new CommandController;Util.$filters=[BevelFilter,BlurFilter,ColorMatrixFilter,ConvolutionFilter,DisplacementMapFilter,DropShadowFilter,GlowFilter,GradientBevelFilter,GradientGlowFilter],this.addEventListener("message",(function(t){command.queue.push(t.data),"deactivate"===command.state&&command.execute()}));class RenderDisplayObjectContainer extends RenderGraphics{constructor(){super(),this._$children=[]}_$clip(t,e){let i=e;const r=this._$matrix;1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(i=Util.$multiplicationMatrix(e,r)),this._$recodes&&this._$canDraw&&super._$clip(t,i);const s=Util.$renderPlayer._$instances,n=this._$children,a=n.length;for(let e=0;e<a;++e){const r=n[e];if(!s.has(r))continue;const a=s.get(r);a._$isMask||(a._$clip(t,i),a._$updated=!1)}i!==e&&Util.$poolFloat32Array6(i)}_$draw(t,e,i){if(!this._$visible)return;let r=i;const s=this._$colorTransform;1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=Util.$multiplicationColor(i,s));if(!Util.$clamp(r[3]+r[7]/255,0,1,0))return;const n=this._$children,a=n.length;if(!(a||this._$recodes&&this._$canDraw))return;const l=this._$preDraw(t,e);if(!l)return;if(l.isFilter&&!l.isUpdated)return void this._$postDraw(t,e,r,l);let o=l.matrix;const h=l.isFilter?l.color:r;this._$recodes&&this._$canDraw&&this._$maxAlpha>0&&super._$draw(t,o,h);let _=!0,$=null;const c=Util.$getArray(),u=Util.$getArray(),d=Util.$getArray(),g=Util.$getArray(),p=Util.$renderPlayer._$instances,m=t._$isLayer;for(let e=0;e<a;++e){const i=n[e];if(!p.has(i))continue;const r=p.get(i);if(r._$isMask)continue;const s=r._$blendMode;if((s===BlendMode.ALPHA||s===BlendMode.ERASE)&&!m)continue;if($&&(r._$placeId>$||r._$clipDepth>0)&&(t.restore(),_&&(t._$leaveClip(),c.length&&(Util.$poolFloat32Array6(o),o=c.pop())),$=d.length?d.pop():null,_=g.pop()),!_)continue;if(r._$clipDepth>0){if(t.save(),$&&d.push($),g.push(_),$=r._$clipDepth,_=r._$shouldClip(o),_){const e=r._$startClip(t,o);if(!1===e){_=!1;continue}e&&(c.push(o),o=e)}continue}let a=null;if(r._$maskId>-1&&(a=p.get(r._$maskId),a)){a._$updated=!1;const e=Util.$renderPlayer._$matrix[0],i=Util.$getFloat32Array6(e,0,0,e,0,0),s=Util.$multiplicationMatrix(i,r._$maskMatrix);if(Util.$poolFloat32Array6(i),t._$isLayer){const e=t._$getCurrentPosition();s[4]-=e.xMin,s[5]-=e.yMin}if(t._$cacheCurrentBuffer&&(s[4]-=t._$cacheCurrentBounds.x,s[5]-=t._$cacheCurrentBounds.y),!a._$shouldClip(s))continue;let n=a._$startClip(t,s);if(t.save(),!1===n){t.restore();continue}if(n){if(u.push(o),this!==a._$parent){const e=this._$matrix;n[0]=$Math.abs(o[0])*$Math.sign(e[0]),n[1]=$Math.abs(o[1])*$Math.sign(e[1]),n[2]=$Math.abs(o[2])*$Math.sign(e[2]),n[3]=$Math.abs(o[3])*$Math.sign(e[3]),n[4]=o[4]-t._$cacheCurrentBounds.x,n[5]=o[5]-t._$cacheCurrentBounds.y}o=n}}r._$draw(t,o,h),r._$updated=!1,a&&(t.restore(),t._$leaveClip(),u.length&&(Util.$poolFloat32Array6(o),o=u.pop()))}if($&&(t.restore(),g.pop()&&t._$leaveClip()),Util.$poolArray(c),Util.$poolArray(u),Util.$poolArray(d),Util.$poolArray(g),l.isFilter)return this._$postDraw(t,e,r,l);Util.$poolFloat32Array6(o),Util.$poolPreObject(l),r!==i&&Util.$poolFloat32Array8(r)}_$getLayerBounds(t=null){let e=Util.$MATRIX_ARRAY_IDENTITY;const i=this._$matrix;t&&(e=t,1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=Util.$multiplicationMatrix(t,i)));const r=this._$recodes,s=this._$children,n=s.length;if(!n&&!r){const i=Util.$getBoundsObject(e[4],0-e[4],e[5],0-e[5]);return t&&e!==t&&Util.$poolFloat32Array6(e),i}const a=$Number.MAX_VALUE;let l=a,o=0-a,h=a,_=0-a;if(r){const t=Util.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax),i=Util.$boundsMatrix(t,e);l=i.xMin,o=i.xMax,h=i.yMin,_=i.yMax,Util.$poolBoundsObject(i),Util.$poolBoundsObject(t)}const $=Util.$renderPlayer._$instances;for(let t=0;t<n;++t){const i=s[t];if(!$.has(i))continue;const r=$.get(i)._$getLayerBounds(e);l=$Math.min(l,r.xMin),o=$Math.max(o,r.xMax),h=$Math.min(h,r.yMin),_=$Math.max(_,r.yMax),Util.$poolBoundsObject(r)}if(t&&e!==t&&Util.$poolFloat32Array6(e),!t)return Util.$getBoundsObject(l,o,h,_);const c=this._$filters;if(!c)return Util.$getBoundsObject(l,o,h,_);let u=new Rectangle(l,h,o-l,_-h);for(let t=0;t<c.length;++t)u=c[t]._$generateFilterRect(u,null,null,!0);return l=u._$x,o=u._$x+u._$width,h=u._$y,_=u._$y+u._$height,Util.$getBoundsObject(l,o,h,_)}_$getBounds(t=null){let e=Util.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$matrix;1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=Util.$multiplicationMatrix(t,i))}const i=this._$recodes,r=this._$children,s=r.length;if(!s&&!i){const i=Util.$getBoundsObject(e[4],0-e[4],e[5],0-e[5]);return t&&e!==t&&Util.$poolFloat32Array6(e),i}const n=$Number.MAX_VALUE;let a=n,l=0-n,o=n,h=0-n;if(i){const t=Util.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax),i=Util.$boundsMatrix(t,e);a=i.xMin,l=i.xMax,o=i.yMin,h=i.yMax,Util.$poolBoundsObject(i),Util.$poolBoundsObject(t)}const _=Util.$renderPlayer._$instances;for(let t=0;t<s;++t){const i=r[t];if(!_.has(i))continue;const s=_.get(i)._$getBounds(e);a=$Math.min(a,s.xMin),l=$Math.max(l,s.xMax),o=$Math.min(o,s.yMin),h=$Math.max(h,s.yMax),Util.$poolBoundsObject(s)}return t&&e!==t&&Util.$poolFloat32Array6(e),Util.$getBoundsObject(a,l,o,h)}_$preDraw(t,e){const i=this._$matrix,r=Util.$multiplicationMatrix(e,i);if(!r[0]&&!r[1]||!r[2]&&!r[3])return!1;const s=Util.$getPreObject();s.matrix=r;const n=this._$filters,a=this._$blendMode;if(a!==BlendMode.NORMAL||n&&n.length>0){const e=this._$getBounds(null),l=Util.$boundsMatrix(e,r),o=+l.xMax,h=+l.xMin,_=+l.yMax,$=+l.yMin;Util.$poolBoundsObject(e),Util.$poolBoundsObject(l);const c=$Math.abs(o-h),u=$Math.abs(_-$);if(0>=c||0>=u)return!1;if(0>h+c||0>$+u)return!1;const d=t.frameBuffer.currentAttachment;if(h>d.width||$>d.height)return!1;s.basePosition.x=i[4],s.basePosition.y=i[5];let g=this._$getLayerBounds(null);const p=Util.$boundsMatrix(g,r);let m=$Math.abs(p.xMax-p.xMin),f=$Math.abs(p.yMax-p.yMin);Util.$poolBoundsObject(p),m===c&&f===u&&(Util.$poolBoundsObject(g),g=null);let x=r[4]-$Math.floor(h),b=r[5]-$Math.floor($),v=null;if(g){const t=Util.$getFloat32Array6(r[0],r[1],r[2],r[3],0,0);v=Util.$boundsMatrix(g,t),Util.$poolBoundsObject(g),Util.$poolFloat32Array6(t),x+=0-$Math.floor(v.xMin)-x,b+=0-$Math.floor(v.yMin)-b}let M=$Math.floor(h),y=$Math.floor($),T=h,A=$;if(v&&(M-=0-$Math.floor(v.xMin)-(r[4]-M),y-=0-$Math.floor(v.yMin)-(r[5]-y),T-=0-v.xMin-(r[4]-T),A-=0-v.yMin-(r[5]-A),Util.$poolBoundsObject(v)),s.position.dx=M>0?M:0,s.position.dy=y>0?y:0,m+T>d.texture.width&&(m-=m-d.texture.width+T),f+A>d.texture.height&&(f-=f-d.texture.height+A),0>M&&(x+=M,m+=T),0>y&&(b+=y,f+=A),0>=m||0>=f||!m||!f)return Util.$poolPreObject(s),!1;t._$startLayer(Util.$getBoundsObject(T,0,A,0)),s.canApply=this._$canApply(n);let C=this._$isFilterUpdated(m,f,r,n,s.canApply,s.basePosition.x,s.basePosition.y);t._$saveCurrentMask(),C&&t._$saveAttachment($Math.ceil(m),$Math.ceil(f),!1),s.isFilter=!0,s.isUpdated=C,s.color=Util.$getFloat32Array8(),s.baseMatrix=r,s.filters=n,s.blendMode=a,s.layerWidth=m,s.layerHeight=f,s.matrix=Util.$getFloat32Array6(r[0],r[1],r[2],r[3],x,b)}return s}_$postDraw(t,e,i,r){const s=Util.$getArray(this._$instanceId,"f"),n=Util.$cacheStore(),a=t._$frameBufferManager;let l=null;if(r.isUpdated){l=a.getTextureFromCurrentAttachment();const t=n.get(s);t&&(n.set(s,null),a.releaseTexture(t))}else l=n.get(s);r.canApply||(l._$offsetX=0,l._$offsetY=0);let o=l._$offsetX,h=l._$offsetY;if(r.isUpdated&&r.canApply){let i=n.get(s);i&&(n.set(s,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,a.releaseTexture(i),i=null);const _=r.filters.length;if(_){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<_;++i)l=r.filters[i]._$applyFilter(t,e);o=t._$offsetX,h=t._$offsetY,t._$offsetX=0,t._$offsetY=0,l._$offsetX=o,l._$offsetY=h}}if(r.isUpdated){l.filterState=r.canApply;const t=r.baseMatrix;l.matrix=`${t[0]}_${t[1]}_${t[2]}_${t[3]}`,l.layerWidth=r.layerWidth,l.layerHeight=r.layerHeight}n.set(s,l),Util.$poolArray(s),r.isUpdated&&t._$restoreAttachment(),Util.$resetContext(t),t._$globalAlpha=Util.$clamp(i[3]+i[7]/255,0,1),t._$globalCompositeOperation=r.blendMode,t.setTransform(1,0,0,1,0,0),t.drawImage(l,0-o+r.position.dx,0-h+r.position.dy,l.width,l.height,i),t._$endLayer(),t._$restoreCurrentMask(),Util.$poolFloat32Array8(r.color),Util.$poolFloat32Array6(r.matrix),Util.$poolFloat32Array6(r.baseMatrix),Util.$poolPreObject(r)}_$remove(){this._$children.length=0,this._$recodes=null,super._$remove(),Util.$containers.push(this)}}class RenderPlayer{constructor(){this._$instances=new Map,this._$cacheStore=new CacheStore,this._$matrix=Util.$getFloat32Array6(1,0,0,1,0,0),this._$colorTransform=new $Float32Array([1,1,1,1,0,0,0,0]),this._$stopFlag=!0,this._$timerId=-1,this._$startTime=0,this._$frameRate=60,this._$fps=1e3/60,this._$width=0,this._$height=0,this._$stage=new RenderDisplayObjectContainer,this._$videos=0,this._$samples=4,this._$canvas=null,this._$context=null,this._$buffer=null,this._$bindRun=this._$run.bind(this)}play(){if(this._$stopFlag){if(this._$stopFlag=!1,this._$timerId>-1){$cancelAnimationFrame(this._$timerId),this._$timerId=-1}this._$startTime=$performance.now(),this._$fps=1e3/this._$frameRate;const t=$requestAnimationFrame;this._$timerId=t(this._$bindRun)}}stop(){$cancelAnimationFrame(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,this._$cacheStore.reset()}_$run(t=0){if(this._$stopFlag)return;let e=t-this._$startTime;e>this._$fps?(this._$startTime=t-e%this._$fps,this._$draw()):this._$videos&&this._$draw();const i=$requestAnimationFrame;this._$timerId=i(this._$bindRun)}_$bitmapDraw(t,e,i,r){const s=this._$context;if(!s)return;s._$bind(this._$buffer),Util.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,this._$width,this._$height),s.beginPath(),t._$draw(s,e,i);const n=s._$frameBufferManager,a=n.getTextureFromCurrentAttachment();n.unbind(),Util.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,this._$width,this._$height),s.drawImage(a,0,0,this._$width,this._$height),s._$bind(this._$buffer),r.getContext("2d").drawImage(this._$canvas,0,0)}_$draw(){if(!this._$width||!this._$height)return;if(!this._$stage._$updated)return;const t=this._$context;if(!t)return;t._$bind(this._$buffer),Util.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.beginPath(),this._$stage._$draw(t,this._$matrix,Util.$COLOR_ARRAY_IDENTITY),this._$stage._$updated=!1;const e=t._$frameBufferManager,i=e.getTextureFromCurrentAttachment();e.unbind(),Util.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.drawImage(i,0,0,this._$width,this._$height),t._$bind(this._$buffer)}_$resize(t,e,i,r=0,s=0){if(this._$width=t,this._$height=e,!this._$canvas)return;this._$canvas.width=t,this._$canvas.height=e;const n=this._$context;if(!n)return;n._$gl.viewport(0,0,t,e);const a=n._$frameBufferManager;this._$buffer&&(a.unbind(),a.releaseAttachment(this._$buffer,!0)),this._$buffer=a.createCacheAttachment(t,e,!1),this._$matrix[0]=i,this._$matrix[3]=i,this._$matrix[4]=r,this._$matrix[5]=s,a._$stencilBufferPool._$maxWidth=t,a._$stencilBufferPool._$maxHeight=e,a._$textureManager._$maxWidth=t,a._$textureManager._$maxHeight=e,n._$pbo._$maxWidth=t,n._$pbo._$maxHeight=e,this._$stage._$updated=!0,this._$cacheStore.reset()}_$setStage(t){this._$stage._$instanceId=t,this._$instances.set(t,this._$stage)}_$updateStage(){this._$stage._$updated=!0}_$createDisplayObjectContainer(t){const e=Util.$getDisplayObjectContainer();e._$instanceId=t.instanceId,t.recodes&&(e._$recodes=t.recodes,e._$maxAlpha=t.maxAlpha,e._$canDraw=t.canDraw,e._$xMin=t.xMin,e._$yMin=t.yMin,e._$xMax=t.xMax,e._$yMax=t.yMax),t.grid&&(e._$scale9Grid=new Rectangle(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),this._$instances.set(e._$instanceId,e)}_$createShape(t){const e=Util.$getShape();e._$instanceId=t.instanceId,e._$recodes=t.recodes,e._$maxAlpha=t.maxAlpha,e._$canDraw=t.canDraw,e._$xMin=t.xMin,e._$yMin=t.yMin,e._$xMax=t.xMax,e._$yMax=t.yMax,"characterId"in t&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId),t.grid&&(e._$scale9Grid=new Rectangle(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),this._$instances.set(e._$instanceId,e)}_$createVideo(t){const e=Util.$getVideo();e._$instanceId=t.instanceId,"characterId"in t&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId),e._$updateProperty(t),this._$instances.set(e._$instanceId,e),this._$videos++}_$createTextField(t){const e=Util.$getTextField();e._$instanceId=t.instanceId,e._$xMin=t.xMin,e._$yMin=t.yMin,e._$xMax=t.xMax,e._$yMax=t.yMax,"characterId"in t&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId),e._$updateProperty(t),this._$instances.set(e._$instanceId,e)}}Util.$renderPlayer=new RenderPlayer;class RenderShape extends RenderGraphics{_$clip(t,e){let i=e;const r=this._$matrix;1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(i=Util.$multiplicationMatrix(e,r));const s=this._$getBounds(),n=Util.$boundsMatrix(s,i);let a=$Math.ceil($Math.abs(n.xMax-n.xMin)),l=$Math.ceil($Math.abs(n.yMax-n.yMin));switch(Util.$poolBoundsObject(s),Util.$poolBoundsObject(n),!0){case 0===a:case 0===l:case a===-1/0:case l===-1/0:case Infinity===a:case Infinity===l:return}super._$clip(t,i),i!==e&&Util.$poolFloat32Array6(i)}_$draw(t,e,i){if(!this._$visible)return;let r=i;const s=this._$colorTransform;1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=Util.$multiplicationColor(i,s));if(!Util.$clamp(r[3]+r[7]/255,0,1,0)||!this._$maxAlpha)return void(r!==i&&Util.$poolFloat32Array8(r));let n=e;const a=this._$matrix;1===a[0]&&0===a[1]&&0===a[2]&&1===a[3]&&0===a[4]&&0===a[5]||(n=Util.$multiplicationMatrix(e,a)),super._$draw(t,n,r,this._$blendMode,this._$filters),n!==e&&Util.$poolFloat32Array6(n),r!==i&&Util.$poolFloat32Array8(r)}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$recodes=null,super._$remove(),Util.$shapes.push(this)}}class RenderTextField extends RenderDisplayObject{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$textData=null,this._$textAreaActive=!1,this._$thickness=0,this._$thicknessColor=0,this._$limitWidth=0,this._$limitHeight=0,this._$autoSize=TextFieldAutoSize.NONE,this._$widthTable=null,this._$heightTable=null,this._$objectTable=null,this._$textHeightTable=null,this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$maxScrollV=null,this._$textHeight=null,this._$verticalAlign=TextFormatVerticalAlign.TOP}get width(){const t=Util.$boundsMatrix(this._$getBounds(null),this._$matrix),e=$Math.abs(t.xMax-t.xMin);switch(Util.$poolBoundsObject(t),!0){case 0===e:case Infinity===e:case e===-1/0:return 0;default:return e}}get height(){const t=Util.$boundsMatrix(this._$getBounds(null),this._$matrix),e=$Math.abs(t.yMax-t.yMin);switch(Util.$poolBoundsObject(t),e){case 0:case Infinity:case-1/0:return 0;default:return e}}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1;const t=this._$textHeightTable.length,e=this.height;if(e>this._$textHeight)return this._$maxScrollV;let i=0,r=0;for(;t>r&&(i+=this._$textHeightTable[r],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}_$clip(t,e){const i=this._$getBounds(),r=i.xMax,s=i.xMin,n=i.yMax,a=i.yMin;Util.$poolBoundsObject(i);let l=$Math.ceil($Math.abs(r-s)),o=$Math.ceil($Math.abs(n-a));if(!l||!o)return;let h=e;const _=this._$matrix;1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||(h=Util.$multiplicationMatrix(e,_)),Util.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(l,0),t.lineTo(l,o),t.lineTo(0,o),t.lineTo(0,0),t.clip(!0),h!==e&&Util.$poolFloat32Array6(h)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&2>this._$textData.length)return;let r=i;const s=this._$colorTransform;1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=Util.$multiplicationColor(i,s));const n=Util.$clamp(r[3]+r[7]/255,0,1);if(!n)return;let a=e;const l=this._$matrix;1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(a=Util.$multiplicationMatrix(e,l));const o=this._$getBounds(null);o.xMin-=this._$thickness,o.xMax+=this._$thickness,o.yMin-=this._$thickness,o.yMax+=this._$thickness;const h=Util.$boundsMatrix(o,a),_=+h.xMax,$=+h.xMin,c=+h.yMax,u=+h.yMin;Util.$poolBoundsObject(h);let d=$Math.ceil($Math.abs(_-$)),g=$Math.ceil($Math.abs(c-u));switch(!0){case 0===d:case 0===g:case d===-1/0:case g===-1/0:case Infinity===d:case Infinity===g:return}if(0>$+d||0>u+g)return;const p=t._$frameBufferManager,m=p.currentAttachment;if($>m.width||u>m.height)return;let f=+$Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(!$Number.isInteger(f)){const t=f.toString(),e=t.indexOf("e");-1!==e&&(f=+t.slice(0,e)),f=+f.toFixed(4)}let x=+$Math.sqrt(a[2]*a[2]+a[3]*a[3]);if(!$Number.isInteger(x)){const t=x.toString(),e=t.indexOf("e");-1!==e&&(x=+t.slice(0,e)),x=+x.toFixed(4)}const b=this._$filters;if(0>$+d||0>u+g){if(!(b&&b.length&&this._$canApply(b)))return;{let t=new Rectangle(0,0,d,g);for(let e=0;e<b.length;++e)t=b[e]._$generateFilterRect(t,f,x);if(0>t.x+t.width||0>t.y+t.height)return}}const v=this._$blendMode,M=Util.$getArray(f,x),y=this._$instanceId,T=Util.$cacheStore(),A=T.generateKeys(y,M);let C=T.get(A);if(this._$isUpdated()&&(T.removeCache(y),C=null),!C){const t=$Math.min(1,$Math.max(f,x)),s=$Math.ceil($Math.abs(o.xMax-o.xMin)*f),n=$Math.ceil($Math.abs(o.yMax-o.yMin)*x);r[3]=1;const a=new OffscreenCanvas(s+2*t,n+2*t).getContext("2d");if(this._$background||this._$border){if(a.beginPath(),a.moveTo(0,0),a.lineTo(s,0),a.lineTo(s,n),a.lineTo(0,n),a.lineTo(0,0),this._$background){const t=Util.$intToRGBA(this._$backgroundColor),e=$Math.max(0,$Math.min(255*t.A*r[3]+r[7],255))/255;a.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,a.fill()}if(this._$border){const e=Util.$intToRGBA(this._$borderColor),i=$Math.max(0,$Math.min(255*e.A*r[3]+r[7],255))/255;a.lineWidth=t,a.strokeStyle=`rgba(${e.R},${e.G},${e.B},${i})`,a.stroke()}}a.save(),a.beginPath(),a.moveTo(2,2),a.lineTo(s-2,2),a.lineTo(s-2,n-2),a.lineTo(2,n-2),a.lineTo(2,2),a.clip(),a.beginPath(),a.setTransform(f,0,0,x,0,0),this._$doDraw(a,e,i,s/f),a.restore(),C=p.createTextureFromCanvas(a.canvas),Util.$useCache&&T.set(A,C),T.destroy(a)}let U=!1,S=0,E=0;b&&b.length&&this._$canApply(b)&&(U=!0,C=this._$drawFilter(t,C,a,b,d,g),S=C._$offsetX,E=C._$offsetY);const B=$Math.atan2(a[1],a[0]),F=$Math.atan2(0-a[2],a[3]);if(U||!B&&!F)t.setTransform(1,0,0,1,$-S,u-E);else{const e=o.xMin*f,i=o.yMin*x,r=$Math.cos(B),s=$Math.sin(B),n=$Math.cos(F),l=$Math.sin(F);t.setTransform(r,s,0-l,n,e*r-i*l+a[4],e*s+i*n+a[5])}Util.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=v,t.drawImage(C,0,0,C.width,C.height,r),Util.$poolArray(A),Util.$poolBoundsObject(o),a!==e&&Util.$poolFloat32Array6(a),r!==i&&Util.$poolFloat32Array8(r)}_$doDraw(t,e,i,r){const s=this._$textData,n=this.width,a=this.height;let l=0,o=0,h=0,_=0;if(this._$verticalAlign!==TextFormatVerticalAlign.TOP&&this.height>this._$textHeight)switch(this._$verticalAlign){case TextFormatVerticalAlign.MIDDLE:_=(this.height-this._$textHeight+2)/2;break;case TextFormatVerticalAlign.BOTTOM:_=this.height-this._$textHeight+2}const $=s.length;for(let c=0;c<$;++c){let $=s[c];if(0===$.width)continue;const u=l+$.x;if(this._$autoSize===TextFieldAutoSize.NONE&&(o>a||u>n))continue;let d=$.textFormat;const g=Util.$intToRGBA($.textFormat._$color),p=$Math.max(0,$Math.min(255*g.A*i[3]+i[7],255))/255;if(t.fillStyle=`rgba(${g.R},${g.G},${g.B},${p})`,this._$thickness){const e=Util.$intToRGBA(this._$thicknessColor),r=$Math.max(0,$Math.min(255*e.A*i[3]+i[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${r})`}const m=0|$.yIndex;switch($.mode){case TextMode.BREAK:case TextMode.WRAP:if(h++,this._$scrollV>h)continue;if(o+=this._$textHeightTable[m],l=this._$getAlignOffset(this._$objectTable[m],r),d._$underline){const r=$.textFormat._$size/12,s=Util.$intToRGBA(d._$color),n=$Math.max(0,$Math.min(255*s.A*i[3]+i[7],255))/255;t.lineWidth=$Math.max(1,1/$Math.min(e[0],e[3])),t.strokeStyle=`rgba(${s.R},${s.G},${s.B},${n})`,t.beginPath(),t.moveTo(l,_+o-r),t.lineTo(l+this._$widthTable[m],_+o-r),t.stroke()}break;case TextMode.TEXT:{if(this._$scrollV>h)continue;let e=o-this._$heightTable[0];Util.$isSafari||(e+=$.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=Util.$generateFontStyle(d._$font,d._$size,d._$italic,d._$bold),this._$thickness&&t.strokeText($.text,u,_+e),t.fillText($.text,u,_+e)}break;case TextMode.IMAGE:if(!$.loaded)continue;t.beginPath(),t.drawImage($.image,$.hspace,_+$.y,$.width,$.height)}}}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],r=t.textFormat,s=r._$blockIndent+r._$leftMargin>0?r._$blockIndent+r._$leftMargin:0;switch(!0){case!1===this._$wordWrap&&i>e:return $Math.max(0,s);case r._$align===TextFormatAlign.CENTER:case this._$autoSize===TextFieldAutoSize.CENTER:return $Math.max(0,e/2-s-r._$rightMargin-i/2);case r._$align===TextFormatAlign.RIGHT:case this._$autoSize===TextFieldAutoSize.RIGHT:return $Math.max(0,e-s-i-r._$rightMargin-2);default:return $Math.max(0,s+2)}}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$textData=null,this._$textAreaActive=!1,super._$remove(),Util.$textFields.push(this)}_$updateProperty(t){this._$textAreaActive=!!t.textAreaActive,this._$textData=t.textData,this._$wordWrap=!!t.wordWrap,this._$limitWidth=t.limitWidth,this._$limitHeight=t.limitHeight,this._$autoSize=t.autoSize,this._$widthTable=t.widthTable,this._$heightTable=t.heightTable,this._$objectTable=t.objectTable,this._$textHeightTable=t.textHeightTable,this._$scrollV=t.scrollV,this._$textHeight=t.textHeight,this._$verticalAlign=t.verticalAlign,this._$border=!!t.border,this._$border&&(this._$borderColor=t.borderColor),this._$background=!!t.background,this._$background&&(this._$backgroundColor=t.backgroundColor),"thickness"in t&&(this._$thickness=t.thickness,this._$thicknessColor=t.thicknessColor)}_$update(t){super._$update(t),this._$textAreaActive=!!t.textAreaActive,this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,t.textData&&this._$updateProperty(t)}}class RenderVideo extends RenderDisplayObject{constructor(){super(),this._$imageBitmap=null,this._$context=null,this._$smoothing=!0,this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0}_$clip(t,e){let i=this._$xMax,r=this._$yMax;if(!i||!r)return;let s=e;const n=this._$matrix;1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(s=Util.$multiplicationMatrix(e,n)),Util.$resetContext(t),t.setTransform(s[0],s[1],s[2],s[3],s[4],s[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,r),t.lineTo(0,r),t.lineTo(0,0),t.clip(!0),s!==e&&Util.$poolFloat32Array6(s)}_$draw(t,e,i){if(!this._$visible||!this._$imageBitmap)return;let r=i;const s=this._$colorTransform;1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=Util.$multiplicationColor(i,s));const n=Util.$clamp(r[3]+r[7]/255,0,1,0);if(!n)return void(r!==i&&Util.$poolFloat32Array8(r));let a=e;const l=this._$matrix;1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(a=Util.$multiplicationMatrix(e,l));const o=this._$getBounds(),h=Util.$boundsMatrix(o,a),_=+h.xMax,$=+h.xMin,c=+h.yMax,u=+h.yMin;Util.$poolBoundsObject(h),Util.$poolBoundsObject(o);let d=$Math.ceil($Math.abs(_-$)),g=$Math.ceil($Math.abs(c-u));switch(!0){case 0===d:case 0===g:case d===-1/0:case g===-1/0:case Infinity===d:case Infinity===g:return}const p=t._$frameBufferManager,m=p.currentAttachment;if($>m.width||u>m.height)return;const f=this._$filters||this.filters;if(0>$+d||0>u+g){if(!(f&&f.length&&this._$canApply(f)))return;{const t=+$Math.sqrt(a[0]*a[0]+a[1]*a[1]),e=+$Math.sqrt(a[2]*a[2]+a[3]*a[3]);let i=new Rectangle(0,0,d,g);for(let r=0;r<f.length;++r)i=f[r]._$generateFilterRect(i,t,e);if(0>i.x+i.width||0>i.y+i.height)return}}const x=this._$blendMode||this.blendMode;this._$context.drawImage(this._$imageBitmap,0,0);let b=p._$textureManager._$createFromElement(this._$imageBitmap.width,this._$imageBitmap.height,this._$context.canvas,this._$smoothing);if(f&&f.length&&this._$canApply(f)){const e=+$Math.sqrt(a[0]*a[0]+a[1]*a[1]),r=+$Math.sqrt(a[2]*a[2]+a[3]*a[3]);if(1!==e||1!==r){const i=p.currentAttachment,s=p.createCacheAttachment(d,g,!1);t._$bind(s),Util.$resetContext(t);const n=Util.$getFloat32Array6(e,0,0,r,d/2,g/2),a=Util.$getFloat32Array6(1,0,0,1,0-b.width/2,0-b.height/2),l=Util.$multiplicationMatrix(n,a);Util.$poolFloat32Array6(n),Util.$poolFloat32Array6(a),t.setTransform(l[0],l[1],l[2],l[3],l[4],l[5]),t.drawImage(b,0,0,b.width,b.height),p.releaseTexture(b),Util.$poolFloat32Array6(l),b=p.getTextureFromCurrentAttachment(),p.releaseAttachment(s,!1),t._$bind(i)}b=this._$drawFilter(t,b,a,f,d,g),Util.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=x;const s=this._$getBounds(),l=Util.$boundsMatrix(s,a);t.setTransform(1,0,0,1,l.xMin-b._$offsetX,l.yMin-b._$offsetY),t.drawImage(b,0,0,b.width,b.height,i),Util.$poolBoundsObject(l),Util.$poolBoundsObject(s)}else Util.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=x,t.setTransform(a[0],a[1],a[2],a[3],a[4],a[5]),t.drawImage(b,0,0,b.width,b.height,i),p.releaseTexture(b);a!==e&&Util.$poolFloat32Array6(a),r!==i&&Util.$poolFloat32Array8(r)}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$imageBitmap=null,this.smoothing=!0,super._$remove(),Util.$renderPlayer._$videos--,Util.$videos.push(this)}_$updateProperty(t){if(this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,this._$imageBitmap=t.imageBitmap,this._$smoothing=t.smoothing,!this._$context&&this._$imageBitmap){const t=new $OffscreenCanvas(this._$imageBitmap.width,this._$imageBitmap.height);this._$context=t.getContext("2d")}}_$update(t){super._$update(t),this._$updateProperty(t)}}'],{type:"text/javascript"}))):null,B.$rendererWorker&&(B.$removeContainerWorker=t=>{t._$removeWorkerInstance();const e=t._$needsChildren?t._$getChildren():t._$children,i=e.length;for(let t=0;t<i;++t){const i=e[t];i&&(i instanceof Q?B.$removeContainerWorker(i):i._$removeWorkerInstance())}},B.$postContainerWorker=t=>{t._$createWorkerInstance(),t._$postProperty();const e=t._$needsChildren?t._$getChildren():t._$children,i=B.$getArray(),r=e.length;for(let t=0;t<r;++t){const r=e[t];r&&(i.push(r._$instanceId),r instanceof Q?B.$postContainerWorker(r):(r._$createWorkerInstance(),r._$postProperty()))}t._$postChildrenIds(i),B.$poolArray(i)},B.$rendererWorker.onmessage=t=>{if("bitmapDraw"!==t.data.command)return;const e=t.data.sourceId,i=B.$bitmapDrawMap.get(e);B.$bitmapDrawMap.delete(e);const r=i.source;if(r instanceof Q?B.$removeContainerWorker(r):r._$removeWorkerInstance(),i.callback){const e=i.context;e.drawImage(t.data.imageBitmap,0,0),i.callback(e.canvas)}}),B.$unzipURL=URL.createObjectURL(new Blob(['const zlibes=function(e){"use strict";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),n=131072,r=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],o=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],f=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function a(e){const t=Object.keys(e);let n=0,r=0,i=Number.MAX_SAFE_INTEGER;t.forEach((e=>{n=Number(e),r<n&&(r=n),i>n&&(i=n)}));let s,o=0;const f={};for(let t=i;t<=r;t++){void 0===(s=e[t])&&(s=[]),s.sort(((e,t)=>e<t?-1:e>t?1:0));const n={};s.forEach((e=>{n[o]=e,o++})),f[t]=n,o<<=1}return f}function h(e,t=15){const n={};for(const t of e)n[t]?n[t]++:n[t]=1;const r=Object.keys(n);let i=[],s=0,o=[];if(1===r.length)o.push({count:n[0],simbles:[Number(r[0])]});else for(let e=0;e<t;e++){for(o=[],r.forEach((e=>{const t={count:n[Number(e)],simbles:[Number(e)]};o.push(t)})),s=0;s+2<=i.length;){const e={count:i[s].count+i[s+1].count,simbles:i[s].simbles.concat(i[s+1].simbles)};o.push(e),s+=2}(o=o.sort(((e,t)=>e.count<t.count?-1:e.count>t.count?1:0))).length%2!=0&&o.pop(),i=o}const f={};let a;o.forEach((e=>{e.simbles.forEach((e=>{f[e]?f[e]++:f[e]=1}))}));const h=Object.keys(f),d={};let u=0,c=3,l=Number.MAX_SAFE_INTEGER,w=0;h.forEach((e=>{c=f[Number(e)],d[c]||(d[c]=[],l>c&&(l=c),w<c&&(w=c)),d[c].push(Number(e))})),u=0;const g=new Map;for(let e=l;e<=w;e++)(a=d[e])&&(a=a.sort(((e,t)=>e<t?-1:e>t?1:0))).forEach((t=>{g.set(t,{code:u,bitlen:e}),u++})),u<<=1;return g}function d(e,t,n){let r=t;const o=t+n-3;let f=0,a=0,h=0,d=0,u=0,c=0,l=0;const w=[],g={},b={},R=function(e,t,n){const r=t+n-3,i={};for(let n=t;n<=r;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===i[t]&&(i[t]=[]),i[t].push(n)}return i}(e,t,n);for(;r<=o;){const t=e[r]<<16|e[r+1]<<8|e[r+2],n=R[t];if(void 0===n||n.length<=1){w.push([e[r]]),r++;continue}f=r>32768?r-32768:0,h=0,d=0;let E=g[t]||0;for(;n[E]<f;)E=E+1|0;for(g[t]=E,E=b[t]||0;n[E]<r;)E=E+1|0;b[t]=E;let p=0;e:for(let i=b[t]-1,s=g[t];s<=i&&!(p>=128||h>=8&&p>=16);i--){p++;const t=n[i];for(let n=h-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;a=258;for(let n=h;n<=258;n++)if(e[t+n]!==e[r+n]){a=n;break}if(h<a&&(h=a,d=t,258<=a))break}if(h>=3&&r+h<=o){u=r-d;for(let e=0;e<i.length&&!(i[e]>h);e++)c=e;for(let e=0;e<s.length&&!(s[e]>u);e++)l=e;w.push([c,l,h,u]),r+=h}else w.push([e[r]]),r++}return w.push([e[r]]),w.push([e[r+1]]),w}class u{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n>>>=1}}function c(e,t,n,a){const u=d(t,n,a),c=[256],l=[];let w=256,g=0;for(let e=0,t=u.length;e<t;e++){const t=u[e];let n=t[0];const r=t[1];void 0!==r&&(n+=257,l.push(r),g<r&&(g=r)),c.push(n),w<n&&(w=n)}const b=h(c),R=h(l),E=[];for(let e=0;e<=w;e++)b.has(e)?E.push(b.get(e).bitlen):E.push(0);const p=E.length;for(let e=0;e<=g;e++)R.has(e)?E.push(R.get(e).bitlen):E.push(0);const B=E.length-p,I=[],N=[];let x=0,m=0;for(let e=0;e<E.length;e++){for(x=E[e],m=1;x===E[e+1];)if(m++,e++,0===x){if(138<=m)break}else if(6<=m)break;if(4<=m)0===x?11<=m?I.push(18):I.push(17):(I.push(x),N.push(1),m--,I.push(16)),N.push(m);else for(let e=0;e<m;e++)I.push(x),N.push(1)}const A=h(I,7);let v,C=0;f.forEach(((e,t)=>{A.has(e)&&(C=t+1)})),e.writeRange(p-257,5),e.writeRange(B-1,5),e.writeRange(C-4,4);for(let t=0;t<C;t++)void 0!==(v=A.get(f[t]))?e.writeRange(v.bitlen,3):e.writeRange(0,3);I.forEach(((t,n)=>{if(void 0===(v=A.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen),18===t?e.writeRange(N[n]-11,7):17===t?e.writeRange(N[n]-3,3):16===t&&e.writeRange(N[n]-3,2)}));for(let t=0,n=u.length;t<n;t++){const n=u[t],f=n[0],a=n[1];if(void 0!==a){if(void 0===(v=b.get(f+257)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen),0<r[f]&&(m=n[2],e.writeRange(m-i[f],r[f]));const t=R.get(a);if(void 0===t)throw new Error("Data is corrupted");if(e.writeRangeCoded(t.code,t.bitlen),0<o[a]){const t=n[3];e.writeRange(t-s[a],o[a])}}else{if(void 0===(v=b.get(f)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen)}}if(void 0===(v=b.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen)}class l{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}class w{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let n=0;n<t;n++)e[n]=this.buffer[n];this.buffer=e}this.buffer[this.index]=e,this.index++}}const g=a(function(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}());function b(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let r=0;r<n;r++)t.write(e.readRange(8))}function R(e,t){const n=g,f=Object.keys(n);let a=0,h=0,d=Number.MAX_SAFE_INTEGER;f.forEach((e=>{a=Number(e),h<a&&(h=a),d>a&&(d=a)}));let u,c,l,w,b,R,E,p,B=0;for(;!e.isEnd;){for(u=void 0,a=d,B=e.readRangeCoded(d);void 0===(u=n[a][B]);){if(h<=a)throw new Error("Data is corrupted");a++,B<<=1,B|=e.read()}if(u<256)t.write(u);else{if(256===u)break;l=i[c=u-257],0<(w=r[c])&&(l+=e.readRange(w)),b=e.readRangeCoded(5),R=s[b],0<(E=o[b])&&(R+=e.readRange(E)),p=t.index-R;for(let e=0;e<l;e++)t.write(t.buffer[p+e])}}}function E(e,t){const n=e.readRange(5)+257,h=e.readRange(5)+1,d=e.readRange(4)+4;let u=0;const c={};for(let t=0;t<d;t++)0!==(u=e.readRange(3))&&(c[u]||(c[u]=[]),c[u].push(f[t]));const l=a(c),w=Object.keys(l);let g=0,b=Number.MAX_SAFE_INTEGER;w.forEach((e=>{u=Number(e),g<u&&(g=u),b>u&&(b=u)}));const R={},E={};let p,B=0,I=0,N=0;const x=n+h;for(let t=0;t<x;){for(p=void 0,u=b,B=e.readRangeCoded(b);void 0===(p=l[u][B]);){if(g<=u)throw new Error("Data is corrupted");u++,B<<=1,B|=e.read()}if(16===p?I=3+e.readRange(2):17===p?(I=3+e.readRange(3),N=0):18===p?(I=11+e.readRange(7),N=0):(I=1,N=p),N<=0)t+=I;else for(;I;)t<n?(R[N]||(R[N]=[]),R[N].push(t++)):(E[N]||(E[N]=[]),E[N].push(t++-n)),I--}const m=a(R),A=a(E),v=Object.keys(m);let C=0,D=0,y=Number.MAX_SAFE_INTEGER;v.forEach((e=>{C=Number(e),D<C&&(D=C),y>C&&(y=C)}));const k=Object.keys(A);let L=0,S=0,_=Number.MAX_SAFE_INTEGER;k.forEach((e=>{L=Number(e),S<L&&(S=L),_>L&&(_=L)}));let M,O,U,j,F,X,T,G,z,Y,P=0;for(;!e.isEnd;){for(M=void 0,C=y,P=e.readRangeCoded(y);void 0===(M=m[C][P]);){if(D<=C)throw new Error("Data is corrupted");C++,P<<=1,P|=e.read()}if(M<256)t.write(M);else{if(256===M)break;for(U=i[O=M-257],0<(j=r[O])&&(U+=e.readRange(j)),F=void 0,G=_,z=e.readRangeCoded(_);void 0===(F=A[G][z]);){if(S<=G)throw new Error("Data is corrupted");G++,z<<=1,z|=e.read()}X=s[F],0<(T=o[F])&&(X+=e.readRange(T)),Y=t.index-X;for(let e=0;e<U;e++)t.write(t.buffer[Y+e])}}}/**     * @license Copyright (c) 2018 zprodev     */return e.inflate=function(e){const n=new l(e);if(8!==n.readRange(4))throw new Error("Not compressed by deflate");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){const r=new w(10*e.length),i=new l(e,n);let s=0,o=0;for(;1!==s;){if(s=i.readRange(1),(o=i.readRange(2))===t.UNCOMPRESSED)b(i,r);else if(o===t.FIXED)R(i,r);else{if(o!==t.DYNAMIC)throw new Error("Not supported BTYPE : "+o);E(i,r)}if(0===s&&i.isEnd)throw new Error("Data length is insufficient")}return r.buffer.subarray(0,r.index)}(e,2)},e.deflate=function(e){const r=function(e){const r=e.length,i=new u(new Uint8Array(r<n/2?n:2*r));let s=0,o=0;for(;s+n>=r?(o=r-s,i.writeRange(1,1)):(o=n,i.writeRange(0,1)),i.writeRange(t.DYNAMIC,2),c(i,e,s,o),!((s+=n)>=r););return 0!==i.nowBitsIndex&&i.writeRange(0,8-i.nowBitsIndex),i.buffer.subarray(0,i.bufferIndex)}(e),i=new u(new Uint8Array(1));i.writeRange(8,4),i.writeRange(7,4);const s=new u(new Uint8Array(1));s.writeRange(28,5),s.writeRange(0,1),s.writeRange(2,2);const o=new u(new Uint8Array(4)),f=function(e){let t=1,n=0;const r=e.length;for(let i=0;i<r;i++)n=((t=(t+e[i])%65521)+n)%65521;return(n<<16)+t}(e);o.writeRange(f>>>24,8),o.writeRange(f>>>16&255,8),o.writeRange(f>>>8&255,8),o.writeRange(255&f,8);const a=new Uint8Array(r.length+6);return a.set(i.buffer),a.set(s.buffer,1),a.set(r,2),a.set(o.buffer,a.length-4),a},e}({});this.addEventListener("message",(function(e){const t=zlibes.inflate(e.data);let n="";for(let e=0;e<t.length;++e)n+=String.fromCharCode(t[e]);this.postMessage(JSON.parse(decodeURIComponent(n)))}));'],{type:"text/javascript"})),B.$unzipWorker=null,B.$unzipQueues=[],B.$unzipWorkerActive=!1,B.$unzipHandler=function(t){if(this._$build(t.data),B.$unzipQueues.length){const t=B.$unlzmaQueues.pop(),e=new Uint8Array(t.json.buffer);B.$unzipWorker.onmessage=B.$unzipHandler.bind(t.scope),B.$unzipWorker.postMessage(e,[e.buffer])}else B.$unzipWorkerActive=!1},B.$packages=t=>{t.display={BitmapData:tt,BitmapDataChannel:et,BlendMode:it,CapsStyle:rt,DisplayObject:q,DisplayObjectContainer:Q,FrameLabel:st,GradientType:nt,Graphics:at,GraphicsGradientFill:ht,InteractiveObject:K,InterpolationMethod:lt,JointStyle:$t,Loader:_t,LoaderInfo:ct,LoopConfig:ut,LoopType:dt,MovieClip:Z,Shape:gt,SpreadMethod:pt,Sprite:J,Stage:ft},t.events={Event:O,EventDispatcher:L,EventPhase:P,FocusEvent:N,HTTPStatusEvent:k,IOErrorEvent:D,MouseEvent:G,ProgressEvent:V,VideoEvent:H},t.filters={BevelFilter:At,BitmapFilterQuality:Tt,BitmapFilterType:bt,BlurFilter:yt,ColorMatrixFilter:Mt,ConvolutionFilter:Et,DisplacementMapFilter:Ct,DisplacementMapFilterMode:vt,DropShadowFilter:St,GlowFilter:Rt,GradientBevelFilter:Ft,GradientGlowFilter:Bt},t.geom={ColorTransform:X,Matrix:Y,Point:z,Rectangle:j,Transform:W},t.media={Sound:kt,SoundMixer:Dt,SoundTransform:Gt,Video:Vt},t.net={URLLoaderDataFormat:Ht,URLRequest:Xt,URLRequestHeader:Yt,URLRequestMethod:zt},t.text={TextField:Ut,TextFieldAutoSize:It,TextFieldType:Ot,TextFormat:Lt,TextFormatAlign:wt,TextFormatVerticalAlign:Pt},t.ui={Easing:jt,Job:Wt,Tween:qt}};class O{constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=!!e,this._$cancelable=!!i,this._$target=null,this._$currentTarget=null,this._$eventPhase=P.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1,this._$preventDefault=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get LOAD(){return"load"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get RESIZE(){return"resize"}static get SCROLL(){return"scroll"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}get eventPhase(){return this._$eventPhase}get listener(){return this._$listener}get target(){return this._$target?this._$target:this._$currentTarget}get type(){return this._$type}formatToString(){let t=`[${arguments[0]}`;for(let e=1;e<arguments.length;++e){const i=arguments[e];t+=` ${i}=`;const r=this[i];t+="string"==typeof r?`"${r}"`:`${r}`}return`${t}]`}isDefaultPrevented(){return!!B.$event&&B.$event.defaultPrevented}preventDefault(){this._$preventDefault=!0}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}class L{constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,r=0){let s,n,a=!1;switch(t=`${t}`){case O.ENTER_FRAME:case O.EXIT_FRAME:case O.FRAME_CONSTRUCTED:case O.RENDER:case O.ACTIVATE:case O.DEACTIVATE:case"keyDown":case"keyUp":n=B.$currentPlayer(),n.broadcastEvents.size&&n.broadcastEvents.has(t)||n.broadcastEvents.set(t,B.$getArray()),s=n.broadcastEvents.get(t),a=!0;break;default:this._$events||(this._$events=B.$getMap()),this._$events.size&&this._$events.has(t)||this._$events.set(t,B.$getArray()),s=this._$events.get(t)}let o=s.length;for(let t=0;t<o;++t){const r=s[t];i===r.useCapture&&(r.target===this&&r.listener===e&&(o=t))}s[o]={listener:e,priority:r,useCapture:i,target:this},a?n.broadcastEvents.set(t,s):(s.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,s))}dispatchEvent(t){switch(t.type){case O.ENTER_FRAME:case O.EXIT_FRAME:case O.FRAME_CONSTRUCTED:case O.RENDER:case O.ACTIVATE:case O.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:B.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t.type)){const e=i.broadcastEvents.get(t.type),r=e.length;for(let i=0;i<r;++i){const r=e[i];if(r.target===this){t._$eventPhase=P.AT_TARGET,t._$currentTarget=r.target;try{t._$listener=r.listener,r.listener.call(s,t)}catch(t){return!1}}}return!0}}break;default:{let e=B.$getArray();this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type).slice(0));const i=B.$getArray();if(this instanceof q){let e=this._$parent;for(;e;)e.hasEventListener(t.type)&&(i[i.length]=e._$events.get(t.type)),e=e._$parent}if(t._$target=this,e.length||i.length){if(t._$eventPhase=P.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const r=i[e];for(let e=0;e<r.length;++e){const i=r[e];if(i.useCapture){t._$currentTarget=i.target,B.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(s,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}if(t._$eventPhase=P.AT_TARGET,!t._$stopImmediatePropagation&&!t._$stopPropagation){const i=e.length;for(let r=0;r<i;++r){const i=e[r];if(!i.useCapture){t._$currentTarget=i.target,B.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(s,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}}switch(t._$eventPhase=P.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const r=i[e];for(let e=0;e<r.length;++e){const i=r[e];if(!i.useCapture){t._$currentTarget=i.target,B.$currentLoaderInfo=i.target._$loaderInfo;try{t._$listener=i.listener,i.listener.call(s,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return B.$poolArray(e),B.$poolArray(i),!0}B.$poolArray(e),B.$poolArray(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case O.ENTER_FRAME:case O.EXIT_FRAME:case O.FRAME_CONSTRUCTED:case O.RENDER:case O.ACTIVATE:case O.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:B.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t)){const e=i.broadcastEvents.get(t);for(let t=0;t<e.length;t++)if(e[t].target===this)return!0}return!1}default:return!!(this._$events&&this._$events.size&&this._$events.has(t))}}removeEventListener(t,e,i=!1){if(t=`${t}`,!this.hasEventListener(t))return;let r,s,n=!1;switch(t){case O.ENTER_FRAME:case O.EXIT_FRAME:case O.FRAME_CONSTRUCTED:case O.RENDER:case O.ACTIVATE:case O.DEACTIVATE:case"keyDown":case"keyUp":n=!0,s=B.$currentPlayer(),s&&(r=s.broadcastEvents.get(t));break;default:r=this._$events.get(t)}const a=r.length;for(let t=0;t<a;++t){const s=r[t];if(i===s.useCapture&&s.listener===e){r.splice(t,1);break}}r.length?n?s.broadcastEvents.set(t,r):(r.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,r)):n?s.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(B.$poolMap(this._$events),this._$events=null))}removeAllEventListener(t,e=!1){if(t=`${t}`,!this.hasEventListener(t))return;let i,r,s=!1;switch(t){case O.ENTER_FRAME:case O.EXIT_FRAME:case O.FRAME_CONSTRUCTED:case O.RENDER:case O.ACTIVATE:case O.DEACTIVATE:case"keyDown":case"keyUp":s=!0,r=B.$currentPlayer(),r&&(i=r.broadcastEvents.get(t));break;default:i=this._$events.get(t)}const n=B.$getArray(),a=i.length;for(let t=0;t<a;++t){const r=i[t];e!==r.useCapture&&n.push(r)}n.length?s?r.broadcastEvents.set(t,n):(n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,n)):s?r.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(B.$poolMap(this._$events),this._$events=null))}willTrigger(t){if(this.hasEventListener(t))return!0;let e=this._$parent;for(;e;){if(e.hasEventListener(t))return!0;e=e._$parent}return!1}}class P{static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class N extends O{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class k extends O{constructor(t,e=!1,i=!1,r=0){super(t,e,i),this._$status=0|r,this._$responseHeaders=[],this._$responseURL=""}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","eventPhase","status","responseURL")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}get responseURL(){return this._$responseURL}get status(){return this._$status}}class D extends O{constructor(t,e=!1,i=!1,r=""){super(t,e,i),this._$text=`${r}`}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}get text(){return this._$text}}class G extends O{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:function(t,e){return e in t?t[e]:B.$event&&e in B.$event?B.$event[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class V extends O{constructor(t,e=!1,i=!1,r=0,s=0){super(t,e,i),this._$bytesLoaded=0|r,this._$bytesTotal=0|s}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class H extends O{constructor(t,e=!1,i=!1,r=0,s=0){super(t,e,i),this._$bytesLoaded=0|r,this._$bytesTotal=0|s}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class X{constructor(t=1,e=1,i=1,r=1,s=0,n=0,a=0,o=0){this._$colorTransform=B.$getFloat32Array8(1,1,1,1,0,0,0,0),this.redMultiplier=t,this.greenMultiplier=e,this.blueMultiplier=i,this.alphaMultiplier=r,this.redOffset=s,this.greenOffset=n,this.blueOffset=a,this.alphaOffset=o}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=B.$clamp(+t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=B.$clamp(0|t,-255,255,0)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=B.$clamp(+t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=B.$clamp(0|t,-255,255,0)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=B.$clamp(+t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=B.$clamp(0|t,-255,255,0)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=B.$clamp(+t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=B.$clamp(0|t,-255,255,0)}concat(t){const e=B.$multiplicationColor(this._$colorTransform,t._$colorTransform);this.redMultiplier=e[0],this.greenMultiplier=e[1],this.blueMultiplier=e[2],this.alphaMultiplier=e[3],this.redOffset=e[4],this.greenOffset=e[5],this.blueOffset=e[6],this.alphaOffset=e[7],B.$poolFloat32Array8(e)}_$clone(){return B.$getColorTransform(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class Y{constructor(t=1,e=0,i=0,r=1,s=0,n=0){this._$matrix=B.$getFloat32Array6(1,0,0,1,0,0),this.a=t,this.b=e,this.c=i,this.d=r,this.tx=s,this.ty=n}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}_$clone(){return this.clone()}clone(){return B.$getMatrix(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let r=e[0]*i[0],s=0,n=0,a=e[3]*i[3],o=e[4]*i[0]+i[4],h=e[5]*i[3]+i[5];(e[1]||e[2]||i[1]||i[2])&&(r+=e[1]*i[2],a+=e[2]*i[1],s+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],o+=e[5]*i[2],h+=e[4]*i[1]),this.a=r,this.b=s,this.c=n,this.d=a,this.tx=o,this.ty=h}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,r=0,s=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(r,s)}createGradientBox(t,e,i=0,r=0,s=0){this.createBox(t/1638.4,e/1638.4,i,r+t/2,s+e/2)}deltaTransformPoint(t){return new z(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){let t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],r=this._$matrix[3],s=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/r,this.tx=-this.a*s,this.ty=-this.d*n;else{const a=t*r-e*i;if(a){const o=1/a;this.a=r*o,this.b=-e*o,this.c=-i*o,this.d=t*o,this.tx=-(this.a*s+this.c*n),this.ty=-(this.b*s+this.d*n)}}}rotate(t){const e=this._$matrix[0],i=this._$matrix[1],r=this._$matrix[2],s=this._$matrix[3],n=this._$matrix[4],a=this._$matrix[5];this.a=e*$.cos(t)-i*$.sin(t),this.b=e*$.sin(t)+i*$.cos(t),this.c=r*$.cos(t)-s*$.sin(t),this.d=r*$.sin(t)+s*$.cos(t),this.tx=n*$.cos(t)-a*$.sin(t),this.ty=n*$.sin(t)+a*$.cos(t)}scale(t,e){this.a*=t,this.c*=t,this.tx*=t,this.b*=e,this.d*=e,this.ty*=e}setTo(t,e,i,r,s,n){this.a=t,this.b=e,this.c=i,this.d=r,this.tx=s,this.ty=n}transformPoint(t){return new z(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class z{constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return $.sqrt($.pow(this.x,2)+$.pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}add(t){return new z(this.x+t.x,this.y+t.y)}clone(){return new z(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return $.sqrt($.pow(t._$x-e._$x,2)+$.pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new z(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new z(t*$.cos(e),t*$.sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new z(this.x-t.x,this.y-t.y)}}class j{constructor(t=0,e=0,i=0,r=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,r)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new z(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new z(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new z(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get x(){return this._$x}set x(t){this._$x=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX,0)}clone(){return new j(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=$.max(this.x,t.x),i=$.max(this.y,t.y),r=$.min(this.right,t.right)-e,s=$.min(this.bottom,t.bottom)-i;return r>0&&s>0?new j(e,i,r,s):new j(0,0,0,0)}intersects(t){const e=$.max(this.x,t.x),i=$.max(this.y,t.y),r=$.min(this.right,t.right),s=$.min(this.bottom,t.bottom);return r-e>0&&s-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,r){this.x=t,this.y=e,this.width=i,this.height=r}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new j($.min(this.x,t.x),$.min(this.y,t.y),$.max(this.right-t.left,t.right-this.left),$.max(this.bottom-t.top,t.bottom-this.top))}}class W{constructor(t){if(!(t instanceof q))throw new Error("Transform params is DisplayObject only.");this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.colorTransform,i=new X;return i._$colorTransform=B.$getFloat32Array8(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),i}return this._$transform(),this._$colorTransform._$clone()}set colorTransform(t){t instanceof X&&this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=B.$multiplicationColor(e._$transform._$rawColorTransform(),t),e=e._$parent;return B.$getColorTransform(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.matrix;return B.$getMatrix(e[0],e[1],e[2],e[3],e[4],e[5])}return this._$transform(),this._$matrix._$clone()}set matrix(t){t instanceof Y&&this._$transform(t._$matrix,null)}get concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=B.$multiplicationMatrix(e._$transform._$rawMatrix(),t),e=e._$parent;return B.$getMatrix(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){const t=new j(0,0,0,0);if(!this._$displayObject)return t;const e=this._$displayObject._$getBounds(null);return t._$x=e.xMin,t._$y=e.yMin,t._$width=+$.abs(e.xMax-e.xMin),t._$height=+$.abs(e.yMax-e.yMin),B.$poolBoundsObject(e),t}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject._$getPlaceObject();if(t){if(_.isArray(t.matrix)){const e=t.matrix;t.matrix=B.$getFloat32Array6(e[0],e[1],e[2],e[3],e[4],e[5]),B.$poolArray(e)}return t.matrix}return B.$MATRIX_ARRAY_IDENTITY}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject._$getPlaceObject();if(t){if(_.isArray(t.colorTransform)){const e=t.colorTransform;t.colorTransform=B.$getFloat32Array8(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),B.$poolArray(e)}return t.colorTransform}return B.$COLOR_ARRAY_IDENTITY}_$transform(t=null,e=null,i=null,r=""){const s=this._$displayObject._$getPlaceObject();this._$setMatrix(t,s),this._$setColorTransform(e,s),this._$setFilters(i,s),this._$setBlendMode(r,s)}_$setMatrix(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),B.$isUpdated=!0),this._$matrix||(this._$matrix=B.$getMatrix(1,0,0,1,0,0),!t&&e&&(t=e.matrix)),t){const e=this._$matrix._$matrix;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5]}}_$setColorTransform(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),B.$isUpdated=!0),this._$colorTransform||(this._$colorTransform=B.$getColorTransform(1,1,1,1,0,0,0,0),!t&&e&&(t=e.colorTransform)),t){const e=this._$colorTransform._$colorTransform;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7]}}_$setFilters(t=null,e=null){if(_.isArray(t))return this._$filters&&B.$poolArray(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void(B.$isUpdated=!0);if(!this._$filters)if(e){if(e.filters)this._$filters=e.filters.slice(0);else if(e.surfaceFilterList){const t=B.$getArray(),i=e.surfaceFilterList.length;for(let r=0;r<i;++r){const i=e.surfaceFilterList[r],s=next2d.filters[i.class];t.push(new(s.bind.apply(s,i.params)))}e.filters=t,this._$filters=t.slice(0)}}else this._$filters=B.$getArray()}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void(B.$isUpdated=!0);this._$blendMode||(this._$blendMode=e?e.blendMode:it.NORMAL)}}class q extends L{constructor(){super(),this._$id=-1,this._$instanceId=e++,this._$dictionaryId=0,this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$created=!1,this._$posted=!1,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=null,this._$startFrame=1,this._$endFrame=0,this._$transform=new W(this),this._$variables=null,this._$placeObject=null,this._$currentPlaceId=-1,this._$changePlace=!1,this._$scaleX=null,this._$scaleY=null,this._$rotation=null}static toString(){return"[class DisplayObject]"}static get namespace(){return"next2d.display.DisplayObject"}toString(){return"[object DisplayObject]"}get namespace(){return"next2d.display.DisplayObject"}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=B.$clamp(t,0,1,0);const e=this._$transform.colorTransform;e._$colorTransform[3]=t,e._$colorTransform[7]=0,this._$transform.colorTransform=e,B.$poolColorTransform(e)}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,this._$blendMode;const e=this._$getPlaceObject();return e?(this._$blendMode=e.blendMode,this._$blendMode):(t._$transform(),this._$blendMode=t._$blendMode,this._$blendMode)}set blendMode(t){this._$transform._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters)return this._$filters;const t=this._$transform;if(t._$filters)return this._$filters=t._$filters.slice(0),this._$filters;const e=this._$getPlaceObject();if(e){if(!e.filters){const t=[];if(e.surfaceFilterList){const i=e.surfaceFilterList.length;for(let r=0;r<i;++r){const i=e.surfaceFilterList[r],s=next2d.filters[i.class];t.push(new(s.bind.apply(s,i.params)))}}e.filters=t}return this._$filters||(this._$filters=e.filters),e.filters.slice(0)}return t._$transform(),this._$filters=t._$filters,this._$filters.slice(0)}set filters(t){t||(t=B.$getArray()),this._$transform._$transform(null,null,t,null),this._$filters=t}get height(){const t=B.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=$.abs(t.yMax-t.yMin);switch(B.$poolBoundsObject(t),e){case 0:case F:case-F:return 0;default:return+e.toFixed(2)}}set height(t){if(!l(t=+t)&&t>-1){const e=this.rotation?B.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=$.abs(e.yMax-e.yMin);switch(B.$poolBoundsObject(e),i){case 0:case F:case-F:this.scaleY=0;break;default:this.scaleY=t/i}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(B.$rendererWorker&&this._$mask._$stage&&this._$mask._$removeWorkerInstance(),this._$mask._$isMask=!1,this._$mask=null),t instanceof q&&(B.$rendererWorker&&t._$createWorkerInstance(),t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return B.$event?this.globalToLocal(B.$currentMousePoint()).x:0}get mouseY(){return B.$event?this.globalToLocal(B.$currentMousePoint()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren(),i=t.length;for(let r=0;r<i;++r){const i=t[r];i._$name&&e._$names.set(i.name,i)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){if(null!==this._$rotation)return this._$rotation;const t=this._$transform._$rawMatrix();return $.atan2(t[1],t[0])*B.$Rad2Deg}set rotation(t){if(t=B.$clamp(t%360,-360,360,0),this._$rotation===t)return;const e=this._$transform,i=e.matrix,r=$.sqrt(i.a*i.a+i.b*i.b),s=$.sqrt(i.c*i.c+i.d*i.d);if(0===t)i.a=r,i.b=0,i.c=0,i.d=s;else{let e=$.atan2(i.b,i.a),n=$.atan2(0-i.c,i.d);const a=t*B.$Deg2Rad;n=n+a-e,e=a,i.b=r*$.sin(e),1===i.b||-1===i.b?i.a=0:i.a=r*$.cos(e),i.c=-s*$.sin(n),1===i.c||-1===i.c?i.d=0:i.d=s*$.cos(n)}e.matrix=i,B.$poolMatrix(i),this._$rotation=t}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid=null,t instanceof j&&(this._$scale9Grid=t,this._$doChanged(),B.$isUpdated=!0)}get scaleX(){if(null!==this._$scaleX)return this._$scaleX;const t=this._$transform._$rawMatrix();let e=$.sqrt(t[0]*t[0]+t[1]*t[1]);if(!c.isInteger(e)){const t=e.toString(),i=t.indexOf("e");-1!==i&&(e=+t.slice(0,i)),e=+e.toFixed(4)}return 0>t[0]?-1*e:e}set scaleX(t){if(t=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX),!c.isInteger(t)){const e=t.toString(),i=e.indexOf("e");-1!==i&&(t=+e.slice(0,i)),t=+t.toFixed(4)}if(this._$scaleX===t)return;const e=this._$transform,i=e.matrix;if(0===i.b||l(i.b))i.a=t;else{let e=$.atan2(i.b,i.a);e===-$.PI&&(e=0),i.b=t*$.sin(e),i.a=t*$.cos(e)}e.matrix=i,B.$poolMatrix(i),this._$scaleX=t}get scaleY(){if(null!==this._$scaleY)return this._$scaleY;const t=this._$transform._$rawMatrix();let e=$.sqrt(t[2]*t[2]+t[3]*t[3]);if(!c.isInteger(e)){const t=e.toString(),i=t.indexOf("e");-1!==i&&(e=+t.slice(0,i)),e=+e.toFixed(4)}return 0>t[3]?-1*e:e}set scaleY(t){if(t=B.$clamp(+t,B.$SHORT_INT_MIN,B.$SHORT_INT_MAX),!c.isInteger(t)){const e=t.toString(),i=e.indexOf("e");-1!==i&&(t=+e.slice(0,i)),t=+t.toFixed(4)}if(this._$scaleY===t)return;const e=this._$transform,i=e.matrix;if(0===i.c||l(i.c))i.d=t;else{let e=$.atan2(-i.c,i.d);e===-$.PI&&(e=0),i.c=-t*$.sin(e),i.d=t*$.cos(e)}e.matrix=i,B.$poolMatrix(i),this._$scaleY=t}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t instanceof ft?t:t._$stage:null}get transform(){return this._$transform}set transform(t){t instanceof W&&(this._$transform=t)}get visible(){return this._$visible}set visible(t){t=!!t,this._$visible!==t&&(this._$doChanged(),B.$isUpdated=!0),this._$visible=!!t}get width(){const t=B.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=$.abs(t.xMax-t.xMin);switch(B.$poolBoundsObject(t),!0){case 0===e:case e===F:case e===0-F:return 0;default:return+e.toFixed(2)}}set width(t){if(!l(t=+t)&&t>-1){const e=this.rotation?B.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=$.abs(e.xMax-e.xMin);switch(B.$poolBoundsObject(e),!0){case 0===i:case i===F:case i===-F:this.scaleX=0;break;default:this.scaleX=t/i}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform,i=this._$transform.matrix;i.tx=t,e.matrix=i,B.$poolMatrix(i)}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform,i=e.matrix;i.ty=t,e.matrix=i,B.$poolMatrix(i)}getBounds(t=null){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,r=B.$boundsMatrix(e,i._$matrix);B.$poolMatrix(i),B.$poolBoundsObject(e);const s=B.$getBoundsObject(r.xMin,r.xMax,r.yMin,r.yMax);B.$poolBoundsObject(r),t||(t=this);const n=t._$transform.concatenatedMatrix;n.invert();const a=B.$boundsMatrix(s,n._$matrix),o=a.xMin,h=a.yMin,l=a.xMax,_=a.yMax;return B.$poolBoundsObject(s),B.$poolBoundsObject(a),B.$poolMatrix(n),new j(o,h,$.abs(l-o),$.abs(_-h))}globalToLocal(t){const e=this._$transform.concatenatedMatrix;e.invert();const i=new z(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return B.$poolMatrix(e),i}hitTestObject(t){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,r=B.$boundsMatrix(e,i._$matrix);B.$poolMatrix(i),B.$poolBoundsObject(e);const s=t._$getBounds(null),n=t._$transform.concatenatedMatrix,a=B.$boundsMatrix(s,n._$matrix);B.$poolMatrix(n),B.$poolBoundsObject(s);const o=$.max(r.xMin,a.xMin),h=$.max(r.yMin,a.yMin),l=$.min(r.xMax,a.xMax),_=$.min(r.yMax,a.yMax);return B.$poolBoundsObject(r),B.$poolBoundsObject(a),l-o>=0&&_-h>=0}hitTestPoint(t,e,i=!1){if(i){let i=B.$MATRIX_ARRAY_IDENTITY,r=this._$parent;for(;r;)i=B.$multiplicationMatrix(r._$transform._$rawMatrix(),i),r=r._$parent;B.$hitContext.setTransform(1,0,0,1,0,0),B.$hitContext.beginPath();const s=this._$hit(B.$hitContext,i,{x:t,y:e},!0);return B.$poolFloat32Array6(i),s}const r=this._$getBounds(null),s=B.$boundsMatrix(r,this._$transform._$rawMatrix()),n=s.xMin,a=s.yMin,o=s.xMax-s.xMin,h=s.yMax-s.yMin,l=this._$parent?this._$parent.globalToLocal(new z(t,e)):new z(t,e);return B.$poolBoundsObject(s),B.$poolBoundsObject(r),new j(n,a,o,h).containsPoint(l)}localToGlobal(t){const e=this._$transform.concatenatedMatrix,i=new z(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return B.$poolMatrix(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=B.$getMap()),this._$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(B.$poolMap(this._$variables),this._$variables=null))}getGlobalVariable(t){return B.$variables.has(t)?B.$variables.get(t):null}setGlobalVariable(t,e){B.$variables.set(t,e)}hasGlobalVariable(t){return B.$variables.has(t)}deleteGlobalVariable(t){B.$variables.has(t)&&B.$variables.delete(t)}clearGlobalVariable(){return B.$variables.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(null===t)return null;const e=this._$parent;if(!e)return null;const i=e._$placeMap;if(!i||!i.length)return null;const r=i[e._$currentFrame||1];if(!r)return null;const s=r[t];this._$changePlace=s!==this._$currentPlaceId,this._$currentPlaceId=s,this._$placeObject=e._$placeObjects[s]}return this._$placeObject}_$sync(){const t=this.contentName;let e=null;if(next2d.fw.response.has(t)&&(e=next2d.fw.response.get(t)._$loaderInfo),!e&&next2d.fw.cache.has(t)&&(e=next2d.fw.cache.get(t)._$loaderInfo),e||(e=this._$loaderInfo||B.$currentLoaderInfo),!e)return null;const i=e._$data.symbols.get(this.namespace),r=e._$data.characters[i];return this._$characterId=i,this._$loaderInfo=e,r}_$build(t,e){const i=e._$loaderInfo;return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;let t=this._$parent;t&&t._$updateState()}_$doChanged(){B.$rendererWorker&&this._$created&&B.$rendererWorker.postMessage({command:"doChanged",instanceId:this._$instanceId}),this._$posted=!1,this._$isNext=!0,this._$updated=!0;let t=this._$parent;t&&t._$doChanged()}_$drawFilter(t,e,i,r,s,n){const a=B.$cacheStore(),o=[this._$instanceId,"f"];let h=a.get(o);const l=this._$isFilterUpdated(s,n,i,r,!0);let $;return h&&!l||(h&&(a.set(o,null),h.layerWidth=0,h.layerHeight=0,h._$offsetX=0,h._$offsetY=0,h.matrix=null,h.colorTransform=null,t.frameBuffer.releaseTexture(h),h=null),$=this._$applyFilter(t,r,e,i,s,n),a.set(o,$)),h&&($=h),$}_$getLayerBounds(t=null){const e=this._$getBounds(t);if(!t)return e;const i=this._$filters||this.filters,r=i.length;if(!r)return e;let s=new j(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);B.$poolBoundsObject(e);for(let t=0;t<r;++t)s=i[t]._$generateFilterRect(s,null,null,!0);const n=s._$x,a=s._$x+s._$width,o=s._$y,h=s._$y+s._$height;return B.$getBoundsObject(n,a,o,h)}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger(O.ADDED)&&this.dispatchEvent(new O(O.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger(O.ADDED_TO_STAGE)&&this.dispatchEvent(new O(O.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!this._$posted&&B.$rendererWorker&&this._$postProperty(),!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e,i,r=null,s=!1,n=0,a=0){if(this._$isUpdated())return!0;if(s)for(let t=0;t<r.length;++t)if(r[t]._$isUpdated())return!0;const o=B.$cacheStore().get([this._$instanceId,"f"]);switch(!0){case null===o:case o.filterState!==s:case o.layerWidth!==$.ceil(t):case o.layerHeight!==$.ceil(e):case o.matrix!==i[0]+"_"+i[1]+"_"+i[2]+"_"+i[3]+"_"+n+"_"+a:return!0}return!1}_$applyFilter(t,e,i,r,s,n){const a=+$.sqrt(r[0]*r[0]+r[1]*r[1]),o=+$.sqrt(r[2]*r[2]+r[3]*r[3]),h=$.atan2(r[1],r[0]),l=$.atan2(-r[2],r[3]),_=B.$getFloat32Array6($.cos(h),$.sin(h),-$.sin(l),$.cos(l),s/2,n/2),c=B.$getFloat32Array6(1,0,0,1,-i.width/2,-i.height/2),u=B.$multiplicationMatrix(_,c);B.$poolFloat32Array6(_),B.$poolFloat32Array6(c);const d=t._$frameBufferManager,g=d.currentAttachment,p=d.createCacheAttachment(s,n);t._$bind(p),B.$resetContext(t),t.setTransform(u[0],u[1],u[2],u[3],u[4],u[5]),B.$poolFloat32Array6(u),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;const f=B.$getFloat32Array6(a,0,0,o,0,0);let m=null;for(let i=0;i<e.length;++i)m=e[i]._$applyFilter(t,f);B.$poolFloat32Array6(f);let x=t._$offsetX,b=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,m._$offsetX=x,m._$offsetY=b,m.matrix=r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3],m.filterState=!0,m.layerWidth=s,m.layerHeight=n,t._$bind(g),d.releaseAttachment(p,!1),m}_$shouldClip(t){if(this instanceof Ut)return!(!this.textWidth||!this.textHeight);const e=this._$getBounds(t),i=$.abs(e.xMax-e.xMin),r=$.abs(e.yMax-e.yMin);return B.$poolBoundsObject(e),!(!i||!r)}_$startClip(t,e){let i=null;if(!t._$cacheCurrentBuffer){let r=e;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(r=B.$multiplicationMatrix(e,s));const n=this._$getBounds(null),a=B.$boundsMatrix(n,r);if(B.$poolBoundsObject(n),i=t._$startClip(e,a),B.$poolBoundsObject(a),r!==e&&B.$poolFloat32Array6(r),!i)return!1}t._$enterClip(),t._$beginClipDef();let r=!1;return this instanceof Q&&(r=!0,t._$updateContainerClipFlag(!0)),this._$clip(t,i||e),this._$updated=!1,r&&(t._$updateContainerClipFlag(!1),t._$drawContainerClip()),t._$endClipDef(),i}_$removeWorkerInstance(){B.$rendererWorker.postMessage({command:"remove",instanceId:this._$instanceId})}_$postProperty(){const t={command:"setProperty",instanceId:this._$instanceId,visible:this._$visible,isMask:this._$isMask,clipDepth:this._$clipDepth,depth:this._$placeId,maskId:-1},e=this._$mask;if(e){t.maskId=e._$instanceId;let i=B.$MATRIX_ARRAY_IDENTITY,r=e._$parent;for(;r;)i=B.$multiplicationMatrix(r._$transform._$rawMatrix(),i),r=r._$parent;t.maskMatrix=i}if(this._$visible){const e=this._$transform,i=e._$rawMatrix();1!==i[0]&&(t.a=i[0]),0!==i[1]&&(t.b=i[1]),0!==i[2]&&(t.c=i[2]),1!==i[3]&&(t.d=i[3]),0!==i[4]&&(t.tx=i[4]),0!==i[5]&&(t.ty=i[5]);const r=e._$rawColorTransform();1!==r[0]&&(t.f0=r[0]),1!==r[1]&&(t.f1=r[1]),1!==r[2]&&(t.f2=r[2]),1!==r[3]&&(t.f3=r[3]),0!==r[4]&&(t.f4=r[4]),0!==r[5]&&(t.f5=r[5]),0!==r[6]&&(t.f6=r[6]),0!==r[7]&&(t.f7=r[7]);const s=this._$filters||this.filters;if(s&&s.length){const e=B.$getArray();for(let t=0;t<s.length;++t)e.push(s[t]._$toArray());t.filters=e}const n=this._$blendMode||this.blendMode;n!==it.NORMAL&&(t.blendMode=n);const a=this._$scale9Grid;if(a&&this._$isUpdated()){const e=this._$parent._$transform.concatenatedMatrix;t.matrixBase=e._$matrix.slice(),B.$poolMatrix(e),t.grid={x:a.x,y:a.y,w:a.width,h:a.height}}}return t}}class K extends q{constructor(){super(),this._$mouseEnabled=!0}static toString(){return"[class InteractiveObject]"}static get namespace(){return"next2d.display.InteractiveObject"}toString(){return"[object InteractiveObject]"}get namespace(){return"next2d.display.InteractiveObject"}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=!!t}}class Q extends K{constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=B.$getArray(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=B.$getMap(),new Proxy(this,{get:(t,e)=>t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]})}static toString(){return"[class DisplayObjectContainer]"}static get namespace(){return"next2d.display.DisplayObjectContainer"}toString(){return"[object DisplayObjectContainer]"}get namespace(){return"next2d.display.DisplayObjectContainer"}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=!!t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){if(!(t instanceof q))throw new TypeError("TypeError: addChild: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));return this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){if(!(t instanceof q))throw new TypeError("TypeError: addChildAt: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),r=i.length;if(0>e||e>r)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(r&&r>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(!(t instanceof q))throw new TypeError("TypeError: contains: not DisplayObject.");if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren(),i=e.length;for(let r=0;r<i;++r){const i=e[r];if(i._$instanceId===t._$instanceId)return!0;if(i instanceof Q&&i.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren(),i=e.length;if(0>t||t>i)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren(),i=e.length;for(let r=0;r<i;++r){const i=e[r];if(i.name===t)return i}return null}getChildIndex(t){if(!(t instanceof q))throw new TypeError("TypeError: getChildIndex: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError("ArgumentError: getChildIndex: not child");const e=this._$getChildren().indexOf(t);if(-1===e)throw new ArgumentError("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(!(t instanceof q))throw new TypeError("TypeError: removeChild: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError(`ArgumentError: removeChild: index error: ${index}`);return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const i=this._$getChildren(),r=i.length;if(r){t=B.$clamp(t,0,2147483646,0)-1,e=B.$clamp(e,1,134217727,134217727);for(let s=$.min(e,r-1);s>t;--s)this._$remove(i[s])}}setChildIndex(t,e){if(!(t instanceof q))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this.getChildIndex(t);if(i===e)return;const r=this._$getChildren();r.splice(i,1),r.splice(e,0,t),B.$rendererWorker&&this._$postChildrenIds(),this._$doChanged()}swapChildren(t,e){if(!(t instanceof q&&e instanceof q))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this._$getChildren(),r=this.getChildIndex(t),s=this.getChildIndex(e);i[r]=e,i[s]=t,B.$rendererWorker&&this._$postChildrenIds(),this._$doChanged()}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=B.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=B.$multiplicationMatrix(t,i))}const i=!!this._$graphics,r=this._$needsChildren?this._$getChildren():this._$children,s=r.length;if(!s&&!i){const i=B.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&B.$poolFloat32Array6(e),i}const n=c.MAX_VALUE;let a=n,o=-n,h=n,l=-n;if(i){const t=B.$boundsMatrix(this._$graphics._$getBounds(),e);a=t.xMin,o=t.xMax,h=t.yMin,l=t.yMax,B.$poolBoundsObject(t)}for(let t=0;t<s;++t){const i=r[t]._$getBounds(e);a=$.min(a,i.xMin),o=$.max(o,i.xMax),h=$.min(h,i.yMin),l=$.max(l,i.yMax),B.$poolBoundsObject(i)}return t&&e!==t&&B.$poolFloat32Array6(e),B.$getBoundsObject(a,o,h,l)}_$getLayerBounds(t=null){let e=B.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==B.$MATRIX_ARRAY_IDENTITY&&(e=B.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),r=this._$needsChildren?this._$getChildren():this._$children,s=r.length;if(!s&&!i){const i=B.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&B.$poolFloat32Array6(e),i}const n=c.MAX_VALUE;let a=n,o=-n,h=n,l=-n;if(i){const t=B.$boundsMatrix(this._$graphics._$getBounds(),e);a=+t.xMin,o=+t.xMax,h=+t.yMin,l=+t.yMax,B.$poolBoundsObject(t)}for(let t=0;t<s;++t){const i=r[t]._$getLayerBounds(e);a=$.min(a,i.xMin),o=$.max(o,i.xMax),h=$.min(h,i.yMin),l=$.max(l,i.yMax),B.$poolBoundsObject(i)}if(t&&e!==t&&B.$poolFloat32Array6(e),!t)return B.$getBoundsObject(a,o,h,l);const _=this._$filters||this.filters,u=_.length;if(!u)return B.$getBoundsObject(a,o,h,l);let d=new j(a,h,o-a,l-h);for(let t=0;t<u;++t)d=_[t]._$generateFilterRect(d,null,null,!0);return a=d._$x,o=d._$x+d._$width,h=d._$y,l=d._$y+d._$height,B.$getBoundsObject(a,o,h,l)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=B.$cacheStore(),e=!!B.$rendererWorker&&!!this._$stage;if(!this._$controller)return this._$children;const i=this._$currentFrame||1;let r=this._$controller[i];const s=B.$getArray(),n=this._$children.length;if(!n){if(r){const t=r.length;for(let e=0;e<t;++e){const t=this._$createInstance(r[e]);t._$placeId=e;const i=t.loopConfig;i&&(t._$currentFrame=t._$getLoopFrame(i)),this._$children.push(t),t._$name&&this._$names.set(t._$name,t)}}return B.$poolArray(s),this._$children}const a=B.$getMap(),o=B.$getMap();let h=0;const l=B.$getArray();for(let s=0;s<n;++s){const n=this._$children[s],$=n._$parent;if(!$||$._$instanceId!==this._$instanceId)continue;const _=n._$instanceId,c=n._$startFrame,u=n._$endFrame;if(1===c&&0===u||c<=i&&u>i){if(n._$isNext=!0,n._$placeObject=null,n._$filters=null,n._$blendMode=null,-1===n._$id){l.push(n),n._$name&&this._$names.set(n._$name,n);continue}const t=r[h];if(n._$id===t){n._$placeId=h,l.push(n),n._$name&&this._$names.set(n._$name,n),o.has(t)&&o.delete(t),a.set(t,!0),h++,e&&n._$postProperty();continue}o.set(n._$id,n)}else e&&n._$removeWorkerInstance(),t.setRemoveTimer(_),n._$loaderInfo&&n._$characterId&&t.setRemoveTimer(`${n._$loaderInfo._$id}@${n._$characterId}`),n.willTrigger(O.REMOVED)&&n.dispatchEvent(new O(O.REMOVED,!0)),n.willTrigger(O.REMOVED_FROM_STAGE)&&n.dispatchEvent(new O(O.REMOVED_FROM_STAGE,!0)),n._$added=!1,n._$addedStage=!1,n._$active=!1,n._$updated=!0,n._$filters=null,n._$blendMode=null,n._$isNext=!0,n._$placeObject=null,n._$created=!1,n._$posted=!1,n instanceof Q&&(n._$executeRemovedFromStage(),n._$removeParentAndStage())}if(r)for(let t=0;t<r.length;++t){const e=r[t];if(a.has(e))continue;const i=o.has(e)?o.get(e):this._$createInstance(e);i._$placeId=t;const s=i.loopConfig;s&&(i._$currentFrame=i._$getLoopFrame(s)),l.push(i),i._$name&&this._$names.set(i._$name,i)}B.$poolMap(a),B.$poolMap(o),B.$poolArray(this._$children),B.$poolArray(s),this._$children=l}return this._$children}_$clearChildren(){this._$doChanged(),B.$isUpdated=!0,this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$parent=this,this.constructor===ft?(t._$stage=this,t._$root=t):(t._$stage=this._$stage,t._$root=this._$root),t instanceof Q&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger(O.ADDED)&&t.dispatchEvent(new O(O.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(B.$rendererWorker&&(t._$createWorkerInstance(),t._$postProperty(),this._$postChildrenIds()),t.willTrigger(O.ADDED_TO_STAGE)&&t.dispatchEvent(new O(O.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof Q&&t._$executeAddedToStage()),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e._$root=this._$root,e._$stage=this._$stage,e instanceof Q&&(e._$setParentAndStage(),e._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=B.$getArray(),i=t.length;for(let r=0;r<i;++r){const i=t[r];i&&(e.push(i._$instanceId),i._$addedStage||(B.$rendererWorker&&(i._$createWorkerInstance(),i._$postProperty()),i.willTrigger(O.ADDED_TO_STAGE)&&i.dispatchEvent(new O(O.ADDED_TO_STAGE)),i._$addedStage=!0),i instanceof Q&&i._$executeAddedToStage())}B.$rendererWorker&&this._$postChildrenIds(e),B.$poolArray(e)}_$remove(t,e=!0){t._$transform._$transform();const i=this._$needsChildren?this._$getChildren():this._$children,r=this.getChildIndex(t);if(i.splice(r,1),this._$names.delete(t.name),e){t.willTrigger(O.REMOVED)&&t.dispatchEvent(new O(O.REMOVED,!0)),null!==this._$stage&&(B.$rendererWorker&&(t._$removeWorkerInstance(),this._$postChildrenIds()),t.willTrigger(O.REMOVED_FROM_STAGE)&&t.dispatchEvent(new O(O.REMOVED_FROM_STAGE)),t instanceof Q&&t._$executeRemovedFromStage());const e=B.$cacheStore();e.setRemoveTimer(t._$instanceId),t._$loaderInfo&&t._$characterId&&e.setRemoveTimer(`${t._$loaderInfo._$id}@${t._$characterId}`),t instanceof Q&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,t._$created=!1,t._$posted=!1,this._$doChanged()}return t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0),e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage&&(B.$rendererWorker&&e._$removeWorkerInstance(),e.willTrigger(O.REMOVED_FROM_STAGE)&&e.dispatchEvent(new O(O.REMOVED_FROM_STAGE)),e._$created=!1,e._$posted=!1,e._$addedStage=!1),e instanceof Q&&e._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=B.$cacheStore(),i=t.length;for(let r=0;r<i;++r){const i=t[r];e.setRemoveTimer(i._$instanceId),i._$loaderInfo&&i._$characterId&&e.setRemoveTimer(`${i._$loaderInfo._$id}@${i._$characterId}`),i instanceof Q&&i._$removeParentAndStage(),i._$stage=null,i._$root=null,i._$addedStage=!1}if(this._$sounds){const t=this._$sounds.values();for(const e of t)for(let t=0;t<e.length;++t){e[t].stop()}}this._$needsChildren=!0}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const r=e[i];r._$isNext&&(t?r._$nextFrame():t=r._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,!this._$posted&&B.$rendererWorker&&this._$postProperty(),this._$isNext}_$clip(t,e){let i=e;const r=this._$transform._$rawMatrix();1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(i=B.$multiplicationMatrix(e,r)),this._$graphics&&this._$graphics._$getBounds()&&this._$graphics._$clip(t,i);const s=this._$getChildren(),n=s.length;for(let e=0;e<n;++e){const r=s[e];r._$isMask||(r._$clip(t,i),r._$updated=!1)}i!==e&&B.$poolFloat32Array6(i)}_$preDraw(t,e){const i=this._$transform._$rawMatrix(),r=B.$multiplicationMatrix(e,i);if(!r[0]&&!r[1]||!r[2]&&!r[3])return!1;const s=B.$getPreObject();s.matrix=r;const n=this._$filters||this.filters,a=this._$blendMode||this.blendMode;if(n.length>0||a!==it.NORMAL){const e=this._$getBounds(null),o=B.$boundsMatrix(e,r),h=+o.xMax,l=+o.xMin,_=+o.yMax,c=+o.yMin;B.$poolBoundsObject(e),B.$poolBoundsObject(o);const u=$.abs(h-l),d=$.abs(_-c);if(0>=u||0>=d)return!1;if(0>l+u||0>c+d)return!1;const g=t.frameBuffer.currentAttachment;if(l>g.width||c>g.height)return!1;s.basePosition.x=i[4],s.basePosition.y=i[5];let p=this._$getLayerBounds(null);const f=B.$boundsMatrix(p,r);let m=$.abs(f.xMax-f.xMin),x=$.abs(f.yMax-f.yMin);B.$poolBoundsObject(f),m===u&&x===d&&(B.$poolBoundsObject(p),p=null);let b=r[4]-$.floor(l),T=r[5]-$.floor(c),v=null;if(p){const t=B.$getFloat32Array6(r[0],r[1],r[2],r[3],0,0);v=B.$boundsMatrix(p,t),B.$poolBoundsObject(p),B.$poolFloat32Array6(t),b+=-$.floor(v.xMin)-b,T+=-$.floor(v.yMin)-T}let y=$.floor(l),A=$.floor(c),M=l,E=c;if(v&&(y-=-$.floor(v.xMin)-(r[4]-y),A-=-$.floor(v.yMin)-(r[5]-A),M-=-v.xMin-(r[4]-M),E-=-v.yMin-(r[5]-E),B.$poolBoundsObject(v)),s.position.dx=y>0?y:0,s.position.dy=A>0?A:0,m+M>g.texture.width&&(m-=m-g.texture.width+M),x+E>g.texture.height&&(x-=x-g.texture.height+E),0>y&&(b+=y,m+=M),0>A&&(T+=A,x+=E),0>=m||0>=x||!m||!x)return B.$poolPreObject(s),!1;t._$startLayer(B.$getBoundsObject(M,0,E,0)),s.canApply=this._$canApply(n);let C=this._$isFilterUpdated(m,x,r,n,s.canApply,s.basePosition.x,s.basePosition.y);t._$saveCurrentMask(),C&&t._$saveAttachment($.ceil(m),$.ceil(x),!1),s.isFilter=!0,s.isUpdated=C,s.color=B.$getFloat32Array8(),s.baseMatrix=r,s.filters=n,s.blendMode=a,s.layerWidth=m,s.layerHeight=x,s.matrix=B.$getFloat32Array6(r[0],r[1],r[2],r[3],b,T)}return s}_$postDraw(t,e,i,r){const s=B.$getArray(this._$instanceId,"f"),n=B.$cacheStore(),a=t._$frameBufferManager;let o=null;if(r.isUpdated){o=a.getTextureFromCurrentAttachment();const t=n.get(s);t&&(n.set(s,null),a.releaseTexture(t))}else o=n.get(s);r.canApply||(o._$offsetX=0,o._$offsetY=0);let h=o._$offsetX,l=o._$offsetY;if(r.isUpdated&&r.canApply){let i=n.get(s);i&&(n.set(s,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,a.releaseTexture(i),i=null);const $=r.filters.length;if($){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<$;++i)o=r.filters[i]._$applyFilter(t,e);h=t._$offsetX,l=t._$offsetY,t._$offsetX=0,t._$offsetY=0,o._$offsetX=h,o._$offsetY=l}}if(r.isUpdated){o.filterState=r.canApply;const t=r.baseMatrix;o.matrix=`${t[0]}_${t[1]}_${t[2]}_${t[3]}`,o.layerWidth=r.layerWidth,o.layerHeight=r.layerHeight}n.set(s,o),B.$poolArray(s),r.isUpdated&&t._$restoreAttachment(),B.$resetContext(t),t._$globalAlpha=B.$clamp(i[3]+i[7]/255,0,1),t._$globalCompositeOperation=r.blendMode,t.setTransform(1,0,0,1,0,0),t.drawImage(o,-h+r.position.dx,-l+r.position.dy,o.width,o.height,i),t._$endLayer(),t._$restoreCurrentMask(),B.$poolFloat32Array8(r.color),B.$poolFloat32Array6(r.matrix),B.$poolFloat32Array6(r.baseMatrix),B.$poolPreObject(r)}_$draw(t,e,i){if(!this._$visible)return;let r=i;const s=this._$transform._$rawColorTransform();1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=B.$multiplicationColor(i,s));if(!B.$clamp(r[3]+r[7]/255,0,1,0))return;const n=this._$needsChildren?this._$getChildren():this._$children,a=n.length;if(!(a||this._$graphics&&this._$graphics._$canDraw))return;const o=this._$preDraw(t,e);if(!o)return;if(o.isFilter&&!o.isUpdated)return void this._$postDraw(t,e,r,o);let h=o.matrix;const l=o.isFilter?o.color:r;this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$draw(t,h,l);let _=!0,c=null;const u=B.$getArray(),d=B.$getArray(),g=B.$getArray(),p=B.$getArray(),f=t._$isLayer,m=this._$isUpdated();for(let e=0;e<a;++e){const i=n[e];if(m&&(i._$placeObject=null),i._$isMask)continue;const r=i._$blendMode||i.blendMode;if((r===it.ALPHA||r===it.ERASE)&&!f)continue;if(c&&(i._$placeId>c||i._$clipDepth>0)&&(t.restore(),_&&(t._$leaveClip(),u.length&&(B.$poolFloat32Array6(h),h=u.pop())),c=g.length?g.pop():null,_=p.pop()),!_)continue;if(i._$clipDepth>0){if(t.save(),c&&g.push(c),p.push(_),c=i._$clipDepth,_=i._$shouldClip(h),_){const e=i._$startClip(t,h);if(!1===e){_=!1;continue}e&&(u.push(h),h=e)}continue}const s=i._$mask;if(s){let e;if(s._$updated=!1,this===s._$parent)e=h;else{e=B.$MATRIX_ARRAY_IDENTITY;let i=s._$parent;for(;i;)e=B.$multiplicationMatrix(i._$transform._$rawMatrix(),e),i=i._$parent;const r=this.stage._$player,n=r._$scale*r._$ratio,a=B.$getFloat32Array6(n,0,0,n,0,0);if(e=B.$multiplicationMatrix(a,e),B.$poolFloat32Array6(a),t._$isLayer){const i=t._$getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t._$cacheCurrentBuffer&&(e[4]-=t._$cacheCurrentBounds.x,e[5]-=t._$cacheCurrentBounds.y)}if(!s._$shouldClip(e))continue;let i=s._$startClip(t,e);if(t.save(),!1===i){t.restore();continue}if(i){if(d.push(h),this!==s._$parent){const e=this._$transform._$rawMatrix();i[0]=$.abs(h[0])*$.sign(e[0]),i[1]=$.abs(h[1])*$.sign(e[1]),i[2]=$.abs(h[2])*$.sign(e[2]),i[3]=$.abs(h[3])*$.sign(e[3]),i[4]=h[4]-t._$cacheCurrentBounds.x,i[5]=h[5]-t._$cacheCurrentBounds.y}h=i}}i._$draw(t,h,l),i._$updated=!1,s&&(t.restore(),t._$leaveClip(),d.length&&(B.$poolFloat32Array6(h),h=d.pop()))}if(c&&(t.restore(),p.pop()&&t._$leaveClip()),B.$poolArray(u),B.$poolArray(d),B.$poolArray(g),B.$poolArray(p),o.isFilter)return this._$postDraw(t,e,r,o);B.$poolFloat32Array6(h),B.$poolPreObject(o),r!==i&&B.$poolFloat32Array8(r)}_$mouseHit(t,e,i,r=!0){let s=e;const n=this._$transform._$rawMatrix();n!==B.$MATRIX_ARRAY_IDENTITY&&(s=B.$multiplicationMatrix(e,n));const a=this._$getChildren(),o=B.$getArray(),h=B.$getArray(),l=B.$getMap();let _=a.length,c=null,u=null;for(let t=0;t<_;++t){const e=a[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?(u=o.length,c=e._$clipDepth,o.push(e)):(c&&e._$placeId>c&&(u=null,c=null),null!==u&&l.set(e._$instanceId,u),h.push(e)))}const d=$.min(this._$mouseChildren,r);let g=!1;const p=this._$root===this;_=h.length;for(let e=0;e<_;++e){const e=h.pop();if(e._$isMask)continue;if(p&&!(e instanceof K))continue;if(l.has(e._$instanceId)){if(!o[l.get(e._$instanceId)]._$hit(t,s,i,!0))continue}const r=e._$mask;if(r)if(this===r._$parent){if(!r._$hit(t,s,i,!0))continue}else{let e=B.$MATRIX_ARRAY_IDENTITY,s=r._$parent;for(;s;)e=B.$multiplicationMatrix(s._$transform._$rawMatrix(),e),s=s._$parent;if(!r._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,s,i,d)||e._$hitArea&&e._$hitArea._$mouseHit(t,s,i,d)){if(e._$root===e)return!0;if(!d)return!0;if(g=!0,e instanceof K){if(!e._$mouseEnabled&&!e._$hitObject)continue;if(!B.$isTouch&&!i.pointer)switch(!0){case e instanceof Ut:e._$type===Ot.INPUT&&(i.pointer="text");break;case e.buttonMode&&e.useHandCursor:i.pointer="pointer"}return i.hit||(i.hit=!e._$mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}return B.$poolArray(o),B.$poolArray(h),B.$poolMap(l),!g&&this._$graphics&&(g=this._$graphics._$hit(t,s,i)),s!==e&&B.$poolFloat32Array6(s),g}_$hit(t,e,i,r=!1){let s=e;const n=this._$transform._$rawMatrix();n!==B.$MATRIX_ARRAY_IDENTITY&&(s=B.$multiplicationMatrix(e,n));const a=this._$getChildren();for(let e=a.length-1;e>-1;--e){const n=a[e];if(!n._$isMask&&n._$hit(t,s,i,r))return!0}let o=!1;return this._$graphics&&(o=this._$graphics._$hit(t,s,i)),s!==e&&B.$poolFloat32Array6(s),o}_$createInstance(t){const e=this._$dictionary[t],i=this._$loaderInfo._$data.characters[e.characterId];i.class||(i.class=i.symbol&&B.$getClass(i.symbol)||B.$getClass(i.extends)),B.$currentLoaderInfo=null;const r=new i.class;return r._$build(e,this),r._$id=t,r}_$outCheck(t,e){let i=B.$MATRIX_ARRAY_IDENTITY,r=this._$parent;for(;r;)i=B.$multiplicationMatrix(r._$transform._$rawMatrix(),i),r=r._$parent;return B.$hitContext.setTransform(1,0,0,1,0,0),B.$hitContext.beginPath(),this._$mouseHit(B.$hitContext,i,{x:t,y:e})}_$createWorkerInstance(){if(this._$created)return;this._$created=!0;const t=B.$getArray(),e={command:"createDisplayObjectContainer",instanceId:this._$instanceId},i=this._$graphics;if(i){const r=i._$getRecodes();t.push(r.buffer),e.recodes=r,e.maxAlpha=i._$maxAlpha,e.canDraw=i._$canDraw,e.xMin=i._$xMin,e.yMin=i._$yMin,e.xMax=i._$xMax,e.yMax=i._$yMax}B.$rendererWorker.postMessage(e,t)}_$postProperty(){this._$postChildrenIds();const t=B.$getArray(),e=super._$postProperty(),i=this._$graphics;if(i&&!i._$buffer){e.maxAlpha=i._$maxAlpha,e.canDraw=i._$canDraw;const r=i._$getRecodes();e.recodes=r,t.push(r.buffer);const s=this._$getBounds();e.xMin=s.xMin,e.yMin=s.yMin,e.xMax=s.xMax,e.yMax=s.yMax}B.$rendererWorker.postMessage(e,t),B.$poolArray(t),this._$posted=!0,this._$updated=!1}_$postChildrenIds(t=null){if(t)B.$rendererWorker.postMessage({command:"setChildren",instanceId:this._$instanceId,children:t});else{const e=this._$needsChildren?this._$getChildren():this._$children;t=B.$getArray();for(let i=0;i<e.length;++i)t.push(e[i]._$instanceId);B.$rendererWorker.postMessage({command:"setChildren",instanceId:this._$instanceId,children:t}),B.$poolArray(t)}}}class J extends Q{constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=!!t}get dropTarget(){return B.$dropTarget}get graphics(){return this._$graphics||(this._$graphics=new at,this._$graphics._$displayObject=this),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=null,t instanceof J&&(this._$hitArea=t,t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new Gt),this._$soundTransform}set soundTransform(t){t instanceof Gt&&(this._$soundTransform=t)}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=!!t}startDrag(t=!1,e=null){let i=0,r=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,r=this.y-t.y}B.$dropTarget=this,B.$dragRules.lock=t,B.$dragRules.position.x=i,B.$dragRules.position.y=r,B.$dragRules.bounds=e}stopDrag(){B.$dropTarget=null,B.$dragRules.lock=!1,B.$dragRules.position.x=0,B.$dragRules.position.y=0,B.$dragRules.bounds=null}_$sync(){const t=super._$sync();return B.$rendererWorker&&this._$stage&&this._$createWorkerInstance(),t&&(this._$controller=t.controller,this._$dictionary=t.dictionary,this._$placeMap=t.placeMap,this._$placeObjects=t.placeObjects),t}_$build(t,e){const i=super._$build(t,e);return B.$rendererWorker&&this._$stage&&this._$createWorkerInstance(),this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(B.$currentMousePoint()):this.globalToLocal(B.$currentMousePoint())}}class Z extends J{constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=B.$getMap(),this._$frameCache=B.$getMap(),this._$labels=null,this._$sounds=B.$getMap(),this._$channels=B.$getMap(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1,this._$loopConfig=null,this._$tweenFrame=0}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)?this._$labels.get(t):null}get currentLabels(){return this._$labels?_.from(this._$labels.values()):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}get loopConfig(){if(this._$loopConfig)return this._$loopConfig;const t=this._$getPlaceObject();return t&&t.loop?(this._$tweenFrame&&(this._$changePlace=this._$tweenFrame!==this._$parent._$currentFrame,this._$tweenFrame=0),t.loop.tweenFrame&&(this._$tweenFrame=t.loop.tweenFrame),t.loop):null}set loopConfig(t){this._$loopConfig=null,t instanceof ut&&(t._$frame=this._$startFrame,this._$loopConfig=t,this._$currentFrame=this._$getLoopFrame(t))}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=B.$getMap()),t instanceof st&&this._$labels.set(t.frame,t)}addFrameScript(){const t=arguments.length;for(let e=0;e<t;e+=2){let t=arguments[e];l(0|t)&&(t=this._$getFrameForLabel(t)),t|=0;const i=arguments[e+1];if(i&&t&&this._$totalFrames>=t&&this._$addAction(t,i),t===this._$currentFrame){const t=B.$currentPlayer();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push.apply(t._$actions,e),t._$actionOffset=0}}}}_$getFrameForLabel(t){for(let[e,i]of this._$labels)if(i.name===t)return 0|e;return 0}_$addAction(t,e){(t|=0)&&(this._$actions.has(t)||this._$actions.set(t,B.$getArray()),this._$actions.get(t).push(e))}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e.willTrigger(O.FRAME_LABEL)&&e.dispatchEvent(new O(O.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=B.$currentPlayer();if(t){-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}}_$goToFrame(t){if(l(+t)&&(t=this._$getFrameForLabel(t)),t<1&&(t=1),t>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const e=B.$currentPlayer();switch(!0){case t!==this._$currentFrame:{this._$wait=!1;const i=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",t),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=t,this._$clearChildren(),e._$actionOffset=e._$actions.length;const r=e._$actionOffset?e._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),e._$actionOffset&&e._$actionOffset!==e._$actions.length){const t=e._$actions.splice(0,e._$actionOffset);e._$actions.push.apply(e._$actions,t),e._$actionOffset=0}if(!this._$actionProcess&&(r>-1||!e._$actionOffset))for(;e._$actions.length&&e._$actions.length!==r;){const t=e._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const i=t._$currentFrame;if(!t._$actions.has(i))continue;const r=t._$actions.get(i),s=r.length;for(let e=0;e<s;++e)try{B.$currentLoaderInfo=t._$loaderInfo,r[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=i,this._$clearChildren())}break;case!this._$actionProcess&&e._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=e._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const r=e._$actions.get(i),s=r.length;for(let t=0;t<s;++t)try{B.$currentLoaderInfo=e._$loaderInfo,r[t].apply(e)}catch(t){e.stop()}}}}B.$currentLoaderInfo=null,this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!e._$sounds.has(this._$instanceId)&&e._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$draw(t,e,i){super._$draw(t,e,i);const r=B.$currentPlayer();this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!r._$sounds.has(this._$instanceId)&&r._$sounds.set(this._$instanceId,this)}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:{t=!0,this._$canAction=!0,this._$canSound=!0;const e=this.loopConfig;if(e){const i=e.end?e.end:this._$totalFrames;switch(e.type){case dt.REPEAT:this._$changePlace?this._$currentFrame=e.start:(++this._$currentFrame,this._$currentFrame>i&&(this._$currentFrame=e.start));break;case dt.NO_REPEAT:this._$changePlace?this._$currentFrame=e.start:(++this._$currentFrame,this._$currentFrame>i&&(this._$currentFrame=i,t=!1,this._$canAction=!1,this._$canSound=!1));break;case dt.FIXED:this._$changePlace?this._$currentFrame=e.start:(t=!1,this._$canAction=!1,this._$canSound=!1);break;case dt.NO_REPEAT_REVERSAL:this._$changePlace?this._$currentFrame=ltotalFrames:(--this._$currentFrame,e.start>this._$currentFrame&&(this._$currentFrame=e.start,t=!1,this._$canAction=!1,this._$canSound=!1));break;case dt.REPEAT_REVERSAL:this._$changePlace?this._$currentFrame=i:(--this._$currentFrame,e.start>this._$currentFrame&&(this._$currentFrame=i))}}else++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1);t&&this._$clearChildren()}}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const r=e[i];r._$isNext&&(t?r._$nextFrame():t=r._$nextFrame())}return this._$setAction(),this._$isNext=t,!this._$posted&&B.$rendererWorker&&this._$postProperty(),this._$isNext}_$getLoopFrame(t){const e=this._$parent._$currentFrame-t.frame;let i=1;switch(t.type){case dt.REPEAT:{const r=t.end?t.end:this._$totalFrames;i=t.start;for(let s=0;s<e;++s)++i,i>r&&(i=t.start)}break;case dt.NO_REPEAT:{const r=t.end?t.end:this._$totalFrames;i=$.min(r,t.start+e)}break;case dt.FIXED:i=t.start;break;case dt.NO_REPEAT_REVERSAL:i=t.end?t.end:this._$totalFrames,i=$.max(t.start,i-e);break;case dt.REPEAT_REVERSAL:{const r=t.end?t.end:this._$totalFrames;i=r;for(let s=0;s<e;++s)--i,t.start>i&&(i=r)}}return i}_$buildCharacter(t){for(let e=0;e<t.sounds.length;++e){const i=t.sounds[e],r=B.$getArray();for(let t=0;t<i.sound.length;++t){const e=new kt;e._$build(i.sound[t],this),r.push(e)}this._$sounds.set(i.frame,r)}for(let e=0;e<t.actions.length;++e){const i=t.actions[e];i.script||(i.script=Function(i.action)),this._$addAction(i.frame,i.script)}for(let e=0;e<t.labels.length;++e){const i=t.labels[e];this.addFrameLabel(new st(i.name,i.frame))}this._$totalFrames=t.totalFrame||1}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$soundPlay(){const t=this._$sounds.get(this._$currentFrame);if(!t)return;const e=t.length;if(e){let i=this._$soundTransform,r=this._$parent;for(;r;)r._$soundTransform&&(i=r._$soundTransform),r=r._$parent;for(let r=0;r<e;++r){const e=t[r];i&&(e.loop=i.loop,e.volume=i.volume),e.play()}}this._$canSound=!1}}class tt{constructor(t=0,i=0){this._$width=0|t,this._$height=0|i,this._$instanceId=e++,this._$buffer=null,this._$image=null,this._$canvas=null,this._$pixelBuffer=null}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get height(){return this._$height}get image(){return this._$image}set image(t){this._$canvas=null,this._$image=t,this._$width=t.width,this._$height=t.height}get canvas(){return this._$canvas}set canvas(t){this._$image=null,this._$canvas=t,this._$width=t.width,this._$height=t.height}get width(){return this._$width}get _$texture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=B.$currentPlayer(),r=i._$cacheStore,s=r.generateKeys(this._$instanceId);let n=r.get(s);if(!n){const a=i._$context;switch(!0){case null!==this._$image:n=a.frameBuffer.createTextureFromImage(this._$image),this._$image=null;break;case null!==this._$canvas:n=a.frameBuffer.createTextureFromCanvas(this._$canvas),this._$canvas=null;break;case null!==this._$pixelBuffer:n=a.frameBuffer.createTextureFromPixels(t,e,a.pbo.getBufferSubDataAsync(this._$pixelBuffer),!0),this._$pixelBuffer=null,n._$bitmapData||(n._$bitmapData=this);break;case null!==this._$buffer:n=a.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0);break;default:{const i=a.frameBuffer.currentAttachment,r=a.frameBuffer.createCacheAttachment(t,e,!1);a._$bind(r),B.$resetContext(a),a.setTransform(1,0,0,1,0,0),a.beginPath(),a.fillRect(0,0,t,e),n=a.frameBuffer.getTextureFromCurrentAttachment(),i?a._$bind(i):a.frameBuffer.unbind(),a.frameBuffer.releaseAttachment(r,!1),n._$bitmapData||(n._$bitmapData=this)}}r.set(s,n)}return B.$poolArray(s),n}set _$texture(t){this._$setPixelQueue=null,this._$setPixelCount=0,this._$linePixelsCache=null,this._$linePixelsCacheY=null;const e=B.$currentPlayer(),i=e._$cacheStore,r=i.generateKeys(this._$instanceId),s=i.get(r);s&&(s._$bitmapData&&delete s._$bitmapData,e._$context.frameBuffer.releaseTexture(s),i.set(r,null)),this._$buffer&&(this._$buffer=null),i.set(r,t),B.$poolArray(r),t._$bitmapData||(t._$bitmapData=this)}draw(t,e=null,i=null,r=null,s=null){if(!(t instanceof q))return;const n=this._$width,a=this._$height;if(!n||!a)return;const o=B.$currentPlayer(),h=o._$width,l=o._$height;(n>h||a>l)&&(o._$width=n,o._$height=a,o._$resizeCanvas(n,a,o._$matrix[0]));const $=i?i._$colorTransform:B.$COLOR_ARRAY_IDENTITY;let _=e?e._$matrix:B.$MATRIX_ARRAY_IDENTITY,c=null;if(e&&(c=t._$transform.matrix,c.invert(),_=B.$multiplicationMatrix(_,c._$matrix),B.$poolMatrix(c)),r||(r=B.$cacheStore().getCanvas()),B.$rendererWorker){t._$stage||(t instanceof Q?B.$postContainerWorker(t):(t._$createWorkerInstance(),t._$postProperty())),r.width=n,r.height=a;const e=r.getContext("2d");e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,n,a);const i=t._$instanceId;B.$bitmapDrawMap.set(i,{source:t,context:e,callback:s});const o=B.$getArray(),h={command:"bitmapDraw",sourceId:i,width:n,height:a};1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||(h.matrix=_.slice(),o.push(h.matrix.buffer)),1===$[0]&&1===$[1]&&1===$[2]&&1===$[3]&&0===$[4]&&0===$[5]&&0===$[6]&&0===$[7]||(h.colorTransform=$.slice(),o.push(h.colorTransform.buffer)),B.$rendererWorker.postMessage(h,o),B.$poolArray(o)}else{const e=o._$context;if(!e)return;const i=e._$frameBufferManager,h=i.currentAttachment;e._$bind(o._$buffer),B.$resetContext(e),e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,o._$width,o._$height),e.beginPath(),t._$draw(e,_,$);const l=i.getTextureFromCurrentAttachment();i.unbind(),B.$resetContext(e),e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,l.width+1,l.height+1),e.drawImage(l,0,0,l.width,l.height),r.width=n,r.height=a;const c=r.getContext("2d");c.setTransform(1,0,0,1,0,0),c.clearRect(0,0,n,a),c.drawImage(o._$canvas,0,0),h&&e._$bind(h),s&&s(r)}e&&B.$poolMatrix(e),i&&B.$poolColorTransform(i)}_$getPixelsAsync(t,e,i,r,s="RGBA"){t=Math.max(t,0),e=Math.max(e,0);const n=$.min(i,this.width-t),a=$.min(r,this.height-e);if(n<=0||a<=0)return;const o=B.$currentPlayer()._$context;if(!o)return;const h=o._$shaderList._$bitmapData.getPixels[s].instance;o._$shaderList.bitmapShaderVariants.setGetPixelsUniform(h.uniform,n/this.width,-a/this.height,t/this.width,1-e/this.height);const l=o.frameBuffer.currentAttachment,_=o.frameBuffer.createCacheAttachment(n,a,!1);o._$bind(_),o._$frameBufferManager._$textureManager.bind0(this._$texture,!1),o.blend.disable(),h._$drawImage(),o.blend.enable(),this._$pixelBuffer=o.pbo.readPixelsAsync(0,0,this.width,this.height),l?o._$bind(l):o.frameBuffer.unbind(),o.frameBuffer.releaseAttachment(_)}_$getPixels(t,e,i,r,s="ARGB",n=null){switch(s){case"ARGB":case"RGBA":case"BGRA":break;default:throw new Error(`Unsupported byteOrder: ${s}`)}t=Math.max(t,0),e=Math.max(e,0);const a=$.min(i,this.width-t),o=$.min(r,this.height-e);if(a<=0||o<=0)return new Uint8Array(0);const h=n?n(a*o*4):new Uint8Array(a*o*4),l=B.$currentPlayer()._$context;if(!l)return h;const _=l._$shaderList._$bitmapData.getPixels[s].instance;l._$shaderList.bitmapShaderVariants.setGetPixelsUniform(_.uniform,a/this.width,-o/this.height,t/this.width,1-e/this.height);const c=l.frameBuffer.currentAttachment,u=l.frameBuffer.createCacheAttachment(a,o,!1);l._$bind(u),l._$frameBufferManager._$textureManager.bind0(this._$texture,!1),l.blend.disable(),_._$drawImage(),l.blend.enable();const d=l._$gl;return d.readPixels(0,0,a,o,d.RGBA,d.UNSIGNED_BYTE,h),c?l._$bind(c):l.frameBuffer.unbind(),l.frameBuffer.releaseAttachment(u),h}}class et{static toString(){return"[class BitmapDataChannel]"}static get namespace(){return"next2d.display.BitmapDataChannel"}toString(){return"[object BitmapDataChannel]"}get namespace(){return"next2d.display.BitmapDataChannel"}static get ALPHA(){return 8}static get BLUE(){return 4}static get GREEN(){return 2}static get RED(){return 1}}class it{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}}class rt{static toString(){return"[class CapsStyle]"}static get namespace(){return"next2d.display.CapsStyle"}toString(){return"[object CapsStyle]"}get namespace(){return"next2d.display.CapsStyle"}static get NONE(){return"none"}static get ROUND(){return"round"}static get SQUARE(){return"square"}}class st extends L{constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class nt{static toString(){return"[class GradientType]"}static get namespace(){return"next2d.display.GradientType"}toString(){return"[object GradientType]"}get namespace(){return"next2d.display.GradientType"}static get LINEAR(){return"linear"}static get RADIAL(){return"radial"}}class at{constructor(t=null){this._$displayObject=t,this.clear()}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}static get BITMAP_STROKE(){return 14}beginBitmapFill(t,e=null,i=!0,r=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=B.$getArray()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$fills.push(at.BEGIN_PATH),this._$fillType=at.BITMAP_FILL,this._$fillBitmap=new ot(t,e,i,r),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=B.$getArray()),t=B.$clamp(B.$toColorInt(t),0,16777215,0),e=B.$clamp(e,0,1,1),this._$maxAlpha=$.max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$fills.push(at.BEGIN_PATH);const i=B.$intToRGBA(t,e);return this._$fillType=at.FILL_STYLE,this._$fillStyleR=i.R,this._$fillStyleG=i.G,this._$fillStyleB=i.B,this._$fillStyleA=i.A,this}beginGradientFill(t,e,i,r,s=null,n=pt.PAD,a=lt.RGB,o=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=B.$getArray());const h=i.length;for(let t=0;t<h;++t)this._$maxAlpha=$.max(this._$maxAlpha,i[t]);return this._$doFill=!0,this._$canDraw=!0,this._$fills.push(at.BEGIN_PATH),this._$fillType=at.GRADIENT_FILL,this._$fillGradient=new ht(t,e,i,r,s,n,a,o),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=0,this._$caps=rt.NONE,this._$joints=$t.ROUND,this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=c.MAX_VALUE,this._$xMax=-c.MAX_VALUE,this._$yMin=c.MAX_VALUE,this._$yMax=-c.MAX_VALUE,this._$recode&&B.$poolArray(this._$recode),this._$fills&&B.$poolArray(this._$fills),this._$lines&&B.$poolArray(this._$lines),this._$buffer=null,this._$recode=null,this._$fills=null,this._$lines=null,this._$restart(),this}clone(){const t=new at;return t.copyFrom(this),t}copyFrom(t){t instanceof at&&(t._$fillGradient&&(this._$fillGradient=t._$fillGradient.clone()),t._$fillBitmap&&(this._$fillBitmap=t._$fillBitmap.clone()),this._$doFill=t._$doFill,this._$fillType=t._$fillType,this._$fillStyleR=t._$fillStyleR,this._$fillStyleG=t._$fillStyleG,this._$fillStyleB=t._$fillStyleB,this._$fillStyleA=t._$fillStyleA,t._$lineGradient&&(this._$lineGradient=t._$lineGradient.clone()),this._$doLine=t._$doLine,this._$lineType=t._$lineType,this._$caps=t._$caps,this._$joints=t._$joints,this._$miterLimit=t._$miterLimit,this._$lineWidth=t._$lineWidth,this._$lineStyleR=t._$lineStyleR,this._$lineStyleG=t._$lineStyleG,this._$lineStyleB=t._$lineStyleB,this._$lineStyleA=t._$lineStyleA,this._$xMin=t._$xMin,this._$xMax=t._$xMax,this._$yMin=t._$yMin,this._$yMax=t._$yMax,this._$maxAlpha=t._$maxAlpha,this._$pointerX=t._$pointerX,this._$pointerY=t._$pointerY,this._$canDraw=t._$canDraw,t._$fills&&(this._$fills=t._$fills.slice(0)),t._$lines&&(this._$lines=t._$lines.slice(0)),t._$recode&&(this._$recode=t._$recode.slice(0)))}cubicCurveTo(t,e,i,r,s,n){return s=+s||0,n=+n||0,this._$pointerX===s&&this._$pointerY===n||(t=+t||0,e=+e||0,i=+i||0,r=+r||0,this._$setBounds(t,e),this._$setBounds(i,r),this._$setBounds(s,n),this._$margePath(B.$getArray(at.CUBIC,t,e,i,r,s,n)),this._$pointerX=s,this._$pointerY=n,this._$restart()),this}curveTo(t,e,i,r){return i=+i||0,r=+r||0,this._$pointerX===i&&this._$pointerY===r||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,r),this._$margePath(B.$getArray(at.CURVE_TO,t,e,i,r)),this._$pointerX=i,this._$pointerY=r,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(B.$getArray(at.MOVE_TO,t+i,e,at.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,i,r){const s=(i=+i||0)/2,n=(r=+r||0)/2,a=(t=+t||0)+s,o=(e=+e||0)+n,h=t+i,l=e+r,_=4/3*($.SQRT2-1),c=_*s,u=_*n;return this.moveTo(a,e).cubicCurveTo(a+c,e,h,o-u,h,o).cubicCurveTo(h,o+u,a+c,l,a,l).cubicCurveTo(a-c,l,t,o+u,t,o).cubicCurveTo(t,o-u,a-c,e,a,e)}drawRect(t,e,i,r){const s=(t=+t||0)+(i=+i||0),n=(e=+e||0)+(r=+r||0);return this.moveTo(t,e).lineTo(t,n).lineTo(s,n).lineTo(s,e).lineTo(t,e)}drawRoundRect(t,e,i,r,s,n=NaN){t=+t||0,e=+e||0,i=+i||0,r=+r||0;const a=(s=+s||0)/2,o=(n=+n||s)/2,h=4/3*($.SQRT2-1),l=h*a,_=h*o,c=t+a,u=t+i,d=u-a,g=e+o,p=e+r,f=p-o;return this.moveTo(c,e).lineTo(d,e).cubicCurveTo(d+l,e,u,g-_,u,g).lineTo(u,f).cubicCurveTo(u,f+_,d+l,p,d,p).lineTo(c,p).cubicCurveTo(c-l,p,t,f+_,t,f).lineTo(t,g).cubicCurveTo(t,g-_,c-l,e,c,e)}endFill(){if(this._$doFill&&this._$fills.length>7)switch(this._$recode||(this._$recode=B.$getArray()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(at.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push.apply(this._$recode,this._$fills),this._$fillType){case at.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,at.END_FILL);break;case at.GRADIENT_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillGradient.toArray());break;case at.BITMAP_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$fills&&(B.$poolArray(this._$fills),this._$fills=null),this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine)switch(this._$recode||(this._$recode=B.$getArray()),this._$recode.push.apply(this._$recode,this._$lines),B.$poolArray(this._$lines),this._$lines=null,this._$lineType){case at.STROKE_STYLE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,at.END_STROKE);break;case at.GRADIENT_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$lineGradient.toArray());break;case at.BITMAP_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$lineType=0,this._$lineWidth=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps=rt.NONE,this._$joints=$t.ROUND,this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineBitmapStyle(t,e=null,i=!0,r=!1){return this._$doLine&&this.endLine(),this._$lines||(this._$lines=B.$getArray()),this._$maxAlpha=1,this._$doLine=!0,this._$canDraw=!0,this._$lines.push(at.BEGIN_PATH),this._$lineType=at.BITMAP_STROKE,this._$fillBitmap=new ot(t,e,i,r),this}lineGradientStyle(t,e,i,r,s=null,n=pt.PAD,a=lt.RGB,o=0){if(!this._$doLine)return this;this._$lines||(this._$lines=B.$getArray());const h=i.length;for(let t=0;t<h;++t)this._$maxAlpha=$.max(this._$maxAlpha,i[t]);return this._$lines.push(at.BEGIN_PATH),this._$lineType=at.GRADIENT_STROKE,this._$lineGradient=new ht(t,e,i,r,s,n,a,o),this}lineStyle(t=1,e=0,i=1,r=rt.ROUND,s=$t.ROUND,n=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=B.$getArray()),e=B.$clamp(B.$toColorInt(e),0,16777215,0),i=B.$clamp(+i,0,1,1),this._$maxAlpha=$.max(this._$maxAlpha,i),this._$doLine=!0,this._$canDraw=!0,this._$pointerX||this._$pointerY?this._$lines.push(at.BEGIN_PATH,at.MOVE_TO,this._$pointerX,this._$pointerY):this._$lines.push(at.BEGIN_PATH);const a=B.$intToRGBA(e,i);return this._$lineType=at.STROKE_STYLE,this._$lineStyleR=a.R,this._$lineStyleG=a.G,this._$lineStyleB=a.B,this._$lineStyleA=a.A,this._$lineWidth=t,this._$caps=`${r}`,this._$joints=`${s}`,this._$joints===$t.MITER&&(this._$miterLimit=n),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(B.$getArray(at.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e);let i=!1;if(this._$doFill){this._$fills[this._$fills.length-3]===at.MOVE_TO&&(i=!0,this._$fills[this._$fills.length-2]=t,this._$fills[this._$fills.length-1]=e)}if(this._$doLine){this._$lines[this._$lines.length-3]===at.MOVE_TO&&(i=!0,this._$lines[this._$lines.length-2]=t,this._$lines[this._$lines.length-1]=e)}return i||this._$margePath(B.$getArray(at.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,e){const i=this._$getBounds(),r=B.$boundsMatrix(i,e);let s=$.ceil($.abs(r.xMax-r.xMin)),n=$.ceil($.abs(r.yMax-r.yMin));switch(B.$poolBoundsObject(i),B.$poolBoundsObject(r),!0){case 0===s:case 0===n:case s===-F:case n===-F:case s===F:case n===F:return}B.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$doDraw(t,null,!0),t.clip()}_$draw(t,e,i,r=it.NORMAL,s=null){if(!this._$maxAlpha)return;const n=B.$clamp(i[3]+i[7]/255,0,1),a=this._$displayObject;let o=null!==a._$scale9Grid;const h=a._$transform._$rawMatrix();o&&(o=o&&$.abs(h[1])<.001&&$.abs(h[2])<1e-4);const l=this._$getBounds(),_=B.$boundsMatrix(l,e),u=_.xMax,d=_.xMin,g=_.yMax,p=_.yMin;B.$poolBoundsObject(_);const f=$.ceil($.abs(u-d)),m=$.ceil($.abs(g-p));switch(!0){case 0===f:case 0===m:case f===-F:case m===-F:case f===F:case m===F:return}const x=t._$frameBufferManager,b=x.currentAttachment;if(d>b.width||p>b.height)return;let T=+$.sqrt(e[0]*e[0]+e[1]*e[1]);if(!c.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}let v=+$.sqrt(e[2]*e[2]+e[3]*e[3]);if(!c.isInteger(v)){const t=v.toString(),e=t.indexOf("e");-1!==e&&(v=+t.slice(0,e)),v=+v.toFixed(4)}if(0>d+f||0>p+m){if(!(s&&s.length&&a._$canApply(s)))return;{let t=new j(0,0,f,m);for(let e=0;e<s.length;++e)t=s[e]._$generateFilterRect(t,T,v);if(0>t.x+t.width||0>t.y+t.height)return}}const y=B.$getArray(T,v);let A=a._$instanceId;!o&&a._$loaderInfo&&a._$characterId&&(A=`${a._$loaderInfo._$id}@${a._$characterId}`);const M=B.$cacheStore(),E=M.generateKeys(A,y,i);B.$poolArray(y);let C=M.get(E);if(!C){const r=x.currentAttachment;let s=$.ceil($.abs(l.xMax-l.xMin)*T),n=$.ceil($.abs(l.yMax-l.yMin)*v);const _=t._$getTextureScale(s,n);_<1&&(s*=_,n*=_);const c=x.createCacheAttachment(s,n,!0);if(t._$bind(c),B.$resetContext(t),t.setTransform(T,0,0,v,-l.xMin*T,-l.yMin*v),o){const i=B.$currentPlayer(),r=i._$scale*i._$ratio,s=B.$getFloat32Array6(r,0,0,r,0,0),n=B.$multiplicationMatrix(s,h);B.$poolFloat32Array6(s);const o=a._$parent._$transform.concatenatedMatrix._$matrix;B.$poolFloat32Array6(o);const _=B.$getFloat32Array6(o[0],o[1],o[2],o[3],o[4]*r-d,o[5]*r-p),c=B.$multiplicationMatrix(_,n),u=c[4]-(e[4]-d),g=c[5]-(e[5]-p);B.$poolFloat32Array6(c);const f=B.$boundsMatrix(l,n),m=+f.xMax,x=+f.xMin,b=+f.yMax,T=+f.yMin,v=$.ceil($.abs(m-x)),y=$.ceil($.abs(b-T));B.$poolBoundsObject(f),t.grid.enable(x,T,v,y,l,a._$scale9Grid,r,n[0],n[1],n[2],n[3],n[4],n[5],_[0],_[1],_[2],_[3],_[4]-u,_[5]-g),B.$poolFloat32Array6(n),B.$poolFloat32Array6(_)}i[3]=1,this._$doDraw(t,i,!1),o&&t.grid.disable(),C=x.getTextureFromCurrentAttachment(),B.$useCache&&M.set(E,C),x.releaseAttachment(c,!1),t._$bind(r)}let S=!1,R=0,w=0;s&&s.length&&a._$canApply(s)&&(S=!0,C=a._$drawFilter(t,C,e,s,f,m),R=C._$offsetX,w=C._$offsetY);const I=$.atan2(e[1],e[0]),U=$.atan2(-e[2],e[3]);if(S||!I&&!U)t.setTransform(1,0,0,1,d-R,p-w);else{const i=l.xMin*T,r=l.yMin*v,s=$.cos(I),n=$.sin(I),a=$.cos(U),o=$.sin(U);t.setTransform(s,n,-o,a,i*s-r*o+e[4],i*n+r*a+e[5])}B.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=r,t.drawImage(C,0,0,C.width,C.height,i),B.$poolArray(E),B.$poolBoundsObject(l)}_$doDraw(t,e,i=!1){B.$resetContext(t),t.beginPath(),this._$runCommand(t,e,i)}_$hit(t,e,i,r=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,r,i)}_$getBounds(){const t=this._$displayObject;return t&&t._$bounds?B.$getBoundsObject(t._$bounds.xMin,t._$bounds.xMax,t._$bounds.yMin,t._$bounds.yMax):B.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){this._$displayObject&&(this._$displayObject._$posted=!1,this._$buffer=null,this._$displayObject._$isUpdated()||(this._$displayObject._$doChanged(),B.$isUpdated=!0,B.$cacheStore().removeCache(this._$displayObject._$instanceId),this._$displayObject._$characterId&&B.$cacheStore().removeCache(this._$displayObject._$characterId)))}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t,e){this._$xMin=$.min(this._$xMin,t),this._$xMax=$.max(this._$xMax,t),this._$yMin=$.min(this._$yMin,e),this._$yMax=$.max(this._$yMax,e)}_$setLineBounds(t,e){this._$xMin=$.min(this._$xMin,$.min(t,this._$pointerX)),this._$xMax=$.max(this._$xMax,$.max(t,this._$pointerX)),this._$yMin=$.min(this._$yMin,$.min(e,this._$pointerY)),this._$yMax=$.max(this._$yMax,$.max(e,this._$pointerY));const i=this._$lineWidth/2,r=.5*$.PI,s=$.atan2(e-this._$pointerY,t-this._$pointerX),n=$.atan2(this._$pointerY-e,this._$pointerX-t),a=s+r,o=s-r,h=n+r,l=n-r;let _=t+i,c=-i+t,u=this._$pointerX+i,d=-i+this._$pointerX,g=e+i,p=-i+e,f=this._$pointerY+i,m=-i+this._$pointerY;switch(this._$xMin=$.min(this._$xMin,$.min(_,$.min(c,$.min(u,d)))),this._$xMax=$.max(this._$xMax,$.max(_,$.max(c,$.max(u,d)))),this._$yMin=$.min(this._$yMin,$.min(g,$.min(p,$.min(f,m)))),this._$yMax=$.max(this._$yMax,$.max(g,$.max(p,$.max(f,m)))),$.abs(a)%r!=0&&(_=t+$.cos(a)*i),$.abs(o)%r!=0&&(c=t+$.cos(o)*i),$.abs(h)%r!=0&&(u=this._$pointerX+$.cos(h)*i),$.abs(l)%r!=0&&(d=this._$pointerX+$.cos(l)*i),a&&$.abs(a)%$.PI!=0&&(g=e+$.sin(a)*i),o&&$.abs(o)%$.PI!=0&&(p=e+$.sin(o)*i),h&&$.abs(h)%$.PI!=0&&(f=this._$pointerY+$.sin(h)*i),l&&$.abs(l)%$.PI!=0&&(m=this._$pointerY+$.sin(l)*i),this._$xMin=$.min(this._$xMin,$.min(_,$.min(c,$.min(u,d)))),this._$xMax=$.max(this._$xMax,$.max(_,$.max(c,$.max(u,d)))),this._$yMin=$.min(this._$yMin,$.min(g,$.min(p,$.min(f,m)))),this._$yMax=$.max(this._$yMax,$.max(g,$.max(p,$.max(f,m)))),this._$caps){case rt.ROUND:if($.abs(s)%r!=0){const e=t+$.cos(s)*i;this._$xMin=$.min(this._$xMin,e),this._$xMax=$.max(this._$xMax,e)}if(s&&$.abs(s)%$.PI!=0){const t=e+$.sin(s)*i;this._$yMin=$.min(this._$yMin,t),this._$yMax=$.max(this._$yMax,t)}if($.abs(n)%r!=0){const t=this._$pointerX+$.cos(n)*i;this._$xMin=$.min(this._$xMin,t),this._$xMax=$.max(this._$xMax,t)}if(n&&$.abs(n)%$.PI!=0){const t=this._$pointerY+$.sin(n)*i;this._$yMin=$.min(this._$yMin,t),this._$yMax=$.max(this._$yMax,t)}break;case rt.SQUARE:if($.abs(s)%r!=0){const t=$.cos(s)*i,e=_+t,r=c+t;this._$xMin=$.min(this._$xMin,$.min(e,r)),this._$xMax=$.max(this._$xMax,$.max(e,r))}if($.abs(n)%r!=0){const t=$.cos(n)*i,e=u+t,r=d+t;this._$xMin=$.min(this._$xMin,$.min(e,r)),this._$xMax=$.max(this._$xMax,$.max(e,r))}if(s&&$.abs(s)%$.PI!=0){const t=$.sin(s)*i,e=g+t,r=p+t;this._$yMin=$.min(this._$yMin,$.min(e,r)),this._$yMax=$.max(this._$yMax,$.max(e,r))}if(n&&$.abs(n)%$.PI!=0){const t=$.sin(n)*i,e=f+t,r=m+t;this._$yMin=$.min(this._$yMin,$.min(e,r)),this._$yMax=$.max(this._$yMax,$.max(e,r))}}}_$margePath(t){this._$doFill&&this._$fills.push.apply(this._$fills,t),this._$doLine&&this._$lines.push.apply(this._$lines,t),B.$poolArray(t)}_$getRecodes(){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),this._$recode||(this._$recode=B.$getArray()),!this._$buffer){const t=B.$getArray(),e=this._$recode;for(let i=0;i<e.length;){const r=e[i++];switch(t.push(r),r){case at.BEGIN_PATH:case at.END_FILL:case at.END_STROKE:case at.CLOSE_PATH:break;case at.MOVE_TO:case at.LINE_TO:t.push(e[i++],e[i++]);break;case at.CURVE_TO:case at.FILL_STYLE:t.push(e[i++],e[i++],e[i++],e[i++]);break;case at.CUBIC:t.push(e[i++],e[i++],e[i++],e[i++],e[i++],e[i++]);break;case at.STROKE_STYLE:t.push(e[i++]);switch(e[i++]){case rt.NONE:t.push(0);break;case rt.ROUND:t.push(1);break;case rt.SQUARE:t.push(2)}switch(e[i++]){case $t.BEVEL:t.push(0);break;case $t.MITER:t.push(1);break;case $t.ROUND:t.push(2)}t.push(e[i++],e[i++],e[i++],e[i++],e[i++]);break;case at.ARC:t.push(e[i++],e[i++],e[i++]);break;case at.GRADIENT_FILL:{const r=e[i++],s=e[i++],n=e[i++],a=e[i++],o=e[i++],h=e[i++];t.push(r===nt.LINEAR?0:1),t.push(s.length);for(let e=0;e<s.length;++e){const i=s[e];t.push(i.ratio,i.R,i.G,i.B,i.A)}switch(t.push(n[0],n[1],n[2],n[3],n[4],n[5]),a){case pt.REFLECT:t.push(0);break;case pt.REPEAT:t.push(1);break;default:t.push(2)}t.push(o===lt.LINEAR_RGB?0:1),t.push(h)}break;case at.GRADIENT_STROKE:{t.push(e[i++]);switch(e[i++]){case rt.NONE:t.push(0);break;case rt.ROUND:t.push(1);break;case rt.SQUARE:t.push(2)}switch(e[i++]){case $t.BEVEL:t.push(0);break;case $t.MITER:t.push(1);break;case $t.ROUND:t.push(2)}t.push(e[i++]);const r=e[i++],s=e[i++],n=e[i++],a=e[i++],o=e[i++],h=e[i++];t.push(r===nt.LINEAR?0:1),t.push(s.length);for(let e=0;e<s.length;++e){const i=s[e];t.push(i.ratio,i.R,i.G,i.B,i.A)}switch(t.push(n[0],n[1],n[2],n[3],n[4],n[5]),a){case pt.REFLECT:t.push(0);break;case pt.REPEAT:t.push(1);break;default:t.push(2)}t.push(o===lt.LINEAR_RGB?0:1),t.push(h)}break;case at.BITMAP_FILL:{const r=e[i++];let s=null;switch(!0){case null!==r._$image:{const t=B.$cacheStore(),e=t.getCanvas(),i=r.width,n=r.height;e.width=i,e.height=n;const a=e.getContext("2d");a.drawImage(r._$image,0,0),s=new C(a.getImageData(0,0,i,n).data),t.destroy(e)}break;case null!==r._$canvas:{const t=B.$cacheStore(),e=t.getCanvas(),i=r.width,n=r.height;e.width=i,e.height=n;const a=e.getContext("2d");a.drawImage(r._$canvas,0,0),s=new C(a.getImageData(0,0,i,n).data),t.destroy(e)}break;case null!==r._$buffer:s=r._$buffer}t.push(r.width),t.push(r.height),t.push(this._$xMax-this._$xMin),t.push(this._$yMax-this._$yMin),t.push(s.length);for(let e=0;e<s.length;++e)t.push(s[e]);const n=e[i++];n?t.push(n[0],n[1],n[2],n[3],n[4],n[5]):t.push(1,0,0,1,0,0);const a=e[i++];t.push("repeat"===a?1:0);const o=e[i++];t.push(o?1:0)}break;case at.BITMAP_STROKE:{t.push(e[i++]);switch(e[i++]){case rt.NONE:t.push(0);break;case rt.ROUND:t.push(1);break;case rt.SQUARE:t.push(2)}switch(e[i++]){case $t.BEVEL:t.push(0);break;case $t.MITER:t.push(1);break;case $t.ROUND:t.push(2)}t.push(e[i++]);const r=e[i++];let s=null;switch(!0){case null!==r._$image:case null!==r._$canvas:break;case null!==r._$buffer:s=r._$buffer}t.push(r.width),t.push(r.height),t.push(s.length);for(let e=0;e<s.length;++e)t.push(s[e]);const n=e[i++];n?t.push(n[0],n[1],n[2],n[3],n[4],n[5]):t.push(1,0,0,1,0,0);const a=e[i++];t.push("repeat"===a?1:0);const o=e[i++];t.push(o?1:0)}}}this._$buffer=new S(t)}return this._$buffer.slice()}_$runTransformCommand(t,e,i=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return;let r=Number.MAX_VALUE,s=-Number.MAX_VALUE,n=Number.MAX_VALUE,a=-Number.MAX_VALUE;const o=this._$recode,h=o.length;for(let l=0;l<h;)switch(o[l++]){case at.BEGIN_PATH:t.beginPath();break;case at.MOVE_TO:{const i=o[l++],h=o[l++],_=i*e[0]+h*e[2],c=i*e[1]+h*e[3];r=$.min(_,r),s=$.max(_,s),n=$.min(c,n),a=$.max(c,a),t.moveTo(_,c)}break;case at.LINE_TO:{const i=o[l++],h=o[l++],_=i*e[0]+h*e[2],c=i*e[1]+h*e[3];r=$.min(_,r),s=$.max(_,s),n=$.min(c,n),a=$.max(c,a),t.lineTo(_,c)}break;case at.CURVE_TO:{const i=o[l++],h=o[l++],_=o[l++],c=o[l++],u=i*e[0]+h*e[2],d=i*e[1]+h*e[3],g=_*e[0]+c*e[2],p=_*e[1]+c*e[3];r=$.min(u,r),s=$.max(u,s),n=$.min(d,n),a=$.max(d,a),r=$.min(g,r),s=$.max(g,s),n=$.min(p,n),a=$.max(p,a),t.quadraticCurveTo(u,d,g,p)}break;case at.CLOSE_PATH:t.closePath();break;case at.CUBIC:{const i=o[l++],h=o[l++],_=o[l++],c=o[l++],u=o[l++],d=o[l++],g=i*e[0]+h*e[2],p=i*e[1]+h*e[3],f=_*e[0]+c*e[2],m=_*e[1]+c*e[3],x=u*e[0]+d*e[2],b=u*e[1]+d*e[3];r=$.min(g,r),s=$.max(g,s),n=$.min(p,n),a=$.max(p,a),r=$.min(f,r),s=$.max(f,s),n=$.min(m,n),a=$.max(m,a),r=$.min(x,r),s=$.max(x,s),n=$.min(b,n),a=$.max(b,a),t.bezierCurveTo(g,p,f,m,x,b)}break;case at.ARC:{const i=o[l++],h=o[l++],_=o[l++],c=i*e[0]+h*e[2],u=i*e[1]+h*e[3];r=$.min(c,r),s=$.max(c,s),n=$.min(u,n),a=$.max(u,a),t.arc(c,u,_,0,2*$.PI)}break;case at.BITMAP_FILL:{t._$matrix[6]-=r*t._$matrix[0]+n*t._$matrix[3],t._$matrix[7]-=r*t._$matrix[1]+n*t._$matrix[4],t.save();const e=o[l++],s=o[l++],a=o[l++],h=o[l++];t.fillStyle=t.createPattern(e._$texture,a,i),s&&t.transform(s[0],s[1],s[2],s[3],s[4],s[5]),t._$imageSmoothingEnabled=h,t.fill(),t.restore(),t._$imageSmoothingEnabled=!1}}}_$runCommand(t,e=null,i=!1,r=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;const s=this._$recode,n=s.length;for(let a=0;a<n;)switch(s[a++]){case at.BEGIN_PATH:t.beginPath();break;case at.MOVE_TO:t.moveTo(s[a++],s[a++]);break;case at.LINE_TO:t.lineTo(s[a++],s[a++]);break;case at.CURVE_TO:t.quadraticCurveTo(s[a++],s[a++],s[a++],s[a++]);break;case at.FILL_STYLE:{if(i||r){a+=4;continue}const n=t._$contextStyle;n._$fillStyle[0]=s[a++]/255,n._$fillStyle[1]=s[a++]/255,n._$fillStyle[2]=s[a++]/255,n._$fillStyle[3]=1!==e[3]||0!==e[7]?$.max(0,$.min(s[a++]*e[3]+e[7],255))/255:s[a++]/255,t._$style=n}break;case at.END_FILL:if(r&&t.isPointInPath(r.x,r.y))return!0;i||r||t.fill();break;case at.STROKE_STYLE:{if(i||r){a+=8;continue}t.lineWidth=s[a++],t.lineCap=s[a++],t.lineJoin=s[a++],t.miterLimit=s[a++];const n=t._$contextStyle;n._$strokeStyle[0]=s[a++]/255,n._$strokeStyle[1]=s[a++]/255,n._$strokeStyle[2]=s[a++]/255,n._$strokeStyle[3]=1!==e[3]||0!==e[7]?$.max(0,$.min(s[a++]*e[3]+e[7],255))/255:s[a++]/255,t._$style=n}break;case at.END_STROKE:if(r&&t.isPointInStroke(r.x,r.y))return!0;i||r||t.stroke();break;case at.CLOSE_PATH:t.closePath();break;case at.CUBIC:t.bezierCurveTo(s[a++],s[a++],s[a++],s[a++],s[a++],s[a++]);break;case at.ARC:t.arc(s[a++],s[a++],s[a++],0,2*$.PI);break;case at.GRADIENT_FILL:{if(r&&t.isPointInPath(r.x,r.y))return!0;if(i||r){a+=6;continue}const n=s[a++],o=s[a++],h=s[a++],l=s[a++],_=s[a++],c=s[a++];let u=null;if(n===nt.LINEAR){const e=B.$linearGradientXY(h);u=t.createLinearGradient(e[0],e[1],e[2],e[3],_,l)}else t.save(),t.transform(h[0],h[1],h[2],h[3],h[4],h[5]),u=t.createRadialGradient(0,0,0,0,0,819.2,_,l,c);const d=o.length;for(let t=0;t<d;++t){const i=o[t];e?u.addColorStop(i.ratio,B.$getFloat32Array4(0|$.max(0,$.min(i.R*e[0]+e[4],255)),0|$.max(0,$.min(i.G*e[1]+e[5],255)),0|$.max(0,$.min(i.B*e[2]+e[6],255)),0|$.max(0,$.min(i.A*e[3]+e[7],255)))):u.addColorStop(i.ratio,B.$getFloat32Array4(i.R,i.G,i.B,i.A))}t.fillStyle=u,t.fill(),n===nt.RADIAL&&t.restore()}break;case at.GRADIENT_STROKE:{if(r&&t.isPointInStroke(r.x,r.y))return!0;if(i||r){a+=12;continue}t.lineWidth=s[a++],t.lineCap=s[a++],t.lineJoin=s[a++],t.miterLimit=s[a++];const n=s[a++],o=s[a++],h=s[a++],l=s[a++],_=s[a++],c=s[a++];let u=null;if(n===nt.LINEAR){const e=B.$linearGradientXY(h);u=t.createLinearGradient(e[0],e[1],e[2],e[3],_,l)}else t.save(),t.transform(h[0],h[1],h[2],h[3],h[4],h[5]),u=t.createRadialGradient(0,0,0,0,0,819.2,_,l,c);const d=o.length;for(let t=0;t<d;++t){const i=o[t];e?u.addColorStop(i.ratio,B.$getFloat32Array4(0|$.max(0,$.min(i.R*e[0]+e[4],255)),0|$.max(0,$.min(i.G*e[1]+e[5],255)),0|$.max(0,$.min(i.B*e[2]+e[6],255)),0|$.max(0,$.min(i.A*e[3]+e[7],255)))):u.addColorStop(i.ratio,B.$getFloat32Array4(i.R,i.G,i.B,i.A))}t.strokeStyle=u,t.stroke(),n===nt.RADIAL&&t.restore()}break;case at.BITMAP_FILL:{if(r&&t.isPointInPath(r.x,r.y))return!0;if(i||r){a+=6;continue}t.save();const n=s[a++],o=s[a++],h=s[a++],l=s[a++];o&&t.transform(o[0],o[1],o[2],o[3],o[4],o[5]),"no-repeat"===h&&n.width===this._$xMax-this._$xMin&&n.height===this._$yMax-this._$yMin?t.drawImage(n._$texture,0,0,n.width,n.height):(t.fillStyle=t.createPattern(n._$texture,h,e),t._$imageSmoothingEnabled=l,t.fill()),t.restore(),t._$imageSmoothingEnabled=!1}break;case at.BITMAP_STROKE:{if(r&&t.isPointInStroke(r.x,r.y))return!0;if(i||r){a+=9;continue}t.save(),t.lineWidth=s[a++],t.lineCap=s[a++],t.lineJoin=s[a++],t.miterLimit=s[a++];const n=s[a++],o=s[a++],h=s[a++],l=s[a++];o&&t.transform(o[0],o[1],o[2],o[3],o[4],o[5]),t.strokeStyle=t.createPattern(n._$texture,h,e),t._$imageSmoothingEnabled=l,t.stroke(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}}class ot{constructor(t,e=null,i=!0,r=!1){this._$bitmapData=t,this._$matrix=e,this._$repeat=!!i,this._$smooth=!!r}clone(){return new ot(this._$bitmapData.clone(),this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){return B.$getArray(this._$bitmapData,this._$matrix,this._$repeat?"repeat":"no-repeat",this._$smooth)}}class ht{constructor(t=nt.LINEAR,e=null,i=null,r=null,s=null,n=pt.PAD,a=lt.RGB,o=0){if(this._$type=nt.RADIAL===t?t:nt.LINEAR,this._$colors=_.isArray(e)?this._$toColorInt(e):null,this._$alphas=_.isArray(i)?this._$toColorInt(i):null,this._$ratios=null,_.isArray(r)){for(let t=0;t<r.length;++t)r[t]=B.$clamp(r[t],0,255,0);this._$ratios=r}switch(this._$matrix=s,n){case pt.REFLECT:case pt.REPEAT:this._$spreadMethod=n;break;default:this._$spreadMethod=pt.PAD}this._$interpolationMethod=a===lt.LINEAR_RGB?a:lt.RGB,this._$focalPointRatio=+o||0,this._$colorStops=null}get colorStops(){if(!this._$colorStops){this._$colorStops=B.$getArray();const t=$.min($.min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=B.$intToRGBA(this._$colors[e],this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:t.R,G:t.G,B:t.B,A:t.A}}}return this._$colorStops}_$toColorInt(t){const e=t.length;for(let i=0;i<e;++i)t[i]=B.$clamp(B.$toColorInt(t[i]),0,16777215,16777215);return t}toArray(){return B.$getArray(this._$type,this.colorStops,this._$matrix?this._$matrix._$matrix:B.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}clone(){return new ht(this._$type,this._$colors.slice(),this._$alphas.slice(),this._$ratios.slice(),this._$matrix?this._$matrix.clone():null,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class lt{static toString(){return"[class InterpolationMethod]"}static get namespace(){return"next2d.display.InterpolationMethod"}toString(){return"[object InterpolationMethod]"}get namespace(){return"next2d.display.InterpolationMethod"}static get LINEAR_RGB(){return"linearRGB"}static get RGB(){return"rgb"}}class $t{static toString(){return"[class JointStyle]"}static get namespace(){return"next2d.display.JointStyle"}toString(){return"[object JointStyle]"}get namespace(){return"next2d.display.JointStyle"}static get BEVEL(){return"bevel"}static get MITER(){return"miter"}static get ROUND(){return"round"}}class _t extends Q{constructor(){super(),this._$loaderInfo=new ct}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo._$content}get contentLoaderInfo(){return this._$loaderInfo}load(t){if(!(t&&t instanceof Xt))return;const e=this.contentLoaderInfo;switch(t.responseDataFormat){case Ht.JSON:case Ht.ARRAY_BUFFER:break;default:return void(e.willTrigger(D.IO_ERROR)&&e.dispatchEvent(new D(D.IO_ERROR,!1,!1,"data format is json or arrayBuffer only.")))}e._$url=t.url,e._$format=t.responseDataFormat,B.$ajax({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(O.OPEN)&&e.dispatchEvent(new O(O.OPEN)),e.willTrigger(V.PROGRESS)&&e.dispatchEvent(new V(V.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(V.PROGRESS)&&e.dispatchEvent(new V(V.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(V.PROGRESS)&&e.dispatchEvent(new V(V.PROGRESS,!1,!1,t.loaded,t.total));const i=B.$getArray(),r=B.$headerToArray(t.target.getAllResponseHeaders()),s=r.length;for(let t=0;t<s;++t){const e=r[t];i.push(new Yt(e.name,e.value))}if(e.willTrigger(k.HTTP_STATUS)){const r=new k(k.HTTP_STATUS,!1,!1,t.target.status);r._$responseURL=t.target.responseURL,r._$responseHeaders=i,e.dispatchEvent(r)}if(199<t.target.status&&400>t.target.status)switch(e.format){case Ht.JSON:{const e=JSON.parse(t.target.responseText);if("zlib"===e.type){if(B.$unzipWorkerActive)return void B.$unzipQueues.push({json:e,scope:this});B.$unzipWorkerActive=!0,B.$unzipWorker||(B.$unzipWorker=new Worker(B.$unzipURL));const t=new Uint8Array(e.buffer);B.$unzipWorker.onmessage=B.$unzipHandler.bind(this),B.$unzipWorker.postMessage(t,[t.buffer])}else this._$build(e)}break;case Ht.ARRAY_BUFFER:this._$imageDecode(new Uint8Array(t.target.response))}else e.willTrigger(D.IO_ERROR)&&e.dispatchEvent(new D(D.IO_ERROR,!1,!1,t.target.statusText))}.bind(this)}})}loadImage(t){t.responseDataFormat=Ht.ARRAY_BUFFER,this.load(t)}_$imageDecode(t){const e={image:new M,scope:this};e.image.decoding="async",e.image.src=g.createObjectURL(new p([t],{type:`image/${B.$getImageType(t)}`})),B.$imageWorkerActive?B.$imageQueues.push(e):(B.$imageWorkerActive=!0,e.image.decode().then(B.$decodeImage.bind(e)).catch((()=>{throw new Error("image encoding error")})))}_$build(t){const e=this.contentLoaderInfo;let i=null;const r=B.$getMap();if(t.symbols.length)for(let e=0;e<t.symbols.length;++e){const s=t.symbols[e];0===s[1]&&(i=s[0]),r.set(s[0],s[1])}if(e._$data={stage:t.stage,characters:t.characters,symbols:r},i){const t=B.$getClass(i)||Z;e._$content=new t}else e._$content=new Z;const s=t.characters[0];e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:s.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const n=B.$currentPlayer();n._$loaders.push(e),n._$loadStatus===De.LOAD_START&&(n._$loadStatus=De.LOAD_END)}}class ct extends L{constructor(){super(),this._$id=i++,this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format=Ht.STRING}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get content(){return this._$content}get url(){return this._$url}get format(){return this._$format}set format(t){this._$format=t}}class ut{constructor(t=0,e=1,i=0){this._$type=0,this._$start=1,this._$end=0,this._$frame=1,this.type=t,this.start=e,this.end=i}static toString(){return"[class LoopConfig]"}static get namespace(){return"next2d.display.LoopConfig"}toString(){return"[object LoopConfig]"}get namespace(){return"next2d.display.LoopConfig"}get frame(){return this._$frame}get type(){return this._$type}set type(t){this._$type=B.$clamp(0|t,dt.REPEAT,dt.REPEAT_REVERSAL)}get start(){return this._$start}set start(t){this._$start=B.$clamp(0|t,1,16777215)}get end(){return this._$end}set end(t){this._$end=B.$clamp(0|t,0,16777215)}}class dt{static toString(){return"[class LoopType]"}static get namespace(){return"next2d.display.LoopType"}toString(){return"[object LoopType]"}get namespace(){return"next2d.display.LoopType"}static get REPEAT(){return 0}static get NO_REPEAT(){return 1}static get FIXED(){return 2}static get NO_REPEAT_REVERSAL(){return 3}static get REPEAT_REVERSAL(){return 4}}class gt extends q{constructor(){super(),this._$graphics=null,this._$bounds=null,this._$bitmapId=0,this._$src=""}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new at(this)),this._$graphics}get src(){return this._$src}set src(t){const e=new Image;e.addEventListener("load",(t=>{const e=t.target,i=e.width,r=e.height,s=new tt(i,r);s.image=e,this.graphics.beginBitmapFill(s).drawRect(0,0,i,r),this.dispatchEvent(new O(O.LOAD))})),this._$src=e.src=t}_$buildCharacter(t,e){const i=this.graphics;if(t.recodes)switch(!0){case t.bitmapId>0:{this._$bitmapId=t.bitmapId;const r=e._$data.characters[t.bitmapId],s=$.abs(r.bounds.xMax-r.bounds.xMin),n=$.abs(r.bounds.yMax-r.bounds.yMin),a=new tt(s,n,!0,0);r._$buffer||(r._$buffer=new Uint8Array(r.buffer),B.$poolArray(r.buffer),r.buffer=null),a._$buffer=r._$buffer.slice(),i._$recode=B.$getArray();const o=t.recodes;if(o[o.length-1]===at.END_FILL){const t=o.length-6;for(let e=0;e<t;++e)i._$recode.push(o[e]);i._$recode.push(at.BITMAP_FILL,a,null,"repeat",!1)}else{const e=o[o.length-9],r=o[o.length-8],s=o[o.length-7],n=o[o.length-6],h=o.length-10;for(let t=0;t<h;++t)i._$recode.push(o[t]);i._$recode.push(at.BITMAP_STROKE,e,r,s,n,a,B.$getFloat32Array6(1,0,0,1,t.bounds.xMin,t.bounds.yMin),"repeat",!1)}}break;case t.inBitmap:{i._$recode=B.$getArray();const e=t.recodes;for(let t=0;t<e.length;++t){const r=e[t];if(i._$recode[t]=r,"object"!=typeof r)continue;if(!r.buffer)continue;const s=new tt(r.width,r.height,!0,0);s._$buffer=new Uint8Array(r.buffer),i._$recode[t++]=s;const n=e[t];i._$recode[t]=B.$getFloat32Array6(n[0],n[1],n[2],n[3],n[4],n[5])}}break;default:i._$recode=t.recodes.slice(0)}else{const e=$.abs(t.bounds.xMax-t.bounds.xMin),r=$.abs(t.bounds.yMax-t.bounds.yMin),s=new tt(e,r,!0,0);t._$buffer||(t._$buffer=new Uint8Array(t.buffer),B.$poolArray(t.buffer),t.buffer=null),s._$buffer=t._$buffer.slice(0),i.beginBitmapFill(s,null,!1).drawRect(0,0,e,r)}i._$maxAlpha=1,i._$canDraw=!0,i._$xMin=t.bounds.xMin,i._$xMax=t.bounds.xMax,i._$yMin=t.bounds.yMin,i._$yMax=t.bounds.yMax,t.grid&&(this._$scale9Grid=new j(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),B.$rendererWorker&&this._$stage&&this._$createWorkerInstance()}_$createWorkerInstance(){if(this._$created)return;this._$created=!0;const t=B.$getArray(),e=this._$getBounds(),i={command:"createShape",instanceId:this._$instanceId,maxAlpha:0,canDraw:!1,xMin:e.xMin,yMin:e.yMin,xMax:e.xMax,yMax:e.yMax},r=this._$graphics;if(r){const e=r._$getRecodes();e.length&&r._$maxAlpha>0&&r._$canDraw&&(i.maxAlpha=r._$maxAlpha,i.canDraw=r._$canDraw,i.recodes=e,t.push(e.buffer))}this._$characterId>-1&&(i.characterId=this._$characterId),this._$loaderInfo&&(i.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(i.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),B.$rendererWorker.postMessage(i,t)}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t,this._$loaderInfo),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i,e._$loaderInfo),i}_$getBounds(t=null){if(!this._$graphics)return B.$getBoundsObject(0,0,0,0);const e=this._$graphics._$getBounds(t);if(!t)return e;let i=t;const r=this._$transform._$rawMatrix();1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(i=B.$multiplicationMatrix(t,r));const s=B.$boundsMatrix(e,i);return B.$poolBoundsObject(e),i!==t&&B.$poolFloat32Array6(i),s}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let r=i;const s=this._$transform._$rawColorTransform();1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=B.$multiplicationColor(i,s));if(!B.$clamp(r[3]+r[7]/255,0,1,0))return void(r!==i&&B.$poolFloat32Array8(r));const n=this._$filters||this.filters,a=this._$blendMode||this.blendMode;let o=e;const h=this._$transform._$rawMatrix();1===h[0]&&0===h[1]&&0===h[2]&&1===h[3]&&0===h[4]&&0===h[5]||(o=B.$multiplicationMatrix(e,h)),this._$graphics._$draw(t,o,r,a,n),o!==e&&B.$poolFloat32Array6(o),r!==i&&B.$poolFloat32Array8(r)}_$clip(t,e){let i=e;const r=this._$transform._$rawMatrix();1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(i=B.$multiplicationMatrix(e,r)),this._$graphics._$clip(t,i),i!==e&&B.$poolFloat32Array6(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,r){let s=!1;if(this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$getBounds()){let n=e;const a=this._$transform._$rawMatrix();1===a[0]&&0===a[1]&&0===a[2]&&1===a[3]&&0===a[4]&&0===a[5]||(n=B.$multiplicationMatrix(e,a)),s=this._$graphics._$hit(t,n,i,r),n!==e&&B.$poolFloat32Array6(n)}return s}_$postProperty(){const t=super._$postProperty(),e=this._$graphics;if(e&&!e._$buffer){t.maxAlpha=e._$maxAlpha,t.canDraw=e._$canDraw;const i=e._$getRecodes();t.recodes=i;const r=B.$getArray(i.buffer),s=this._$getBounds();t.xMin=s.xMin,t.yMin=s.yMin,t.xMax=s.xMax,t.yMax=s.yMax,B.$rendererWorker.postMessage(t,r),B.$poolArray(r)}else B.$rendererWorker.postMessage(t);this._$posted=!0,this._$updated=!1}}class pt{static toString(){return"[class SpreadMethod]"}static get namespace(){return"next2d.display.SpreadMethod"}toString(){return"[object SpreadMethod]"}get namespace(){return"next2d.display.SpreadMethod"}static get PAD(){return"pad"}static get REFLECT(){return"reflect"}static get REPEAT(){return"repeat"}}class ft extends Q{constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=B.$clamp(B.$toColorInt(t),0,16777215,16777215);const e=this._$player;if(e){const t=B.$uintToRGBA(this._$color);e._$context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=B.$clamp(+t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get player(){return this._$player}get canvasHeight(){return this._$player?this._$player._$height/n:0}get canvasWidth(){return this._$player?this._$player._$width/n:0}get currentStageHeight(){return this._$player?this._$player._$baseHeight*this._$player._$scale:0}get currentStageWidth(){return this._$player?this._$player._$baseWidth*this._$player._$scale:0}get stageHeight(){return this._$player?this._$player._$baseHeight:0}get stageWidth(){return this._$player?this._$player._$baseWidth:0}invalidate(){this._$invalidate=!0}}class mt{static toString(){return"[class StageQuality]"}static get namespace(){return"next2d.display.StageQuality"}toString(){return"[object StageQuality]"}get namespace(){return"next2d.display.StageQuality"}static get HIGH(){return"high"}static get LOW(){return"low"}static get MEDIUM(){return"medium"}}class xt{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,B.$isUpdated=!0}}class bt{static toString(){return"[class BitmapFilterType]"}static get namespace(){return"next2d.filters.BitmapFilterType"}toString(){return"[object BitmapFilterType]"}get namespace(){return"next2d.filters.BitmapFilterType"}static get FULL(){return"full"}static get INNER(){return"inner"}static get OUTER(){return"outer"}}class Tt{static toString(){return"[class BitmapFilterQuality]"}static get namespace(){return"next2d.filters.BitmapFilterQuality"}toString(){return"[object BitmapFilterQuality]"}get namespace(){return"next2d.filters.BitmapFilterQuality"}static get LOW(){return 1}static get MEDIUM(){return 2}static get HIGH(){return 3}}class vt{static toString(){return"[class DisplacementMapFilterMode]"}static get namespace(){return"next2d.filters.DisplacementMapFilterMode"}toString(){return"[object DisplacementMapFilterMode]"}get namespace(){return"next2d.filters.DisplacementMapFilterMode"}static get CLAMP(){return"clamp"}static get COLOR(){return"color"}static get IGNORE(){return"ignore"}static get WRAP(){return"wrap"}}class yt extends xt{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=B.$clamp(+t,0,255,0))!==this._$blurX&&this._$doChanged(),this._$blurX=t}get blurY(){return this._$blurY}set blurY(t){(t=B.$clamp(+t,0,255,0))!==this._$blurY&&this._$doChanged(),this._$blurY=t}get quality(){return this._$quality}set quality(t){(t=B.$clamp(0|t,0,15,Tt.LOW))!==this._$quality&&this._$doChanged(),this._$quality=t}clone(){return new yt(this._$blurX,this._$blurY,this._$quality)}_$toArray(){return B.$getArray(1,this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=null,i=null){const r=t.clone();if(!this._$quality)return r;const s=yt.STEP[this._$quality-1];let n=0>=this._$blurX?1:this._$blurX*s,a=0>=this._$blurY?1:this._$blurY*s;switch(!0){case"number"==typeof e:case"number"==typeof i:n*=e,a*=i;break;default:n=$.round(n),a=$.round(a)}return r.x-=n,r.width+=2*n,r.y-=a,r.height+=2*a,r}_$isSame(t){return this._$quality===t._$quality&&this._$blurX===t._$blurX&&this._$blurY===t._$blurY}_$canApply(){return this._$quality&&this._$blurX&&this._$blurY}_$applyFilter(t,e,i=!0){this._$updated=!1;const r=t._$frameBufferManager,s=r.currentAttachment,n=r.getTextureFromCurrentAttachment();if(!this._$canApply())return i?n:r.createTextureFromCurrentAttachment();const a=$.sqrt(e[0]*e[0]+e[1]*e[1]),o=$.sqrt(e[2]*e[2]+e[3]*e[3]),h=new j(0,0,n.width,n.height),l=this._$generateFilterRect(h,a,o),_=0|$.ceil(l.width),c=0|$.ceil(l.height),u=$.ceil($.abs(l.x)+.5*$.abs(_-l.width)),d=$.ceil($.abs(l.y)+.5*$.abs(c-l.height));t._$offsetX=+(u+t._$offsetX),t._$offsetY=+(d+t._$offsetY);const g=this._$blurX*a,p=this._$blurY*o;let f=1,m=1;g>128?f=.0625:g>64?f=.125:g>32?f=.25:g>16&&(f=.5),p>128?m=.0625:p>64?m=.125:p>32?m=.25:p>16&&(m=.5);const x=g*f,b=p*m;let T=$.ceil(_*f),v=$.ceil(c*m);const y=r.createTextureAttachment(T,v),A=[y,r.createTextureAttachment(T,v)];let M=0;t._$bind(y),B.$resetContext(t),t.setTransform(f,0,0,m,0,0),t.drawImage(n,u,d,n.width,n.height),t.blend.toOneZero();let E=r.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(E,!0,x),E=r.getTextureFromCurrentAttachment()}if(this._$blurY>0){M=(M+1)%2;const e=A[M];t._$bind(e),t._$applyBlurFilter(E,!1,b),E=r.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==f||1!==m){const e=r.createTextureAttachment(_,c);t._$bind(e),B.$resetContext(t),t._$imageSmoothingEnabled=!0,t.setTransform(1/f,0,0,1/m,0,0),t.drawImage(E,0,0,T,v),E=r.getTextureFromCurrentAttachment(),B.$resetContext(t),t.setTransform(1,0,0,1,0,0),r.releaseAttachment(A[0],!0),r.releaseAttachment(A[1],!0),i?r.releaseAttachment(s,!0):r.releaseAttachment(e,!1)}else r.releaseAttachment(A[(M+1)%2],!0),i?r.releaseAttachment(s,!0):r.releaseAttachment(A[M],!1);return E}}class At extends xt{constructor(t=4,e=45,i=16777215,r=1,s=0,n=1,a=4,o=4,h=1,l=1,$="inner",_=!1){super(),this._$blurFilter=new yt(a,o,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type=bt.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=r,this.shadowColor=s,this.shadowAlpha=n,this.strength=h,this.type=$,this.knockout=!!_}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(),this._$angle=B.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=B.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(),this._$distance=t}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=B.$clamp(+t,0,1,0))!==this._$highlightAlpha&&this._$doChanged(),this._$highlightAlpha=t}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=B.$clamp(B.$toColorInt(t),0,16777215,16777215))!==this._$highlightColor&&this._$doChanged(),this._$highlightColor=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=B.$clamp(+t,0,1,0))!==this._$shadowAlpha&&this._$doChanged(),this._$shadowAlpha=t}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=B.$clamp(B.$toColorInt(t),0,16777215,0))!==this._$shadowColor&&this._$doChanged(),this._$shadowColor=t}get strength(){return this._$strength}set strength(t){(t=B.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(),t){case bt.OUTER:case bt.INNER:this._$type=t;break;default:this._$type=bt.FULL}}clone(){return new At(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$toArray(){return B.$getArray(0,this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const s=this._$angle*B.$Deg2Rad,n=$.abs($.cos(s)*this._$distance),a=$.abs($.sin(s)*this._$distance);return r.x+=-n,r.width+=n,r.y+=-a,r.height+=2*a,r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$highlightColor===t._$highlightColor&&(this._$highlightAlpha===t._$highlightAlpha&&(this._$shadowColor===t._$shadowColor&&(this._$shadowAlpha===t._$shadowAlpha&&(this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))))))}_$canApply(){return this._$strength&&this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const s=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=$.sqrt(e[0]*e[0]+e[1]*e[1]),l=$.sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*B.$Deg2Rad,c=+$.cos(_)*this._$distance*h,u=+$.sin(_)*this._$distance*l;let d=t.frameBuffer.createTextureAttachment(s,n);t._$bind(d),B.$resetContext(t),t.drawImage(r,0,0,s,n),t.globalCompositeOperation=it.ERASE,t.drawImage(r,2*c,2*u,s,n);const g=this._$blurFilter._$applyFilter(t,e,!1),p=g.width,f=g.height,m=$.ceil(p+2*$.abs(c)),x=$.ceil(f+2*$.abs(u)),b=this._$type===bt.INNER,T=b?s:m,v=b?n:x,y=$.abs(c),A=$.abs(u),M=(p-s)/2,E=(f-n)/2;let C,S,R,F;return b?(C=0,S=0,R=-M-c,F=-E-u):(C=y+M,S=A+E,R=y-c,F=A-u),t._$bind(i),t._$applyBitmapFilter(g,T,v,s,n,C,S,p,f,R,F,!1,this._$type,this._$knockout,this._$strength,null,null,null,B.$intToR(this._$highlightColor,this._$highlightAlpha,!0),B.$intToG(this._$highlightColor,this._$highlightAlpha,!0),B.$intToB(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,B.$intToR(this._$shadowColor,this._$shadowAlpha,!0),B.$intToG(this._$shadowColor,this._$shadowAlpha,!0),B.$intToB(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=a+C,t._$offsetY=o+S,t.frameBuffer.releaseTexture(g),t.frameBuffer.getTextureFromCurrentAttachment()}}class Mt extends xt{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this._$doApply=!1,this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(_.isArray(t)&&20===t.length){if(this._$matrix){const e=t.length;for(let i=0;i<e;++i)if(t[i]!==this._$matrix[i]){this._$doChanged(),this._$doApply=!0;break}}this._$matrix=t}}clone(){return new Mt(this._$matrix)}_$toArray(){return B.$getArray(2,this._$matrix)}_$generateFilterRect(t){return t}_$isSame(t){const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$doApply}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment(),r=i.width,s=i.height,n=t.frameBuffer.createTextureAttachment(r,s);return t._$bind(n),B.$resetContext(t),t._$applyColorMatrixFilter(i,this._$matrix),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class Et extends xt{constructor(t=0,e=0,i=null,r=1,s=0,n=!0,a=!0,o=0,h=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=r,this.bias=s,this.preserveAlpha=n,this.clamp=a,this.color=o,this.alpha=h}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=B.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(),this._$alpha=t}get bias(){return this._$bias}set bias(t){(t=+t)!==this._$bias&&this._$doChanged(),this._$bias=t}get clamp(){return this._$clamp}set clamp(t){(t=!!t)!==this._$clamp&&this._$doChanged(),this._$clamp=t}get color(){return this._$color}set color(t){(t=B.$clamp(B.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(),this._$color=t}get divisor(){return this._$divisor}set divisor(t){(t=+t)!==this._$divisor&&this._$doChanged(),this._$divisor=t}get matrix(){return this._$matrix}set matrix(t){this._$doChanged(),this._$matrix&&B.$poolArray(this._$matrix),this._$matrix=B.$getArray(),_.isArray(t)&&(this._$matrix=t.slice(0))}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|B.$clamp(0|t,0,15,0))!==this._$matrixX&&this._$doChanged(),this._$matrixX=t}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|B.$clamp(0|t,0,15,0))!==this._$matrixY&&this._$doChanged(),this._$matrixY=t}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){(t=!!t)!==this._$preserveAlpha&&this._$doChanged(),this._$preserveAlpha=t}clone(){return new Et(this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$toArray(){return B.$getArray(3,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){if(this._$matrixX!==t._$matrixX)return!1;if(this._$matrixY!==t._$matrixY)return!1;if(this._$divisor!==t._$divisor)return!1;if(this._$bias!==t._$bias)return!1;if(this._$preserveAlpha!==t._$preserveAlpha)return!1;if(this._$clamp!==t._$clamp)return!1;if(this._$color!==t._$color)return!1;if(this._$alpha!==t._$alpha)return!1;const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment();return this._$canApply()?(t._$applyConvolutionFilter(i,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,B.$intToR(this._$color,this._$alpha,!1),B.$intToG(this._$color,this._$alpha,!1),B.$intToB(this._$color,this._$alpha,!1),this._$alpha),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()):i}}class Ct extends xt{constructor(t=null,e=null,i=0,r=0,s=0,n=0,a="wrap",o=0,h=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode=vt.WRAP,this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=r,this.scaleX=s,this.scaleY=n,this.mode=a,this.color=o,this.alpha=h}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=B.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(),this._$alpha=t}get color(){return this._$color}set color(t){(t=B.$clamp(B.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(),this._$color=t}get componentX(){return this._$componentX}set componentX(t){switch((t|=0)!==this._$componentX&&this._$doChanged(),this._$componentX=0,t){case et.ALPHA:case et.BLUE:case et.GREEN:case et.RED:this._$componentX=t}}get componentY(){return this._$componentY}set componentY(t){switch((t|=0)!==this._$componentY&&this._$doChanged(),this._$componentY=0,t){case et.ALPHA:case et.BLUE:case et.GREEN:case et.RED:this._$componentY=t}}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&this._$doChanged(),this._$mapBitmap=null,t instanceof tt&&(this._$mapBitmap=t)}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&this._$doChanged(),this._$mapPoint=null,t instanceof z&&(this._$mapPoint=t)}get mode(){return this._$mode}set mode(t){switch((t+="")!==this._$mode&&this._$doChanged(),this._$mode=vt.WRAP,t){case vt.CLAMP:case vt.COLOR:case vt.IGNORE:this._$mode=t}}get scaleX(){return this._$scaleX}set scaleX(t){(t=B.$clamp(+t,-65535,65535,0))!==this._$scaleX&&this._$doChanged(),this._$scaleX=t}get scaleY(){return this._$scaleY}set scaleY(t){(t=B.$clamp(+t,-65535,65535,0))!==this._$scaleY&&this._$doChanged(),this._$scaleY=t}clone(){return new Ct(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$toArray(){return B.$getArray(4,this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){return this._$mapBitmap===t._$mapBitmap&&(this._$mapPoint.x===t._$mapPoint.x&&(this._$mapPoint.y===t._$mapPoint.y&&(this._$componentX===t._$componentX&&(this._$componentY===t._$componentY&&(this._$scaleX===t._$scaleX&&(this._$scaleY===t._$scaleY&&(this._$mode===t._$mode&&(this._$color===t._$color&&this._$alpha===t._$alpha))))))))}_$canApply(){return this._$mapBitmap&&this._$componentX&&this._$componentY&&this._$scaleX&&this._$scaleY}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const s=$.sqrt(e[0]*e[0]+e[1]*e[1]),n=$.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(r,this._$mapBitmap._$texture,r.width/s,r.height/n,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,B.$intToR(this._$color,this._$alpha,!0),B.$intToG(this._$color,this._$alpha,!0),B.$intToB(this._$color,this._$alpha,!0),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class St extends xt{constructor(t=4,e=45,i=0,r=1,s=4,n=4,a=1,o=1,h=!1,l=!1,$=!1){super(),this._$blurFilter=new yt(s,n,o),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=r,this.strength=a,this.inner=h,this.knockout=l,this.hideObject=$}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=B.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=B.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=B.$clamp(B.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get distance(){return this._$distance}set distance(t){(t=B.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get hideObject(){return this._$hideObject}set hideObject(t){(t=!!t)!==this._$hideObject&&this._$doChanged(!0),this._$hideObject=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=B.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new St(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$toArray(){return B.$getArray(5,this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const s=this._$angle*B.$Deg2Rad,n=$.cos(s)*this._$distance*2,a=$.sin(s)*this._$distance*2;return r.x=$.min(r.x,n),r.width+=$.abs(n),r.y=$.min(r.y,a),r.height+=$.abs(a),r}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&(this._$hideObject===t._$hideObject&&this._$blurFilter._$isSame(t._$blurFilter))))))))}_$canApply(){return this._$alpha&&this._$strength&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t._$frameBufferManager,r=i.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const s=r.width,a=r.height,o=t._$offsetX,h=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,c=l.height,u=t._$offsetX,d=t._$offsetY,g=u-o,p=d-h,f=$.sqrt(e[0]*e[0]+e[1]*e[1]),m=$.sqrt(e[2]*e[2]+e[3]*e[3]),x=this._$angle*B.$Deg2Rad,b=$.cos(x)*this._$distance*2*f/n,T=$.sin(x)*this._$distance*2*m/n,v=this._$inner?s:_+$.max(0,$.abs(b)-g),y=this._$inner?a:c+$.max(0,$.abs(T)-p),A=$.ceil(v),M=$.ceil(y),E=(A-v)/2,C=(M-y)/2;let S,R,F,w,I,U;return this._$inner?(S=0,R=0,F=b-u,w=T-d):(S=$.max(0,g-b)+E,R=$.max(0,p-T)+C,F=(b>0?$.max(0,b-g):0)+E,w=(T>0?$.max(0,T-p):0)+C),this._$inner?(I=bt.INNER,U=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(I=bt.FULL,U=!0):(I=bt.OUTER,U=this._$knockout),t._$bind(r),t._$applyBitmapFilter(l,A,M,s,a,S,R,_,c,F,w,!0,I,U,this._$strength,null,null,null,B.$intToR(this._$color,this._$alpha,!0),B.$intToG(this._$color,this._$alpha,!0),B.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=o+S,t._$offsetY=h+R,i.releaseTexture(l),i.getTextureFromCurrentAttachment()}}class Rt extends xt{constructor(t=0,e=1,i=4,r=4,s=1,n=1,a=!1,o=!1){super(),this._$blurFilter=new yt(i,r,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=s,this.inner=a,this.knockout=o}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=B.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(),this._$alpha=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=B.$clamp(B.$toColorInt(t),0,16777215,4))!==this._$color&&this._$doChanged(),this._$color=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=B.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}clone(){return new Rt(this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$toArray(){return B.$getArray(6,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){const r=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(r,e,i):r}_$isSame(t){return this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))}_$canApply(){return this._$alpha&&this._$strength&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,s=i.height,n=t._$offsetX,a=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),h=o.width,l=o.height,$=t._$offsetX,_=t._$offsetY,c=this._$inner?r:h,u=this._$inner?s:l;let d,g,p,f;this._$inner?(d=0,g=0,p=-$,f=-_):(d=$-n,g=_-a,p=0,f=0);const m=this._$inner?bt.INNER:bt.OUTER;return t._$bind(i),t._$applyBitmapFilter(o,c,u,r,s,d,g,h,l,p,f,!0,m,this._$knockout,this._$strength,null,null,null,B.$intToR(this._$color,this._$alpha,!0),B.$intToG(this._$color,this._$alpha,!0),B.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=n+d,t._$offsetY=a+g,t.frameBuffer.releaseTexture(o),t.frameBuffer.getTextureFromCurrentAttachment()}}class Ft extends xt{constructor(t=4,e=45,i=null,r=null,s=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new yt(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=bt.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=r,this.ratios=s,this.strength=o,this.type=l,this.knockout=$}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,_.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=B.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(),this._$angle=B.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,_.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){let e=0|B.$toColorInt(t[i]);e<0&&(e=16777216-$.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=B.$clamp($.abs(e),0,16777215)}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=B.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,_.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i)t[i]=B.$clamp(+t[i],0,255,0);this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=B.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(),t){case bt.OUTER:case bt.FULL:this._$type=t;break;default:this._$type=bt.INNER}}clone(){return new Ft(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$toArray(){return B.$getArray(7,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t){let e=t.clone();if(!this._$canApply())return e;e=this._$blurFilter._$generateFilterRect(e);const i=this._$angle*B.$Deg2Rad,r=$.abs($.cos(i)*this._$distance),s=$.abs($.sin(i)*this._$distance);return e.x+=-r,e.width+=r,e.y+=-s,e.height+=2*s,e}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$canApply(){return this._$strength&&this._$distance&&this._$alphas&&this._$ratios&&this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const r=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return r;const s=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=$.sqrt(e[0]*e[0]+e[1]*e[1]),l=$.sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*B.$Deg2Rad,c=+$.cos(_)*this._$distance*h,u=+$.sin(_)*this._$distance*l;let d=t.frameBuffer.createTextureAttachment(s,n);t._$bind(d),B.$resetContext(t),t.drawImage(r,0,0,s,n),t.globalCompositeOperation=it.ERASE,t.drawImage(r,2*c,2*u,s,n);const g=this._$blurFilter._$applyFilter(t,e,!1),p=g.width,f=g.height,m=$.ceil(p+2*$.abs(c)),x=$.ceil(f+2*$.abs(u)),b=this._$type===bt.INNER,T=b?s:m,v=b?n:x,y=$.abs(c),A=$.abs(u),M=(p-s)/2,E=(f-n)/2;let C,S,R,F;return b?(C=0,S=0,R=-M-c,F=-E-u):(C=y+M,S=A+E,R=y-c,F=A-u),t._$bind(i),t._$applyBitmapFilter(g,T,v,s,n,C,S,p,f,R,F,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=a+C,t._$offsetY=o+S,t.frameBuffer.releaseTexture(g),t.frameBuffer.getTextureFromCurrentAttachment()}}class Bt extends xt{constructor(t=4,e=45,i=null,r=null,s=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new yt(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=bt.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=r,this.ratios=s,this.strength=o,this.type=l,this.knockout=$}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,_.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=B.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(),this._$angle=B.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,_.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){let e=0|B.$toColorInt(t[i]);e<0&&(e=16777216-$.abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=B.$clamp($.abs(e),0,16777215)}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=B.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,_.isArray(t)){this._$doChanged();const e=t.length;for(let i=0;i<e;++i){const e=B.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=B.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(),t){case bt.OUTER:case bt.FULL:this._$type=t;break;default:this._$type=bt.INNER}}clone(){return new Bt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$toArray(){return B.$getArray(8,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,i);const s=this._$angle*B.$Deg2Rad,n=$.cos(s)*this._$distance,a=$.sin(s)*this._$distance;return r.x=$.min(r.x,n),r.width+=$.abs(n),r.y=$.min(r.y,a),r.height+=$.abs(a),r}_$canApply(){return this._$strength&&this._$alphas&&this._$ratios&&this._$colors&&this._$blurFilter._$canApply()}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$applyFilter(t,e){this._$updated=!1;const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const r=i.width,s=i.height,n=t._$offsetX,a=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),h=o.width,l=o.height,_=t._$offsetX,c=t._$offsetY,u=_-n,d=c-a,g=$.sqrt(e[0]*e[0]+e[1]*e[1]),p=$.sqrt(e[2]*e[2]+e[3]*e[3]),f=+this._$angle*B.$Deg2Rad,m=+$.cos(f)*this._$distance*g,x=+$.sin(f)*this._$distance*p,b=this.type===bt.INNER,T=b?r:h+$.max(0,$.abs(m)-u),v=b?s:l+$.max(0,$.abs(x)-d),y=$.ceil(T),A=$.ceil(v),M=(y-T)/2,E=(A-v)/2;let C,S,R,F;return b?(C=0,S=0,R=m-_,F=x-c):(C=$.max(0,u-m)+M,S=$.max(0,d-x)+E,R=(m>0?$.max(0,m-u):0)+M,F=(x>0?$.max(0,x-d):0)+E),t._$bind(i),t._$applyBitmapFilter(o,y,A,r,s,C,S,h,l,R,F,!0,this.type,this.knockout,this._$strength,this.ratios,this.colors,this.alphas,0,0,0,0,0,0,0,0),t._$offsetX=n+C,t._$offsetY=a+S,t.frameBuffer.releaseTexture(o),t.frameBuffer.getTextureFromCurrentAttachment()}}class wt{static toString(){return"[class TextFormatAlign]"}static get namespace(){return"next2d.text.TextFormatAlign"}toString(){return"[object TextFormatAlign]"}get namespace(){return"next2d.text.TextFormatAlign"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get RIGHT(){return"right"}}class It{static toString(){return"[class TextFieldAutoSize]"}static get namespace(){return"next2d.text.TextFieldAutoSize"}toString(){return"[object TextFieldAutoSize]"}get namespace(){return"next2d.text.TextFieldAutoSize"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get NONE(){return"none"}static get RIGHT(){return"right"}}class Ut extends K{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0;const t=new Lt;t._$setDefault(this),this._$defaultTextFormat=t,this._$decisionTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict=null,this._$isHTML=!1,this._$textData=null,this._$textHeight=null,this._$textWidth=null,this._$widthTable=null,this._$textarea=null,this._$autoSize=It.NONE,this._$autoFontSize=!1,this._$textAppending=!1,this._$heightTable=null,this._$textFormatTable=[],this._$textAreaActive=!1,this._$totalWidth=null,this._$objectTable=null,this._$imageData=null,this._$scrollEnabled=!0,this._$scrollSprite=null,this._$type=Ot.STATIC,this._$textHeightTable=null,this._$focus=!1,this._$isComposing=!1,this._$thickness=0,this._$thicknessColor=0,this._$verticalAlign=Pt.TOP}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}get autoFontSize(){return this._$autoFontSize}set autoFontSize(t){this._$autoFontSize=!!t}get autoSize(){return this._$autoSize}set autoSize(t){switch(t){case It.CENTER:case It.LEFT:case It.RIGHT:this._$autoSize=t;break;default:this._$autoSize=It.NONE}this._$reload()}get background(){return this._$background}set background(t){this._$background=!!t,this._$reset()}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){this._$backgroundColor=B.$clamp(B.$toColorInt(t),0,16777215,16777215),this._$reset()}get border(){return this._$border}set border(t){this._$border=!!t,this._$reset()}get borderColor(){return this._$borderColor}set borderColor(t){this._$borderColor=B.$clamp(B.$toColorInt(t),0,16777215,0),this._$reset()}get defaultTextFormat(){return this._$defaultTextFormat}set defaultTextFormat(t){t instanceof Lt&&(t._$merge(this._$defaultTextFormat),t._$textField=this,this._$defaultTextFormat=t,this._$reset())}get focus(){return this._$focus}set focus(t){if(this._$focus!==!!t)if(this._$focus=!!t,this._$focus){if(this._$type===Ot.INPUT){const t=B.$currentPlayer(),e=a.getElementById(t.contentElementId);if(!e)return;this._$createTextAreaElement(t._$scale);const i=this._$textarea,r=this._$transform.concatenatedMatrix,s=this._$getBounds(null),o=B.$intToRGBA(this._$defaultTextFormat._$color,100);i.style.color=`rgb(${o.R},${o.G},${o.B})`,i.style.left=(r.tx+s.xMin+t._$tx/t._$scale/n)*t._$scale+"px",i.style.top=(r.ty+s.yMin+t._$ty/t._$scale/n)*t._$scale+"px",i.style.width=`${$.ceil((this.width-1)*t._$scale)}px`,i.style.height=`${$.ceil((this.height-1)*t._$scale)}px`,i.value=this.text,e.appendChild(i);A((()=>{i.focus()})),this._$doChanged(),B.$isUpdated=!0,this._$textAreaActive=!0,this.willTrigger(N.FOCUS_IN)&&this.dispatchEvent(new N(N.FOCUS_IN))}}else this._$textarea&&(this._$textarea.dispatchEvent(new s.Event(`${B.$PREFIX}_blur`)),this.willTrigger(N.FOCUS_OUT)&&this.dispatchEvent(new N(N.FOCUS_OUT)),this._$textarea.remove())}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=`${t}`,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable=[],this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1,this._$getTextData();const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=0,r=0;for(;t>r&&(i+=this._$textHeightTable[r],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){this._$multiline=!!t,this._$reset()}get numLines(){return null===this._$textData&&this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=`${t}`}get scrollEnabled(){return this._$scrollEnabled}set scrollEnabled(t){this._$scrollEnabled=!!t}get scrollH(){return this._$scrollH}set scrollH(t){t=B.$clamp(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger(O.SCROLL)&&this.dispatchEvent(new O(O.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){if(t=B.$clamp(0|t,1,this.maxScrollV),this._$scrollV!==t){if(this._$scrollV=$.max(1,t),this._$reset(),this.textHeight>this.height){this._$scrollSprite.height=this.height*this.height/this.textHeight-1;const t=this._$parent;if(t){this._$scrollSprite.alpha=1,this._$scrollSprite.x=this.x+this.width-this._$scrollSprite.width-.5,this._$scrollSprite.y=this.y+.5+(this.height-1-this._$scrollSprite.height)/(this.maxScrollV-1)*(this._$scrollV-1),t.addChildAt(this._$scrollSprite,t.getChildIndex(this)+1),this._$scrollSprite.hasLocalVariable("job")&&this._$scrollSprite.getLocalVariable("job").stop();const e=qt.add(this._$scrollSprite,{alpha:1},{alpha:0},1);e.addEventListener(O.COMPLETE,(t=>{const e=t.target.target;e.deleteLocalVariable("job"),e.parent&&e.parent.removeChild(e)})),e.start(),this._$scrollSprite.setLocalVariable("job",e)}}this.willTrigger(O.SCROLL)&&this.dispatchEvent(new O(O.SCROLL,!0))}}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData(),i=0|e.length;for(let r=1;r<i;++r){const i=e[r];switch(i.mode){case Nt.TEXT:t+=i.text;break;case Nt.BREAK:t+="\r"}}return!this._$isHTML&&this._$initText&&(t+="\r"),this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$cacheText="",this._$isHTML=!1,this._$textAppending||(this._$textFormatTable=[]),this._$reload())}get textColor(){return this._$defaultTextFormat.color}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(""===this.text)return 0;if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();let t=0|this._$decisionTextFormat._$leading;const e=this._$textHeightTable.length;1===e&&(this._$textHeight+=t);for(let t=0;t<e;++t)this._$textHeight+=this._$textHeightTable[t]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=$.max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get thickness(){return this._$thickness}set thickness(t){this._$thickness=0|t,this._$reset()}get thicknessColor(){return this._$thicknessColor}set thicknessColor(t){this._$thicknessColor=B.$clamp(B.$toColorInt(t),0,16777215,16777215),this._$reset()}get type(){return this._$type}set type(t){(t+="")===Ot.STATIC?(this._$type=t,this._$textarea=null):this._$type=Ot.INPUT}get verticalAlign(){return this._$verticalAlign}set verticalAlign(t){switch(t){case Pt.MIDDLE:case Pt.BOTTOM:this._$verticalAlign=t;break;default:this._$verticalAlign=Pt.TOP}}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap=!!t}get width(){return super.width}set width(t){if(!l(t=+t)&&t>-1){const e=this._$getBounds(null),i=$.abs(e.xMin);this._$originBounds.xMax=t+i,this._$originBounds.xMin=i,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}}get height(){return super.height}set height(t){if(!l(t=+t)&&t>-1){const e=this._$getBounds(null),i=$.abs(e.yMin);this._$originBounds.yMax=t+i,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this._$textAppending=!0,this.text=e+`${t}`,this._$textAppending=!1}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),r=e>-1?e:i.length;let s=!1,n=new Lt,a=t>-1?t:0;for(;a<r;++a){if(i[a].mode===Nt.BREAK)continue;const t=i[a].textFormat;s?(n._$align=n._$align!==t._$align?null:t._$align,n._$blockIndent=n._$blockIndent!==t._$blockIndent?null:t._$blockIndent,n._$bold=n._$bold!==t._$bold?null:t._$bold,n._$color=n._$color!==t._$color?null:t._$color,n._$font=n._$font!==t._$font?null:t._$font,n._$indent=n._$indent!==t._$indent?null:t._$indent,n._$italic=n._$italic!==t._$italic?null:t._$italic,n._$leading=n._$leading!==t._$leading?null:t._$leading,n._$leftMargin=n._$leftMargin!==t._$leftMargin?null:t._$leftMargin,n._$letterSpacing=n._$letterSpacing!==t._$letterSpacing?null:t._$letterSpacing,n._$rightMargin=n._$rightMargin!==t._$rightMargin?null:t._$rightMargin,n._$size=n._$size!==t._$size?null:t._$size,n._$underline=n._$underline!==t._$underline?null:t._$underline):(s=!0,n=t._$clone())}return n}getLineText(t){if(!this._$text&&!this._$htmlText)return"";t|=0;let e="";const i=this._$getTextData();for(let r=0;r<i.length;r++){const s=i[r];if(s.yIndex>t)break;s.yIndex===t&&(s.mode===Nt.TEXT&&(e+=s.text))}return e}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const r=this.text;t>=r.length?e>=r.length&&e>=t&&(this.text=r+`${i}`):this.text=r.substr(0,t)+`${i}`+r.substr(e,r.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const r=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:{const e=r.length;for(let i=0;i<e;++i)this._$textFormatTable[i]=t._$clone()}break;case e>-1&&-1===i:{let i=e+1,s=r[i];s.mode===Nt.WRAP&&(s=r[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let s=0;for(let n=e;n<i;++n){const e=r[n];e&&(e.mode!==Nt.WRAP&&e.mode!==Nt.BREAK?this._$textFormatTable[n+s]=t._$clone():(++i,--s))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(null===this._$textData){this._$textData=[],this._$imageData=[],this._$heightTable=[],this._$textHeightTable=[],this._$objectTable=[],this._$widthTable=[],this._$heightCache=B.$getMap();let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),B.$P_TAG.innerHTML!==e&&(B.$P_TAG.textContent="",B.$P_TAG.insertAdjacentHTML("afterbegin",e));let r=this._$decisionTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(r),r=t}this._$totalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=this._$getTextHeight(r),this._$widthTable[0]=0;const s={mode:Nt.BREAK,x:0,yIndex:0,textFormat:r._$clone()};this._$objectTable[0]=s,this._$textData[0]=s,this._$parseTag(B.$P_TAG,r._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")],i=e.length;for(let r=0;r<i;++r){this._$totalWidth=0;let i=this.defaultTextFormat;const s=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[s]=0,this._$textHeightTable[s]=this._$getTextHeight(i),this._$widthTable[s]=0,s&&(this._$heightTable[s]=this._$heightTable[s-1],this._$textHeightTable[s]=this._$textHeightTable[s-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(i),i=t}const n={mode:Nt.BREAK,x:0,yIndex:s,textFormat:i._$clone()};i=this.defaultTextFormat,this._$objectTable[s]=n,this._$textData[this._$textData.length]=n;const a=e[r];a&&(t=this._$parseText(a,i,t))}}B.$poolMap(this._$heightCache),this._$heightCache=null}return this._$textData}_$parseTag(t,e,i){const r=t.childNodes,s=r.length;for(let t=0;t<s;++t){let s=e._$clone();const n=r[t];if(3!==n.nodeType)switch(n.nodeName){case"P":{if(n.hasAttribute("align")&&(s._$align=n.getAttribute("align").toLowerCase(),1===this._$textData.length&&(this._$textData[0].textFormat._$align=s._$align)),this._$parseTag(n,s,i),!this._$multiline)break;this._$totalWidth=this._$getImageOffsetX();const t=this._$heightTable.length;if(this._$heightTable[t]=0,this._$textHeightTable[t]=0,this._$widthTable[t]=0,t&&(this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}const e={mode:Nt.BREAK,x:0,yIndex:t,textFormat:s};this._$objectTable[t]=e,this._$textData.push(e)}break;case"B":s._$bold=!0,this._$parseTag(n,s,i);break;case"I":s._$italic=!0,this._$parseTag(n,s,i);break;case"U":s._$underline=!0,this._$parseTag(n,s,i);break;case"FONT":n.hasAttribute("face")&&(s._$font=n.getAttribute("face")),n.hasAttribute("size")&&(s._$size=0|n.getAttribute("size")),n.hasAttribute("color")&&(s._$color=B.$toColorInt(n.getAttribute("color"))),n.hasAttribute("letterSpacing")&&(s.letterSpacing=0|n.getAttribute("letterSpacing")),this._$parseTag(n,s,i);break;case"TEXTFORMAT":n.hasAttribute("blockindent")&&(s._$blockIndent=0|n.getAttribute("blockindent")),n.hasAttribute("indent")&&(s._$indent=0|n.getAttribute("indent")),n.hasAttribute("leading")&&(s._$leading=0|n.getAttribute("leading")),n.hasAttribute("leftmargin")&&(s._$leftMargin=0|n.getAttribute("leftmargin")),n.hasAttribute("rightmargin")&&(s._$rightMargin=0|n.getAttribute("rightmargin")),this._$parseTag(n,s,i);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0,this._$totalWidth=this._$getImageOffsetX(),s._$indent=0;const e={mode:Nt.BREAK,x:0,yIndex:t,textFormat:s};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"IMG":{let t="";n.hasAttribute("src")&&(t=n.getAttribute("src"));let e=null;if(B.$loadedImages.has(t))e=B.$loadedImages.get(t);else{const i=n.getAttribute("width")||0,r=n.getAttribute("height")||0,a=n.getAttribute("vspace")||8,o=n.getAttribute("hspace")||8;let h=0;for(let t=0;t<this._$textHeightTable.length;t++)h+=this._$textHeightTable[t];if(e={mode:Nt.IMAGE,src:t,loaded:!1,x:0,y:h,width:0|i,height:0|r,hspace:0|o,vspace:0|a,textFormat:s._$clone()},this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],i=t.y+t.height+2*t.vspace;e.y=$.max(h,i)}this._$loadImage(e),B.$loadedImages.set(t,e)}this._$textData[this._$textData.length]=e,this._$imageData[this._$imageData.length]=e}break;default:this._$parseTag(n,s,i)}else i=this._$parseText(n.nodeValue,s)}}_$loadImage(t){t.scope=this,t.image=new M,t.image.crossOrigin="anonymous",t.image.addEventListener("load",function(){this.loaded=!0,this.width||(this.width=0|this.image.width),this.height||(this.height=0|this.image.height);const t=this.scope;this.scope=null,B.$loadedImages.set(this.src,this),t._$reload()}.bind(t),!1),t.image.src=t.src}_$parseText(t,e,i){let r=this._$heightTable.length-1|0,s=e._$clone();const n=this._$transform.concatenatedMatrix._$matrix,a=(this._$originBounds.xMax-this._$originBounds.xMin)*(n[0]/n[3]);B.$poolFloat32Array6(n);const o=a-s._$widthMargin()-4;for(let n=0;n<t.length;++n){if(s=e._$clone(),this._$textData.length+i in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+i]._$clone();t._$merge(s),s=t}const a={mode:Nt.TEXT,text:t[n],x:0,width:0,fontScale:0,yIndex:r,textFormat:s};let h=null;this._$multiline&&(h="\n"===a.text||"\r"===a.text||"\n\r"===a.text);let l=r?s._$leading:0,_=0,c=0,u=0,d=null;if(B.$textContext.font=s._$generateFontStyle(),_=B.$textContext.measureText(a.text).width+s._$letterSpacing,c=this._$getTextHeight(s),u=c+l,a.height=c,h||this._$wordWrap&&this._$totalWidth+_>o){this._$widthTable[++r]=0,a.yIndex=r,this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1],this._$totalWidth=this._$getImageOffsetX(),s=s._$clone(),s._$indent=0;d={mode:h?Nt.BREAK:Nt.WRAP,x:0,yIndex:r,textFormat:s},this._$objectTable[r]=d,h||--i;let t=a.text,e=0,n=!0;const o=/[0-9a-zA-Z?!;:.,？！。、；：〜]/g;for(;t.match(o);){++e;const i=this._$textData[this._$textData.length-e];if(i.mode!==Nt.TEXT){n=!1;break}t=i.text}if(e>1&&this._$textData[this._$textData.length-e+1].text.match(/[0-9a-zA-Z]/g)&&--e,e>0&&n){const t=this._$textData.length-e;this._$textData.splice(t,0,d);let i=1,s=this._$textData[t-i];for(this._$widthTable[r-1]=0,this._$heightTable[r-1]=0,this._$textHeightTable[r-1]=0;s.mode===Nt.TEXT;)c=this._$getTextHeight(s.textFormat),u=c+l,this._$widthTable[r-1]+=s.width,this._$heightTable[r-1]=$.max(this._$heightTable[r-1],c),this._$textHeightTable[r-1]=$.max(this._$textHeightTable[r-1],u),++i,s=this._$textData[t-i];for(i=1;this._$textData.length>t+i;)s=this._$textData[t+i],++i,c=this._$getTextHeight(s.textFormat),u=c+l,this._$heightTable[r]=$.max(this._$heightTable[r],c),this._$textHeightTable[r]=$.max(this._$textHeightTable[r],u),s.x=this._$totalWidth,s.yIndex=r,this._$totalWidth+=s.width}else this._$textData[this._$textData.length]=d}h||(a.width=_,a.x=this._$totalWidth,this._$totalWidth+=_,this._$widthTable[r]=$.max(this._$widthTable[r],this._$totalWidth),this._$heightTable[r]=$.max(this._$heightTable[r],c),this._$textHeightTable[r]=$.max(this._$textHeightTable[r],u),this._$textData[this._$textData.length]=a)}return i}_$getTextHeight(t){if(!B.$DIV){const t=a.createElement("div");t.innerHTML="a",t.style.display="block",t.style.position="absolute",t.style.top="-9999px",t.style.left="-9999px",t.style.padding="0",t.style.margin="0",t.style.padding="0",t.style.border="0",t.style.outline="0",t.style.verticalAlign="bottom",t.style.lineHeight="100%",B.$DIV=t,a.body.appendChild(B.$DIV)}const e=t._$size,i=t._$font,r=t._$bold?"bold":"normal",s=`${e}_${i}_${r}`;if(this._$heightCache.has(s))return this._$heightCache.get(s);const n=B.$DIV.style,o=`${e}px`;n.fontSize!==o&&(n.fontSize=o),n.fontFamily!==i&&(n.fontFamily=i),n.fontWeight!==r&&(n.fontWeight=r);const h=10>e?B.$DIV.clientHeight*e*.1:B.$DIV.clientHeight;return this._$heightCache.set(s,h),h}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],r=i.height+2*i.vspace;if(i.y<=t&&t<i.y+r)return i.width+2*i.hspace}return 0}_$reset(){this._$textData=null,this._$imageData=null,this._$textHeight=null,this._$textWidth=null,this._$heightTable=null,this._$textHeightTable=null,this._$widthTable=null,this._$objectTable=null,this._$totalWidth=null,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),B.$isUpdated=!0,B.$cacheStore().removeCache(this._$instanceId)}_$reload(){if(this._$reset(),this._$getTextData(),this._$autoSize===It.NONE&&this._$autoFontSize){const t=this.defaultTextFormat.size;if(this.width&&this.textWidth&&this.textWidth>this.width)for(;this.textWidth>this.width;){if(this.defaultTextFormat.size--,1>this.defaultTextFormat.size){this.defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}if(this.height&&this.textHeight&&this.textHeight>this.height)for(;this.textHeight>this.height;){if(this.defaultTextFormat.size--,1>this.defaultTextFormat.size){this.defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}this.defaultTextFormat.size=t}this._$resize()}_$resize(){if(this._$autoSize!==It.NONE){const t=this._$defaultTextFormat,e=this.textWidth+4+t._$leftMargin+t._$rightMargin;if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case It.LEFT:case It.CENTER:this._$bounds.xMax=e+this._$bounds.xMin;break;case It.RIGHT:this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}else this._$scrollEnabled&&!this._$scrollSprite&&(this._$scrollSprite=new J,this._$scrollSprite.graphics.beginFill("#000",.3).drawRoundRect(0,0,3,3,3),this._$scrollSprite._$scale9Grid=new j(1.5,1.5,.1,.1))}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],r=t.textFormat,s=r._$blockIndent+r._$leftMargin>0?r._$blockIndent+r._$leftMargin:0;switch(!0){case!1===this._$wordWrap&&i>e:return $.max(0,s);case r._$align===wt.CENTER:case this._$autoSize===It.CENTER:return $.max(0,e/2-s-r._$rightMargin-i/2);case r._$align===wt.RIGHT:case this._$autoSize===It.RIGHT:return $.max(0,e-s-i-r._$rightMargin-2);default:return $.max(0,s+2)}}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();return 1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=B.$multiplicationMatrix(t,i)),B.$boundsMatrix(this._$bounds,e)}return B.$boundsMatrix(this._$bounds,this._$correctMatrix(B.$MATRIX_ARRAY_IDENTITY))}_$correctMatrix(t){switch(this._$autoSize){case It.CENTER:{const e=this.textWidth+4,i=(this._$originBounds.xMax-this._$originBounds.xMin)/2-e/2;return B.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}case It.RIGHT:{const e=this.textWidth+4,i=this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin);return B.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}default:return t}}_$buildCharacter(t){const e=this.defaultTextFormat;switch(e.font=t.font,e.size=0|t.size,e.align=t.align,e.color=0|t.color,e.leading=t.leading,e.letterSpacing=t.letterSpacing,e.leftMargin=t.leftMargin,e.rightMargin=t.rightMargin,t.fontType){case 1:e.bold=!0;break;case 2:e.italic=!0;break;case 3:e.bold=!0,e.italic=!0}switch(this._$type=t.inputType,this._$multiline=!!t.multiline,this._$wordWrap=!!t.wordWrap,this._$border=!!t.border,this._$scrollEnabled=!!t.scroll,this._$thickness=0|t.thickness,this._$thicknessColor=0|t.thicknessColor,this._$bounds.xMin=t.originBounds.xMin,this._$bounds.xMax=t.originBounds.xMax,this._$bounds.yMin=t.originBounds.yMin,this._$bounds.yMax=t.originBounds.yMax,this._$originBounds.xMin=t.originBounds.xMin,this._$originBounds.xMax=t.originBounds.xMax,this._$originBounds.yMin=t.originBounds.yMin,this._$originBounds.yMax=t.originBounds.yMax,t.autoSize){case 1:this.autoSize=t.align;break;case 2:this.autoFontSize=!0}this.text=t.text,B.$rendererWorker&&this._$stage&&this._$createWorkerInstance()}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const i=this._$getBounds(),r=i.xMax,s=i.xMin,n=i.yMax,a=i.yMin;B.$poolBoundsObject(i);let o=$.ceil($.abs(r-s)),h=$.ceil($.abs(n-a));if(!o||!h)return;let l=e;const _=this._$transform._$rawMatrix();1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||(l=B.$multiplicationMatrix(e,_)),B.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(o,0),t.lineTo(o,h),t.lineTo(0,h),t.lineTo(0,0),t.clip(!0),l!==e&&B.$poolFloat32Array6(l)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let r=i;const s=this._$transform._$rawColorTransform();1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=B.$multiplicationColor(i,s));const n=B.$clamp(r[3]+r[7]/255,0,1);if(!n)return;let a=e;const o=this._$transform._$rawMatrix();1===o[0]&&0===o[1]&&0===o[2]&&1===o[3]&&0===o[4]&&0===o[5]||(a=B.$multiplicationMatrix(e,o));const h=this._$getBounds(null);h.xMin-=this._$thickness,h.xMax+=this._$thickness,h.yMin-=this._$thickness,h.yMax+=this._$thickness;const l=B.$boundsMatrix(h,a),_=+l.xMax,u=+l.xMin,d=+l.yMax,g=+l.yMin;B.$poolBoundsObject(l);let p=$.ceil($.abs(_-u)),f=$.ceil($.abs(d-g));switch(!0){case 0===p:case 0===f:case p===-F:case f===-F:case p===F:case f===F:return}if(0>u+p||0>g+f)return;const m=t._$frameBufferManager,x=m.currentAttachment;if(u>x.width||g>x.height)return;let b=+$.sqrt(a[0]*a[0]+a[1]*a[1]);if(!c.isInteger(b)){const t=b.toString(),e=t.indexOf("e");-1!==e&&(b=+t.slice(0,e)),b=+b.toFixed(4)}let T=+$.sqrt(a[2]*a[2]+a[3]*a[3]);if(!c.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}const v=this._$filters||this.filters;if(0>u+p||0>g+f){if(!(v&&v.length&&this._$canApply(v)))return;{let t=new j(0,0,p,f);for(let e=0;e<v.length;++e)t=v[e]._$generateFilterRect(t,b,T);if(0>t.x+t.width||0>t.y+t.height)return}}const y=this._$blendMode||this.blendMode,A=B.$getArray(b,T),M=this._$instanceId,E=B.$cacheStore(),C=E.generateKeys(M,A);let S=E.get(C);if(this._$isUpdated()&&(E.removeCache(M),S=null),!S){const t=$.min(1,$.max(b,T)),i=$.ceil($.abs(h.xMax-h.xMin)*b),s=$.ceil($.abs(h.yMax-h.yMin)*T);r[3]=1;const n=E.getCanvas();n.width=i+2*t,n.height=s+2*t;const a=n.getContext("2d");if(this._$background||this._$border){if(a.beginPath(),a.moveTo(0,0),a.lineTo(i,0),a.lineTo(i,s),a.lineTo(0,s),a.lineTo(0,0),this._$background){const t=B.$intToRGBA(this._$backgroundColor),e=$.max(0,$.min(255*t.A*r[3]+r[7],255))/255;a.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,a.fill()}if(this._$border){const e=B.$intToRGBA(this._$borderColor),i=$.max(0,$.min(255*e.A*r[3]+r[7],255))/255;a.lineWidth=t,a.strokeStyle=`rgba(${e.R},${e.G},${e.B},${i})`,a.stroke()}}a.save(),a.beginPath(),a.moveTo(2,2),a.lineTo(i-2,2),a.lineTo(i-2,s-2),a.lineTo(2,s-2),a.lineTo(2,2),a.clip(),a.beginPath(),a.setTransform(b,0,0,T,0,0),this._$doDraw(a,e,r,i/b),a.restore(),S=m.createTextureFromCanvas(a.canvas),B.$useCache&&E.set(C,S),E.destroy(a)}let R=!1,w=0,I=0;v&&v.length&&this._$canApply(v)&&(R=!0,S=this._$drawFilter(t,S,a,v,p,f),w=S._$offsetX,I=S._$offsetY);const U=$.atan2(a[1],a[0]),O=$.atan2(-a[2],a[3]);if(R||!U&&!O)t.setTransform(1,0,0,1,u-w,g-I);else{const e=h.xMin*b,i=h.yMin*T,r=$.cos(U),s=$.sin(U),n=$.cos(O),o=$.sin(O);t.setTransform(r,s,-o,n,e*r-i*o+a[4],e*s+i*n+a[5])}B.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=y,t.drawImage(S,0,0,S.width,S.height,r),B.$poolArray(C),B.$poolBoundsObject(h),a!==e&&B.$poolFloat32Array6(a),r!==i&&B.$poolFloat32Array8(r)}_$doDraw(t,e,i,r){const s=this._$getTextData(),n=this.width,a=this.height;let o=0,h=0,l=0,_=0;if(this._$verticalAlign!==Pt.TOP&&this.height>this.textHeight)switch(this._$verticalAlign){case Pt.MIDDLE:_=(this.height-this.textHeight+2)/2;break;case Pt.BOTTOM:_=this.height-this.textHeight+2}const c=s.length;for(let u=0;u<c;++u){let c=s[u];if(0===c.width)continue;const d=o+c.x;if(this._$autoSize===It.NONE&&(h>a||d>n))continue;let g=c.textFormat;const p=B.$intToRGBA(c.textFormat._$color),f=$.max(0,$.min(255*p.A*i[3]+i[7],255))/255;if(t.fillStyle=`rgba(${p.R},${p.G},${p.B},${f})`,this._$thickness){const e=B.$intToRGBA(this._$thicknessColor),r=$.max(0,$.min(255*e.A*i[3]+i[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${r})`}const m=0|c.yIndex;switch(c.mode){case Nt.BREAK:case Nt.WRAP:if(l++,this.scrollV>l)continue;if(h+=this._$textHeightTable[m],o=this._$getAlignOffset(this._$objectTable[m],r),g._$underline){const r=c.textFormat._$size/12,s=B.$intToRGBA(g._$color),n=$.max(0,$.min(255*s.A*i[3]+i[7],255))/255;t.lineWidth=$.max(1,1/$.min(e[0],e[3])),t.strokeStyle=`rgba(${s.R},${s.G},${s.B},${n})`,t.beginPath(),t.moveTo(o,_+h-r),t.lineTo(o+this._$widthTable[m],_+h-r),t.stroke()}break;case Nt.TEXT:{if(this.scrollV>l)continue;let e=h-this._$heightTable[0];B.$isSafari||(e+=c.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=B.$generateFontStyle(g._$font,g._$size,g._$italic,g._$bold),this._$thickness&&t.strokeText(c.text,d,_+e),t.fillText(c.text,d,_+e)}break;case Nt.IMAGE:if(!c.loaded)continue;t.beginPath(),t.drawImage(c.image,c.hspace,_+c.y,c.width,c.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let r=e;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(r=B.$multiplicationMatrix(e,s));const n=this._$getBounds(null),a=B.$boundsMatrix(n,r),o=+a.xMax,h=+a.xMin,l=+a.yMax,_=+a.yMin;B.$poolBoundsObject(a),B.$poolBoundsObject(n);const c=$.ceil($.abs(o-h)),u=$.ceil($.abs(l-_));return t.setTransform(1,0,0,1,h,_),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,u),t.lineTo(0,u),t.lineTo(0,0),r!==e&&B.$poolFloat32Array6(r),t.isPointInPath(i.x,i.y)}_$createTextAreaElement(t){if(!this._$textarea){this._$textarea=a.createElement("textarea"),this._$textarea.value=this.text,this._$textarea.id=`${B.$PREFIX}_TextField_${this._$instanceId}`,this._$wordWrap||(this._$textarea.wrap="off");const t=this.defaultTextFormat,e=this._$textarea.style;if(e.position="absolute",e.outline="0",e.padding=`2px 2px 2px ${$.max(3,0|t.leftMargin)}px`,e.margin="0",e.appearance="none",e.resize="none",e.border=this._$border?`solid 1px #${this.borderColor.toString(16)}`:"none",e.overflow="hidden",e.zIndex=2147483647,e.verticalAlign="top",e.backgroundColor=this._$border||this._$background?`#${this.backgroundColor.toString(16)}`:"transparent",this._$textarea.addEventListener(`${B.$PREFIX}_blur`,(t=>{let e=t.target.value?t.target.value:"";if(e&&this._$restrict){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new u(t,"gm"));e=i?i.join(""):""}if(a.getElementById(B.$currentPlayer().contentElementId)){const t=a.getElementById(`${B.$PREFIX}_TextField_${this._$instanceId}`);t&&t.remove()}this.text=e,this._$focus=!1,this._$textAreaActive=!1,this._$doChanged(),B.$isUpdated=!0})),this._$textarea.addEventListener("input",(t=>{let e=t.target.value?t.target.value:"";if(this._$restrict&&!this._$isComposing&&e){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new u(t,"gm"));e=i?i.join(""):""}if(!this._$isComposing&&this.text!==e){this.text=e,t.target.value=e,this.willTrigger(O.CHANGE)&&this.dispatchEvent(new O(O.CHANGE,!0));const i=B.$currentPlayer(),r=this._$textarea,s=this._$transform.concatenatedMatrix,a=this._$getBounds(null);r.style.left=`${$.floor((s.tx+a.xMin+i._$tx/i._$scale/n)*i._$scale)}px`,r.style.top=`${$.floor((s.ty+a.yMin+i._$ty/i._$scale/n)*i._$scale)}px`,r.style.width=`${$.ceil((this.width-1)*i._$scale)}px`,r.style.height=`${$.ceil((this.height-1)*i._$scale)}px`}})),this._$textarea.addEventListener("compositionstart",(()=>{this._$isComposing=!0})),this._$textarea.addEventListener("compositionend",(t=>{this._$isComposing=!1;let e=t.target.value?t.target.value:"";if(!this._$restrict||!e)return;let i=this._$restrict;"["!==i[0]&&(i="["+i),"]"!==i[i.length-1]&&(i+="]");const r=e.match(new u(i,"gm"));e=r?r.join(""):"",this.text=e,t.target.value=e})),this._$textarea.addEventListener("click",(()=>{this.willTrigger(G.CLICK)&&this.dispatchEvent(new G(G.CLICK))})),this._$textarea.addEventListener(B.$MOUSE_WHEEL,(t=>{this.scrollV+=t.deltaY})),this._$textarea.addEventListener(B.$SCROLL,(()=>{if(this._$scrollEventLock)return void(this._$scrollEventLock=!1);const t=parseFloat(this._$textarea.style.height);this.scrollV=this._$textarea.scrollTop/(this._$textarea.scrollHeight-t)*this.maxScrollV+1})),!0===B.$isTouch)this._$textarea.addEventListener(B.$TOUCH_START,(()=>{const t=B.$currentPlayer();t&&(t._$state="down")})),this._$textarea.addEventListener(B.$TOUCH_END,(()=>{const t=B.$currentPlayer();t&&(t._$state="up")}));else this._$textarea.addEventListener(B.$MOUSE_DOWN,(()=>{const t=B.$currentPlayer();t&&(t._$state="down")})),this._$textarea.addEventListener(B.$MOUSE_UP,(()=>{const t=B.$currentPlayer();t&&(t._$state="up")}))}const e=this.defaultTextFormat,i=$.ceil(e.size*t*this._$transform.concatenatedMatrix.d);this._$textarea.style.fontSize=`${i}px`,this._$textarea.style.fontFamily=e.font,this._$textarea.style.lineHeight=(i+$.max(0,0|e.leading))/i+"em",this._$autoSize!==It.NONE?this._$textarea.style.textAlign=It.CENTER:this._$textarea.style.textAlign=e.align,this._$textarea.onkeydown||(this._$textarea.onkeydown=t=>{let e=t.target.value?t.target.value:"";if(this._$restrict&&!this._$isComposing&&e){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new u(t,"gm"));e=i?i.join(""):""}if(this._$isComposing||(this.text=e,t.target.value=e),13===t.keyCode&&!this._$multiline)return!1}),this._$textarea.maxLength=2147483647,this._$maxChars&&(this._$textarea.maxLength=this._$maxChars)}_$createWorkerInstance(){if(this._$created)return;this._$created=!0;const t=this._$getBounds(),e={command:"createTextField",instanceId:this._$instanceId,xMin:t.xMin,yMin:t.yMin,xMax:t.xMax,yMax:t.yMax,textData:this._$getTextData(),scrollV:this.scrollV,widthTable:this._$widthTable,heightTable:this._$heightTable,textHeightTable:this._$textHeightTable,objectTable:this._$objectTable,limitWidth:this.width,limitHeight:this.height,textHeight:this.textHeight,verticalAlign:this._$verticalAlign,autoSize:this._$autoSize};this._$characterId>-1&&(e.characterId=this._$characterId),this._$loaderInfo&&(e.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(e.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),B.$rendererWorker.postMessage(e)}_$postProperty(){const t=super._$postProperty();t.textAreaActive=this._$textAreaActive;const e=this._$getBounds(null);t.xMin=e.xMin,t.yMin=e.yMin,t.xMax=e.xMax,t.yMax=e.yMax,B.$poolBoundsObject(e),this._$isUpdated()&&(t.textData=this._$getTextData(),t.scrollV=this.scrollV,t.widthTable=this._$widthTable,t.heightTable=this._$heightTable,t.textHeightTable=this._$textHeightTable,t.objectTable=this._$objectTable,t.limitWidth=this.width,t.limitHeight=this.height,t.textHeight=this.textHeight,t.verticalAlign=this._$verticalAlign,t.autoSize=this._$autoSize,t.wordWrap=this._$wordWrap,t.border=this._$border,this._$border&&(t.borderColor=this._$borderColor),t.background=this._$background,this._$background&&(t.backgroundColor=this._$backgroundColor),t.thickness=this._$thickness,this._$thickness&&(t.thicknessColor=this._$backgroundColor)),B.$rendererWorker.postMessage(t),this._$posted=!0,this._$updated=!1}}class Ot{static toString(){return"[class TextFieldType]"}static get namespace(){return"next2d.text.TextFieldType"}toString(){return"[object TextFieldType]"}get namespace(){return"next2d.text.TextFieldType"}static get INPUT(){return"input"}static get STATIC(){return"static"}}class Lt{constructor(t=null,e=null,i=null,r=null,s=null,n=null,a=null,o=null,h=null,l=null,$=null,_=null){this._$font=t,this._$size=e,this._$color=null===i?null:B.$clamp(B.$toColorInt(i),0,16777215,16777215),this._$bold=r,this._$italic=s,this._$underline=n,this._$align=a,this._$leftMargin=o,this._$rightMargin=h,this._$indent=l,this._$leading=$,this._$blockIndent=_,this._$letterSpacing=0,this._$textField=null}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){switch(t){case wt.CENTER:case wt.RIGHT:case wt.LEFT:this._$align=t;break;default:this._$align=null}this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get bold(){return this._$bold}set bold(t){this._$bold=!!t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get color(){return this._$color}set color(t){this._$color=B.$clamp(B.$toColorInt(t),0,16777215,0),this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get font(){return this._$font}set font(t){this._$font=`${t}`,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get indent(){return this._$indent}set indent(t){this._$indent=t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get italic(){return this._$italic}set italic(t){this._$italic=!!t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get leading(){return this._$leading}set leading(t){this._$leading=t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get size(){return this._$size}set size(t){this._$size=0|t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}get underline(){return this._$underline}set underline(t){this._$underline=!!t,this._$textField&&(this._$textField._$doChanged(),B.$isUpdated=!0)}_$clone(){const t=new Lt(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t}_$setDefault(t=null){this._$align=wt.LEFT,this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="Times New Roman",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1,this._$textField=t}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t.color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){return this._$indent+this._$leftMargin+this._$rightMargin}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','sans-serif'`}}class Pt{static toString(){return"[class TextFormatVerticalAlign]"}static get namespace(){return"next2d.text.TextFormatVerticalAlign"}toString(){return"[object TextFormatVerticalAlign]"}get namespace(){return"next2d.text.TextFormatVerticalAlign"}static get TOP(){return"top"}static get MIDDLE(){return"middle"}static get BOTTOM(){return"bottom"}}class Nt{static get TEXT(){return"text"}static get BREAK(){return"break"}static get WRAP(){return"wrap"}static get IMAGE(){return"image"}}class kt extends L{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$buffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=B.$getArray(),this._$volume=1,this._$currentCount=0,this._$loopCount=0,this._$stopFlag=!0,this._$src=""}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loopCount(){return this._$loopCount}set loopCount(t){this._$loopCount=t}get src(){return this._$src}set src(t){this.load(new Xt(t))}get volume(){return this._$volume}set volume(t){this._$volume=$.min(Dt.volume,B.$clamp(t,0,1,1));const e=this._$sources.length;if(e&&B.$audioContext)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume}}clone(){const t=new kt;return t.volume=this.volume,t.loop=this.loop,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){this._$src=t.url,B.$ajax({format:Ht.ARRAY_BUFFER,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(O.OPEN)&&this.dispatchEvent(new O(O.OPEN)),this.willTrigger(V.PROGRESS)&&this.dispatchEvent(new V(V.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(V.PROGRESS)&&this.dispatchEvent(new V(V.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(V.PROGRESS)&&this.dispatchEvent(new V(V.PROGRESS,!1,!1,t.loaded,t.total)),199<t.target.status&&400>t.target.status?(this._$buffer=new Uint8Array(t.target.response),B.$audioContext?B.$decodeAudioData(this):B.$audios.push(this),B.$currentPlayer()._$loaders.push(this)):this.willTrigger(D.IO_ERROR)&&this.dispatchEvent(new D(D.IO_ERROR,!1,!1,t.target.statusText,t.target.status))}.bind(this)}})}play(t=0){const e=this._$character?this._$character.audioBuffer:this._$audioBuffer;if(B.$audioContext&&e)this._$createBufferSource(t);else{const e=function(t,i=0){if(null!==(this._$character?this._$character.audioBuffer:this._$audioBuffer)&&null!==B.$audioContext){const e=(m.now()-t)/1e3;return void this._$createBufferSource(i,e)}A(e)}.bind(this,m.now(),t);A(e)}}stop(){this._$stopFlag=!0;const t=this._$sources.length;if(t){const e=B.$currentPlayer();if(B.$audioContext)for(let e=0;e<t;++e){const t=this._$sources[e];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect()}e._$sources.splice(e._$sources.indexOf(this),1),this._$currentCount=0,this._$sources.length=0}}_$build(t,e){this._$character=e._$loaderInfo._$data.characters[t.characterId],this._$character.init||(this._$character.init=!0,this._$character.buffer=new Uint8Array(this._$character.buffer),B.$audioContext?B.$decodeAudioData(this):B.$audios.push(this)),this._$loopCount=0|t.loopCount,this._$volume=$.min(Dt.volume,t.volume)}_$createBufferSource(t=0,e=0){const i=B.$audioContext.createBufferSource();i._$startTime=t,i.onended=this._$endEventHandler.bind(this),i.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,i._$gainNode=B.$audioContext.createGain(),i._$gainNode.connect(B.$audioContext.destination);const r=$.min(Dt.volume,this._$volume);i._$gainNode.gain.value=r,i._$volume=r,i.connect(i._$gainNode),i.start(0|t,e);const s=B.$currentPlayer();-1===s._$sources.indexOf(this)&&s._$sources.push(this),this._$sources.push(i),this._$stopFlag=!1}_$endEventHandler(t){const e=t.target;if(this._$sources.splice(this._$sources.indexOf(e),1),!this._$stopFlag&&this._$loopCount>this._$currentCount)this._$createBufferSource(),this._$currentCount++;else{if(this._$currentCount=0,B.$audioContext&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),!this._$sources.length){const t=B.$currentPlayer();t._$sources.splice(t._$sources.indexOf(this),1)}this.willTrigger(O.SOUND_COMPLETE)&&this.dispatchEvent(new O(O.SOUND_COMPLETE))}}}class Dt{static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static get volume(){return B.$soundMixerVolume}static set volume(t){B.$soundMixerVolume=B.$clamp(t,0,1,1);const e=B.$currentPlayer()._$sources;for(let t=0;t<e.length;++t){const i=e[t];i._$gainNode.gain.value=$.min(B.$soundMixerVolume,i._$volume)}const i=B.$currentPlayer()._$videos;for(let t=0;t<i.length;++t){const e=i[t];e._$video.volume=$.min(e.volume,B.$soundMixerVolume)}}static stopAll(){const t=B.$currentPlayer(),e=t._$sources;for(;e.length;)e[0].stop();const i=t._$videos;for(let t=0;t<i.length;++t)i[t].pause()}}class Gt{constructor(t=1,e=!1){this._$volume=1,this._$loop=!1,this.volume=t,this.loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=!!t}get volume(){return this._$volume}set volume(t){this._$volume=B.$clamp(+t,0,1,0)}}class Vt extends q{constructor(t=0,e=0){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=B.$getBoundsObject(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$stop=!0,this._$wait=!1,this._$volume=1,this._$context=null}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=!!t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video?(this._$video.removeEventListener("canplaythrough",this._$start),this._$video.addEventListener("canplaythrough",this._$start)):this._$initializeVideo(),fetch(t).then((t=>t.arrayBuffer())).then((t=>{this._$video.src=URL.createObjectURL(new Blob([t],{type:"video/mp4"}))})),this._$video.load()}get videoHeight(){return this._$video?this._$video.videoHeight:this._$bounds.yMax}get videoWidth(){return this._$video?this._$video.videoWidth:this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=$.min(Dt.volume,B.$clamp(t,0,1,1)),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$video&&this._$video.pause(),this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause();b(this._$timerId),this._$timerId=-1,this.dispatchEvent(new H(H.PAUSE),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=B.$currentPlayer();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){if(this._$video&&this._$stop){this._$stop=!1,this._$video.volume=$.min(this._$volume,Dt.volume),this._$video.play();const t=A;this._$timerId=t(this._$update),this.dispatchEvent(new H(H.PLAY),!1,!1,this._$bytesLoaded,this._$bytesTotal);const e=B.$currentPlayer();-1===e._$videos.indexOf(this)&&e._$videos.push(this)}}seek(t){this._$video&&(this._$video.currentTime=t,this.dispatchEvent(new H(H.SEEK),!1,!1,this._$bytesLoaded,this._$bytesTotal))}_$initializeVideo(){this._$video=a.createElement("video"),this._$update=()=>{const t=B.$currentPlayer();if(!this._$stage){this._$video.pause();return b(this._$timerId),this._$timerId=-1,void t._$videos.splice(t._$videos.indexOf(this),1)}B.$rendererWorker&&this._$postProperty(),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this.dispatchEvent(new H(H.PROGRESS),!1,!1,this._$bytesLoaded,this._$bytesTotal),this._$doChanged());const e=A;this._$timerId=e(this._$update)},this._$sound=()=>{const t=B.$isTouch?B.$TOUCH_END:B.$MOUSE_UP;B.$currentPlayer()._$canvas.removeEventListener(t,this._$sound),this._$video.muted=!1},this._$video.muted=!0,this._$video.autoplay=!1,this._$video.crossOrigin="anonymous",this._$video.type="video/mp4",B.$isTouch&&this._$video.setAttribute("playsinline",""),this._$start=()=>{this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration;const t=B.$currentPlayer();if(B.$audioContext)this._$video.muted=!1;else{const e=B.$isTouch?B.$TOUCH_END:B.$MOUSE_UP;t._$canvas.addEventListener(e,this._$sound)}this._$autoPlay&&(-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$wait=!0,this._$doChanged()),this._$createContext()},this._$video.addEventListener("canplaythrough",this._$start),this._$video.addEventListener("ended",(()=>{if(this._$loop)return void(this._$video.currentTime=0);this.dispatchEvent(new H(H.PLAY_END),!1,!1,this._$bytesLoaded,this._$bytesTotal);b(this._$timerId),this._$timerId=-1}))}_$createContext(){if(B.$rendererWorker){const t=new v(this._$video.videoWidth,this._$video.videoHeight);this._$context=t.getContext("2d")}}_$buildCharacter(t){this._$loop=t.loop,this._$autoPlay=t.autoPlay,this._$bounds=t.bounds,this._$video||this._$initializeVideo(),this._$video.src=URL.createObjectURL(new Blob([new Uint8Array(t.buffer)],{type:"video/mp4"})),this._$video.volume=$.min(t.volume,Dt.volume),this._$video.load(),B.$rendererWorker&&this._$stage&&this._$createWorkerInstance()}_$sync(){const t=super._$sync();return t&&this._$buildCharacter(t),t}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$clip(t,e){let i=this._$bounds.xMax,r=this._$bounds.yMax;if(!i||!r)return;let s=e;const n=this._$transform._$rawMatrix();1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(s=B.$multiplicationMatrix(e,n)),B.$resetContext(t),t.setTransform(s[0],s[1],s[2],s[3],s[4],s[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,r),t.lineTo(0,r),t.lineTo(0,0),t.clip(!0),s!==e&&B.$poolFloat32Array6(s)}_$draw(t,e,i){if(!this._$visible||!this._$video)return;if(this._$wait){this._$stop=!1,this._$video.play(),this.dispatchEvent(new H(H.PLAY_START),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=A;this._$timerId=t(this._$update),this._$wait=!1}let r=i;const s=this._$transform._$rawColorTransform();1===s[0]&&1===s[1]&&1===s[2]&&1===s[3]&&0===s[4]&&0===s[5]&&0===s[6]&&0===s[7]||(r=B.$multiplicationColor(i,s));const n=B.$clamp(r[3]+r[7]/255,0,1,0);if(!n)return void(r!==i&&B.$poolFloat32Array8(r));let a=e;const o=this._$transform._$rawMatrix();1===o[0]&&0===o[1]&&0===o[2]&&1===o[3]&&0===o[4]&&0===o[5]||(a=B.$multiplicationMatrix(e,o));const h=B.$boundsMatrix(this._$bounds,a),l=+h.xMax,_=+h.xMin,c=+h.yMax,u=+h.yMin;B.$poolBoundsObject(h);let d=$.ceil($.abs(l-_)),g=$.ceil($.abs(c-u));switch(!0){case 0===d:case 0===g:case d===-F:case g===-F:case d===F:case g===F:return}const p=t._$frameBufferManager,f=p.currentAttachment;if(_>f.width||u>f.height)return;const m=this._$filters||this.filters;if(0>_+d||0>u+g){if(!(m&&m.length&&this._$canApply(m)))return;{const t=+$.sqrt(a[0]*a[0]+a[1]*a[1]),e=+$.sqrt(a[2]*a[2]+a[3]*a[3]);let i=new j(0,0,d,g);for(let r=0;r<m.length;++r)i=m[r]._$generateFilterRect(i,t,e);if(0>i.x+i.width||0>i.y+i.height)return}}const x=this._$blendMode||this.blendMode;let b=p.createTextureFromVideo(this._$video,this._$smoothing);if(m&&m.length&&this._$canApply(m)){const e=+$.sqrt(a[0]*a[0]+a[1]*a[1]),i=+$.sqrt(a[2]*a[2]+a[3]*a[3]);if(1!==e||1!==i){const r=p.currentAttachment,s=p.createCacheAttachment(d,g,!1);t._$bind(s),B.$resetContext(t);const n=B.$getFloat32Array6(e,0,0,i,d/2,g/2),a=B.$getFloat32Array6(1,0,0,1,-b.width/2,-b.height/2),o=B.$multiplicationMatrix(n,a);B.$poolFloat32Array6(n),B.$poolFloat32Array6(a),t.setTransform(o[0],o[1],o[2],o[3],o[4],o[5]),t.drawImage(b,0,0,b.width,b.height),p.releaseTexture(b),B.$poolFloat32Array6(o),b=p.getTextureFromCurrentAttachment(),p.releaseAttachment(s,!1),t._$bind(r)}b=this._$drawFilter(t,b,a,m,d,g),B.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=x;const s=B.$boundsMatrix(this._$bounds,a);t.setTransform(1,0,0,1,s.xMin-b._$offsetX,s.yMin-b._$offsetY),t.drawImage(b,0,0,b.width,b.height,r),B.$poolBoundsObject(s)}else B.$resetContext(t),t._$globalAlpha=n,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=x,t.setTransform(a[0],a[1],a[2],a[3],a[4],a[5]),t.drawImage(b,0,0,b.width,b.height,r),p.releaseTexture(b);a!==e&&B.$poolFloat32Array6(a),r!==i&&B.$poolFloat32Array8(r)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let r=e;const s=this._$transform._$rawMatrix();s!==B.$MATRIX_ARRAY_IDENTITY&&(r=B.$multiplicationMatrix(e,s));const n=this._$getBounds(null),a=B.$boundsMatrix(n,r),o=+a.xMax,h=+a.xMin,l=+a.yMax,_=+a.yMin;B.$poolBoundsObject(a),B.$poolBoundsObject(n);const c=$.ceil($.abs(o-h)),u=$.ceil($.abs(l-_));return t.setTransform(1,0,0,1,h,_),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,u),t.lineTo(0,u),t.lineTo(0,0),r!==e&&B.$poolFloat32Array6(r),t.isPointInPath(i.x,i.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();i!==B.$MATRIX_ARRAY_IDENTITY&&(e=B.$multiplicationMatrix(t,i));const r=B.$boundsMatrix(this._$bounds,e);return e!==t&&B.$poolFloat32Array6(e),r}return B.$getBoundsObject(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}_$createWorkerInstance(){if(this._$created)return;this._$created=!0;const t={command:"createVideo",instanceId:this._$instanceId,smoothing:this._$smoothing,xMin:this._$bounds.xMin,yMin:this._$bounds.yMin,xMax:this._$bounds.xMax,yMax:this._$bounds.yMax};this._$characterId>-1&&(t.characterId=this._$characterId),this._$loaderInfo&&(t.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(t.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),B.$rendererWorker.postMessage(t)}_$postProperty(){if(this._$wait){this._$stop=!1,this._$video.play(),this.dispatchEvent(new H(H.PLAY_START),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=A;this._$timerId=t(this._$update),this._$wait=!1}const t=super._$postProperty();t.smoothing=this._$smoothing;const e=B.$getArray(),i=this._$context;if(i){t.xMin=this._$bounds.xMin,t.yMin=this._$bounds.yMin,t.xMax=this._$bounds.xMax,t.yMax=this._$bounds.yMax,i.drawImage(this._$video,0,0);const r=i.canvas.transferToImageBitmap();t.imageBitmap=r,e.push(r)}B.$rendererWorker.postMessage(t,e),B.$poolArray(e),this._$posted=!0,this._$updated=!1}}class Ht{static toString(){return"[class URLLoaderDataFormat]"}static get namespace(){return"next2d.net.URLLoaderDataFormat"}toString(){return"[object URLLoaderDataFormat]"}get namespace(){return"next2d.net.URLLoaderDataFormat"}static get ARRAY_BUFFER(){return"arraybuffer"}static get JSON(){return"json"}}class Xt{constructor(t=""){this._$url=t,this._$contentType="application/json",this._$data=null,this._$method=zt.GET,this._$requestHeaders=B.$getArray(),this._$responseDataFormat=Ht.JSON,this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){switch((t+="").toUpperCase()){case zt.DELETE:case zt.HEAD:case zt.OPTIONS:case zt.POST:case zt.PUT:this._$method=t;break;default:this._$method=zt.GET}}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){_.isArray(t)&&(this._$requestHeaders=t)}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=B.$currentPlayer();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get responseDataFormat(){return this._$responseDataFormat}set responseDataFormat(t){this._$responseDataFormat=`${t}`}get withCredentials(){return this._$withCredentials}get headers(){const t=B.$getMap();t.set("Content-Type",`${this._$contentType}`);const e=this._$requestHeaders.length;for(let i=0;i<e;++i){const e=this._$requestHeaders[i];e instanceof Yt&&t.set(e.name,e.value)}return t}}class Yt{constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}get value(){return this._$value}}class zt{static toString(){return"[class URLRequestMethod]"}static get namespace(){return"next2d.net.URLRequestMethod"}toString(){return"[object URLRequestMethod]"}get namespace(){return"next2d.net.URLRequestMethod"}static get DELETE(){return"DELETE"}static get GET(){return"GET"}static get HEAD(){return"HEAD"}static get OPTIONS(){return"OPTIONS"}static get POST(){return"POST"}static get PUT(){return"PUT"}}class jt{static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,r){return t/r*i+e}static inQuad(t,e,i,r){return(t/=r)*t*i+e}static outQuad(t,e,i,r){return-(t/=r)*(t-2)*i+e}static inOutQuad(t,e,i,r){return(t/=r/2)<1?t*t*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,r){return(t/=r)*t*t*i+e}static outCubic(t,e,i,r){return t/=r,(--t*t*t+1)*i+e}static inOutCubic(t,e,i,r){return(t/=r/2)<1?t*t*t*i/2+e:((t-=2)*t*t+2)*i/2+e}static inQuart(t,e,i,r){return(t/=r)*t*t*t*i+e}static outQuart(t,e,i,r){return t/=r,(--t*t*t*t-1)*-i+e}static inOutQuart(t,e,i,r){return(t/=r/2)<1?t*t*t*t*i/2+e:((t-=2)*t*t*t-2)*-i/2+e}static inQuint(t,e,i,r){return(t/=r)*t*t*t*t*i+e}static outQuint(t,e,i,r){return t/=r,(--t*t*t*t*t+1)*i+e}static inOutQuint(t,e,i,r){return(t/=r/2)<1?t*t*t*t*t*i/2+e:((t-=2)*t*t*t*t+2)*i/2+e}static inSine(t,e,i,r){return-i*$.cos(t/r*($.PI/2))+i+e}static outSine(t,e,i,r){return i*Math.sin(t/r*(Math.PI/2))+e}static inOutSine(t,e,i,r){return-i/2*(Math.cos(Math.PI*t/r)-1)+e}static inExpo(t,e,i,r){return i*Math.pow(2,10*(t/r-1))+e}static outExpo(t,e,i,r){return i*(1-Math.pow(2,-10*t/r))+e}static inOutExpo(t,e,i,r){return(t/=r/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*(t-1)))+e}static inCirc(t,e,i,r){return(1-Math.sqrt(1-(t/=r)*t))*i+e}static outCirc(t,e,i,r){return t/=r,Math.sqrt(1- --t*t)*i+e}static inOutCirc(t,e,i,r){return(t/=2*r)<1?(Math.sqrt(1-t*t)-1)/-2*i+e:(Math.sqrt(1-(t-=2)*t)+1)/2*i+e}static inBack(t,e,i,r){return(2.70158*(t/=r)*t*t-1.70158*t*t)*i+e}static outBack(t,e,i,r){return(1+2.70158*Math.pow((t/=r)-1,3)+1.70158*Math.pow(t-1,2))*i+e}static inOutBack(t,e,i,r){let s=1.70158;return(t/=r/2)<1?t*t*((1+(s*=1.525))*t-s)*i/2+e:((t-=2)*t*((1+(s*=1.525))*t+s)+2)*i/2+e}static inElastic(t,e,i,r){return 0==(t/=r)?e:1===t?i+e:-Math.pow(2,(t*=10)-10)*Math.sin((t-10.75)*(2*Math.PI/3))*i+e}static outElastic(t,e,i,r){return 0==(t/=r)?e:1===t?i+e:(Math.pow(2,-10*t)*Math.sin((10*t-.75)*(2*Math.PI/3))+1)*i+e}static inOutElastic(t,e,i,r){return 0==(t/=r)?e:1===t?i+e:t<.5?-Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2*i+e:(Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2+1)*i+e}static outBounce(t,e,i,r){return(t/=r)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,r){return i-jt.outBounce(r-t,0,i,r)+e}static inOutBounce(t,e,i,r){return t<r/2?jt.inBounce(2*t,e,i/2,r):jt.outBounce(2*t-r,e+i/2,i/2,r)}}class Wt extends L{constructor(t,e=null,i=null,r=0,s=1,n=null){super(),this._$target=t,this._$delay=r,this._$duration=s,this._$ease=n||jt.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$forceStop=!1,this._$to=i,this._$update=null}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$forceStop||(this._$stopFlag=!1,this._$startTime=m.now(),this._$update=this.update.bind(this),this._$names=this.entries(this._$from),this.addEventListener(O.ENTER_FRAME,this._$update))}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],r=i[1];r&&"object"==typeof r&&(i[1]=this.entries(r))}return e}start(){if(this._$delay){y(function(){this.initialize()}.bind(this),1e3*this._$delay)}else this.initialize()}stop(){this._$forceStop=!0,this._$stopFlag=!0,this.removeEventListener(O.ENTER_FRAME,this._$update),this.hasEventListener(O.STOP)&&this.dispatchEvent(new O(O.STOP))}update(){this._$stopFlag?this.removeEventListener(O.ENTER_FRAME,this._$update):(this._$currentTime=.001*(m.now()-this._$startTime),this.updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener(O.UPDATE)&&this.dispatchEvent(new O(O.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener(O.ENTER_FRAME,this._$update),this.hasEventListener(O.COMPLETE)&&this.dispatchEvent(new O(O.COMPLETE))))}updateProperty(t,e,i,r){for(let s=0;s<r.length;++s){const n=r[s],a=n[0],o=n[1];if(o&&"object"==typeof o){this.updateProperty(t[a],e[a],i[a],o);continue}const h=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,h,i[a]-h,this._$duration):t[a]=i[a]}}}class qt{static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,r=0,s=1,n=null){return new Wt(t,e,i,r,s,n)}}class Kt{constructor(){this._$pool=[],this._$store=new Map,this._$timerMap=new Map,this._$context=null,this._$delayBitmapLifeCheck=this.bitmapLifeCheck.bind(this)}reset(){const t=this._$store.values();for(const e of t){const t=e.values();for(const e of t)this.destroy(e);B.$poolMap(e)}this._$store.clear()}destroy(t){if(t)switch(t.constructor){case E:if(!this._$context)return;A((()=>{const e=t._$bitmapData;if(e&&!e._$buffer){e._$getPixelsAsync(0,0,e.width,e.height,"RGBA"),t._$bitmapData=!1;y(this._$delayBitmapLifeCheck,2e3,e)}this._$context.frameBuffer.releaseTexture(t)}));break;case T:{const e=t.canvas,i=e.width,r=e.height;t.clearRect(0,0,i+1,r+1),e.width=e.height=1,this._$pool.push(e)}}}getCanvas(){return this._$pool.pop()||a.createElement("canvas")}remove(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t);i.has(e)&&(i.delete(e),i.size||(B.$poolMap(i),this._$store.delete(t)))}clearTimer(t){if(t=`${t}`,this._$timerMap.has(t)){x(this._$timerMap.get(t)),this._$timerMap.delete(t)}}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const t of e.values())this.destroy(t);e.clear(),B.$poolMap(e),this._$store.delete(t)}this.clearTimer(t)}setRemoveTimer(t){if(t=`${t}`,this.clearTimer(t),this._$store.has(t)){const e=y((()=>{this.removeCache(t)}),5e3);this._$timerMap.set(t,e)}}generateLifeKey(t,e){return`${t}:${e}`}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){this._$timerMap.has(e)&&this.clearTimer(e);const t=this._$store.get(e);if(t.has(i))return t.get(i)}return null}set(t,e=null){const i=`${t[0]}`,r=`${t[1]}`;this._$store.has(i)||this._$store.set(i,B.$getMap());const s=this._$store.get(i);if(!e)return s.delete(r),void(s.size||(B.$poolMap(s),this._$store.delete(i)));const n=s.get(r);n&&n!==e&&this.destroy(n),s.set(r,e)}has(t){const e=`${t[0]}`;return!!this._$store.has(e)&&this._$store.get(e).has(`${t[1]}`)}bitmapLifeCheck(t){if(!t._$pixelBuffer)return;const e=this._$context;e&&(t._$buffer=e.pbo.getBufferSubDataAsync(t._$pixelBuffer),t._$pixelBuffer=null)}generateKeys(t,e=null,i=null){let r="";e&&(r+=`${e.join("_")}`),i&&(r+=this.colorToString(i));const s=B.$getArray();return s[1]=r?this.generateHash(r):"_0",s[0]=`${t}`,s}colorToString(t=null){return t&&0!==t[7]?`_${t[7]}`:""}generateHash(t){let e=0;const i=t.length;for(let r=0;r<i;r++){e=(e<<5)-e+t.charCodeAt(r),e|=0}return`_${e}`}}class Qt{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n`}}class Jt{static SOLID_COLOR(){return"#version 300 es\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\nout vec4 o_color;\n\nvoid main() {\n    o_color = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n"}static BITMAP_CLIPPED(){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = texture(u_texture, uv);\n    ${Qt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    o_color = src;\n}`}static BITMAP_PATTERN(){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = texture(u_texture, uv);\n    ${Qt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    o_color = src;\n}`}static MASK(){return"#version 300 es\nprecision mediump float;\n\nin vec2 v_bezier;\nout vec4 o_color;\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        o_color = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n"}}class Zt{static TEMPLATE(t,e){let i;switch(t){case it.SUBTRACT:i=this.FUNCTION_SUBTRACT();break;case it.MULTIPLY:i=this.FUNCTION_MULTIPLY();break;case it.LIGHTEN:i=this.FUNCTION_LIGHTEN();break;case it.DARKEN:i=this.FUNCTION_DARKEN();break;case it.OVERLAY:i=this.FUNCTION_OVERLAY();break;case it.HARDLIGHT:i=this.FUNCTION_HARDLIGHT();break;case it.DIFFERENCE:i=this.FUNCTION_DIFFERENCE();break;case it.INVERT:i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${e?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${i}\n\nvoid main() {\n    vec4 dst = texture(u_textures[0], v_coord);\n    vec4 src = texture(u_textures[1], v_coord);\n    ${e?Qt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}class te{static TEMPLATE(t,e,i,r,s){const n=i?this.STATEMENT_GRADIENT_TYPE_RADIAL(e,r):this.STATEMENT_GRADIENT_TYPE_LINEAR(e);let a;switch(s){case"reflect":a="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":a="fract(t)";break;default:a="clamp(t, 0.0, 1.0)"}return`#version 300 es\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${t}];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 p = v_uv;\n    ${n}\n    t = ${a};\n    o_color = texture(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}class ee{static TEMPLATE(t,e,i){let r="";for(let t=1;t<e;t++){const i=t-1,s=t,n=`u_mediump[${e+$.floor(i/4)}][${i%4}]`,a=`u_mediump[${e+$.floor(s/4)}][${s%4}]`;r+=`\n    if (t <= ${a}) {\n        return mix(${`u_mediump[${i}]`}, ${`u_mediump[${s}]`}, (t - ${n}) / (${a} - ${n}));\n    }\n`}return`#version 300 es\nprecision mediump float;\n\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${e}][0]) {\n        return u_mediump[0];\n    }\n    ${r}\n    return u_mediump[${e-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${i?"color = pow(color, vec4(0.45454545));":""}\n    color.rgb *= color.a;\n\n    o_color = color;\n}\n\n`}}class ie{static TEMPLATE(t){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${t?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec4 src = texture(u_texture, v_coord);\n    ${t?Qt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = src;\n}\n\n`}}class re{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getBitmapShader(){return this._$collection.has("b")||this._$collection.set("b",new Le(this._$gl,this._$context,$e.TEXTURE(),ie.TEMPLATE(0,0,!1))),this._$collection.get("b")}setBitmapUniform(){}setGetPixelsUniform(t,e,i,r,s){const n=t.highp;n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n[12]=e,n[13]=0,n[14]=0,n[16]=0,n[17]=i,n[18]=0,n[3]=r,n[7]=s,n[11]=1}setSetPixelsUniform(t,e,i,r,s,n,a,o,h){const l=t.highp;l[0]=e,l[1]=0,l[2]=0,l[4]=0,l[5]=i,l[6]=0,l[8]=r,l[9]=s,l[10]=1,l[12]=n,l[13]=0,l[14]=0,l[16]=0,l[17]=a,l[18]=0,l[3]=o,l[7]=h,l[11]=1}setColorTransformUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4]/255,i[5]=e[5]/255,i[6]=e[6]/255,i[7]=e[7]/255}setManipulatePixelsUniform(t,e,i,r,s,n){const a=t.highp;a[0]=e[0],a[1]=e[1],a[2]=e[2],a[4]=e[3],a[5]=e[4],a[6]=e[5],a[8]=e[6],a[9]=e[7],a[10]=e[8],s?(a[12]=r[0],a[13]=r[1],a[14]=r[2],a[16]=r[3],a[17]=r[4],a[18]=r[5],a[20]=r[6],a[21]=r[7],a[22]=r[8],a[24]=n[0],a[25]=n[1],a[26]=n[2],a[3]=n[3],a[7]=n[4],a[11]=n[5],a[15]=n[6],a[19]=n[7],a[23]=n[8]):i&&(a[12]=r[0],a[13]=r[1],a[14]=r[2],a[16]=r[3],a[17]=r[4],a[18]=r[5],a[3]=r[6],a[7]=r[7],a[11]=r[8])}setCopyChannelUniform(t,e,i){const r=t.textures;r[0]=0,r[1]=1;const s=t.mediump;s[0]=1&e,s[1]=e>>1&1,s[2]=e>>2&1,s[3]=e>>3&1,s[4]=1&i,s[5]=i>>1&1,s[6]=i>>2&1,s[7]=i>>3&1}setCopyPixelsUniform(t,e){if(e){const e=t.textures;e[0]=0,e[1]=1}}setFillRectUniform(t,e,i,r,s){const n=t.mediump;n[0]=e,n[1]=i,n[2]=r,n[3]=s}setGetColorBoundsRectUniform(t,e,i,r,s,n){const a=t.highp;a[0]=1,a[1]=0,a[2]=0,a[4]=0,a[5]=1,a[6]=0,a[8]=0,a[9]=0,a[10]=1,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[16]=e[3],a[17]=e[4],a[18]=e[5],a[3]=e[6],a[7]=e[7],a[11]=e[8];const o=t.mediump;o[0]=i[0],o[1]=i[1],o[2]=r;const h=t.integer;h[0]=s[0],h[1]=s[1],h[2]=s[2],h[3]=s[3],h[4]=n[0],h[5]=n[1],h[6]=n[2],h[7]=n[3]}setMergeUniform(t,e,i,r,s){const n=t.textures;n[0]=0,n[1]=1;const a=t.mediump;a[0]=e,a[1]=i,a[2]=r,a[3]=s}setNoiseUniform(t,e,i,r,s,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=r,u[3]=s,u[4]=n,u[5]=a,u[6]=o,u[7]=h,u[8]=l,u[9]=$,u[10]=_,u[11]=c}setPaletteMapUniform(t){const e=t.textures;e[0]=0,e[1]=2}setPixelDissolveUniform(t,e,i,r,s){const n=t.mediump;n[0]=e,n[1]=i,n[2]=r,n[3]=s}setFlushSetPixelQueueUniform(t){const e=t.highp;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=-1,e[5]=0,e[6]=0,e[7]=1,e[8]=1}setThresholdUniform(t,e,i,r,s,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=r,u[3]=s,u[4]=n,u[5]=a,u[6]=o,u[7]=h;const d=t.integer;d[0]=l,d[1]=$,d[2]=_,d[3]=c}}class se{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getNormalBlendShader(t){const e="n"+(t?"y":"n");return this._$collection.has(e)||this._$collection.set(e,new Le(this._$gl,this._$context,$e.BLEND(),ie.TEMPLATE(t))),this._$collection.get(e)}getClipShader(){return this._$collection.has("c")||this._$collection.set("c",new Le(this._$gl,this._$context,$e.BLEND_CLIP(),ie.TEMPLATE(!1))),this._$collection.get("c")}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;return this._$collection.has(i)||this._$collection.set(i,new Le(this._$gl,this._$context,$e.BLEND(),Zt.TEMPLATE(t,e))),this._$collection.get(i)}setNormalBlendUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,p){const f=t.highp;if(f[0]=e,f[1]=i,f[2]=r,f[3]=s,f[4]=n[0],f[5]=n[1],f[6]=n[2],f[8]=n[3],f[9]=n[4],f[10]=n[5],f[12]=n[6],f[13]=n[7],f[14]=n[8],f[7]=a,f[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=p}}setClipUniform(t,e,i,r,s,n,a,o){const h=t.highp;h[0]=e,h[1]=i,h[2]=r,h[3]=s,h[4]=n[0],h[5]=n[1],h[6]=n[2],h[8]=n[3],h[9]=n[4],h[10]=n[5],h[12]=n[6],h[13]=n[7],h[14]=n[8],h[7]=a,h[11]=o}setBlendUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,p){const f=t.textures;f[0]=0,f[1]=1;const m=t.highp;if(m[0]=e,m[1]=i,m[2]=r,m[3]=s,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=p}}}class ne{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getBlurFilterShader(t){const e=`b${t}`;return this._$collection.has(e)||this._$collection.set(e,new Le(this._$gl,this._$context,$e.TEXTURE(),ue.TEMPLATE(t))),this._$collection.get(e)}getBitmapFilterShader(t,e,i,r,s,n,a){const o=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${r}${s?"y":"n"}${n?"y":"n"}`;if(!this._$collection.has(o)){let h=1;t&&h++,a&&h++;let l=(t?4:0)+(e?4:0)+(n?1:0);a||(l+=i?4:8),l=$.ceil(l/4),this._$collection.set(o,new Le(this._$gl,this._$context,$e.TEXTURE(),fe.TEMPLATE(h,l,t,e,i,r,s,n,a)))}return this._$collection.get(o)}getColorMatrixFilterShader(){return this._$collection.has("m")||this._$collection.set("m",new Le(this._$gl,this._$context,$e.TEXTURE(),de.TEMPLATE())),this._$collection.get("m")}getConvolutionFilterShader(t,e,i,r){const s=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${r?"y":"n"}`;if(!this._$collection.has(s)){const n=(r?1:2)+$.ceil(t*e/4);this._$collection.set(s,new Le(this._$gl,this._$context,$e.TEXTURE(),ge.TEMPLATE(n,t,e,i,r)))}return this._$collection.get(s)}getDisplacementMapFilterShader(t,e,i){const r=`d${t}${e}${i}`;if(!this._$collection.has(r)){const s=i===vt.COLOR?3:2;this._$collection.set(r,new Le(this._$gl,this._$context,$e.TEXTURE(),pe.TEMPLATE(s,t,e,i)))}return this._$collection.get(r)}setBlurFilterUniform(t,e,i,r,s,n){const a=t.mediump;r?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=s,a[3]=n}setBitmapFilterUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,p,f,m,x,b,T,v,y,A){let M;T?(M=t.textures,M[0]=0,M[1]=1,A&&(M[2]=2)):A&&(M=t.textures,M[0]=0,M[1]=2);const E=t.mediump;let C=0;T&&(E[C]=e/r,E[C+1]=i/s,E[C+2]=n/r,E[C+3]=(i-s-a)/s,C+=4),v&&(E[C]=e/o,E[C+1]=i/h,E[C+2]=l/o,E[C+3]=(i-h-$)/h,C+=4),A||(_?(E[C]=u,E[C+1]=d,E[C+2]=g,E[C+3]=p,C+=4):(E[C]=u,E[C+1]=d,E[C+2]=g,E[C+3]=p,E[C+4]=f,E[C+5]=m,E[C+6]=x,E[C+7]=b,C+=8)),y&&(E[C++]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,r,s,n,a,o,h,l,$){const _=t.mediump;_[0]=1/e,_[1]=1/i,_[2]=1/s,_[3]=n/255;let c=4;a||(_[c]=o,_[c+1]=h,_[c+2]=l,_[c+3]=$,c+=4);const u=r.length;for(let t=0;t<u;t++)_[c++]=r[t]}setDisplacementMapFilterUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=r/e,g[1]=s/i,g[2]=n/e,g[3]=(s-i-a)/i,g[4]=o/r,g[5]=-h/s,l===vt.COLOR&&(g[8]=$,g[9]=_,g[10]=c,g[11]=u)}}class ae{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=$.ceil(5*t/4);this._$collection.set(i,new Le(this._$gl,this._$context,$e.TEXTURE(),ee.TEMPLATE(r,t,e)))}return this._$collection.get(i)}setGradientLUTUniformForShape(t,e,i,r,s){let n=0;const a=t.mediump;for(let t=i;t<r;t++){const i=e[t][1];a[n++]=s[i[0]],a[n++]=s[i[1]],a[n++]=s[i[2]],a[n++]=s[i[3]]}for(let t=i;t<r;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,r,s,n){let a=0;const o=t.mediump;for(let t=s;t<n;t++){const e=i[t];o[a++]=(e>>16)/255,o[a++]=(e>>8&255)/255,o[a++]=(255&e)/255,o[a++]=r[t]}for(let t=s;t<n;t++)o[a++]=e[t]}}class oe{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getGradientShapeShader(t,e,i,r,s){const n=this.createCollectionKey(t,e,i,r,s);if(!this._$collection.has(n)){let a=(e?13:5)+(t?1:0)+1;const o=a-1;let h;h=t?ce.TEMPLATE(a,o,!0,e):_e.TEMPLATE(a,!0,!1,e),this._$collection.set(n,new Le(this._$gl,this._$context,h,te.TEMPLATE(a,o,i,r,s)))}return this._$collection.get(n)}createCollectionKey(t,e,i,r,s){const n=t?"y":"n",a=e?"y":"n",o=i?"y":"n",h=i&&r?"y":"n";let l=0;switch(s){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${o}${h}${l}`}setGradientShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=o[0],d[13]=o[1],d[14]=o[2],d[16]=o[3],d[17]=o[4],d[18]=o[5],d[11]=o[6],d[15]=o[7],d[19]=o[8],d[3]=h,d[7]=l;let g=20;n&&(d[g]=$.parentMatrixA,d[g+1]=$.parentMatrixB,d[g+2]=$.parentMatrixC,d[g+4]=$.parentMatrixD,d[g+5]=$.parentMatrixE,d[g+6]=$.parentMatrixF,d[g+8]=$.parentMatrixG,d[g+9]=$.parentMatrixH,d[g+10]=$.parentMatrixI,d[g+12]=$.ancestorMatrixA,d[g+13]=$.ancestorMatrixB,d[g+14]=$.ancestorMatrixC,d[g+16]=$.ancestorMatrixD,d[g+17]=$.ancestorMatrixE,d[g+18]=$.ancestorMatrixF,d[g+20]=$.ancestorMatrixG,d[g+21]=$.ancestorMatrixH,d[g+22]=$.ancestorMatrixI,d[g+11]=$.parentViewportX,d[g+15]=$.parentViewportY,d[g+19]=$.parentViewportW,d[g+23]=$.parentViewportH,d[g+24]=$.minXST,d[g+25]=$.minYST,d[g+26]=$.minXPQ,d[g+27]=$.minYPQ,d[g+28]=$.maxXST,d[g+29]=$.maxYST,d[g+30]=$.maxXPQ,d[g+31]=$.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=r,d[g+2]=s,g+=4),_?(d[g]=c[5],d[g+1]=u):(d[g]=c[0],d[g+1]=c[1],d[g+2]=c[2],d[g+3]=c[3])}}class he{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=new Map}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=(e?8:3)+(t?1:0),s=r;let n;n=t?ce.TEMPLATE(r,s,!1,!1,e):_e.TEMPLATE(r,!1,!1,e),this._$collection.set(i,new Le(this._$gl,this._$context,n,Jt.SOLID_COLOR()))}return this._$collection.get(i)}getBitmapShapeShader(t,e,i){const r=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(!this._$collection.has(r)){const s=(i?13:5)+(t?1:0),n=s;let a;a=t?ce.TEMPLATE(s,n,!0,!1,i):_e.TEMPLATE(s,!0,!1,i);const o=e?Jt.BITMAP_PATTERN():Jt.BITMAP_CLIPPED();this._$collection.set(r,new Le(this._$gl,this._$context,a,o))}return this._$collection.get(r)}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=(e?8:3)+(t?1:0),s=r;let n;n=t?ce.TEMPLATE(r,s,!1,!0,e):_e.TEMPLATE(r,!1,!0,e),this._$collection.set(i,new Le(this._$gl,this._$context,n,Jt.MASK()))}return this._$collection.get(i)}setSolidColorShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_){const c=t.highp;let u;n?(c[0]=l.parentMatrixA,c[1]=l.parentMatrixB,c[2]=l.parentMatrixC,c[4]=l.parentMatrixD,c[5]=l.parentMatrixE,c[6]=l.parentMatrixF,c[8]=l.parentMatrixG,c[9]=l.parentMatrixH,c[10]=l.parentMatrixI,c[12]=l.ancestorMatrixA,c[13]=l.ancestorMatrixB,c[14]=l.ancestorMatrixC,c[16]=l.ancestorMatrixD,c[17]=l.ancestorMatrixE,c[18]=l.ancestorMatrixF,c[20]=l.ancestorMatrixG,c[21]=l.ancestorMatrixH,c[22]=l.ancestorMatrixI,c[3]=o,c[7]=h,c[11]=l.parentViewportX,c[15]=l.parentViewportY,c[19]=l.parentViewportW,c[23]=l.parentViewportH,c[24]=l.minXST,c[25]=l.minYST,c[26]=l.minXPQ,c[27]=l.minYPQ,c[28]=l.maxXST,c[29]=l.maxYST,c[30]=l.maxXPQ,c[31]=l.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=o,c[7]=h,u=12),e&&(c[u]=i,c[u+1]=r,c[u+2]=s);const d=t.mediump;d[0]=$[0],d[1]=$[1],d[2]=$[2],d[3]=$[3]*_}setBitmapShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,p,f,m,x,b){const T=t.highp;let v;T[0]=a[0],T[1]=a[1],T[2]=a[2],T[4]=a[3],T[5]=a[4],T[6]=a[5],T[8]=a[6],T[9]=a[7],T[10]=a[8],T[12]=o[0],T[13]=o[1],T[14]=o[2],T[16]=o[3],T[17]=o[4],T[18]=o[5],T[11]=o[6],T[15]=o[7],T[19]=o[8],T[3]=h,T[7]=l,v=20,n&&(T[v]=$.parentMatrixA,T[v+1]=$.parentMatrixB,T[v+2]=$.parentMatrixC,T[v+4]=$.parentMatrixD,T[v+5]=$.parentMatrixE,T[v+6]=$.parentMatrixF,T[v+8]=$.parentMatrixG,T[v+9]=$.parentMatrixH,T[v+10]=$.parentMatrixI,T[v+12]=$.ancestorMatrixA,T[v+13]=$.ancestorMatrixB,T[v+14]=$.ancestorMatrixC,T[v+16]=$.ancestorMatrixD,T[v+17]=$.ancestorMatrixE,T[v+18]=$.ancestorMatrixF,T[v+20]=$.ancestorMatrixG,T[v+21]=$.ancestorMatrixH,T[v+22]=$.ancestorMatrixI,T[v+11]=$.parentViewportX,T[v+15]=$.parentViewportY,T[v+19]=$.parentViewportW,T[v+23]=$.parentViewportH,T[v+24]=$.minXST,T[v+25]=$.minYST,T[v+26]=$.minXPQ,T[v+27]=$.minYPQ,T[v+28]=$.maxXST,T[v+29]=$.maxYST,T[v+30]=$.maxXPQ,T[v+31]=$.maxYPQ,v=52),e&&(T[v]=i,T[v+1]=r,T[v+2]=s);const y=t.mediump;y[0]=_,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=p,y[8]=f,y[9]=m,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.highp;e?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=_,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=r,d[2]=s,d[4]=n,d[5]=a,d[6]=o,d[8]=h,d[9]=l,d[10]=$,d[3]=_,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const r=t.highp;r[0]=1,r[1]=0,r[2]=0,r[4]=0,r[5]=1,r[6]=0,r[8]=0,r[9]=0,r[10]=1,r[3]=e,r[7]=i}}class le{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class $e{static TEXTURE(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n"}static BLEND(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}static BLEND_CLIP(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}}class _e{static TEMPLATE(t,e,i,r){const s=i?this.ATTRIBUTE_BEZIER_ON():"",n=i?this.VARYING_BEZIER_ON():e?this.VARYING_UV_ON():"",a=i?this.STATEMENT_BEZIER_ON():e?this.STATEMENT_UV_ON():"";return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n${s}\n\nuniform vec4 u_highp[${t}];\n\n${n}\n\n${r?le.FUNCTION_GRID_ON(e?5:0):le.FUNCTION_GRID_OFF()}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${a}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(){return"\nlayout (location = 1) in vec2 a_bezier;\n"}static VARYING_UV_ON(){return"\nout vec2 v_uv;\n"}static VARYING_BEZIER_ON(){return"\nout vec2 v_bezier;\n"}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class ce{static TEMPLATE(t,e,i,r){const s=e-1,n=i?this.VARYING_UV_ON():"",a=i?this.STATEMENT_UV_ON():"";return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\nlayout (location = 1) in vec2 a_option1;\nlayout (location = 2) in vec2 a_option2;\nlayout (location = 3) in float a_type;\n\nuniform vec4 u_highp[${t}];\n\n${n}\n\n${r?le.FUNCTION_GRID_ON(i?5:0):le.FUNCTION_GRID_OFF()}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${s}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${s}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${s}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // 線分\n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // スクエア線端\n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // マイター結合（線分Bの凸側）\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // マイター結合（線分Aの凸側）\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // マイター結合（線分Aの凹側）\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // マイター結合（線分Bの凹側）\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // ラウンド結合\n        float face = u_highp[${s}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${a}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(){return"\nout vec2 v_uv;\n"}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class ue{static TEMPLATE(t){const e=t.toFixed(1);return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = texture(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${e}; i += 1.0) {\n        color += texture(u_texture, v_coord + offset * i);\n        color += texture(u_texture, v_coord - offset * i);\n    }\n    color += texture(u_texture, v_coord + offset * ${e}) * fraction;\n    color += texture(u_texture, v_coord - offset * ${e}) * fraction;\n    color /= samples;\n\n    o_color = color;\n}\n\n`}}class de{static TEMPLATE(){return"#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = texture(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    o_color = color;\n}\n\n"}}class ge{static TEMPLATE(t,e,i,r,s){const n=$.floor(.5*e),a=$.floor(.5*i),o=e*i;let h="";const l=s?1:2;for(let t=0;t<o;++t){h+=`\n    result += getWeightedColor(${t}, u_mediump[${l+$.floor(t/4)}][${t%4}]);\n`}const _=r?"result.a = texture(u_texture, v_coord).a;":"",c=s?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${Qt.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${e};\n    int i_mod_x = i - ${e} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${n}, ${a} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = texture(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${c}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${h}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${_}\n\n    result.rgb *= result.a;\n    o_color = result;\n}\n\n`}}class pe{static TEMPLATE(t,e,i,r){let s,n,a;switch(e){case et.RED:s="map_color.r";break;case et.GREEN:s="map_color.g";break;case et.BLUE:s="map_color.b";break;case et.ALPHA:s="map_color.a";break;default:s="0.5"}switch(i){case et.RED:n="map_color.r";break;case et.GREEN:n="map_color.g";break;case et.BLUE:n="map_color.b";break;case et.ALPHA:n="map_color.a";break;default:n="0.5"}switch(r){case vt.CLAMP:a="\n    vec4 source_color = texture(u_textures[0], uv);\n";break;case vt.IGNORE:a="\n    vec4 source_color =texture(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n";break;case vt.COLOR:a="\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, texture(u_textures[0], uv), isInside(uv));\n";break;default:a="\n    vec4 source_color = texture(u_textures[0], fract(uv));\n"}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${Qt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = texture(u_textures[1], st);\n\n    vec2 offset = vec2(${s}, ${n}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${a}\n\n    o_color = mix(texture(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}class fe{static TEMPLATE(t,e,i,r,s,n,a,o,h){let l=0;const $=i?this.STATEMENT_BASE_TEXTURE_TRANSFORM(l++):"",_=r?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(l++):this.STATEMENT_BLUR_TEXTURE(),c=n===bt.INNER,u=l;let d,g,p=4*l;switch(h?d=s?this.STATEMENT_GLOW(!1,i,o,h,u,p):this.STATEMENT_BEVEL(i,r,o,h,u,p):s?(p+=4,d=this.STATEMENT_GLOW(c,i,o,h,u,p)):(p+=8,d=this.STATEMENT_BEVEL(i,r,o,h,u,p)),n){case bt.OUTER:g=a?"blur - blur * base.a":"base + blur - blur * base.a";break;case bt.FULL:g=a?"blur":"base - base * blur.a + blur";break;default:g="blur"}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[${t}];\nuniform vec4 u_mediump[${e}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${Qt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${$}\n    ${_}\n    ${d}\n    o_color = ${g};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t){return`\n    vec2 base_scale  = u_mediump[${t}].xy;\n    vec2 base_offset = u_mediump[${t}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), texture(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(){return"\n    vec4 blur = texture(u_textures[0], v_coord);\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t){return`\n    vec2 blur_scale  = u_mediump[${t}].xy;\n    vec2 blur_offset = u_mediump[${t}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), texture(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,r,s,n){return`\n    ${t?"blur.a = 1.0 - blur.a;":""}\n    ${i?this.STATEMENT_GLOW_STRENGTH(n):""}\n    ${r?this.STATEMENT_GLOW_GRADIENT_COLOR(e):this.STATEMENT_GLOW_SOLID_COLOR(s)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${$.floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t){return`\n    blur = texture(u_textures[${t?2:1}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,r,s,n){return`\n    ${e?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2():this.STATEMENT_BLUR_TEXTURE_2()}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${i?this.STATEMENT_BEVEL_STRENGTH(n):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${r?this.STATEMENT_BEVEL_GRADIENT_COLOR(t):this.STATEMENT_BEVEL_SOLID_COLOR(s)}\n`}static STATEMENT_BLUR_TEXTURE_2(){return"\n    vec4 blur2 = texture(u_textures[0], 1.0 - v_coord);\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(){return"\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), texture(u_textures[0], pq), isInside(pq));\n"}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${$.floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t){return`\n    blur = texture(u_textures[${t?2:1}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}class me{static cubicToQuad(t,e,i,r,s,n,a,o){this._$split2Cubic(t,e,i,r,s,n,a,o,0,16),this._$split2Cubic(B.$bezierConverterBuffer[0],B.$bezierConverterBuffer[1],B.$bezierConverterBuffer[2],B.$bezierConverterBuffer[3],B.$bezierConverterBuffer[4],B.$bezierConverterBuffer[5],B.$bezierConverterBuffer[6],B.$bezierConverterBuffer[7],0,8),this._$split2Cubic(B.$bezierConverterBuffer[16],B.$bezierConverterBuffer[17],B.$bezierConverterBuffer[18],B.$bezierConverterBuffer[19],B.$bezierConverterBuffer[20],B.$bezierConverterBuffer[21],B.$bezierConverterBuffer[22],B.$bezierConverterBuffer[23],16,24),this._$split2Quad(B.$bezierConverterBuffer[0],B.$bezierConverterBuffer[1],B.$bezierConverterBuffer[2],B.$bezierConverterBuffer[3],B.$bezierConverterBuffer[4],B.$bezierConverterBuffer[5],B.$bezierConverterBuffer[6],B.$bezierConverterBuffer[7],0),this._$split2Quad(B.$bezierConverterBuffer[8],B.$bezierConverterBuffer[9],B.$bezierConverterBuffer[10],B.$bezierConverterBuffer[11],B.$bezierConverterBuffer[12],B.$bezierConverterBuffer[13],B.$bezierConverterBuffer[14],B.$bezierConverterBuffer[15],8),this._$split2Quad(B.$bezierConverterBuffer[16],B.$bezierConverterBuffer[17],B.$bezierConverterBuffer[18],B.$bezierConverterBuffer[19],B.$bezierConverterBuffer[20],B.$bezierConverterBuffer[21],B.$bezierConverterBuffer[22],B.$bezierConverterBuffer[23],16),this._$split2Quad(B.$bezierConverterBuffer[24],B.$bezierConverterBuffer[25],B.$bezierConverterBuffer[26],B.$bezierConverterBuffer[27],B.$bezierConverterBuffer[28],B.$bezierConverterBuffer[29],B.$bezierConverterBuffer[30],B.$bezierConverterBuffer[31],24)}static _$split2Cubic(t,e,i,r,s,n,a,o,h,l){const $=.125*(t+3*(i+s)+a),_=.125*(e+3*(r+n)+o),c=.125*(a+s-i-t),u=.125*(o+n-r-e);B.$bezierConverterBuffer[h]=t,B.$bezierConverterBuffer[h+1]=e,B.$bezierConverterBuffer[h+2]=.5*(t+i),B.$bezierConverterBuffer[h+3]=.5*(e+r),B.$bezierConverterBuffer[h+4]=$-c,B.$bezierConverterBuffer[h+5]=_-u,B.$bezierConverterBuffer[h+6]=$,B.$bezierConverterBuffer[h+7]=_,B.$bezierConverterBuffer[l]=$,B.$bezierConverterBuffer[l+1]=_,B.$bezierConverterBuffer[l+2]=$+c,B.$bezierConverterBuffer[l+3]=_+u,B.$bezierConverterBuffer[l+4]=.5*(s+a),B.$bezierConverterBuffer[l+5]=.5*(n+o),B.$bezierConverterBuffer[l+6]=a,B.$bezierConverterBuffer[l+7]=o}static _$split2Quad(t,e,i,r,s,n,a,o,h){const l=.125*(t+3*(i+s)+a),$=.125*(e+3*(r+n)+o);B.$bezierConverterBuffer[h]=.25*t+.75*i,B.$bezierConverterBuffer[h+1]=.25*e+.75*r,B.$bezierConverterBuffer[h+2]=l,B.$bezierConverterBuffer[h+3]=$,B.$bezierConverterBuffer[h+4]=.75*s+.25*a,B.$bezierConverterBuffer[h+5]=.75*n+.25*o,B.$bezierConverterBuffer[h+6]=a,B.$bezierConverterBuffer[h+7]=o}}class xe{constructor(){this._$rgb=lt.RGB,this._$mode=pt.PAD,this._$focalPointRatio=0,this._$points=B.$getFloat32Array6(),this._$stops=B.$getArray(),this._$type=null}linear(t,e,i,r,s=lt.RGB,n=pt.PAD){return this._$type=nt.LINEAR,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=r,this._$rgb=s,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,r,s,n,a=lt.RGB,o=pt.PAD,h=0){return this._$type=nt.RADIAL,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=r,this._$points[4]=s,this._$points[5]=n,this._$rgb=a,this._$mode=o,this._$focalPointRatio=B.$clamp(h,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push([t,e]),this._$stops.sort((function(t,e){switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}}))}}class be{constructor(t=null,e="",i=null){this._$initialization(t,e,i)}_$initialization(t=null,e="",i=null){return this._$texture=t,this._$repeat=e,this._$colorTransform=i,this}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$colorTransform}}class Te{constructor(t,e){this._$gl=t;const i=$.min(e,t.getParameter(t.MAX_SAMPLES));this._$maxTextureSize=$.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new Ee,this._$style=this._$contextStyle,this._$fillBuffer=null,this._$strokeBuffer=null,this._$cacheCurrentBounds={x:0,y:0,w:0,h:0},this._$cacheCurrentBuffer=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation=it.NORMAL,this._$matrix=B.$getFloat32Array9(1,0,0,0,1,0,0,0,1),this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new Re(t,i),this._$path=new Me,this._$grid=new ye,this._$offsetX=0,this._$offsetY=0,this._$blends=[],this._$positions=[],this._$isLayer=!1,this._$shaderList=new Pe(this,t),this._$gradientLUT=new Ne(this,t),this._$vao=new Ie(t),this._$pbo=new Fe(t),this._$mask=new Ae(this,t),this._$blend=new ve(this,t),this._$canvasPatternToWebGL=new be,this._$canvasGradientToWebGL=new xe,this._$maskBufferArray=[],this._$maskBoundsArray=[],this._$attachmentArray=[]}get canvas(){return this._$gl.canvas}get fillStyle(){return this._$style._$fillStyle}set fillStyle(t){this._$style._$fillStyle.constructor===S&&B.$poolFloat32Array4(this._$style._$fillStyle),this._$style._$fillStyle=t}get strokeStyle(){return this._$style._$strokeStyle}set strokeStyle(t){this._$style._$strokeStyle.constructor===Float32Array&&B.$poolFloat32Array4(this._$style._$strokeStyle),this._$style._$strokeStyle=t}get lineWidth(){return this._$style._$lineWidth}set lineWidth(t){this._$style._$lineWidth=t}get lineCap(){return this._$style._$lineCap}set lineCap(t){switch(t){case rt.NONE:case rt.SQUARE:this._$style._$lineCap=t;break;default:this._$style._$lineCap=rt.ROUND}}get lineJoin(){return this._$style._$lineJoin}set lineJoin(t){switch(t){case $t.BEVEL:case $t.MITER:this._$style._$lineJoin=t;break;default:this._$style._$lineJoin=$t.ROUND}}get miterLimit(){return this._$style._$miterLimit}set miterLimit(t){this._$style._$miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=B.$clamp(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=!!t}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get pbo(){return this._$pbo}get blend(){return this._$blend}_$getTextureScale(t,e){const i=Math.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}_$bind(t){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,r=t.width,s=t.height;this._$viewportWidth===r&&this._$viewportHeight===s||(this._$viewportWidth=r,this._$viewportHeight=s,this._$gl.viewport(0,0,r,s)),(e.dirty||i&&i.dirty)&&(e.dirty=!1,i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}fillRect(t,e,i,r){if(!i||!r)return;this._$viewportWidth=i,this._$viewportHeight=r;let s=!1;if(!this._$fillBuffer){s=!0;const n=this._$path.createRectVertices(t,e,i,r);this._$fillBuffer=this._$vao.createFill(n),B.$poolArray(n.pop()),B.$poolArray(n)}const n=this._$grid.enabled,a=this._$shaderList.shapeShaderVariants,o=a.getSolidColorShapeShader(!1,n),h=o.uniform;a.setSolidColorShapeUniform(h,!1,0,0,0,n,this._$matrix,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha),o._$fill(this._$fillBuffer),s&&(this._$vao.release(this._$fillBuffer),B.$poolArray(this._$fillBuffer.indexRanges)),this.beginPath()}setTransform(t,e,i,r,s,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=r,this._$matrix[6]=s,this._$matrix[7]=n}transform(t,e,i,r,s,n){const a=this._$matrix[0],o=this._$matrix[1],h=this._$matrix[3],l=this._$matrix[4],$=this._$matrix[6],_=this._$matrix[7];this._$matrix[0]=t*a+e*h,this._$matrix[1]=t*o+e*l,this._$matrix[3]=i*a+r*h,this._$matrix[4]=i*o+r*l,this._$matrix[6]=s*a+n*h+$,this._$matrix[7]=s*o+n*l+_}drawImage(t,e,i,r,s,n=null){let a=1,o=1,h=1,l=this._$globalAlpha,$=0,_=0,c=0;n&&(a=n[0],o=n[1],h=n[2],$=n[4]/255,_=n[5]/255,c=n[6]/255),this._$blend.drawImage(t,e,i,r,s,a,o,h,l,$,_,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,r=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=r,this._$gl.clearColor(t,e,i,r)}clearRect(t,e,i,r){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,r),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,r){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,r),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin(),this._$isGraphics&&(this._$fillBuffer&&(this.vao.release(this._$fillBuffer),this.vao.release(this._$fillBuffer.boundObject),B.$poolArray(this._$fillBuffer.indexRanges),B.$poolArray(this._$fillBuffer.boundObject.indexRanges)),this._$strokeBuffer&&this.vao.release(this._$strokeBuffer)),this._$isGraphics=!1,this._$fillBuffer=null,this._$strokeBuffer=null}quadraticCurveTo(t,e,i,r){this._$path.quadTo(t,e,i,r)}bezierCurveTo(t,e,i,r,s,n){this._$path.cubicTo(t,e,i,r,s,n)}_$getVertices(){return this._$path.vertices}fill(){const t=this.fillStyle;let e,i,r,s=this._$matrix;switch(!0){case t.constructor===xe:if(this.fillStyle._$type===nt.LINEAR);else s=this._$stack[this._$stack.length-1];break;case t.constructor===be:s=this._$stack[this._$stack.length-1]}const n=this._$grid.enabled;switch(!0){case t.constructor===xe:{const t=this.fillStyle,a=t._$stops,o="linearRGB"===t._$rgb;if(e=this._$gradientLUT.generateForShape(a,o),this._$frameBufferManager._$textureManager.bind0(e,!0),i=this._$shaderList.gradientShapeShaderVariants,t._$type===nt.LINEAR)r=i.getGradientShapeShader(!1,n,!1,!1,t._$mode),i.setGradientShapeUniform(r.uniform,!1,0,0,0,n,s,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,t._$points,0);else{const e=0!==t._$focalPointRatio;r=i.getGradientShapeShader(!1,n,!0,e,t._$mode),i.setGradientShapeUniform(r.uniform,!1,0,0,0,n,s,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,t._$points,t._$focalPointRatio)}}break;case t.constructor===be:{const t=this.fillStyle,a=t.colorTransform;e=t.texture,this._$frameBufferManager._$textureManager.bind0(e,this._$imageSmoothingEnabled),i=this._$shaderList.shapeShaderVariants,r=i.getBitmapShapeShader(!1,""!==t.repeat,n),a?i.setBitmapShapeUniform(r.uniform,!1,0,0,0,n,s,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,e.width,e.height,a[0],a[1],a[2],this._$globalAlpha,a[4]/255,a[5]/255,a[6]/255,0):i.setBitmapShapeUniform(r.uniform,!1,0,0,0,n,s,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,e.width,e.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:i=this._$shaderList.shapeShaderVariants,r=i.getSolidColorShapeShader(!1,this._$grid.enabled),i.setSolidColorShapeUniform(r.uniform,!1,0,0,0,n,s,this._$viewportWidth,this._$viewportHeight,this._$grid,t,this._$globalAlpha)}const a=this._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,n);if(a.setMaskShapeUniform(o.uniform,n,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],this._$viewportWidth,this._$viewportHeight,this._$grid),!this._$fillBuffer){const t=this._$getVertices();if(!t.length)return;const e=B.$getArray();for(let i=0;i<t.length;++i){const r=t[i];9>r.length||e.push(r)}if(!e.length)return;this._$isGraphics=!0,this._$fillBuffer=this._$vao.createFill(e);const i=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(i),B.$poolArray(i.pop()),B.$poolArray(i)}this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),o._$fill(this._$fillBuffer),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),r._$fill(this._$fillBuffer.boundObject),this._$gl.disable(this._$gl.STENCIL_TEST)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$updateContainerClipFlag(t){this._$mask._$containerClip=!!t}_$startClip(t,e){let i=e.xMin,r=e.yMin,s=Math.abs(e.xMax-e.xMin),n=Math.abs(e.yMax-e.yMin);const a=this._$frameBufferManager,o=a.currentAttachment;if(s+i>o.texture.width&&(s-=s-o.texture.width+i),n+r>o.texture.height&&(n-=n-o.texture.height+r),0>i&&(s+=i,i=0),0>r&&(n+=r,r=0),0>=s||0>=n)return null;s=Math.ceil(s),n=Math.ceil(n),this._$cacheCurrentBounds.x=i,this._$cacheCurrentBounds.y=r,this._$cacheCurrentBounds.w=s,this._$cacheCurrentBounds.h=n,this._$cacheCurrentBuffer=o;const h=o.texture;return this._$bind(a.createCacheAttachment(s,n,!0)),B.$resetContext(this),this.setTransform(1,0,0,1,0,0),this.drawImage(h,-i,-r,h.width,h.height),B.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]-i,t[5]-r)}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}_$unionStencilMask(t,e,i){this._$mask._$unionStencilMask(t,e,i)}closePath(){this._$path.close()}stroke(){if(!this._$strokeBuffer){const t=this._$getVertices();if(!t.length)return;const e=B.$getArray();for(let i=0;i<t.length;++i){const r=t[i];6>r.length||e.push(r)}if(!e.length)return;this._$isGraphics=!0,this._$strokeBuffer=this._$vao.createStroke(t,this.lineCap,this.lineJoin)}let t=this._$matrix;switch(!0){case this.strokeStyle.constructor===xe:if(this.strokeStyle._$type===nt.LINEAR);else t=this._$stack[this._$stack.length-1];break;case this.strokeStyle.constructor===be:t=this._$stack[this._$stack.length-1]}let e=$.sign(t[0]*t[4]);e>0&&0!==t[1]&&0!==t[3]&&(e=-$.sign(t[1]*t[3]));let i,r,s=.5*this.lineWidth;this._$grid.enabled?(s*=B.$getSameScaleBase(),i=$.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),r=$.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(i=$.abs(t[0]+t[3]),r=$.abs(t[1]+t[4]));const n=$.min(i,r),a=$.max(i,r);let o,h,l;s*=a*(1-.3*$.cos(.5*$.PI*(n/a))),s=$.max(1,s);const _=this._$grid.enabled;switch(!0){case this.strokeStyle.constructor===xe:{const i=this.strokeStyle,r=i._$stops,n="linearRGB"===i._$rgb;if(o=this._$gradientLUT.generateForShape(r,n),this._$frameBufferManager._$textureManager.bind0(o,!0),h=this._$shaderList.gradientShapeShaderVariants,i._$type===nt.LINEAR)l=h.getGradientShapeShader(!0,_,!1,!1,i._$mode),h.setGradientShapeUniform(l.uniform,!0,s,e,this.miterLimit,_,t,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,i._$points,0);else{const r=0!==i._$focalPointRatio;l=h.getGradientShapeShader(!0,_,!0,r,i._$mode),h.setGradientShapeUniform(l.uniform,!0,s,e,this.miterLimit,_,t,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,i._$points,i._$focalPointRatio)}}break;case this.strokeStyle.constructor===be:{const i=this.strokeStyle,r=i.colorTransform;o=i.texture,this._$frameBufferManager._$textureManager.bind0(o),h=this._$shaderList.shapeShaderVariants,l=h.getBitmapShapeShader(!0,""!==i.repeat,this._$grid.enabled),r?h.setBitmapShapeUniform(l.uniform,!0,s,e,this.miterLimit,_,t,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,o.width,o.height,r[0],r[1],r[2],this._$globalAlpha,r[4]/255,r[5]/255,r[6]/255,0):h.setBitmapShapeUniform(l.uniform,!0,s,e,this.miterLimit,_,t,B.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,o.width,o.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:h=this._$shaderList.shapeShaderVariants,l=h.getSolidColorShapeShader(!0,this._$grid.enabled),h.setSolidColorShapeUniform(l.uniform,!0,s,e,this.miterLimit,_,t,this._$viewportWidth,this._$viewportHeight,this._$grid,this.strokeStyle,this._$globalAlpha)}l._$stroke(this._$strokeBuffer)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(t=!1){const e=this._$shaderList.shapeShaderVariants,i=e.getMaskShapeShader(!1,!1),r=i.uniform;if(e.setMaskShapeUniform(r,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),!this._$fillBuffer){this._$fillBuffer=this._$vao.createFill(this._$getVertices());const t=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(t),B.$poolArray(t.pop()),B.$poolArray(t)}this._$mask._$onClip(this._$matrix,this._$viewportWidth,this._$viewportHeight)||(i._$fill(this._$fillBuffer),t&&(this._$vao.release(this._$fillBuffer),this._$vao.release(this._$fillBuffer.boundObject),B.$poolArray(this._$fillBuffer.indexRanges),B.$poolArray(this._$fillBuffer.boundObject.indexRanges),this._$fillBuffer=null),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(B.$getFloat32Array9(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){this._$stack.length&&(B.$poolFloat32Array9(this._$matrix),this._$matrix=this._$stack.pop()),this._$mask._$onRestore()}createPattern(t,e,i){return this._$canvasPatternToWebGL._$initialization(t,e,i)}createLinearGradient(t,e,i,r,s=lt.RGB,n=pt.PAD){return this._$canvasGradientToWebGL.linear(t,e,i,r,s,n)}createRadialGradient(t,e,i,r,s,n,a=lt.RGB,o=pt.PAD,h=0){return this._$canvasGradientToWebGL.radial(t,e,i,r,s,n,a,o,h)}_$applyBlurFilter(t,e,i){const r=this._$frameBufferManager,s=r.currentAttachment,n=s.width,a=s.height;r._$textureManager.bind0(t,!0);const o=$.ceil(.5*i),h=1-(o-.5*i),l=1+i,_=this._$shaderList.filterShaderVariants,c=_.getBlurFilterShader(o);_.setBlurFilterUniform(c.uniform,n,a,e,h,l),c._$drawImage()}_$applyBitmapFilter(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,p,f,m,x,b,T,v,y,A,M){const E=this._$frameBufferManager,C=c===bt.INNER,S=E.currentAttachment,R=E.getTextureFromCurrentAttachment();let F;const B=null!==g;let w;B&&(F=this._$gradientLUT.generateForFilter(g,p,f)),C?B?E._$textureManager.bind02(t,F,!0):E._$textureManager.bind0(t):(w=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(w),B?E._$textureManager.bind012(t,R,F,!0):E._$textureManager.bind01(t,R));const I=!(C||c===bt.FULL&&u),U=!(e===o&&i===h&&0===l&&0===$),O=!(1===d),L=this._$shaderList.filterShaderVariants,P=L.getBitmapFilterShader(I,U,_,c,u,O,B);L.setBitmapFilterUniform(P.uniform,e,i,r,s,n,a,o,h,l,$,_,d,m,x,b,T,v,y,A,M,I,U,O,B),C?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),P._$drawImage(),C||E.releaseAttachment(S,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager._$textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,r=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(r.uniform,e),this.blend.reset(),r._$drawImage()}_$applyConvolutionFilter(t,e,i,r,s,n,a,o,h,l,$,_){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager._$textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,p=g.getConvolutionFilterShader(e,i,a,o);g.setConvolutionFilterUniform(p.uniform,c,u,r,s,n,o,h,l,$,_),this.blend.reset(),p._$drawImage()}_$applyDisplacementMapFilter(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.width,g=t.height,p=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(p),s||(s={x:0,y:0}),this._$frameBufferManager._$textureManager.bind01(t,e);const f=this._$shaderList.filterShaderVariants,m=f.getDisplacementMapFilterShader(n,a,l);f.setDisplacementMapFilterUniform(m.uniform,e.width,e.height,i,r,s.x,s.y,o,h,l,$,_,c,u),this.blend.reset(),m._$drawImage()}getImageData(t,e,i,r){const s=i*r*4,n=B.$getUint8Array(s);this._$gl.readPixels(t,r-(r-e),i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,n);for(let t=0;t<s;t+=4){const e=n[t+3];e&&(n[t]=255&$.min(255*n[t]/e,255),n[t+1]=255&$.min(255*n[t+1]/e,255),n[t+2]=255&$.min(255*n[t+2]/e,255))}return n}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){B.$poolBoundsObject(this._$positions.pop()),this._$isLayer=!!this._$blends.pop()}_$saveCurrentMask(){this._$maskBufferArray.push(this._$cacheCurrentBuffer),this._$cacheCurrentBuffer=null;const t=this._$cacheCurrentBounds;this._$maskBoundsArray.push(B.$getBoundsObject(t.x,t.w,t.y,t.h))}_$saveAttachment(t,e,i=!1){const r=this._$frameBufferManager;this._$attachmentArray.push(r.currentAttachment),this._$bind(r.createCacheAttachment(t,e,i))}_$restoreAttachment(t=!1){const e=this._$frameBufferManager;e.releaseAttachment(e.currentAttachment,t),this._$bind(this._$attachmentArray.pop())}_$restoreCurrentMask(){this._$cacheCurrentBuffer=this._$maskBufferArray.pop(),this._$cacheCurrentBounds=this._$maskBoundsArray.pop()}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$textureScale(t,e){const i=$.max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}changeSamples(t=4){t=$.min(t,this._$gl.getParameter(this._$gl.MAX_SAMPLES));const e=this._$frameBufferManager;e._$objectPool=[],e._$colorBufferPool._$objectPool=[],e._$stencilBufferPool._$objectPool=[],e._$colorBufferPool._$samples=t}}class ve{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case it.ADD:this.toAdd();break;case it.SCREEN:this.toScreen();break;case it.ALPHA:this.toAlpha();break;case it.ERASE:this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,i,r,s,n,a,o,h,l,_,u,d,g,p,f,m,x){const b=this._$context._$frameBufferManager,T=b.currentAttachment,v=1!==n||1!==a||1!==o||1!==h||0!==l||0!==_||0!==u||0!==d,y=this._$context._$shaderList.blendShaderVariants;switch(g){case it.NORMAL:case it.LAYER:case it.ADD:case it.SCREEN:case it.ALPHA:case it.ERASE:case"copy":{b._$textureManager.bind0(t,x);const T=y.getNormalBlendShader(v);y.setNormalBlendUniform(T.uniform,e,i,r,s,m,p,f,v,n,a,o,h,l,_,u,d);const A=m[0],M=m[1],E=m[3],C=m[4],S=m[6],R=m[7];if(1!==A||0!==M||0!==E||1!==C){const t=e+r,n=i+s,a=+(t*A+n*E+S),o=+(t*A+i*E+S),h=+(e*A+n*E+S),l=+(e*A+i*E+S),_=+(t*M+n*C+R),u=+(t*M+i*C+R),d=+(e*M+n*C+R),g=+(e*M+i*C+R),m=c.MAX_VALUE,x=+$.min($.min($.min($.min(m,a),o),h),l),b=+$.max($.max($.max($.max(-m,a),o),h),l),T=+$.min($.min($.min($.min(m,_),u),d),g),v=+$.max($.max($.max($.max(-m,_),u),d),g),y=$.max(0,x),F=$.max(0,T),B=$.min($.max(0,p-y),$.ceil($.abs(b-x))),w=$.min($.max(0,f-F),$.ceil($.abs(v-T)));if(!B||!w)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(y,$.max(0,f-(F+w)),B+1,w+1)}else{const t=$.max(0,e+S),n=$.max(0,i+R),a=$.min($.max(0,p-t),r),o=$.min($.max(0,f-n),s);if(!a||!o)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,Math.max(0,f-(n+o)),a+1,o+1)}this.toOperation(g),T._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const $=Math.max(0,e+m[6]),c=Math.max(0,i+m[7]),A=Math.min(Math.max(0,p-$),r),M=Math.min(Math.max(0,f-c),s);if(!A||!M)return;const E=b.getTextureFromCurrentAttachment(),C=this._$context._$frameBufferManager.createTextureAttachment(r,s);this._$context._$bind(C),b._$textureManager.bind0(E);const S=y.getClipShader(),R=S.uniform;y.setClipUniform(R,e,i,r,s,B.$inverseMatrix(m),p,f),this.reset(),S._$drawImage();const F=b.getTextureFromCurrentAttachment();this._$context._$bind(T),b._$textureManager.bind01(F,t,x);const w=y.getBlendShader(g,v);y.setBlendUniform(w.uniform,e,i,r,s,m,p,f,v,n,a,o,h,l,_,u,d),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor($,Math.max(0,f-(c+M)),A,M),this.toOneZero(),w._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),b.releaseAttachment(C,!0)}}}}class ye{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,i,r,s,n,a,o,h,l,_,c,u,d,g,p,f,m,x){const b=s.xMax-s.xMin,T=s.yMax-s.yMin,v=n.width,y=n.height,A=$.abs($.ceil(b*a)),M=$.abs($.ceil(T*a)),E=v>0?(n.x-s.xMin)/b:1e-5,C=y>0?(n.y-s.yMin)/T:1e-5,S=v>0?(n.x+n.width-s.xMin)/b:.99999,R=y>0?(n.y+n.height-s.yMin)/T:.99999;let F=A*E/i,B=M*C/r,w=(i-A*(1-S))/i,I=(r-M*(1-R))/r;if(F>=w){const t=E/(E+(1-S));F=$.max(t-1e-5,0),w=$.min(t+1e-5,1)}if(B>=I){const t=C/(C+(1-R));B=$.max(t-1e-5,0),I=$.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=o,this.parentMatrixB=h,this.parentMatrixD=l,this.parentMatrixE=_,this.parentMatrixG=c,this.parentMatrixH=u,this.ancestorMatrixA=d,this.ancestorMatrixB=g,this.ancestorMatrixD=p,this.ancestorMatrixE=f,this.ancestorMatrixG=m,this.ancestorMatrixH=x,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=i,this.parentViewportH=r,this.minXST=E,this.minYST=C,this.minXPQ=F,this.minYPQ=B,this.maxXST=S,this.maxYST=R,this.maxXPQ=w,this.maxYPQ=I}disable(){this.enabled=!1}}class Ae{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$clipStatus=!1,this._$containerClip=!1,this._$poolClip=[],this._$currentClip=!1}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context._$frameBufferManager,e=t.getTextureFromCurrentAttachment(),i=t.currentAttachment;this._$context._$bind(this._$context._$cacheCurrentBuffer),this._$context._$cacheCurrentBuffer=null,this._$context._$blend.disable();const r=this._$context._$cacheCurrentBounds.x,s=this._$context._$cacheCurrentBounds.y;B.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(e,r,s,e.width,e.height),this._$context._$blend.enable(),t.releaseAttachment(i,!0)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context._$frameBufferManager.currentAttachment;t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context._$frameBufferManager.currentAttachment;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context._$frameBufferManager.currentAttachment.clipLevel;let e=0;for(let i=0;i<t;++i)e|=(1<<t-i)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&e,e),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context._$frameBufferManager.currentAttachment;if(--t.clipLevel,t.mask=!!t.clipLevel,!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context._$cacheCurrentBuffer&&this._$endClip());const e=t.width,i=t.height,r=this._$context._$path.createRectVertices(0,0,e,i),s=this._$context._$vao.createFill(r);B.$poolArray(r.pop()),B.$poolArray(r);const n=this._$context._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),o=a.uniform;n.setMaskShapeUniformIdentity(o,e,i);const h=s.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(s,h.first,h.count),this._$context._$vao.release(s),B.$poolArray(s.indexRanges),this._$context._$endClipDef()}_$drawContainerClip(){const t=this._$context._$frameBufferManager.currentAttachment,e=t.clipLevel,i=this._$poolClip.length,r=this._$context._$shaderList.shapeShaderVariants,s=r.getMaskShapeShader(!1,!1),n=s.uniform;let a=e;const o=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);for(let t=0;t<i;++t){const t=this._$poolClip.shift();r.setMaskShapeUniform(n,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const i=t.fillBuffer.indexRanges.length;for(let e=0;e<i;++e){const i=t.fillBuffer.indexRanges[e];this._$gl.stencilMask(1<<a-1),s._$containerClip(t.fillBuffer,i.first,i.count)}++a,a>7&&(this._$context._$unionStencilMask(e,o,h),a=e)}a>e+1&&this._$context._$unionStencilMask(e,o,h)}_$unionStencilMask(t,e,i){const r=this._$context._$path.createRectVertices(0,0,e,i),s=this._$context._$vao.createFill(r);B.$poolArray(r.pop()),B.$poolArray(r);const n=this._$context._$shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),o=a.uniform;n.setMaskShapeUniformIdentity(o,e,i);const h=s.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(s,h.first,h.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT)),this._$context._$vao.release(s),B.$poolArray(s.indexRanges)}_$onClip(t,e,i){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip[this._$poolClip.length]={fillBuffer:this._$context._$fillBuffer,matrixA:t[0],matrixB:t[1],matrixC:t[2],matrixD:t[3],matrixE:t[4],matrixF:t[5],matrixG:t[6],matrixH:t[7],matrixI:t[8],viewportWidth:e,viewportHeight:i},!0)}_$onSave(){this._$clips[this._$clips.length]=this._$clipStatus}_$onRestore(){this._$clips.length&&(this._$clipStatus=!!this._$clips.pop())}}class Me{constructor(){this._$currentPath=[],this._$vertices=[],this._$bounds={xMin:0,xMax:0,yMin:0,yMax:0},this._$resetBounds()}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)B.$poolArray(this._$vertices.pop());this._$resetBounds()}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,r){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,r)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,r,!1))}cubicTo(t,e,i,r,s,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(s,n))return;const a=this._$currentPath[this._$currentPath.length-3],o=this._$currentPath[this._$currentPath.length-2];me.cubicToQuad(a,o,t,e,i,r,s,n);const h=B.$bezierConverterBuffer.length;for(let t=0;t<h;)this.quadTo(B.$bezierConverterBuffer[t++],B.$bezierConverterBuffer[t++],B.$bezierConverterBuffer[t++],B.$bezierConverterBuffer[t++])}drawCircle(t,e,i){const r=i,s=.5522847498307936*i;this.cubicTo(t+r,e+s,t+s,e+r,t,e+r),this.cubicTo(t-s,e+r,t-r,e+s,t-r,e),this.cubicTo(t-r,e-s,t-s,e-r,t,e-r),this.cubicTo(t+s,e-r,t+r,e-s,t+r,e)}close(){if(this._$currentPath.length<=6)return;const t=this._$currentPath[0],e=this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=this._$currentPath[this._$currentPath.length-3],r=this._$currentPath[this._$currentPath.length-2];return t===i&&e===r}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t),this._$currentPath.push(e),this._$currentPath.push(i),this._$bounds.xMin=$.min(t,this._$bounds.xMin),this._$bounds.xMax=$.max(t,this._$bounds.xMax),this._$bounds.yMin=$.min(e,this._$bounds.yMin),this._$bounds.yMax=$.max(e,this._$bounds.yMax)}_$pushCurrentPathToVertices(){this._$currentPath.length<=3?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=B.$getArray())}_$resetBounds(){const t=Number.MAX_VALUE;this._$bounds.xMin=t,this._$bounds.xMax=-t,this._$bounds.yMin=t,this._$bounds.yMax=-t}getBoundsVertices(){return B.$getArray(B.$getArray(this._$bounds.xMin,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMax,!1,this._$bounds.xMin,this._$bounds.yMax,!1))}createRectVertices(t,e,i,r){return B.$getArray(B.$getArray(t,e,!1,t+i,e,!1,t+i,e+r,!1,t,e+r,!1))}}class Ee{constructor(){this._$fillStyle=new S([1,1,1,1]),this._$strokeStyle=new S([1,1,1,1]),this._$lineWidth=1,this._$lineCap=0,this._$lineJoin=0,this._$miterLimit=5}}class Ce{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=[]}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();return t.stencil=this._$gl.createRenderbuffer(),t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}return this._$objectPool.shift()}create(t,e,i=0){t=$.max(256,B.$upperPowerOfTwo(t)),e=$.max(256,B.$upperPowerOfTwo(e));const r=this._$getColorBuffer(t*e);return(r.width<t||r.height<e||i&&r.samples!==i)&&(t=$.max(t,r.width),e=$.max(e,r.height),r.samples=i||this._$samples,r.width=t,r.height=e,r.area=t*e,r.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.STENCIL_INDEX8,t,e)),r}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;$.abs(i-e)>1;){const r=$.floor((i+e)/2);t<=this._$objectPool[r].area?i=r:e=r}return i}}const Se={vertices:null};Se.subhulls=new Array(512),Se.subhullsIndex=0,Se.extremePoints=new Array(32),Se.extremePointsIndex=0,Se.t=0,Se.hulls=[new Array(16),new Array(64),new Array(256)],Se.hullsIndex=0;class Re{constructor(t,e){this._$gl=t,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),this._$frameBufferTexture=null,this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new we(t),this._$colorBufferPool=null,this._$stencilBufferPool=new Be(t),this._$frameBufferTexture=t.createFramebuffer(),this._$colorBufferPool=new Ce(t,e),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer)}get currentAttachment(){return this._$currentAttachment}createCacheAttachment(t,e,i=!1,r=0){const s=this._$objectPool.length?this._$objectPool.pop():{},n=this._$textureManager.create(t,e);return s.width=t,s.height=e,i?(s.color=this._$colorBufferPool.create(t,e,r),s.texture=n,s.msaa=!0,s.stencil=s.color.stencil):(s.color=n,s.texture=n,s.msaa=!1,s.stencil=this._$stencilBufferPool.create(n.width,n.height)),s.mask=!1,s.clipLevel=0,s.isActive=!0,s}createTextureAttachment(t,e){const i=this._$objectPool.length?this._$objectPool.pop():{},r=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=r,i.texture=r,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.length?this._$objectPool.pop():{};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t,e=!1){t.isActive&&(t.msaa?this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):(this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment.msaa)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,r=!1,s=!0){return this._$textureManager.create(t,e,i,r,s)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t,e=!1){return this._$textureManager.createFromImage(t,e)}createAlphaTextureFromPixels(t,e,i){return this._$textureManager.createAlpha(t,e,i)}createTextureFromVideo(t,e=!1,i=null){return this._$textureManager.createFromVideo(t,e,i)}createTextureFromCurrentAttachment(){const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class Fe{constructor(t){this._$gl=t,this._$objectPool=[],this._$maxWidth=0,this._$maxHeight=0,this._$cacheSize=0}_$getPixelBufferObject(t){if(!this._$objectPool.length){const t=this._$gl.createBuffer();return t.size=0,t}for(let e=0;e<this._$objectPool.length;e++){const i=this._$objectPool[e];if(i.size===t)return this._$objectPool.splice(e,1),this._$cacheSize-=i.size/4,i}const e=this._$objectPool.shift();return this._$cacheSize-=e.size/4,e}readPixelsAsync(t,e,i,r){const s=i*r*4,n=this._$getPixelBufferObject(s);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,n),n.size!==s&&(n.size=s,this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER,s,this._$gl.DYNAMIC_COPY)),this._$gl.readPixels(t,e,i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,0),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),n}getBufferSubDataAsync(t){const e=new Uint8Array(t.size);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,t),this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER,0,e),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),this.release(t),e}release(t){if(t.size>this._$maxWidth*this._$maxHeight*4)this._$gl.deleteBuffer(t);else if(this._$objectPool.push(t),this._$cacheSize+=t.size/4,this._$cacheSize>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$cacheSize-=t.size/4,this._$gl.deleteBuffer(t)}}}class Be{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let r=0;r<i;r++){const i=this._$objectPool[r];if(i.width===t&&i.height===e)return this._$objectPool.splice(r,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t)}}}class we{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(t,e){const i=this._$gl.createTexture();return i.width=0,i.height=0,i.area=0,i.dirty=!0,i.smoothing=!0,i._$offsetX=0,i._$offsetY=0,this.bind0(i,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,t,e),i}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const r=this._$objectPool[i];if(r.width===t&&r.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=r.area,this.bind0(r,!1),r}return this._$createTexture(t,e)}createAlpha(t,e,i){return this._$alphaTexture?this.bind0(this._$alphaTexture):(this._$alphaTexture=this._$gl.createTexture(),this.bind0(this._$alphaTexture),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST)),this._$alphaTexture.width=t,this._$alphaTexture.height=e,this._$alphaTexture.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.ALPHA,t,e,0,this._$gl.ALPHA,this._$gl.UNSIGNED_BYTE,i),this._$alphaTexture}create(t,e,i=null,r=!1,s=!0){const n=this._$getTexture(t,e);return r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),s||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,t,e,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):i&&(n.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,t,e,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)),r&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),s||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),n}createFromImage(t,e=!1){return this._$createFromElement(t.width,t.height,t,e,null)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromVideo(t,e=!1,i=null){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e,i)}_$createFromElement(t,e,i,r=!1,s=null){const n=s||this._$getTexture(t,e);return n.dirty=!1,this.bind0(n,r),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,r=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,r),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i,r){const s=i!==this._$boundTextures[t],n=null!==r&&r!==i.smoothing;if((s||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),s&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i.smoothing=r;const t=r?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class Ie{constructor(t){this._$gl=t,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new S([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$getVertexArray(t,e){const i=this._$gl.createVertexArray();this.bind(i);const r=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,r),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length)return this._$fillVertexArrayPool.pop();const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length)return this._$strokeVertexArrayPool.pop();const t=this._$gl.createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=Ue.generate(t),i=e.vertexBufferData,r=this._$getFillVertexArray();return r.indexRanges=e.indexRanges,this.bind(r),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,r.vertexBuffer),r.vertexLength<i.length&&(r.vertexLength=B.$upperPowerOfTwo(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*r.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),r}createStroke(t,e,i){const r=Oe.generate(t,e,i),s=r.vertexBufferData,n=r.indexBufferData,a=this._$getStrokeVertexArray();return a.indexCount=n.length,this.bind(a),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,a.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,a.indexBuffer),a.vertexLength<s.length&&(a.vertexLength=B.$upperPowerOfTwo(s.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*a.vertexLength,this._$gl.DYNAMIC_DRAW)),a.indexLength<n.length&&(a.indexLength=B.$upperPowerOfTwo(n.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*a.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,s),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,n),a}release(t){t.indexBuffer?this._$strokeVertexArrayPool.push(t):this._$fillVertexArrayPool.push(t)}bind(t){if(t){if(t===this._$boundVertexArray)return;this._$boundVertexArray=t}else this._$boundVertexArray=null;this._$gl.bindVertexArray(t)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class Ue{static generate(t){let e=0;for(let i=0;i<t.length;i++)e+=12*(t[i].length/3-2);this._$vertexBufferData=new S(e),this._$indexRanges=B.$getArray(),this._$currentIndex=0;for(let e=0;e<t.length;e++){const i=this._$currentIndex;this._$generateMesh(t[e]);const r=this._$currentIndex-i;this._$indexRanges.push({first:i,count:r})}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const r=t.length-5;for(let s=3;s<r;s+=3){let r=4*i;t[s+2]?(e[r++]=t[s-3],e[r++]=t[s-2],e[r++]=0,e[r++]=0,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=0,e[r++]=t[s+3],e[r++]=t[s+4],e[r++]=1,e[r++]=1):t[s+5]?(e[r++]=t[0],e[r++]=t[1],e[r++]=.5,e[r++]=.5,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=.5,e[r++]=t[s+6],e[r++]=t[s+7],e[r++]=.5,e[r++]=.5):(e[r++]=t[0],e[r++]=t[1],e[r++]=.5,e[r++]=.5,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=.5,e[r++]=t[s+3],e[r++]=t[s+4],e[r++]=.5,e[r++]=.5),i+=3}this._$currentIndex=i}}class Oe{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new Float32Array(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const r=this._$vertexBufferPos;this._$generateLineJoin(i,r),this._$generateLineCap(i,r)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new S(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new R(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,r,s,n){let a=t,o=e;for(let h=1;h<11;h++){const l=h/11,$=1-l,_=(t*$+i*l)*$+(i*$+s*l)*l,c=(e*$+r*l)*$+(r*$+n*l)*l;this._$addLineSegmentMesh(a,o,_,c,2),a=_,o=c}this._$addLineSegmentMesh(a,o,s,n)}static _$addLineSegmentMesh(t,e,i,r,s=1){const n=this._$vertexBufferPos/7,a=n+1,o=n+2,h=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let $=this._$indexBufferPos;l[$++]=n,l[$++]=a,l[$++]=h,l[$++]=h,l[$++]=o,l[$++]=n,this._$indexBufferPos=$,this._$expandVertexBufferIfNeeded(28);const _=this._$vertexBufferData;let c=this._$vertexBufferPos;_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=r,_[c++]=1,_[c++]=1,_[c++]=1,_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=r,_[c++]=-1,_[c++]=-1,_[c++]=1,_[c++]=i,_[c++]=r,_[c++]=t,_[c++]=e,_[c++]=-1,_[c++]=-1,_[c++]=s,_[c++]=i,_[c++]=r,_[c++]=t,_[c++]=e,_[c++]=1,_[c++]=1,_[c++]=s,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,r=e-55;for(let e=t;e<r;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,r,s,n,a,o,h,l,_){const c=i-t,u=r-e,d=n-i,g=a-r,p=B.$cross(c,u,d,g);if(!($.abs(p)<1e-4))if(2!==s)switch(this._$lineJoin){case $t.ROUND:this._$addRoundJoinMesh(i,r);break;case $t.MITER:this._$addMiterJoinMesh(i,r,t,e,n,a,l,o,h,_);break;default:this._$addBevelJoinMesh(i,r,l,o,h,_)}else this._$addBevelJoinMesh(i,r,l,o,h,_)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const r=this._$indexBufferData;let s=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;r[s++]=i,r[s++]=e,r[s++]=e+1}r[s++]=i,r[s++]=i+18,r[s++]=i+1,this._$indexBufferPos=s,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,r,s,n,a,o,h,l){const $=this._$vertexBufferPos/7,_=$+1,c=$+2,u=$+3,d=$+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let p=this._$indexBufferPos;g[p++]=$,g[p++]=a,g[p++]=_,g[p++]=$,g[p++]=_,g[p++]=c,g[p++]=$,g[p++]=c,g[p++]=o,g[p++]=$,g[p++]=h,g[p++]=u,g[p++]=$,g[p++]=u,g[p++]=d,g[p++]=$,g[p++]=d,g[p++]=l,this._$indexBufferPos=p,this._$expandVertexBufferIfNeeded(35);const f=this._$vertexBufferData;let m=this._$vertexBufferPos;f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=r,f[m++]=s,f[m++]=n,f[m++]=0,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=r,f[m++]=s,f[m++]=n,f[m++]=21,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=r,f[m++]=s,f[m++]=n,f[m++]=22,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=r,f[m++]=s,f[m++]=n,f[m++]=23,f[m++]=t,f[m++]=e,f[m++]=i,f[m++]=r,f[m++]=s,f[m++]=n,f[m++]=24,this._$vertexBufferPos=m}static _$addBevelJoinMesh(t,e,i,r,s,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let h=this._$indexBufferPos;o[h++]=a,o[h++]=i,o[h++]=r,o[h++]=a,o[h++]=s,o[h++]=n,this._$indexBufferPos=h,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let $=this._$vertexBufferPos;l[$++]=t,l[$++]=e,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,this._$vertexBufferPos=$}static _$generateLineCap(t,e){const i=this._$vertexBufferData,r=i[t],s=i[t+1],n=i[t+2],a=i[t+3],o=i[e-7],h=i[e-6],l=i[e-5],$=i[e-4],_=t/7,c=e/7;r!==o||s!==h?(this._$addLineCapMesh(r,s,n,a,_,_+1),this._$addLineCapMesh(o,h,l,$,c-1,c-2)):this._$addLineJoinMesh(l,$,r,s,n,a,c-2,c-1,_,_+1)}static _$addLineCapMesh(t,e,i,r,s,n){switch(this._$lineCap){case rt.ROUND:this._$addRoundJoinMesh(t,e);break;case rt.SQUARE:this._$addSquareCapMesh(t,e,i,r,s,n)}}static _$addSquareCapMesh(t,e,i,r,s,n){const a=this._$vertexBufferPos/7,o=a+1;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let l=this._$indexBufferPos;h[l++]=s,h[l++]=a,h[l++]=o,h[l++]=o,h[l++]=n,h[l++]=s,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const $=this._$vertexBufferData;let _=this._$vertexBufferPos;$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=r,$[_++]=-1,$[_++]=-1,$[_++]=10,$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=r,$[_++]=1,$[_++]=1,$[_++]=10,this._$vertexBufferPos=_}}class Le{constructor(t,e,i,r){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,r),this._$uniform=new ke(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(t,e){const i=this._$gl.createProgram();i.id=r++;const s=this._$gl.createShader(this._$gl.VERTEX_SHADER);this._$gl.shaderSource(s,t),this._$gl.compileShader(s);const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);return this._$gl.shaderSource(n,e),this._$gl.compileShader(n),this._$gl.attachShader(i,s),this._$gl.attachShader(i,n),this._$gl.linkProgram(i),this._$gl.detachShader(i,s),this._$gl.detachShader(i,n),this._$gl.deleteShader(s),this._$gl.deleteShader(n),i}_$attachProgram(){this._$context._$shaderList._$currentProgramId!==this._$program.id&&(this._$context._$shaderList._$currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(t,e){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(t,e),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawElements(this._$gl.TRIANGLES,t.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t);const e=t.indexRanges[t.indexRanges.length-1],i=e.first+e.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,i)}_$containerClip(t,e,i){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.TRIANGLES,e,i)}_$drawPoints(t,e,i){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.POINTS,e,i)}}class Pe{constructor(t,e){this._$currentProgramId=-1,this._$shapeShaderVariants=new he(t,e),this._$bitmapShaderVariants=new re(t,e),this._$gradientShapeShaderVariants=new oe(t,e),this._$gradientLUTShaderVariants=new ae(t,e),this._$filterShaderVariants=new ne(t,e),this._$blendShaderVariants=new se(t,e)}get shapeShaderVariants(){return this._$shapeShaderVariants}get bitmapShaderVariants(){return this._$bitmapShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Ne{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=$.floor(.75*e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new S(256),this._$rgbIdentityTable=new S(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=$.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,s=this._$context._$shaderList.gradientLUTShaderVariants,n=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<r;i+=this._$maxLength-1){const a=$.min(i+this._$maxLength,r),o=s.getGradientLUTShader(a-i,e),h=o.uniform;s.setGradientLUTUniformForShape(h,t,i,a,n),o._$drawGradient(0===i?0:t[i][0],a===r?1:t[a-1][0])}return this._$context._$bind(i),this._$attachment.texture}generateForFilter(t,e,i){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const s=t.length,n=this._$context._$shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<s;r+=this._$maxLength-1){const a=$.min(r+this._$maxLength,s),o=n.getGradientLUTShader(a-r,!1),h=o.uniform;n.setGradientLUTUniformForFilter(h,t,e,i,r,a),o._$drawGradient(0===r?0:t[r],a===s?1:t[a-1])}return this._$context._$bind(r),this._$attachment.texture}}class ke{constructor(t,e){this._$gl=t,this._$array=[],this._$map=new Map;const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),r=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,s={},n=this._$gl.getUniformLocation(e,r);if(i.type!==this._$gl.SAMPLER_2D||1!==i.size){switch(i.type){case this._$gl.FLOAT_VEC4:s.method=this._$gl.uniform4fv.bind(this._$gl,n),s.array=new S(4*i.size),s.assign=-1;break;case this._$gl.INT_VEC4:s.method=this._$gl.uniform4iv.bind(this._$gl,n),s.array=new Int32Array(4*i.size),s.assign=-1;break;case this._$gl.SAMPLER_2D:s.method=this._$gl.uniform1iv.bind(this._$gl,n),s.array=new Int32Array(i.size),s.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(s),this._$map.set(r,s)}}}getArray(t){return this._$map.get(t).array}get textures(){return this._$map.get("u_textures").array}get highp(){return this._$map.get("u_highp").array}get mediump(){return this._$map.get("u_mediump").array}get integer(){return this._$map.get("u_integer").array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array))}}}class De{constructor(){this._$stage=new ft,this._$stage._$player=this,B.$rendererWorker&&B.$rendererWorker.postMessage({command:"setStage",instanceId:this._$stage._$instanceId}),this._$cacheStore=new Kt,this._$mode="loader",this._$actionOffset=0,this._$actions=B.$getArray(),this._$loaders=B.$getArray(),this._$sounds=B.$getMap(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$ratio=n,this._$stopFlag=!0,this._$startTime=0,this._$fps=16,this._$isLoad=!1,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=B.$getFloat32Array6(1,0,0,1,0,0),this._$tx=0,this._$ty=0,this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$broadcastEvents=B.$getMap(),this._$optionWidth=0,this._$optionHeight=0,this._$tagId=null,this._$bgColor=null,this._$base="",this._$fullScreen=!1,this._$quality=mt.HIGH,this._$sources=B.$getArray(),this._$videos=B.$getArray(),this._$textField=null,this._$touchY=0,this._$bindRun=this._$run.bind(this),this._$timerId=-1,this._$loadId=-1,this._$context=null,this._$buffer=null}static get LOAD_START(){return 1}static get LOAD_END(){return 2}get broadcastEvents(){return this._$broadcastEvents}get base(){return this._$base}set base(t){if("string"==typeof t)if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${h.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else if(-1===t.indexOf("?"))this._$base="/"===t.slice(-1)?t:`${t}/`;else{const e=t.split("?")[0];this._$base="/"===e.slice(-1)?e:`${e}/`}}get stage(){return this._$stage}get x(){return this._$tx}get y(){return this._$ty}get scaleX(){return this._$matrix[0]}get scaleY(){return this._$matrix[3]}get contentElementId(){return`${B.$PREFIX}`}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}play(){if(this._$stopFlag){if(this._$stopFlag=!1,this._$timerId>-1){b(this._$timerId)}this._$startTime=m.now();const t=this._$stage._$frameRate;this._$fps=1e3/t;const e=A;this._$timerId=e(this._$bindRun),B.$rendererWorker&&B.$rendererWorker.postMessage({command:"play",frameRate:t})}}stop(){b(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,Dt.stopAll(),this._$cacheStore.reset(),B.$rendererWorker&&B.$rendererWorker.postMessage({command:"stop"})}removeCache(t){this._$cacheStore.removeCache(t),B.$rendererWorker&&B.$rendererWorker.postMessage({command:"removeCache",id:t})}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this.base=t.base||this._$base,this._$fullScreen=!!t.fullScreen,"bgColor"in t&&(this._$bgColor=t.bgColor)),this._$initialize()}_$loadWebAudio(){B.$audioContext||B.$loadAudioData()}_$updateLoadStatus(){if(this._$loadStatus===De.LOAD_END)return void this._$loaded();const t=A;this._$loadId=t(this._$updateLoadStatus.bind(this))}_$loaded(){const t=a.getElementById(this.contentElementId);if(t){this._$setBackgroundColor(this._$bgColor),this._$deleteNode(),t.appendChild(this._$canvas),this._$stage._$prepareActions(),this._$broadcastEvents.has(O.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new O(O.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(O.EXIT_FRAME)&&this._$dispatchEvent(new O(O.EXIT_FRAME));const e=0|this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t instanceof ct&&(t._$lock=!1),t.hasEventListener(O.INIT)&&t.dispatchEvent(new O(O.INIT)),t.hasEventListener(O.COMPLETE)&&t.dispatchEvent(new O(O.COMPLETE)),t._$player=null}this._$broadcastEvents.has(O.ACTIVATE)&&this._$dispatchEvent(new O(O.ACTIVATE)),this._$doAction(),this._$draw(),this.play()}}_$initialize(){const t=a;if("loading"===t.readyState){const t=function(e){e.target.removeEventListener("DOMContentLoaded",t),this._$initialize()}.bind(this);return void s.addEventListener("DOMContentLoaded",t)}const e=this.contentElementId;if(null===this._$tagId)t.body.insertAdjacentHTML("beforeend",`<div id="${e}"></div>`);else{const i=t.getElementById(this._$tagId);if(!i)return void alert("Not Found Tag ID:"+this._$tagId);if(t.getElementById(e))this._$deleteNode();else{const r=t.createElement("div");r.id=e,r.tabIndex=-1,i.appendChild(r)}}this._$canvas||this._$initializeCanvas();const i=t.getElementById(e),r=i.parentNode;if(r){this._$initStyle(i),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===r.tagName?s.innerWidth:r.offsetWidth,e=this._$optionHeight?this._$optionHeight:"BODY"===r.tagName?s.innerHeight:r.offsetHeight;"loader"===this._$mode&&t&&e&&(this._$baseWidth=t,this._$baseHeight=e,this._$resize())}"loader"===this._$mode?(this._$loadStatus=De.LOAD_START,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(e){const i=e.style;i.position="relative",i.top="0",i.left="0",i.backgroundColor="transparent",i.overflow="hidden",i.padding="0",i.margin="0",i.userSelect="none",i.outline="none";const r=this._$optionWidth,s=this._$optionHeight,n=e.parentNode;if("BODY"===n.tagName)return i.width=r?`${r}px`:`${t.innerWidth}px`,void(i.height=s?`${s}px`:`${t.innerHeight}px`);i.width=r?`${r}px`:`${n.offsetWidth}px`,i.height=s?`${s}px`:`${n.offsetHeight}px`}_$buildWait(){const t=a.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=a.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=a.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){const t=a.createElement("canvas");if(t.width=1,t.height=1,B.$rendererWorker){const e=t.transferControlToOffscreen();B.$rendererWorker.postMessage({command:"initialize",canvas:e,samples:this._$getSamples(),devicePixelRatio:n},[e])}else{const e=t.getContext("webgl2",{stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0});e?(this._$context=new Te(e,this._$getSamples()),this._$cacheStore._$context=this._$context):alert("WebGL setting is off. Please turn the setting on.")}if(B.$isTouch){const e=t=>{t.target.removeEventListener(B.$TOUCH_END,e),B.$loadAudioData()};t.addEventListener(B.$TOUCH_END,e),t.addEventListener(B.$TOUCH_START,(t=>{B.$event=t,B.$eventType=B.$TOUCH_START,this._$touchY=t.changedTouches[0].pageY,this._$hitTest()})),t.addEventListener(B.$TOUCH_MOVE,(t=>{B.$event=t,B.$eventType=B.$TOUCH_MOVE,this._$hitTest()})),t.addEventListener(B.$TOUCH_END,(t=>{B.$event=t,B.$eventType=B.$TOUCH_END,this._$hitTest()})),t.addEventListener(B.$TOUCH_MOVE,(t=>{const e=t.changedTouches[0].pageY;t.deltaY=this._$touchY-e,this._$touchY=e,B.$event=t,B.$eventType=B.$MOUSE_WHEEL,this._$hitTest()}),{passive:!1})}else{const e=t=>{t.target.removeEventListener(B.$MOUSE_DOWN,e),B.$loadAudioData()};t.addEventListener(B.$MOUSE_DOWN,e),t.addEventListener(B.$MOUSE_DOWN,(t=>{B.$event=t,B.$eventType=B.$MOUSE_DOWN,t.button||this._$hitTest()})),t.addEventListener(B.$DOUBLE_CLICK,(t=>{B.$event=t,B.$eventType=B.$DOUBLE_CLICK,t.button||this._$hitTest()})),t.addEventListener(B.$MOUSE_LEAVE,(t=>{B.$event=t,B.$eventType=B.$MOUSE_LEAVE,this._$hitTest(),B.$event=null,this._$stageX=-1,this._$stageY=-1})),t.addEventListener(B.$MOUSE_UP,(t=>{B.$event=t,B.$eventType=B.$MOUSE_UP,t.button||this._$hitTest()})),t.addEventListener(B.$MOUSE_MOVE,(t=>{B.$event=t,B.$eventType=B.$MOUSE_MOVE,this._$hitTest()})),t.addEventListener(B.$MOUSE_WHEEL,(t=>{t.defaultPrevented||(B.$event=t,B.$eventType=B.$MOUSE_WHEEL,this._$hitTest())}),{passive:!1})}const e=t.style;e.position="absolute",e.top="0",e.left="0",e.webkitTapHighlightColor="rgba(0,0,0,0)",e.backfaceVisibility="hidden",e.transformOrigin="0 0",1!==n&&(e.transform=`scale(${1/n})`),this._$canvas=t}_$resize(){const t=a.getElementById(this.contentElementId);if(t){this._$stage._$doChanged(),this._$cacheStore.reset();const e=t.parentNode,i=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?s.innerWidth:e.offsetWidth?e.offsetWidth:f(e.style.width),r=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?s.innerHeight:e.offsetHeight?e.offsetHeight:f(e.style.height),a="BODY"===e.tagName?s.innerWidth:e.offsetWidth,o=$.min(i/this._$baseWidth,r/this._$baseHeight);let h=this._$fullScreen?i:this._$baseWidth*o|0,l=this._$fullScreen?r:this._$baseHeight*o|0;const _=t.style;_.width=`${h}px`,_.height=`${l}px`,_.top="0",_.left=this._$fullScreen?"0":a/2-h/2+"px",h*=n,l*=n,this._$scale=o,this._$width=h,this._$height=l;const c=this._$scale*this._$ratio;this._$matrix[0]=c,this._$matrix[3]=c,this._$fullScreen&&(this._$tx=(h-this._$baseWidth*o*n)/2,this._$ty=(l-this._$baseHeight*o*n)/2,this._$matrix[4]=this._$tx,this._$matrix[5]=this._$ty),this._$resizeCanvas(h,l,c,this._$tx,this._$ty),this._$ratio>1&&n>1&&(this._$canvas.style.transform=`scale(${1/this._$ratio})`),t.children.length>1&&t.children[1].dispatchEvent(new s.Event(`${B.$PREFIX}_blur`))}}_$setBackgroundColor(t=null){if(B.$rendererWorker)B.$rendererWorker.postMessage({command:"setBackgroundColor",backgroundColor:t});else{const e=this._$context;if(!e)return;if(t&&"transparent"!==t){const i=B.$uintToRGBA(B.$toColorInt(t));e._$setColor(i.R/255,i.G/255,i.B/255,i.A/255)}else e._$setColor(0,0,0,0)}}_$resizeCanvas(t,e,i,r=0,s=0){if(B.$rendererWorker)B.$rendererWorker.postMessage({command:"resize",width:t,height:e,scale:i,tx:r,ty:s});else{const i=this._$context;if(!i)return;this._$canvas.width=t,this._$canvas.height=e,i._$gl.viewport(0,0,t,e);const r=i._$frameBufferManager;this._$buffer&&(r.unbind(),r.releaseAttachment(this._$buffer,!0)),this._$buffer=r.createCacheAttachment(t,e,!1),r._$stencilBufferPool._$maxWidth=t,r._$stencilBufferPool._$maxHeight=e,r._$textureManager._$maxWidth=t,r._$textureManager._$maxHeight=e,i._$pbo._$maxWidth=t,i._$pbo._$maxHeight=e}}_$getSamples(){switch(this._$quality){case mt.HIGH:return B.$HIGH_SAMPLES;case mt.MEDIUM:return B.$MEDIUM_SAMPLES;default:return B.$LOW_SAMPLES}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t._$eventPhase=P.AT_TARGET;const i=e.length;for(let r=0;r<i;++r){const i=e[r];if(t._$currentTarget=i.target,t._$listener=i.listener,i.listener.call(s,t),t._$stopImmediatePropagation)break}return B.$poolArray(e),!0}}_$run(t=0){if(this._$stopFlag)return;this._$doAction();let e=t-this._$startTime;e>this._$fps?(this._$startTime=t-e%this._$fps,this._$action(),this._$draw(),!this._$hitTestStart&&"up"===this._$state&&B.$event&&this._$stageX>-1&&this._$stageY>-1&&this._$pointerCheck()):this._$videos.length&&!B.$rendererWorker&&this._$draw();const i=A;this._$timerId=i(this._$bindRun)}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,B.$hitContext.setTransform(1,0,0,1,0,0),B.$hitContext.beginPath(),B.$MATRIX_HIT_ARRAY_IDENTITY[4]=this._$tx/this._$scale/n,B.$MATRIX_HIT_ARRAY_IDENTITY[5]=this._$ty/this._$scale/n,this._$stage._$mouseHit(B.$hitContext,B.$MATRIX_HIT_ARRAY_IDENTITY,this._$hitObject,!0);let i=null,r=null,s=!1,a=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(G.MOUSE_OUT)&&t.dispatchEvent(new G(G.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==i){let s=null;if(this._$rollOverObject)for(r=this._$rollOverObject,r.willTrigger(G.ROLL_OUT)&&r.dispatchEvent(new G(G.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),s=r._$parent;s&&s._$root!==s&&s!==i;){if(s._$mouseEnabled&&s._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===s){t=!0;break}e=e._$parent}if(!t&&s._$parent===i._$parent&&s._$index>i._$index&&(t=!0),t)break}s.willTrigger(G.ROLL_OUT)&&s.dispatchEvent(new G(G.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),s=s._$parent}for(r=i;r.willTrigger(G.ROLL_OVER)&&r.dispatchEvent(new G(G.ROLL_OVER,!1,!1,r.mouseX,r.mouseY)),r=r._$parent,r&&r!==s&&r.stage!==r;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i.willTrigger(G.MOUSE_OVER)&&i.dispatchEvent(new G(G.MOUSE_OVER,!0,!1,i.mouseX,i.mouseY)),this._$mouseOverTarget=i}if("up"===this._$state&&(this._$clickTarget=null),!B.$isTouch&&"up"===this._$state)for(r=i;r&&r.root!==r;){switch(!0){case r instanceof Ut:r._$type===Ot.INPUT&&(s=!0);break;case r.buttonMode:a=!0}if(s||a)break;r=r._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(G.MOUSE_OUT)&&i.dispatchEvent(new G(G.MOUSE_OUT,!0,!1,i.mouseX,i.mouseY))),this._$rollOverObject)for(r=this._$rollOverObject;r&&r.root!==r;)r.willTrigger(G.ROLL_OUT)&&r.dispatchEvent(new G(G.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),r=r._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case s:this._$canvas.style.cursor="text";break;case a:this._$canvas.style.cursor="pointer";break;case!B.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has(O.ENTER_FRAME)&&this._$dispatchEvent(new O(O.ENTER_FRAME)),this._$broadcastEvents.has(O.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new O(O.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(O.EXIT_FRAME)&&this._$dispatchEvent(new O(O.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new O(O.RENDER))),e){for(let i=0;i<e;++i){const e=t[i];e.hasEventListener(O.INIT)&&e.dispatchEvent(new O(O.INIT)),e.hasEventListener(O.COMPLETE)&&e.dispatchEvent(new O(O.COMPLETE))}B.$poolArray(t)}this._$doAction()}_$draw(){if(!this._$width||!this._$height)return;if(!this._$stage._$updated)return;if(this._$sounds.size){const t=this._$sounds.values();for(const e of t)e._$soundPlay();this._$sounds.clear()}const t=this._$context;if(!t)return;t._$bind(this._$buffer),B.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.beginPath(),this._$stage._$draw(t,this._$matrix,B.$COLOR_ARRAY_IDENTITY),this._$stage._$updated=!1;const e=t._$frameBufferManager,i=e.getTextureFromCurrentAttachment();e.unbind(),B.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.drawImage(i,0,0,this._$width,this._$height),t._$bind(this._$buffer)}_$doAction(){for(;this._$actions.length;){B.$actionProcess=!0;const t=this._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;t._$actionProcess=!0;const i=t._$actions.get(e),r=i.length;for(let e=0;e<r;++e)B.$currentLoaderInfo=t._$loaderInfo,i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}B.$currentLoaderInfo=null,B.$actionProcess=!1}_$hitTest(){if(this._$stopFlag)return;this._$hitTestStart=!0,B.$isUpdated=!1;const t=B.$event;let e=null,i=null,r=s.pageXOffset,o=s.pageYOffset;const h=a.getElementById(this.contentElementId);if(h){const t=h.getBoundingClientRect();r+=t.left,o+=t.top}let l=0,$=0;if(B.$isTouch){const e=t.changedTouches[0];l=e.pageX,$=e.pageY}else l=t.pageX,$=t.pageY;l=(l-r)/this._$scale,$=($-o)/this._$scale,t._$stageX=l,t._$stageY=$,this._$stageX=l,this._$stageY=$,this._$hitObject.x=l,this._$hitObject.y=$,this._$hitObject.pointer="",this._$hitObject.hit=null,B.$hitContext.setTransform(1,0,0,1,0,0),B.$hitContext.beginPath(),B.$MATRIX_HIT_ARRAY_IDENTITY[4]=this._$tx/this._$scale/n,B.$MATRIX_HIT_ARRAY_IDENTITY[5]=this._$ty/this._$scale/n,this._$stage._$mouseHit(B.$hitContext,B.$MATRIX_HIT_ARRAY_IDENTITY,this._$hitObject,!0),this._$hitObject.hit&&t.preventDefault();let _=!1,c=!1,u=!1;switch(B.$eventType){case B.$TOUCH_MOVE:case B.$MOUSE_MOVE:if(B.$dropTarget){const t=B.$dropTarget._$dragMousePoint();let e=t.x,i=t.y;B.$dragRules.lock||(e+=B.$dragRules.position.x,i+=B.$dragRules.position.y);const r=B.$dragRules.bounds;r&&(e=B.$clamp(e,r.left,r.right),i=B.$clamp(i,r.top,r.bottom)),B.$dropTarget.x=e,B.$dropTarget.y=i}break;case B.$TOUCH_START:case B.$MOUSE_DOWN:this._$state="down",u="pointer"===this._$canvas.style.cursor,c=!0;break;case B.$TOUCH_END:case B.$MOUSE_UP:case B.$DOUBLE_CLICK:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case B.$eventType===B.$MOUSE_LEAVE:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(G.MOUSE_OUT)&&e.dispatchEvent(new G(G.MOUSE_OUT,!0,!1,e.mouseX,e.mouseY))),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(G.ROLL_OUT)&&i.dispatchEvent(new G(G.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,B.$eventType){case B.$MOUSE_WHEEL:this._$stage.hasEventListener(G.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new G(G.MOUSE_WHEEL,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case B.$TOUCH_START:case B.$MOUSE_DOWN:this._$stage.hasEventListener(G.MOUSE_DOWN)&&this._$stage.dispatchEvent(new G(G.MOUSE_DOWN,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$textField&&this._$textField instanceof Ut&&(this._$textField.focus=!1,this._$textField=null);break;case B.$TOUCH_END:case B.$MOUSE_UP:this._$textField&&this._$textField instanceof Ut&&(this._$textField.focus=!1,this._$textField=null),this._$stage.hasEventListener(G.CLICK)&&this._$stage.dispatchEvent(new G(G.CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$stage.hasEventListener(G.MOUSE_UP)&&this._$stage.dispatchEvent(new G(G.MOUSE_UP,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case B.$TOUCH_MOVE:case B.$MOUSE_MOVE:this._$stage.hasEventListener(G.MOUSE_MOVE)&&this._$stage.dispatchEvent(new G(G.MOUSE_MOVE,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case B.$DOUBLE_CLICK:this._$stage.hasEventListener(G.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new G(G.DOUBLE_CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY))}break;default:switch(e=this._$hitObject.hit,B.$eventType){case B.$TOUCH_MOVE:case B.$MOUSE_MOVE:if(e.willTrigger(G.MOUSE_MOVE)&&e.dispatchEvent(new G(G.MOUSE_MOVE,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(G.MOUSE_OUT)&&t.dispatchEvent(new G(G.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(G.ROLL_OUT)&&i.dispatchEvent(new G(G.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(l,$)){let i=!1,r=e;for(;r&&r._$root!==r;){if(r===t){i=!0;break}r=r._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(G.ROLL_OUT)&&t.dispatchEvent(new G(G.ROLL_OUT,!1,!1,t.mouseX,t.mouseY)),t=t._$parent}for(i=e;i.willTrigger(G.ROLL_OVER)&&i.dispatchEvent(new G(G.ROLL_OVER,!1,!1,i.mouseX,i.mouseY)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(G.MOUSE_OVER)&&e.dispatchEvent(new G(G.MOUSE_OVER,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget=e}"up"===this._$state&&(this._$clickTarget=null);break;case B.$TOUCH_START:case B.$MOUSE_DOWN:e!==this._$textField&&this._$textField instanceof Ut&&(this._$textField.focus=!1,this._$textField=null),e instanceof Ut&&(e.focus=!0,this._$textField=e),e.willTrigger(G.MOUSE_DOWN)&&e.dispatchEvent(new G(G.MOUSE_DOWN,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=e;break;case B.$TOUCH_END:case B.$MOUSE_UP:e!==this._$textField&&this._$textField instanceof Ut&&(this._$textField.focus=!1,this._$textField=null),e.willTrigger(G.MOUSE_UP)&&e.dispatchEvent(new G(G.MOUSE_UP,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget===e&&e.willTrigger(G.CLICK)&&e.dispatchEvent(new G(G.CLICK,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=null;break;case B.$MOUSE_WHEEL:e.willTrigger(G.MOUSE_WHEEL)&&e.dispatchEvent(new G(G.MOUSE_WHEEL)),e instanceof Ut&&e._$scrollEnabled&&(e.scrollV+=t.deltaY);break;case B.$DOUBLE_CLICK:e.willTrigger(G.DOUBLE_CLICK)&&e.dispatchEvent(new G(G.DOUBLE_CLICK))}if(!c&&!B.$isTouch&&"up"===this._$state)for(i=e;i&&i.root!==i;){if(i instanceof Ut){if(i._$type===Ot.INPUT){_=!0;break}}else if(i._$buttonMode){u=!0;break}i=i._$parent}}switch(!0){case _:this._$canvas.style.cursor="text";break;case u:this._$canvas.style.cursor="pointer";break;case!B.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}!B.$actionProcess&&this._$actions.length>1&&this._$doAction(),B.$isUpdated&&(this._$stage._$prepareActions(),B.$actionProcess||this._$doAction()),this._$hitTestStart=!1}}s.next2d=new class{constructor(){this._$player=new De}load(t,e=null){if("develop"===t){const e=h.search.slice(1).split("&")[0];if(!e)return;t=`${h.origin}/${e}`}if(!t)return;"/"===t.charAt(1)&&(t=t.slice(1)),e&&"base"in e||!(t.indexOf("//")>-1)||(this._$player.base=t),this._$player.setOptions(e);const i=new _t,r=i.contentLoaderInfo;r.addEventListener(D.IO_ERROR,(t=>{t.target.removeEventListener(D.IO_ERROR,t.listener),alert("Error: "+t.message)})),r.addEventListener(O.COMPLETE,(t=>{const e=t.target;e.removeEventListener(O.COMPLETE,t.listener);const i=B.$currentPlayer(),r=e._$data.stage;if(null===i._$bgColor&&(i._$bgColor=B.$getArray(1,1,1,1)),_.isArray(i._$bgColor)){const t=B.$intToRGBA(0|`0x${r.bgColor.slice(1)}`);i._$bgColor[0]=t.R/255,i._$bgColor[1]=t.G/255,i._$bgColor[2]=t.B/255}i._$setBackgroundColor(i._$bgColor),i.stage.addChild(e.content),i._$baseWidth=0|r.width,i._$baseHeight=0|r.height,i.stage._$frameRate=B.$clamp(+r.fps,1,60,60),i._$resize()})),i.load(new Xt(t))}createRootMovieClip(t=240,e=240,i=24,r=null){const s=this._$player;s._$baseWidth=0|t,s._$baseHeight=0|e,s._$loadStatus=De.LOAD_END,s._$mode="create",s._$stage._$frameRate=0|i,s.setOptions(r);const n=s._$stage.addChild(new J);return s.play(),n}},B.$packages(s.next2d),console.log("%c Next2D Player %c 1.14.4 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729","")})(window);