/*!
 * licenses: MIT Licenses.
 * version: 1.0.0
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2020-2021 Toshiyuki Ienaga.
 */
"next2d"in window||function(t){"use strict";let e=0,i=0;const r={$PREFIX:"__next2d__"};r.$MAX_VALUE=t.Number.MAX_VALUE,r.$MIN_VALUE=t.Number.MIN_VALUE,r.$HIGH_SAMPLES=4,r.$MEDIUM_SAMPLES=2,r.$LOW_SAMPLES=0,r.$LOAD_START="loadstart",r.$PROGRESS="progress",r.$LOADEND="loadend",r.$TOUCH_START="touchstart",r.$TOUCH_MOVE="touchmove",r.$TOUCH_END="touchend",r.$MOUSE_DOWN="mousedown",r.$MOUSE_MOVE="mousemove",r.$MOUSE_UP="mouseup",r.$MOUSE_WHEEL="wheel",r.$DOUBLE_CLICK="dblclick",r.$MOUSE_LEAVE="mouseleave",r.$KEY_DOWN="keydown",r.$KEY_UP="keyup",r.$SCROLL="scroll",r.$P_TAG=t.document.createElement("p"),r.$COLOR_ARRAY_IDENTITY=new Float32Array([1,1,1,1,0,0,0,0]),r.$COLOR_MATRIX_FILTER=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],r.$soundMixerVolume=1,r.$bezierConverterBuffer=new Array(32),r.$window=t,r.$document=t.document,r.$navigator=t.navigator,r.$userAgent=t.navigator.userAgent,r.$location=t.location,r.$isNaN=t.isNaN,r.$min=Math.min,r.$max=Math.max,r.$sin=Math.sin,r.$cos=Math.cos,r.$tan=Math.tan,r.$sqrt=Math.sqrt,r.$pow=Math.pow,r.$abs=Math.abs,r.$sign=Math.sign,r.$ceil=Math.ceil,r.$atan2=Math.atan2,r.$floor=Math.floor,r.$round=Math.round,r.$SQRT2=Math.SQRT2,r.$PI=Math.PI,r.$Deg2Rad=r.$PI/180,r.$Rad2Deg=180/r.$PI,r.$Array=t.Array,r.$Map=t.Map,r.$Image=t.Image,r.$URL=t.URL,r.$Blob=t.Blob,r.$parseFloat=t.parseFloat,r.$setTimeout=t.setTimeout,r.$encodeURIComponent=t.encodeURIComponent,r.$Infinity=t.Infinity,r.$WebGLTexture=t.WebGLTexture,r.$clearTimeout=t.clearTimeout,r.$setTimeout=t.setTimeout,r.$audioContext=null,r.$CanvasRenderingContext2D=t.CanvasRenderingContext2D,r.$requestAnimationFrame=t.requestAnimationFrame,r.$cancelAnimationFrame=t.cancelAnimationFrame,r.$performance=t.performance,r.$Float32Array=t.Float32Array,r.$Int16Array=t.Int16Array,r.$variables=new Map,r.$isUpdated=!1,r.$event=null,r.$dropTarget=null,r.$dragRules={lock:!1,position:{x:0,y:0},bounds:null},r.$rgbToLinearTable=new r.$Float32Array(256),r.$rgbIdentityTable=new r.$Float32Array(256);for(let t=0;t<256;++t)r.$rgbToLinearTable[t]=r.$pow(t/255,2.23333333),r.$rgbIdentityTable[t]=t/255;r.$SHORT_INT_MIN=-32768,r.$SHORT_INT_MAX=32767,r.$devicePixelRatio=r.$min(2,t.devicePixelRatio),r.$MATRIX_ARRAY_IDENTITY=new Float32Array([1,0,0,1,0,0]),r.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0=new Float32Array([r.$devicePixelRatio,0,0,r.$devicePixelRatio,0,0]),r.$bounds=[],r.$arrays=[],r.$audios=[],r.$maps=[],r.$preObjects=[],r.$matrices=[],r.$colors=[],r.$float32Array4=[],r.$float32Array6=[],r.$float32Array8=[],r.$float32Array9=[],r.$isAndroid=r.$userAgent.indexOf("Android")>-1,r.isiOS=r.$userAgent.indexOf("iPhone")>-1||r.$userAgent.indexOf("iPod")>-1,r.$isTouch=r.$isAndroid||r.isiOS,r.$isChrome=r.$userAgent.indexOf("Chrome")>-1,r.$isFireFox=r.$userAgent.indexOf("Firefox")>-1,r.$isSafari=-1===r.$userAgent.indexOf("Chrome")&&r.$userAgent.indexOf("Safari")>-1,r.$isEdge=r.$userAgent.indexOf("Edge")>-1,r.$isMac=r.$userAgent.indexOf("Mac")>-1,r.$isWindows=!1===r.$isMac;const s=t.document.createElement("canvas");s.width=1,s.height=1,r.$hitContext=s.getContext("2d"),r.$hitContext.globalAlpha=0,r.$hitContext.imageSmoothingEnabled=!1;const n=t.document.createElement("canvas");n.width=1,n.height=1,r.$textContext=n.getContext("2d"),r.$hitContext.globalAlpha=0,r.$hitContext.imageSmoothingEnabled=!1,r.$DIV=null,r.$isArray=function(t){return r.$Array.isArray(t)},r.$getArray=function(...t){const e=r.$arrays.pop()||[];return t.length&&e.push.apply(e,t),e},r.$poolArray=function(t){t.length&&(t.length=0),r.$arrays.push(t)},r.$clamp=function(t,e,i,s=null){const n=+t;return r.$isNaN(n)&&null!==s?s:r.$min(r.$max(e,r.$isNaN(n)?0:n),i)},r.$multiplicationColor=function(t,e){return r.$getFloat32Array8(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7])},r.$multiplicationMatrix=function(t,e){return r.$getFloat32Array6(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5])},r.$getBoundsObject=function(t=0,e=0,i=0,s=0){const n=r.$bounds.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return n.xMin=t,n.xMax=e,n.yMin=i,n.yMax=s,n},r.$poolBoundsObject=function(t){r.$bounds.push(t)},r.$poolMap=function(t){t.size&&t.clear(),r.$maps.push(t)},r.$getMap=function(){return r.$maps.pop()||new r.$Map},r.$getFloat32Array4=function(t=0,e=0,i=0,s=0){const n=r.$float32Array4.pop()||new r.$window.Float32Array(4);return n[0]=t,n[1]=e,n[2]=i,n[3]=s,n},r.$poolFloat32Array4=function(t){r.$float32Array4.push(t)},r.$getFloat32Array6=function(t=0,e=0,i=0,s=0,n=0,a=0){const o=r.$float32Array6.pop()||new r.$window.Float32Array(6);return o[0]=t,o[1]=e,o[2]=i,o[3]=s,o[4]=n,o[5]=a,o},r.$poolFloat32Array6=function(t){r.$float32Array6.push(t)},r.$getFloat32Array8=function(t=1,e=1,i=1,s=1,n=0,a=0,o=0,h=0){const l=r.$float32Array8.pop()||new r.$window.Float32Array(8);return l[0]=t,l[1]=e,l[2]=i,l[3]=s,l[4]=n,l[5]=a,l[6]=o,l[7]=h,l},r.$poolFloat32Array8=function(t){r.$float32Array8.push(t)},r.$getFloat32Array9=function(t=0,e=0,i=0,s=0,n=0,a=0,o=0,h=0,l=0){const $=r.$float32Array9.pop()||new r.$window.Float32Array(9);return $[0]=t,$[1]=e,$[2]=i,$[3]=s,$[4]=n,$[5]=a,$[6]=o,$[7]=h,$[8]=l,$},r.$poolFloat32Array9=function(t){r.$float32Array9.push(t)},r.$currentPlayer=function(){return t.next2d._$player},r.$currentMousePoint=function(){const t=r.$currentPlayer();let e=r.$window.pageXOffset,i=r.$window.pageYOffset;const s=r.$document.getElementById(t.contentElementId);if(s){const t=s.getBoundingClientRect();e+=t.left,i+=t.top}let n=r.$event.pageX,a=r.$event.pageY;if(r.$isTouch){const t=r.$event.changedTouches[0];n=t.pageX,a=t.pageY}const o=(n-e)/t._$scale|0,h=(a-i)/t._$scale|0;return new p(o,h)},r.$boundsMatrix=function(t,e){const i=t.xMax*e[0]+t.yMax*e[2]+e[4],s=t.xMax*e[0]+t.yMin*e[2]+e[4],n=t.xMin*e[0]+t.yMax*e[2]+e[4],a=t.xMin*e[0]+t.yMin*e[2]+e[4],o=t.xMax*e[1]+t.yMax*e[3]+e[5],h=t.xMax*e[1]+t.yMin*e[3]+e[5],l=t.xMin*e[1]+t.yMax*e[3]+e[5],$=t.xMin*e[1]+t.yMin*e[3]+e[5],_=r.$min(r.$MAX_VALUE,i,s,n,a),c=r.$max(-r.$MAX_VALUE,i,s,n,a),u=r.$min(r.$MAX_VALUE,o,h,l,$),d=r.$max(-r.$MAX_VALUE,o,h,l,$);return r.$getBoundsObject(_,c,u,d)},r.$upperPowerOfTwo=function(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t},r.$getMatrix=function(t=1,e=0,i=0,s=1,n=0,a=0){if(!r.$matrices.length)return new f(t,e,i,s,n,a);const o=r.$matrices.pop();return o._$matrix=r.$getFloat32Array6(t,e,i,s,n,a),o},r.$poolMatrix=function(t){r.$poolFloat32Array6(t._$matrix),t._$matrix=null,r.$matrices.push(t)},r.$toBoolean=function(t=!1){switch(typeof t){case"boolean":return t;case"function":return!0;case"object":case"string":case"number":return!!t;default:return!1}},r.$getColorTransform=function(t=1,e=1,i=1,s=1,n=0,a=0,o=0,h=0){if(!r.$colors.length)return new g(t,e,i,s,n,a,o,h);const l=r.$colors.pop();return l._$colorTransform=r.$getFloat32Array8(t,e,i,s,n,a,o,h),l},r.$poolColorTransform=function(t){r.$poolFloat32Array8(t._$colorTransform),t._$colorTransform=null,r.$colors.push(t)},r.$toColorInt=function(t){return r.$isNaN(+t)?this.$colorStringToInt(t):+t},r.$colorStringToInt=function(t){r.$hitContext.fillStyle=t;const e=r.$hitContext.fillStyle.substr(1);return r.$hitContext.fillStyle="rgba(0, 0, 0, 1)",0|`0x${e}`},r.$intToR=function(t,e,i){return(t>>16)*(i?e:1)/255},r.$intToG=function(t,e,i){return(t>>8&255)*(i?e:1)/255},r.$intToB=function(t,e,i){return(255&t)*(i?e:1)/255},r.$uintToRGBA=function(t){return{A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}},r.$intToRGBA=function(t,e=1){return{R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}},r.$generateColorTransform=function(t,e){return{R:r.$max(0,r.$min(t.R*e[0]+e[4],255)),G:r.$max(0,r.$min(t.G*e[1]+e[5],255)),B:r.$max(0,r.$min(t.B*e[2]+e[6],255)),A:r.$max(0,r.$min(255*t.A*e[3]+e[7],255))/255}},r.$cacheStore=function(){return r.$currentPlayer()._$cacheStore},r.$inverseMatrix=function(t){const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return r.$getFloat32Array9(t[4]*e,-t[1]*e,0,-t[3]*e,t[0]*e,0,i*e,s*e,1)},r.$decodeAudioFailed=function(){const t=this._$character?this._$character.buffer:this._$buffer;let e=0;for(;e=t.indexOf(255,e),-1!==e&&224!=(224&t[e+1]);)++e;e>-1&&r.$audioContext.decodeAudioData(t.buffer.subarray(e),r.$decodeAudioSuccess.bind(this))},r.$decodeAudioSuccess=function(t){this._$character?(this._$character.buffer=null,this._$character.audioBuffer=t):(this._$buffer=null,this._$audioBuffer=t)},r.$decodeAudioData=function(t){const e=t._$character?t._$character.buffer:t._$buffer;e&&r.$audioContext.decodeAudioData(e.buffer,r.$decodeAudioSuccess.bind(t),r.$decodeAudioFailed.bind(t))},r.$loadAudioData=function(){if(r.$audioContext||(r.$audioContext=new r.$window.AudioContext,r.$audioContext.resume()),r.$audioContext){const t=r.$audios.length;for(let e=0;e<t;++e){const t=r.$audios[e];if(t._$character&&t._$character.audioBuffer)return;if(t._$audioBuffer)return;r.$decodeAudioData(t)}r.$audios.length=0}},r.$getImageType=function(t){return 255===t[0]&&216===t[1]?"jpeg":71===t[0]&&73===t[1]&&70===t[2]?"gif":137===t[0]&&80===t[1]&&78===t[2]&&71===t[3]&&13===t[4]&&10===t[5]&&26===t[6]&&10===t[7]?"png":66===t[0]&&77===t[1]?"bmp":null},r.$resizeTimerId=0,r.$resize=function(){(0,r.$clearTimeout)(r.$resizeTimerId);const t=r.$setTimeout;r.$resizeTimerId=t(r.$resizeExecute,300)},r.$resizeExecute=function(){const t=r.$currentPlayer();t._$loadStatus===te.LOAD_END&&t._$resize()},r.$window.addEventListener("resize",r.$resize),r.$resetContext=function(t){const e=t._$contextStyle;switch(e._$fillStyle.constructor){case It:case Ft:e._$fillStyle=r.$getFloat32Array4(1,1,1,1);break;default:e._$fillStyle[0]=1,e._$fillStyle[1]=1,e._$fillStyle[2]=1,e._$fillStyle[3]=1}switch(e._$strokeStyle.constructor){case It:case Ft:e._$strokeStyle=r.$getFloat32Array4(1,1,1,1);break;default:e._$strokeStyle[0]=1,e._$strokeStyle[1]=1,e._$strokeStyle[2]=1,e._$strokeStyle[3]=1}t._$style=e,t._$globalAlpha=1,t._$globalCompositeOperation=C.NORMAL,t._$imageSmoothingEnabled=!1},r.$getPreObject=function(){return r.$preObjects.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,currentAttachment:null,currentMaskBuffer:null,currentMaskBounds:null,cacheCurrentBounds:null,blendMode:null,filters:null,layerWidth:null,layerHeight:null}},r.$poolPreObject=function(t){t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.currentAttachment=null,t.currentMaskBuffer=null,t.currentMaskBounds=null,t.cacheCurrentBounds=null,t.blendMode=null,t.filters=null,t.layerWidth=null,t.layerHeight=null,r.$preObjects.push(t)},r.$cross=function(t,e,i,r){return t*r-i*e},r.$linearGradientXY=function(t){const e=-819.2*t[0]-819.2*t[2]+t[4],i=819.2*t[0]-819.2*t[2]+t[4],s=-819.2*t[0]+819.2*t[2]+t[4],n=-819.2*t[1]-819.2*t[3]+t[5],a=819.2*t[1]-819.2*t[3]+t[5];let o=s-e,h=-819.2*t[1]+819.2*t[3]+t[5]-n;const l=r.$sqrt(o*o+h*h);l?(o/=l,h/=l):(o=0,h=0);const $=(i-e)*o+(a-n)*h;return r.$getArray(e+$*o,n+$*h,i,a)},r.$ajax=function(t=null){t||(t={method:"GET"}),"method"in t||(t.method="GET");let e=null;switch(t.method.toUpperCase()){case ft.GET:if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():e[1]+"&"+t.data.toString(),t.url=e.join("?")}break;case ft.PUT:case ft.POST:e=t.data?t.data.toString():null}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),t.withCredentials&&(i.withCredentials=!0),t.event){const e=Object.keys(t.event),s=e.length;for(let r=0;r<s;++r){const s=e[r];i.addEventListener(s,t.event[s])}r.$poolArray(e)}if(t.format===ut.ARRAY_BUFFER&&(i.responseType=ut.ARRAY_BUFFER),t.headers){const e=t.headers,s=Object.keys(e),n=s.length;for(let t=0;t<n;++t){const r=s[t];i.setRequestHeader(r,e[r])}r.$poolArray(s)}i.send(e)},r.$headerToArray=function(t){const e=r.$getArray();if(t){const i=t.trim().split("\n"),r=i.length;for(let t=0;t<r;++t){const r=i[t].split(":");e.push({name:r[0],value:r[1].trim()})}}return e},r.$getClass=function(t){const e=t.split(".");let i=r.$window;for(let t=0;t<e.length;++t){const r=e[t];if(!(r in i))return null;i=i[r]}return i},r.$imageWorkerActive=!1,r.$imageQueues=[],r.$decodeImage=function(){const t=r.$currentPlayer(),e=this.image.width,i=this.image.height,s=new A(e,i,!0,4278190080),n=t._$context,a=n.frameBuffer.currentAttachment;s._$texture=n.frameBuffer.createTextureFromImage(this.image);const o=new N;o.graphics.beginBitmapFill(s,null,!1).drawRect(0,0,e,i);const h=this.scope.contentLoaderInfo;if(h._$content=o,t._$loaders.push(h),a?n._$bind(a):n.frameBuffer.unbind(),r.$imageQueues.length){const t=r.$imageQueues.shift();t.image.decode().then(r.$decodeImage.bind(t)).catch((()=>{throw new Error("image encoding error")}))}else r.$imageWorkerActive=!1},r.$unzipURL=URL.createObjectURL(new Blob(['/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){"use strict";var t=void 0,r=this;function i(i,e){var s,h=i.split("."),n=r;!(h[0]in n)&&n.execScript&&n.execScript("var "+h[0]);for(;h.length&&(s=h.shift());)h.length||e===t?n=n[s]?n[s]:n[s]={}:n[s]=e}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function s(t){var r,i,s,h,n,a,o,f,l,u,c=t.length,b=0,y=Number.POSITIVE_INFINITY;for(f=0;f<c;++f)t[f]>b&&(b=t[f]),t[f]<y&&(y=t[f]);for(r=1<<b,i=new(e?Uint32Array:Array)(r),s=1,h=0,n=2;s<=b;){for(f=0;f<c;++f)if(t[f]===s){for(a=0,o=h,l=0;l<s;++l)a=a<<1|1&o,o>>=1;for(u=s<<16|f,l=a;l<r;l+=n)i[l]=u;++h}++s,h<<=1,n<<=1}return[i,b,y]}function h(t,r){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=e?new Uint8Array(t):t,this.m=!1,this.i=a,this.r=!1,!r&&(r={})||(r.index&&(this.a=r.index),r.bufferSize&&(this.h=r.bufferSize),r.bufferType&&(this.i=r.bufferType),r.resize&&(this.r=r.resize)),this.i){case n:this.b=32768,this.c=new(e?Uint8Array:Array)(32768+this.h+258);break;case a:this.b=0,this.c=new(e?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error("invalid inflate mode")}}var n=0,a=1,o={t:n,s:a};h.prototype.k=function(){for(;!this.m;){var r=S(this,3);switch(1&r&&(this.m=!0),r>>>=1){case 0:var i=this.input,h=this.a,o=this.c,f=this.b,l=i.length,u=t,b=o.length,y=t;if(this.d=this.f=0,h+1>=l)throw Error("invalid uncompressed block header: LEN");if(u=i[h++]|i[h++]<<8,h+1>=l)throw Error("invalid uncompressed block header: NLEN");if(u===~(i[h++]|i[h++]<<8))throw Error("invalid uncompressed block header: length verify");if(h+u>i.length)throw Error("input buffer is broken");switch(this.i){case n:for(;f+u>o.length;){if(u-=y=b-f,e)o.set(i.subarray(h,h+y),f),f+=y,h+=y;else for(;y--;)o[f++]=i[h++];this.b=f,o=this.e(),f=this.b}break;case a:for(;f+u>o.length;)o=this.e({p:2});break;default:throw Error("invalid inflate mode")}if(e)o.set(i.subarray(h,h+u),f),f+=u,h+=u;else for(;u--;)o[f++]=i[h++];this.a=h,this.b=f,this.c=o;break;case 1:this.j(E,z);break;case 2:var p,d,g,v,w=S(this,5)+257,A=S(this,5)+1,k=S(this,4)+4,U=new(e?Uint8Array:Array)(c.length),m=t,I=t,x=t,N=t,j=t;for(j=0;j<k;++j)U[c[j]]=S(this,3);if(!e)for(j=k,k=U.length;j<k;++j)U[c[j]]=0;for(p=s(U),m=new(e?Uint8Array:Array)(w+A),j=0,v=w+A;j<v;)switch(I=T(this,p),I){case 16:for(N=3+S(this,2);N--;)m[j++]=x;break;case 17:for(N=3+S(this,3);N--;)m[j++]=0;x=0;break;case 18:for(N=11+S(this,7);N--;)m[j++]=0;x=0;break;default:x=m[j++]=I}d=s(e?m.subarray(0,w):m.slice(0,w)),g=s(e?m.subarray(w):m.slice(w)),this.j(d,g);break;default:throw Error("unknown BTYPE: "+r)}}return this.n()};var f,l,u=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],c=e?new Uint16Array(u):u,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],y=e?new Uint16Array(b):b,p=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],d=e?new Uint8Array(p):p,g=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],v=e?new Uint16Array(g):g,w=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],A=e?new Uint8Array(w):w,k=new(e?Uint8Array:Array)(288);for(f=0,l=k.length;f<l;++f)k[f]=143>=f?8:255>=f?9:279>=f?7:8;var U,m,E=s(k),I=new(e?Uint8Array:Array)(30);for(U=0,m=I.length;U<m;++U)I[U]=5;var z=s(I);function S(t,r){for(var i,e=t.f,s=t.d,h=t.input,n=t.a,a=h.length;s<r;){if(n>=a)throw Error("input buffer is broken");e|=h[n++]<<s,s+=8}return i=e&(1<<r)-1,t.f=e>>>r,t.d=s-r,t.a=n,i}function T(t,r){for(var i,e,s=t.f,h=t.d,n=t.input,a=t.a,o=n.length,f=r[0],l=r[1];h<l&&!(a>=o);)s|=n[a++]<<h,h+=8;if((e=(i=f[s&(1<<l)-1])>>>16)>h)throw Error("invalid code length: "+e);return t.f=s>>e,t.d=h-e,t.a=a,65535&i}function x(t,r){var i,e;switch(this.input=t,this.a=0,!r&&(r={})||(r.index&&(this.a=r.index),r.verify&&(this.A=r.verify)),i=t[this.a++],e=t[this.a++],15&i){case N:this.method=N;break;default:throw Error("unsupported compression method")}if(0!=((i<<8)+e)%31)throw Error("invalid fcheck flag:"+((i<<8)+e)%31);if(32&e)throw Error("fdict flag is not supported");this.q=new h(t,{index:this.a,bufferSize:r.bufferSize,bufferType:r.bufferType,resize:r.resize})}h.prototype.j=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length-258;256!==(s=T(this,t));)if(256>s)e>=o&&(this.b=e,i=this.e(),e=this.b),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e>=o&&(this.b=e,i=this.e(),e=this.b);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.w=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length;256!==(s=T(this,t));)if(256>s)e>=o&&(o=(i=this.e()).length),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e+a>o&&(o=(i=this.e()).length);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.e=function(){var t,r,i=new(e?Uint8Array:Array)(this.b-32768),s=this.b-32768,h=this.c;if(e)i.set(h.subarray(32768,i.length));else for(t=0,r=i.length;t<r;++t)i[t]=h[t+32768];if(this.g.push(i),this.l+=i.length,e)h.set(h.subarray(s,s+32768));else for(t=0;32768>t;++t)h[t]=h[s+t];return this.b=32768,h},h.prototype.z=function(t){var r,i,s,h=this.input.length/this.a+1|0,n=this.input,a=this.c;return t&&("number"==typeof t.p&&(h=t.p),"number"==typeof t.u&&(h+=t.u)),2>h?i=(s=(n.length-this.a)/this.o[2]/2*258|0)<a.length?a.length+s:a.length<<1:i=a.length*h,e?(r=new Uint8Array(i)).set(a):r=a,this.c=r},h.prototype.n=function(){var t,r,i,s,h,n=0,a=this.c,o=this.g,f=new(e?Uint8Array:Array)(this.l+(this.b-32768));if(0===o.length)return e?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(r=0,i=o.length;r<i;++r)for(s=0,h=(t=o[r]).length;s<h;++s)f[n++]=t[s];for(r=32768,i=this.b;r<i;++r)f[n++]=a[r];return this.g=[],this.buffer=f},h.prototype.v=function(){var t,r=this.b;return e?this.r?(t=new Uint8Array(r)).set(this.c.subarray(0,r)):t=this.c.subarray(0,r):(this.c.length>r&&(this.c.length=r),t=this.c),this.buffer=t},x.prototype.k=function(){var t,r,i=this.input;if(t=this.q.k(),this.a=this.q.a,this.A){r=(i[this.a++]<<24|i[this.a++]<<16|i[this.a++]<<8|i[this.a++])>>>0;var e=t;if("string"==typeof e){var s,h,n=e.split("");for(s=0,h=n.length;s<h;s++)n[s]=(255&n[s].charCodeAt(0))>>>0;e=n}for(var a,o=1,f=0,l=e.length,u=0;0<l;){l-=a=1024<l?1024:l;do{f+=o+=e[u++]}while(--a);o%=65521,f%=65521}if(r!==(f<<16|o)>>>0)throw Error("invalid adler-32 checksum")}return t};var N=8;i("Zlib.Inflate",x),i("Zlib.Inflate.prototype.decompress",x.prototype.k);var j,C,O,L,Z={ADAPTIVE:o.s,BLOCK:o.t};if(Object.keys)j=Object.keys(Z);else for(C in j=[],O=0,Z)j[O++]=C;for(O=0,L=j.length;O<L;++O)i("Zlib.Inflate.BufferType."+(C=j[O]),Z[C])}).call(this),this.addEventListener("message",(function(t){const r=new Zlib.Inflate(t.data).decompress();let i="";for(let t=0;t<r.length;++t)i+=String.fromCharCode(r[t]);this.postMessage(JSON.parse(decodeURIComponent(i)))}));'],{type:"text/javascript"})),r.$unzipWorker=null,r.$unzipQueues=[],r.$unzipWorkerActive=!1,r.$unzipHandler=function(t){if(this._$build(t.data),r.$unzipQueues.length){const t=r.$unlzmaQueues.pop(),e=new Uint8Array(t.json.buffer);r.$unzipWorker.onmessage=r.$unzipHandler.bind(t.scope),r.$unzipWorker.postMessage(e,[e.buffer])}},r.$packages=function(t){t.display={BitmapData:A,BitmapDataChannel:M,BlendMode:C,CapsStyle:S,DisplayObject:b,DisplayObjectContainer:v,FrameLabel:R,GradientType:w,Graphics:O,InteractiveObject:T,InterpolationMethod:F,JointStyle:L,Loader:P,LoaderInfo:D,MovieClip:E,Shape:N,SpreadMethod:U,Sprite:y,Stage:k},t.events={Event:a,EventDispatcher:o,EventPhase:h,FocusEvent:l,HTTPStatusEvent:$,IOErrorEvent:_,MouseEvent:c,ProgressEvent:u,VideoEvent:d},t.filters={BevelFilter:z,BitmapFilterQuality:H,BitmapFilterType:Y,BlurFilter:V,ColorMatrixFilter:W,ConvolutionFilter:q,DisplacementMapFilter:K,DisplacementMapFilterMode:j,DropShadowFilter:Q,GlowFilter:J,GradientBevelFilter:Z,GradientGlowFilter:tt},t.geom={ColorTransform:g,Matrix:f,Point:p,Rectangle:m,Transform:x},t.media={Sound:at,SoundMixer:ot,SoundTransform:ht,Video:lt},t.net={URLLoaderDataFormat:ut,URLRequest:dt,URLRequestHeader:gt,URLRequestMethod:ft},t.text={TextField:rt,TextFieldAutoSize:it,TextFieldType:st,TextFormat:nt,TextFormatAlign:et},t.ui={Easing:$t,Job:_t,Tween:ct}};class a{constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=!!e,this._$cancelable=!!i,this._$target=null,this._$currentTarget=null,this._$eventPhase=h.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1,this._$preventDefault=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get SCROLL(){return"scroll"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}get eventPhase(){return this._$eventPhase}get listener(){return this._$listener}get target(){return this._$target?this._$target:this._$currentTarget}get type(){return this._$type}formatToString(){let t=`[${arguments[0]}`;for(let e=1;e<arguments.length;++e){const i=arguments[e];t+=` ${i}=`;const r=this[i];t+="string"==typeof r?`"${r}"`:`${r}`}return`${t}]`}isDefaultPrevented(){return!!r.$event&&r.$event.defaultPrevented}preventDefault(){this._$preventDefault=!0}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}class o{constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,s=0){let n,o,h=!1;switch(t=`${t}`){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":o=r.$currentPlayer(),o.broadcastEvents.size&&o.broadcastEvents.has(t)||o.broadcastEvents.set(t,r.$getArray()),n=o.broadcastEvents.get(t),h=!0;break;default:this._$events||(this._$events=r.$getMap()),this._$events.size&&this._$events.has(t)||this._$events.set(t,r.$getArray()),n=this._$events.get(t)}let l=n.length;for(let t=0;t<l;++t){const r=n[t];i===r.useCapture&&(r.target===this&&r.listener===e&&(l=t))}n[l]={listener:e,priority:s,useCapture:i,target:this},h?o.broadcastEvents.set(t,n):(n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,n))}dispatchEvent(t){switch(t.type){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:r.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t.type)){const e=i.broadcastEvents.get(t.type),s=e.length;for(let i=0;i<s;++i){const s=e[i];if(s.target===this){t._$eventPhase=h.AT_TARGET,t._$currentTarget=s.target;try{t._$listener=s.listener,s.listener.call(r.$window,t)}catch(t){return!1}}}return!0}}break;default:{let e=r.$getArray();this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type).slice(0));const i=r.$getArray();if(this instanceof b){let e=this._$parent;for(;e;)e.hasEventListener(t.type)&&(i[i.length]=e._$events.get(t.type)),e=e._$parent}if(t._$target=this,e.length||i.length){if(t._$eventPhase=h.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(i.useCapture){t._$currentTarget=i.target;try{t._$listener=i.listener,i.listener.call(r.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}if(t._$eventPhase=h.AT_TARGET,!t._$stopImmediatePropagation&&!t._$stopPropagation){const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(!i.useCapture){t._$currentTarget=i.target;try{t._$listener=i.listener,i.listener.call(r.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}}switch(t._$eventPhase=h.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(!i.useCapture){t._$currentTarget=i.target;try{t._$listener=i.listener,i.listener.call(r.$window,t)}catch(t){return!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return r.$poolArray(e),r.$poolArray(i),!0}r.$poolArray(e),r.$poolArray(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":{const e=this.stage,i=e?e._$player:r.$currentPlayer();if(i&&i.broadcastEvents.size&&i.broadcastEvents.has(t)){const e=i.broadcastEvents.get(t);for(let t=0;t<e.length;t++)if(e[t].target===this)return!0}return!1}default:return this._$events&&this._$events.size&&this._$events.has(t)}}removeEventListener(t,e,i=!1){if(t=`${t}`,!this.hasEventListener(t))return;let s,n,o=!1;switch(t){case a.ENTER_FRAME:case a.EXIT_FRAME:case a.FRAME_CONSTRUCTED:case a.RENDER:case a.ACTIVATE:case a.DEACTIVATE:case"keyDown":case"keyUp":o=!0,n=r.$currentPlayer(),n&&(s=n.broadcastEvents.get(t));break;default:s=this._$events.get(t)}const h=s.length;for(let t=0;t<h;++t){const r=s[t];if(i===r.useCapture&&r.listener===e){s.splice(t,1);break}}s.length?o?n.broadcastEvents.set(t,s):(s.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),this._$events.set(t,s)):o?n.broadcastEvents.delete(t):(this._$events.delete(t),this._$events.size||(r.$poolMap(this._$events),this._$events=null))}willTrigger(t){if(this.hasEventListener(t))return!0;let e=this._$parent;for(;e;){if(e.hasEventListener(t))return!0;e=e._$parent}return!1}}class h{static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class l extends a{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class $ extends a{constructor(t,e=!1,i=!1,r=0){super(t,e,i),this._$status=0|r,this._$responseHeaders=[],this._$responseURL=""}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","eventPhase","status","responseURL")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}get responseURL(){return this._$responseURL}get status(){return this._$status}}class _ extends a{constructor(t,e=!1,i=!1,r=""){super(t,e,i),this._$text=`${r}`}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}get text(){return this._$text}}class c extends a{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:function(t,e){return e in t?t[e]:r.$event&&e in r.$event?r.$event[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class u extends a{constructor(t,e=!1,i=!1,r=0,s=0){super(t,e,i),this._$bytesLoaded=0|r,this._$bytesTotal=0|s}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class d extends a{constructor(t,e=!1,i=!1,r=0,s=0){super(t,e,i),this._$bytesLoaded=0|r,this._$bytesTotal=0|s}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class g{constructor(t=1,e=1,i=1,s=1,n=0,a=0,o=0,h=0){this._$colorTransform=r.$getFloat32Array8(1,1,1,1,0,0,0,0),this.redMultiplier=t,this.greenMultiplier=e,this.blueMultiplier=i,this.alphaMultiplier=s,this.redOffset=n,this.greenOffset=a,this.blueOffset=o,this.alphaOffset=h}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=r.$clamp(+t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=r.$clamp(0|t,-255,255,0)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=r.$clamp(+t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=r.$clamp(0|t,-255,255,0)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=r.$clamp(+t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=r.$clamp(0|t,-255,255,0)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=r.$clamp(+t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=r.$clamp(0|t,-255,255,0)}concat(t){const e=r.$multiplicationColor(this._$colorTransform,t._$colorTransform);this.redMultiplier=e[0],this.greenMultiplier=e[1],this.blueMultiplier=e[2],this.alphaMultiplier=e[3],this.redOffset=e[4],this.greenOffset=e[5],this.blueOffset=e[6],this.alphaOffset=e[7],r.$poolFloat32Array8(e)}_$clone(){return r.$getColorTransform(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class f{constructor(t=1,e=0,i=0,s=1,n=0,a=0){this._$matrix=r.$getFloat32Array6(1,0,0,1,0,0),this.a=t,this.b=e,this.c=i,this.d=s,this.tx=n,this.ty=a}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}_$clone(){return this.clone()}clone(){return r.$getMatrix(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let r=e[0]*i[0],s=0,n=0,a=e[3]*i[3],o=e[4]*i[0]+i[4],h=e[5]*i[3]+i[5];(e[1]||e[2]||i[1]||i[2])&&(r+=e[1]*i[2],a+=e[2]*i[1],s+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],o+=e[5]*i[2],h+=e[4]*i[1]),this.a=r,this.b=s,this.c=n,this.d=a,this.tx=o,this.ty=h}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,r=0,s=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(r,s)}createGradientBox(t,e,i=0,r=0,s=0){this.createBox(t/1638.4,e/1638.4,i,r+t/2,s+e/2)}deltaTransformPoint(t){return new p(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){let t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],r=this._$matrix[3],s=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/r,this.tx=-this.a*s,this.ty=-this.d*n;else{const a=t*r-e*i;if(a){const o=1/a;this.a=r*o,this.b=-e*o,this.c=-i*o,this.d=t*o,this.tx=-(this.a*s+this.c*n),this.ty=-(this.b*s+this.d*n)}}}rotate(t){const e=this._$matrix[0],i=this._$matrix[1],s=this._$matrix[2],n=this._$matrix[3],a=this._$matrix[4],o=this._$matrix[5];this.a=e*r.$cos(t)-i*r.$sin(t),this.b=e*r.$sin(t)+i*r.$cos(t),this.c=s*r.$cos(t)-n*r.$sin(t),this.d=s*r.$sin(t)+n*r.$cos(t),this.tx=a*r.$cos(t)-o*r.$sin(t),this.ty=a*r.$sin(t)+o*r.$cos(t)}scale(t,e){this.a*=t,this.c*=t,this.tx*=t,this.b*=e,this.d*=e,this.ty*=e}setTo(t,e,i,r,s,n){this.a=t,this.b=e,this.c=i,this.d=r,this.tx=s,this.ty=n}transformPoint(t){return new p(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class p{constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return r.$sqrt(r.$pow(this.x,2)+r.$pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}add(t){return new p(this.x+t.x,this.y+t.y)}clone(){return new p(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return r.$sqrt(r.$pow(t._$x-e._$x,2)+r.$pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new p(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new p(t*r.$cos(e),t*r.$sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new p(this.x-t.x,this.y-t.y)}}class m{constructor(t=0,e=0,i=0,r=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,r)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new p(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new p(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new p(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get x(){return this._$x}set x(t){this._$x=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}get y(){return this._$y}set y(t){this._$y=r.$clamp(+t,r.$SHORT_INT_MIN,r.$SHORT_INT_MAX,0)}clone(){return new m(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=r.$max(this.x,t.x),i=r.$max(this.y,t.y),s=r.$min(this.right,t.right)-e,n=r.$min(this.bottom,t.bottom)-i;return s>0&&n>0?new m(e,i,s,n):new m(0,0,0,0)}intersects(t){const e=r.$max(this.x,t.x),i=r.$max(this.y,t.y),s=r.$min(this.right,t.right),n=r.$min(this.bottom,t.bottom);return s-e>0&&n-i>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,r){this.x=t,this.y=e,this.width=i,this.height=r}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new m(r.$min(this.x,t.x),r.$min(this.y,t.y),r.$max(this.right-t.left,t.right-this.left),r.$max(this.bottom-t.top,t.bottom-this.top))}}class x{constructor(t){if(!(t instanceof b))throw new Error("Transform params is DisplayObject only.");this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.colorTransform,i=new g;return i._$colorTransform=r.$getFloat32Array8(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),i}return this._$transform(),this._$colorTransform._$clone()}set colorTransform(t){t instanceof g&&this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=r.$multiplicationColor(e._$transform._$rawColorTransform(),t),e=e._$parent;return r.$getColorTransform(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject._$getPlaceObject();if(t){const e=t.matrix;return r.$getMatrix(e[0],e[1],e[2],e[3],e[4],e[5])}return this._$transform(),this._$matrix._$clone()}set matrix(t){t instanceof f&&this._$transform(t._$matrix,null)}get concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=r.$multiplicationMatrix(e._$transform._$rawMatrix(),t),e=e._$parent;return r.$getMatrix(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){const t=new m(0,0,0,0);if(!this._$displayObject)return t;const e=this._$displayObject._$getBounds(null);return t._$x=e.xMin,t._$y=e.yMin,t._$width=+r.$abs(e.xMax-e.xMin),t._$height=+r.$abs(e.yMax-e.yMin),r.$poolBoundsObject(e),t}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject._$getPlaceObject();return t?t.matrix:r.$MATRIX_ARRAY_IDENTITY}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject._$getPlaceObject();return t?t.colorTransform:r.$COLOR_ARRAY_IDENTITY}_$transform(t=null,e=null,i=null,r=""){const s=this._$displayObject._$getPlaceObject();this._$setMatrix(t,s),this._$setColorTransform(e,s),this._$setFilters(i,s),this._$setBlendMode(r,s)}_$setMatrix(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),r.$isUpdated=!0),this._$matrix||(this._$matrix=r.$getMatrix(1,0,0,1,0,0),!t&&e&&(t=e.matrix)),t){const e=this._$matrix._$matrix;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5]}}_$setColorTransform(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),r.$isUpdated=!0),this._$colorTransform||(this._$colorTransform=r.$getColorTransform(1,1,1,1,0,0,0,0),!t&&e&&(t=e.colorTransform)),t){const e=this._$colorTransform._$colorTransform;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7]}}_$setFilters(t=null,e=null){if(r.$isArray(t))return this._$filters&&r.$poolArray(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void(r.$isUpdated=!0);if(!this._$filters)if(e){if(e.filters)this._$filters=e.filters.slice(0);else if(e.surfaceFilterList){const t=r.$getArray(),i=e.surfaceFilterList.length;for(let r=0;r<i;++r){const i=e.surfaceFilterList[r],s=next2d.filters[i.class];t.push(new(s.bind.apply(s,i.params)))}e.filters=t,this._$filters=t.slice(0)}}else this._$filters=r.$getArray()}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void(r.$isUpdated=!0);this._$blendMode||(this._$blendMode=e?e.blendMode:C.NORMAL)}}class b extends o{constructor(){super(),this._$id=0,this._$instanceId=e++,this._$dictionaryId=0,this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$buffer=null,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=null,this._$startFrame=1,this._$endFrame=0,this._$transform=new x(this),this._$variables=null,this._$placeObject=null}static toString(){return"[class DisplayObject]"}static get namespace(){return"next2d.display.DisplayObject"}toString(){return"[object DisplayObject]"}get namespace(){return"next2d.display.DisplayObject"}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=r.$clamp(t,0,1,0);const e=this._$transform.colorTransform;e._$colorTransform[3]=t,e._$colorTransform[7]=0,this._$transform.colorTransform=e,r.$poolColorTransform(e)}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,this._$blendMode;const e=this._$getPlaceObject();return e?(this._$blendMode=e.blendMode,this._$blendMode):(t._$transform(),this._$blendMode=t._$blendMode,this._$blendMode)}set blendMode(t){this._$transform._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters)return this._$filters;const t=this._$transform;if(t._$filters)return this._$filters=t._$filters.slice(0),this._$filters;const e=this._$getPlaceObject();if(e){if(!e.filters){const t=[];if(e.surfaceFilterList){const i=e.surfaceFilterList.length;for(let r=0;r<i;++r){const i=e.surfaceFilterList[r],s=next2d.filters[i.class];t.push(new(s.bind.apply(s,i.params)))}}e.filters=t}return this._$filters||(this._$filters=e.filters),e.filters.slice(0)}return t._$transform(),this._$filters=t._$filters,this._$filters.slice(0)}set filters(t){t||(t=r.$getArray()),this._$transform._$transform(null,null,t,null),this._$filters=t}get height(){const t=r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=r.$abs(t.yMax-t.yMin);switch(r.$poolBoundsObject(t),e){case 0:case r.$Infinity:case-r.$Infinity:return 0;default:return e}}set height(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this.rotation?r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=r.$abs(e.yMax-e.yMin);switch(r.$poolBoundsObject(e),i){case 0:case r.$Infinity:case-r.$Infinity:this.scaleY=0;break;default:this.scaleY=t/i}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(this._$mask._$isMask=!1,this._$mask=null),t instanceof b&&(t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return r.$event?this.globalToLocal(r.$currentMousePoint()).x:0}get mouseY(){return r.$event?this.globalToLocal(r.$currentMousePoint()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren(),i=t.length;for(let r=0;r<i;++r){const i=t[r];i._$name&&e._$names.set(i.name,i)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){const t=this._$transform._$rawMatrix();return r.$atan2(t[1],t[0])*r.$Rad2Deg}set rotation(t){t=r.$clamp(t%360,-360,360,0);const e=this._$transform,i=e.matrix,s=r.$sqrt(i.a*i.a+i.b*i.b),n=r.$sqrt(i.c*i.c+i.d*i.d);if(0===t)i.a=s,i.b=0,i.c=0,i.d=n;else{let e=r.$atan2(i.b,i.a),a=r.$atan2(-i.c,i.d);const o=t*r.$Deg2Rad;a=a+o-e,e=o,i.b=s*r.$sin(e),1===i.b||-1===i.b?i.a=0:i.a=s*r.$cos(e),i.c=-n*r.$sin(a),1===i.c||-1===i.c?i.d=0:i.d=n*r.$cos(a)}e.matrix=i,r.$poolMatrix(i)}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid=null,t instanceof m&&(this._$scale9Grid=t)}get scaleX(){const t=this._$transform._$rawMatrix(),e=r.$sqrt(t[0]*t[0]+t[1]*t[1]);return 0>t[0]?-1*e:e}set scaleX(t){const e=this._$transform,i=e.matrix;if(0===i.b||r.$isNaN(i.b))i.a=t;else{const e=r.$atan2(i.b,i.a);i.b=t*r.$sin(e),i.a=1===i.b||-1===i.b?0:t*r.$cos(e)}e.matrix=i,r.$poolMatrix(i)}get scaleY(){const t=this._$transform._$rawMatrix(),e=r.$sqrt(t[2]*t[2]+t[3]*t[3]);return 0>t[3]?-1*e:e}set scaleY(t){const e=this._$transform,i=e.matrix;if(0===i.c||r.$isNaN(i.c))i.d=t;else{const e=r.$atan2(-i.c,i.d);i.c=-t*r.$sin(e),i.d=1===i.c||-1===i.c?0:t*r.$cos(e)}e.matrix=i,r.$poolMatrix(i)}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t instanceof k?t:t._$stage:null}get transform(){return this._$transform}set transform(t){t instanceof x&&(this._$transform=t)}get visible(){return this._$visible}set visible(t){t=!!t,this._$visible!==t&&(this._$doChanged(),r.$isUpdated=!0),this._$visible=!!t}get width(){const t=r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()),e=r.$abs(t.xMax-t.xMin);switch(r.$poolBoundsObject(t),!0){case 0===e:case e===r.$Infinity:case e===-r.$Infinity:return 0;default:return e}}set width(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this.rotation?r.$boundsMatrix(this._$getBounds(null),this._$transform._$rawMatrix()):this._$getBounds(null),i=r.$abs(e.xMax-e.xMin);switch(r.$poolBoundsObject(e),!0){case 0===i:case i===r.$Infinity:case i===-r.$Infinity:this.scaleX=0;break;default:this.scaleX=t/i}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform,i=this._$transform.matrix;i.tx=t,e.matrix=i,r.$poolMatrix(i)}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform,i=e.matrix;i.ty=t,e.matrix=i,r.$poolMatrix(i)}getBounds(t=null){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,s=r.$boundsMatrix(e,i._$matrix);r.$poolMatrix(i),r.$poolBoundsObject(e);const n=r.$getBoundsObject(s.xMin,s.xMax,s.yMin,s.yMax);r.$poolBoundsObject(s),t||(t=this);const a=t._$transform.concatenatedMatrix;a.invert();const o=r.$boundsMatrix(n,a._$matrix),h=o.xMin,l=o.yMin,$=o.xMax,_=o.yMax;return r.$poolBoundsObject(n),r.$poolBoundsObject(o),r.$poolMatrix(a),new m(h,l,r.$abs($-h),r.$abs(_-l))}globalToLocal(t){const e=this._$transform.concatenatedMatrix;e.invert();const i=new p(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return r.$poolMatrix(e),i}hitTestObject(t){const e=this._$getBounds(null),i=this._$transform.concatenatedMatrix,s=r.$boundsMatrix(e,i._$matrix);r.$poolMatrix(i),r.$poolBoundsObject(e);const n=t._$getBounds(null),a=t._$transform.concatenatedMatrix,o=r.$boundsMatrix(n,a._$matrix);r.$poolMatrix(a),r.$poolBoundsObject(n);const h=r.$max(s.xMin,o.xMin),l=r.$max(s.yMin,o.yMin),$=r.$min(s.xMax,o.xMax),_=r.$min(s.yMax,o.yMax);return r.$poolBoundsObject(s),r.$poolBoundsObject(o),$-h>=0&&_-l>=0}hitTestPoint(t,e,i=!1){if(i){let i=r.$MATRIX_ARRAY_IDENTITY,s=this._$parent;for(;s;)i=r.$multiplicationMatrix(s._$transform._$rawMatrix(),i),s=s._$parent;r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath();const n=this._$hit(r.$hitContext,i,{x:t,y:e},!0);return r.$poolFloat32Array6(i),n}const s=this._$getBounds(null),n=r.$boundsMatrix(s,this._$transform._$rawMatrix()),a=n.xMin,o=n.yMin,h=n.xMax-n.xMin,l=n.yMax-n.yMin,$=this._$parent?this._$parent.globalToLocal(new p(t,e)):new p(t,e);return r.$poolBoundsObject(n),r.$poolBoundsObject(s),new m(a,o,h,l).containsPoint($)}localToGlobal(t){const e=this._$transform.concatenatedMatrix,i=new p(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return r.$poolMatrix(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=r.$getMap()),r.$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(r.$poolMap(this._$variables),this._$variables=null))}getGlobalVariable(t){return r.$variables.has(t)?r.$variables.get(t):null}setGlobalVariable(t,e){r.$variables.set(t,e)}hasGlobalVariable(t){return r.$variables.has(t)}deleteGlobalVariable(t){r.$variables.has(t)&&r.$variables.delete(t)}clearGlobalVariable(){return r.$variables.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(null===t)return null;const e=this._$parent;if(!e)return null;const i=e._$placeMap;if(!i||!i.length)return null;const r=i[e._$currentFrame||1];if(!r)return null;this._$placeObject=e._$placeObjects[r[t]]}return this._$placeObject}_$build(t,e){const i=e._$loaderInfo;return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;let t=this._$parent;t&&t._$updateState()}_$doChanged(){this._$isNext=!0,this._$updated=!0;let t=this._$parent;t&&t._$doChanged()}_$getLayerBounds(t=null){const e=this._$getBounds(t);if(!t)return e;const i=this._$filters||this.filters,s=i.length;if(!s)return e;let n=new m(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);r.$poolBoundsObject(e);for(let t=0;t<s;++t)n=i[t]._$generateFilterRect(n,null,null,!0);const a=n._$x,o=n._$x+n._$width,h=n._$y,l=n._$y+n._$height;return r.$getBoundsObject(a,o,h,l)}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger(a.ADDED)&&this.dispatchEvent(new a(a.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger(a.ADDED_TO_STAGE)&&this.dispatchEvent(new a(a.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e,i,s,n=null,a=!1,o=0,h=0){if(this._$isUpdated())return!0;if(a)for(let t=0;t<n.length;++t)if(n[t]._$isUpdated())return!0;const l=r.$cacheStore().get([this._$instanceId,"f"]);switch(!0){case null===l:case l.filterState!==a:case l.layerWidth!==r.$ceil(t):case l.layerHeight!==r.$ceil(e):case l.matrix!==i[0]+"_"+i[1]+"_"+i[2]+"_"+i[3]+"_"+o+"_"+h:case l.colorTransform!==s[0]+"_"+s[1]+"_"+s[2]+"_"+s[3]+"_"+s[4]+"_"+s[5]+"_"+s[6]+"_"+s[7]:return!0}return!1}_$getFilterTexture(t,e,i,s,n){const a=t.frameBuffer.currentAttachment,o=t.frameBuffer.createCacheAttachment(i.width,i.height);t._$bind(o),r.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.drawImage(i,0,0,i.width,i.height),t._$offsetX=0,t._$offsetY=0;let h=null;for(let i=0;i<e.length;++i)h=e[i]._$applyFilter(t,s);let l=t._$offsetX,$=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,h._$offsetX=l,h._$offsetY=$,h.matrix=s[0]+"_"+s[1]+"_"+s[2]+"_"+s[3]+"_0_0",h.colorTransform=n[0]+"_"+n[1]+"_"+n[2]+"_"+n[3]+"_"+n[4]+"_"+n[5]+"_"+n[6]+"_"+n[7],h.filterState=!0,h.layerWidth=i.width,h.layerHeight=i.height,t._$bind(a),t.frameBuffer.releaseAttachment(o,!1),h}_$preDraw(t,e,i){const s=this._$transform._$rawMatrix(),n=r.$multiplicationMatrix(e,s);if(!n[0]&&!n[1]||!n[2]&&!n[3])return!1;const a=r.$getPreObject();a.matrix=n;const o=this._$filters||this.filters,h=this._$blendMode||this.blendMode;if(o.length>0||h!==C.NORMAL){const e=this._$getBounds(null),l=r.$boundsMatrix(e,n),$=+l.xMax,_=+l.xMin,c=+l.yMax,u=+l.yMin;r.$poolBoundsObject(e),r.$poolBoundsObject(l);const d=r.$abs($-_),g=r.$abs(c-u);if(0>=d||0>=g)return!1;if(0>_+d||0>u+g)return!1;const f=t.frameBuffer.currentAttachment;if(_>f.width||u>f.height)return!1;a.basePosition.x=s[4],a.basePosition.y=s[5];let p=this._$getLayerBounds(null);const m=r.$boundsMatrix(p,n);let x=r.$abs(m.xMax-m.xMin),b=r.$abs(m.yMax-m.yMin);r.$poolBoundsObject(m),x===d&&b===g&&(r.$poolBoundsObject(p),p=null);let T=n[4]-r.$floor(_),v=n[5]-r.$floor(u),y=null;if(p){const t=r.$getFloat32Array6(n[0],n[1],n[2],n[3],0,0);y=r.$boundsMatrix(p,t),r.$poolBoundsObject(p),r.$poolFloat32Array6(t),T+=-r.$floor(y.xMin)-T,v+=-r.$floor(y.yMin)-v}let E=r.$floor(_),A=r.$floor(u),M=_,C=u;if(y&&(E-=-r.$floor(y.xMin)-(n[4]-E),A-=-r.$floor(y.yMin)-(n[5]-A),M-=-y.xMin-(n[4]-M),C-=-y.yMin-(n[5]-C),r.$poolBoundsObject(y)),a.position.dx=E>0?E:0,a.position.dy=A>0?A:0,x+M>f.texture.width&&(x-=x-f.texture.width+M),b+C>f.texture.height&&(b-=b-f.texture.height+C),0>E&&(T+=E,x+=M),0>A&&(v+=A,b+=C),0>=x||0>=b||!x||!b)return r.$poolPreObject(a),!1;t._$startLayer(r.$getBoundsObject(M,0,C,0)),a.canApply=this._$canApply(o);let S=this._$isFilterUpdated(x,b,n,i,o,a.canApply,a.basePosition.x,a.basePosition.y);const R=t._$cacheCurrentBuffer;t._$cacheCurrentBuffer=null;const w=t._$cacheCurrentBounds,O=r.$getBoundsObject(w.x,w.w,w.y,w.h);S&&(this._$buffer=t.frameBuffer.createCacheAttachment(r.$ceil(x),r.$ceil(b),!1),t._$bind(this._$buffer)),a.isFilter=!0,a.isUpdated=S,a.color=r.$getFloat32Array8(),a.baseMatrix=n,a.baseColor=i,a.currentAttachment=f,a.currentMaskBuffer=R,a.currentMaskBounds=O,a.filters=o,a.blendMode=h,a.layerWidth=x,a.layerHeight=b,a.matrix=r.$getFloat32Array6(n[0],n[1],n[2],n[3],T,v)}return a}_$postDraw(t,e,i,s){const n=[this._$instanceId,"f"];let a=null;if(this._$buffer){a=t.frameBuffer.getTextureFromCurrentAttachment();const e=r.$cacheStore().get(n);e&&(r.$cacheStore().set(n,null),t.frameBuffer.releaseTexture(e))}else a=r.$cacheStore().get(n);s.canApply||(a._$offsetX=0,a._$offsetY=0);let o=a._$offsetX,h=a._$offsetY;if(s.isUpdated&&s.canApply){let i=r.$cacheStore().get(n);i&&(r.$cacheStore().set(n,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,t.frameBuffer.releaseTexture(i),i=null);const l=s.filters.length;if(l){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<l;++i)a=s.filters[i]._$applyFilter(t,e);o=t._$offsetX,h=t._$offsetY,t._$offsetX=0,t._$offsetY=0,a._$offsetX=o,a._$offsetY=h}}if(s.isUpdated){a.filterState=s.canApply;const t=s.baseMatrix;a.matrix=t[0]+"_"+t[1]+"_"+t[2]+"_"+t[3]+"_"+s.basePosition.x+"_"+s.basePosition.y;const e=s.baseColor;a.colorTransform=e[0]+"_"+e[1]+"_"+e[2]+"_"+e[3]+"_"+e[4]+"_"+e[5]+"_"+e[6]+"_"+e[7],a.layerWidth=s.layerWidth,a.layerHeight=s.layerHeight}r.$cacheStore().set(n,a),r.$poolArray(n),t._$bind(s.currentAttachment);const l=a.width,$=a.height;r.$resetContext(t),t.setTransform(1,0,0,1,0,0),t._$globalAlpha=r.$clamp(i[3]+i[7]/255,0,1),t._$globalCompositeOperation=s.blendMode,t.drawImage(a,-o+s.position.dx,-h+s.position.dy,l,$,i),t._$endLayer(),this._$buffer&&(t.frameBuffer.releaseAttachment(this._$buffer,!1),this._$buffer=null),t._$cacheCurrentBuffer=s.currentMaskBuffer,t._$cacheCurrentBounds.x=s.currentMaskBounds.xMin,t._$cacheCurrentBounds.y=s.currentMaskBounds.yMin,t._$cacheCurrentBounds.w=s.currentMaskBounds.xMax,t._$cacheCurrentBounds.h=s.currentMaskBounds.yMax,r.$poolFloat32Array8(s.color),r.$poolFloat32Array6(s.matrix),r.$poolFloat32Array6(s.baseMatrix),r.$poolBoundsObject(s.currentMaskBounds),r.$poolPreObject(s)}_$shouldClip(t){if(this instanceof rt)return!(!this.textWidth||!this.textHeight);const e=this._$getBounds(t),i=r.$abs(e.xMax-e.xMin),s=r.$abs(e.yMax-e.yMin);return r.$poolBoundsObject(e),!(!i||!s)}_$startClip(t,e){let i=null;return!(!t._$cacheCurrentBuffer&&(i=t._$startClip(this,e),!i))&&(t._$enterClip(),t._$beginClipDef(),this instanceof v&&(t._$mask._$containerClip=!0),this._$clip(t,i||e),this._$updated=!1,t._$mask._$containerClip&&(t._$mask._$containerClip=!1,t._$drawContainerClip()),t._$endClipDef(),i)}}class T extends b{constructor(){super(),this._$mouseEnabled=!0}static toString(){return"[class InteractiveObject]"}static get namespace(){return"next2d.display.InteractiveObject"}toString(){return"[object InteractiveObject]"}get namespace(){return"next2d.display.InteractiveObject"}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=!!t}}class v extends T{constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=r.$getArray(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=r.$getMap(),new Proxy(this,{get:(t,e)=>t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]})}static toString(){return"[class DisplayObjectContainer]"}static get namespace(){return"next2d.display.DisplayObjectContainer"}toString(){return"[object DisplayObjectContainer]"}get namespace(){return"next2d.display.DisplayObjectContainer"}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=!!t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){if(!(t instanceof b))throw new TypeError("TypeError: addChild: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));return this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){if(!(t instanceof b))throw new TypeError("TypeError: addChildAt: not DisplayObject.");t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),r=i.length;if(0>e||e>r)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(r&&r>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(!(t instanceof b))throw new TypeError("TypeError: contains: not DisplayObject.");if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren(),i=e.length;for(let r=0;r<i;++r){const i=e[r];if(i._$instanceId===t._$instanceId)return!0;if(i instanceof v&&i.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren(),i=e.length;if(0>t||t>i)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren(),i=e.length;for(let r=0;r<i;++r){const i=e[r];if(i.name===t)return i}return null}getChildIndex(t){if(!(t instanceof b))throw new TypeError("TypeError: getChildIndex: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError("ArgumentError: getChildIndex: not child");const e=this._$getChildren().indexOf(t);if(-1===e)throw new ArgumentError("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(!(t instanceof b))throw new TypeError("TypeError: removeChild: not DisplayObject.");if(t._$parent!==this)throw new ArgumentError(`ArgumentError: removeChild: index error: ${index}`);return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const i=this._$getChildren(),s=i.length;if(s){t=r.$clamp(t,0,2147483646,0)-1,e=r.$clamp(e,1,134217727,134217727);for(let n=r.$min(e,s-1);n>t;--n)this._$remove(i[n])}}setChildIndex(t,e){if(!(t instanceof b))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this.getChildIndex(t);if(i===e)return;const r=this._$getChildren();r.splice(i,1),r.splice(e,0,t)}swapChildren(t,e){if(!(t instanceof b&&e instanceof b))throw new TypeError("TypeError: removeChild: not DisplayObject.");const i=this._$getChildren(),r=this.getChildIndex(t),s=this.getChildIndex(e);i[r]=e,i[s]=t}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=r.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==r.$MATRIX_ARRAY_IDENTITY&&(e=r.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),s=this._$needsChildren?this._$getChildren():this._$children,n=s.length;if(!n&&!i){const i=r.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&r.$poolFloat32Array6(e),i}const a=r.$MAX_VALUE;let o=a,h=-a,l=a,$=-a;if(i){const t=r.$boundsMatrix(this._$graphics._$getBounds(),e);o=t.xMin,h=t.xMax,l=t.yMin,$=t.yMax,r.$poolBoundsObject(t)}for(let t=0;t<n;++t){const i=s[t]._$getBounds(e);o=r.$min(o,i.xMin),h=r.$max(h,i.xMax),l=r.$min(l,i.yMin),$=r.$max($,i.yMax),r.$poolBoundsObject(i)}return t&&e!==t&&r.$poolFloat32Array6(e),r.$getBoundsObject(o,h,l,$)}_$getLayerBounds(t=null){let e=r.$MATRIX_ARRAY_IDENTITY;if(t){e=t;const i=this._$transform._$rawMatrix();i!==r.$MATRIX_ARRAY_IDENTITY&&(e=r.$multiplicationMatrix(t,i))}const i=this._$graphics&&this._$graphics._$getBounds(),s=this._$needsChildren?this._$getChildren():this._$children,n=s.length;if(!n&&!i){const i=r.$getBoundsObject(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&r.$poolFloat32Array6(e),i}const a=r.$MAX_VALUE;let o=a,h=-a,l=a,$=-a;if(i){const t=r.$boundsMatrix(this._$graphics._$getBounds(),e);o=+t.xMin,h=+t.xMax,l=+t.yMin,$=+t.yMax,r.$poolBoundsObject(t)}for(let t=0;t<n;++t){const i=s[t]._$getLayerBounds(e);o=r.$min(o,i.xMin),h=r.$max(h,i.xMax),l=r.$min(l,i.yMin),$=r.$max($,i.yMax),r.$poolBoundsObject(i)}if(t&&e!==t&&r.$poolFloat32Array6(e),!t)return r.$getBoundsObject(o,h,l,$);const _=this._$filters||this.filters,c=_.length;if(!c)return r.$getBoundsObject(o,h,l,$);let u=new m(o,l,h-o,$-l);for(let t=0;t<c;++t)u=_[t]._$generateFilterRect(u,null,null,!0);return o=u._$x,h=u._$x+u._$width,l=u._$y,$=u._$y+u._$height,r.$getBoundsObject(o,h,l,$)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=this._$currentFrame||1;if(!this._$controller)return this._$children;let e=this._$controller[t];const i=this._$children.length;if(!i){if(e){const t=e.length;for(let i=0;i<t;++i){const t=this._$createInstance(e[i]);t._$placeId=i,this._$children.push(t),t._$name&&this._$names.set(t._$name,t)}}return this._$children}const s=r.$getMap(),n=r.$getMap();let o=0;const h=r.$getArray();for(let r=0;r<i;++r){const i=this._$children[r],l=i._$parent;if(l&&l._$instanceId===this._$instanceId)if(i._$startFrame<=t&&i._$endFrame>t){if(i._$filters=null,i._$blendMode=null,null===i._$id){h.push(i),i._$name&&this._$names.set(i._$name,i);continue}const t=e[o];if(i._$id===t){i._$placeId=o,h.push(i),i._$name&&this._$names.set(i._$name,i),n.has(t)&&n.delete(t),s.set(t,!0),o++;continue}n.set(i._$id,i)}else i.willTrigger(a.REMOVED)&&i.dispatchEvent(new a(a.REMOVED,!0)),i.willTrigger(a.REMOVED_FROM_STAGE)&&i.dispatchEvent(new a(a.REMOVED_FROM_STAGE,!0)),i._$added=!1,i._$addedStage=!1,i._$active=!1,i._$updated=!0,i._$filters=null,i._$blendMode=null,i._$isNext=!0,i instanceof v&&(i._$executeRemovedFromStage(),i._$removeParentAndStage())}if(e)for(let t=0;t<e.length;++t){const i=e[t];if(s.has(i))continue;const r=n.has(i)?n.get(i):this._$createInstance(i);r._$placeId=t,h.push(r),r._$name&&this._$names.set(r._$name,r)}r.$poolMap(s),r.$poolMap(n),r.$poolArray(this._$children),this._$children=null,this._$children=h}return this._$children}_$clearChildren(){this._$doChanged(),r.$isUpdated=!0,this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$stage=this._$stage,t._$parent=this,t._$root=this.constructor===k?t:this._$root,t instanceof v&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger(a.ADDED)&&t.dispatchEvent(new a(a.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(t.willTrigger(a.ADDED_TO_STAGE)&&t.dispatchEvent(new a(a.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof v&&t._$executeAddedToStage()),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e._$root=this._$root,e._$stage=this._$stage,e instanceof v&&(e._$setParentAndStage(),e._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage||(e.willTrigger(a.ADDED_TO_STAGE)&&e.dispatchEvent(new a(a.ADDED_TO_STAGE)),e._$addedStage=!0),e instanceof v&&e._$executeAddedToStage())}}_$remove(t,e=!0){t._$transform._$transform();const i=this._$needsChildren?this._$getChildren():this._$children,r=this.getChildIndex(t);return i.splice(r,1),this._$names.delete(t.name),e&&(t.willTrigger(a.REMOVED)&&t.dispatchEvent(new a(a.REMOVED,!0)),null!==this._$stage&&(t.willTrigger(a.REMOVED_FROM_STAGE)&&t.dispatchEvent(new a(a.REMOVED_FROM_STAGE)),t instanceof v&&t._$executeRemovedFromStage()),t instanceof v&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,this._$doChanged()),t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0),e=t.length;for(let i=0;i<e;++i){const e=t[i];e&&(e._$addedStage&&(e.willTrigger(a.REMOVED_FROM_STAGE)&&e.dispatchEvent(new a(a.REMOVED_FROM_STAGE)),e._$addedStage=!1),e instanceof v&&e._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=t.length;for(let i=0;i<e;++i){const e=t[i];e instanceof v&&e._$removeParentAndStage(),e._$stage=null,e._$root=null,e._$addedStage=!1}if(this._$sounds){const t=this._$sounds.values();for(const e of t)for(let t=0;t<e.length;++t){e[t].stop()}}}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const r=e[i];r._$isNext&&(t?r._$nextFrame():t=r._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,this._$isNext}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();s!==r.$MATRIX_ARRAY_IDENTITY&&(i=r.$multiplicationMatrix(e,s)),this._$graphics&&this._$graphics._$getBounds()&&this._$graphics._$clip(t,i);const n=this._$getChildren(),a=n.length;for(let e=0;e<a;++e){const r=n[e];r._$isMask||(r._$clip(t,i),r._$updated=!1)}i!==e&&r.$poolFloat32Array6(i)}_$draw(t,e,i){if(!this._$visible)return;let s=i;const n=this._$transform._$rawColorTransform();n!==r.$COLOR_ARRAY_IDENTITY&&(s=r.$multiplicationColor(i,n));if(!r.$clamp(s[3]+s[7]/255,0,1,0))return;const a=this._$needsChildren?this._$getChildren():this._$children,o=a.length;if(!(o||this._$graphics&&this._$graphics._$canDraw))return;const h=this._$preDraw(t,e,i);if(!h)return;if(h.isFilter&&!h.isUpdated)return void this._$postDraw(t,e,s,h);let l=h.matrix;const $=h.isFilter?h.color:s;this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$draw(t,l,$);let _=!0,c=null;const u=r.$getArray(),d=r.$getArray(),g=r.$getArray(),f=r.$getArray(),p=t._$isLayer,m=this._$isUpdated();for(let e=0;e<o;++e){const i=a[e];if(m&&(i._$placeObject=null),i._$isMask)continue;const s=i._$blendMode||i.blendMode;if((s===C.ALPHA||s===C.ERASE)&&!p)continue;if(c&&(i._$placeId>c||i._$clipDepth>0)&&(t.restore(),_&&(t._$leaveClip(),u.length&&(r.$poolFloat32Array6(l),l=u.pop())),c=g.length?g.pop():null,_=f.pop()),!_)continue;if(i._$clipDepth>0){if(t.save(),c&&g.push(c),f.push(_),c=i._$clipDepth,_=i._$shouldClip(l),_){const e=i._$startClip(t,l);if(!1===e){_=!1;continue}e&&(u.push(l),l=e)}continue}const n=i._$mask;if(n){let e;if(n._$updated=!1,this===n._$parent)e=l;else{e=r.$MATRIX_ARRAY_IDENTITY;let i=n._$parent;for(;i;)e=r.$multiplicationMatrix(i._$transform._$rawMatrix(),e),i=i._$parent;const s=this.stage._$player,a=s._$scale*s._$ratio/20,o=r.$getFloat32Array6(a,0,0,a,0,0);if(e=r.$multiplicationMatrix(o,e),t._$isLayer){const i=t._$getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t._$cacheCurrentBuffer&&(e[4]-=t._$cacheCurrentBounds.x,e[5]-=t._$cacheCurrentBounds.y)}if(!n._$shouldClip(e))continue;let i=n._$startClip(t,e);if(t.save(),!1===i){t.restore();continue}if(i){if(d.push(l),this!==n._$parent){const e=this._$transform._$rawMatrix();i[0]=r.$abs(l[0])*r.$sign(e[0]),i[1]=r.$abs(l[1])*r.$sign(e[1]),i[2]=r.$abs(l[2])*r.$sign(e[2]),i[3]=r.$abs(l[3])*r.$sign(e[3]),i[4]=l[4]-t._$cacheCurrentBounds.x,i[5]=l[5]-t._$cacheCurrentBounds.y}l=i}}i._$draw(t,l,$),i._$updated=!1,n&&(t.restore(),t._$leaveClip(),d.length&&(r.$poolFloat32Array6(l),l=d.pop()))}if(c&&(t.restore(),f.pop()&&t._$leaveClip()),r.$poolArray(u),r.$poolArray(d),r.$poolArray(g),r.$poolArray(f),h.isFilter)return this._$postDraw(t,e,s,h);r.$poolFloat32Array6(l),r.$poolPreObject(h)}_$mouseHit(t,e,i,s=!0){let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a));const o=this._$getChildren(),h=r.$getArray(),l=r.$getArray(),$=r.$getMap();let _=o.length,c=null,u=null;for(let t=0;t<_;++t){const e=o[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?(u=h.length,c=e._$clipDepth,h.push(e)):(c&&e._$placeId>c&&(u=null,c=null),null!==u&&$.set(e._$instanceId,u),l.push(e)))}const d=r.$min(this._$mouseChildren,s);let g=!1;const f=this._$root===this;_=l.length;for(let e=0;e<_;++e){const e=l.pop();if(e._$isMask)continue;if(f&&!(e instanceof T))continue;if($.has(e._$instanceId)){if(!h[$.get(e._$instanceId)]._$hit(t,n,i,!0))continue}const s=e._$mask;if(s)if(this===s._$parent){if(!s._$hit(t,n,i,!0))continue}else{let e=r.$MATRIX_ARRAY_IDENTITY,n=s._$parent;for(;n;)e=r.$multiplicationMatrix(n._$transform._$rawMatrix(),e),n=n._$parent;if(!s._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,n,i,d)||e._$hitArea&&e._$hitArea._$mouseHit(t,n,i,d)){if(e._$root===e)return!0;if(!d)return!0;if(g=!0,e instanceof T){if(!e._$mouseEnabled&&!e._$hitObject)continue;if(!r.$isTouch&&!i.pointer)switch(!0){case e instanceof rt:e._$type===st.INPUT&&(i.pointer="text");break;case e.buttonMode&&e.useHandCursor:i.pointer="pointer"}return i.hit||(i.hit=!e._$mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}return r.$poolArray(h),r.$poolArray(l),r.$poolMap($),!g&&this._$graphics&&(g=this._$graphics._$hit(t,n,i)),n!==e&&r.$poolFloat32Array6(n),g}_$hit(t,e,i,s=!1){let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a));const o=this._$getChildren();for(let e=o.length-1;e>-1;--e){const r=o[e];if(!r._$isMask&&r._$hit(t,n,i,s))return!0}let h=!1;return this._$graphics&&(h=this._$graphics._$hit(t,n,i)),n!==e&&r.$poolFloat32Array6(n),h}_$createInstance(t){const e=this._$dictionary[t],i=this._$loaderInfo,s=i._$data.characters[e.characterId];if(!s.class){const t=i._$data.symbols;let n=s.symbol;e.characterId in t&&(n=t[s._$characterId]),s.class=r.$getClass(n)}const n=new s.class;return n._$build(e,this),n._$id=t,n}_$outCheck(t,e){let i=r.$MATRIX_ARRAY_IDENTITY,s=this._$parent;for(;s;)i=r.$multiplicationMatrix(s._$transform._$rawMatrix(),i),s=s._$parent;return r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath(),this._$mouseHit(r.$hitContext,i,{x:t,y:e})}}class y extends v{constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=!!t}get dropTarget(){return r.$dropTarget}get graphics(){return this._$graphics||(this._$graphics=new O,this._$graphics._$displayObject=this),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=null,t instanceof y&&(this._$hitArea=t,t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new ht),this._$soundTransform}set soundTransform(t){t instanceof ht&&(this._$soundTransform=t)}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=!!t}startDrag(t=!1,e=null){let i=0,s=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,s=this.y-t.y}r.$dropTarget=this,r.$dragRules.lock=t,r.$dragRules.position.x=i,r.$dragRules.position.y=s,r.$dragRules.bounds=e}stopDrag(){r.$dropTarget=null,r.$dragRules.lock=!1,r.$dragRules.position.x=0,r.$dragRules.position.y=0,r.$dragRules.bounds=null}_$build(t,e){const i=super._$build(t,e);return this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(r.$currentMousePoint()):this.globalToLocal(r.$currentMousePoint())}}class E extends y{constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=r.$getMap(),this._$frameCache=r.$getMap(),this._$labels=null,this._$sounds=r.$getMap(),this._$channels=r.$getMap(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1,this._$enabled=!0}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)?this._$labels.get(t):null}get currentLabels(){return this._$labels?r.$Array.from(this._$labels.values()):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=r.$getMap()),t instanceof R&&this._$labels.set(t.frame,t)}addFrameScript(){const t=arguments.length;for(let e=0;e<t;e+=2){let t=arguments[e];r.$isNaN(0|t)&&(t=this._$getFrameForLabel(t)),t|=0;const i=arguments[e+1];if(i&&t&&this._$totalFrames>=t&&this._$addAction(t,i),t===this._$currentFrame){const t=r.$currentPlayer();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push.apply(t._$actions,e),t._$actionOffset=0}}}}_$getFrameForLabel(t){for(let[e,i]of this._$labels)if(i.name===t)return 0|e;return 0}_$addAction(t,e){(t|=0)&&(this._$actions.has(t)||this._$actions.set(t,r.$getArray()),this._$actions.get(t).push(e))}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e.willTrigger(a.FRAME_LABEL)&&e.dispatchEvent(new a(a.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=r.$currentPlayer();if(t){-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}}_$goToFrame(t){if(r.$isNaN(+t)&&(t=this._$getFrameForLabel(t)),t<1&&(t=1),t>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const e=r.$currentPlayer();switch(!0){case t!==this._$currentFrame:{this._$wait=!1;const i=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",t),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=t,this._$clearChildren(),e._$actionOffset=e._$actions.length;const r=e._$actionOffset?e._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),e._$actionOffset&&e._$actionOffset!==e._$actions.length){const t=e._$actions.splice(0,e._$actionOffset);e._$actions.push.apply(e._$actions,t),e._$actionOffset=0}if(!this._$actionProcess&&(r>-1||!e._$actionOffset))for(;e._$actions.length&&e._$actions.length!==r;){const t=e._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const i=t._$currentFrame;if(!t._$actions.has(i))continue;const r=t._$actions.get(i),s=r.length;for(let e=0;e<s;++e)try{r[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=i,this._$clearChildren())}break;case!this._$actionProcess&&e._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=e._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const r=e._$actions.get(i),s=r.length;for(let t=0;t<s;++t)try{r[t].apply(e)}catch(t){e.stop()}}}}this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!e._$sounds.has(this._$instanceId)&&e._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$draw(t,e,i){super._$draw(t,e,i);const s=r.$currentPlayer();this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!s._$sounds.has(this._$instanceId)&&s._$sounds.set(this._$instanceId,this)}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:t=!0,this._$canAction=!0,this._$canSound=!0,++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1),this._$clearChildren()}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const r=e[i];r._$isNext&&(t?r._$nextFrame():t=r._$nextFrame())}return this._$setAction(),this._$isNext=t,this._$isNext}_$build(t,e){const i=super._$build(t,e);for(let t=0;t<i.sounds.length;++t){const e=i.sounds[t],s=r.$getArray();for(let t=0;t<e.sound.length;++t){const i=new at;i._$build(e.sound[t],this),s.push(i)}this._$sounds.set(e.frame,s)}for(let t=0;t<i.actions.length;++t){const e=i.actions[t];e.script||(e.script=Function(e.action)),this._$addAction(e.frame,e.script)}for(let t=0;t<i.labels.length;++t){const e=i.labels[t];this.addFrameLabel(new R(e.name,e.frame))}return this._$totalFrames=i.totalFrame||1,i}_$soundPlay(){const t=this._$sounds.get(this._$currentFrame);if(!t)return;const e=t.length;if(e){let i=this._$soundTransform,r=this._$parent;for(;r;)r._$soundTransform&&(i=r._$soundTransform),r=r._$parent;for(let r=0;r<e;++r){const e=t[r];i&&(e.loop=i.loop,e.volume=i.volume),e.play()}}this._$canSound=!1}}class A{constructor(t=0,i=0,s=!0,n=4294967295){this._$width=0|t,this._$height=0|i,this._$transparent=s,this._$color=this._$toRGBA(r.$clamp(n,0,4294967295,4294967295)),this._$instanceId=e++}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get height(){return this._$height}get image(){return this._$image}set image(t){this._$image=t}get transparent(){return this._$transparent}get width(){return this._$width}get _$texture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=r.$currentPlayer(),s=i._$cacheStore,n=s.generateKeys(this._$instanceId);let a=s.get(n);if(!a){const o=i._$context;switch(!0){case null!==this._$image:a=o.frameBuffer.createTextureFromImage(this._$image),this._$image=null;break;case null!==this._$buffer:a=o.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0),this._$buffer=null;break;default:{const i=o.frameBuffer.currentAttachment,s=o.frameBuffer.createCacheAttachment(t,e,!1);o._$bind(s),r.$resetContext(o),o.fillStyle=[this._$color.R/255,this._$color.G/255,this._$color.B/255,this._$color.A/255],o.setTransform(1,0,0,1,0,0),o.beginPath(),o.fillRect(0,0,t,e),a=o.frameBuffer.getTextureFromCurrentAttachment(),i?o._$bind(i):o.frameBuffer.unbind(),o.frameBuffer.releaseAttachment(s,!1)}}s.set(n,a)}return r.$poolArray(n),a._$bitmapData||(a._$bitmapData=this),a}set _$texture(t){this._$setPixelQueue=null,this._$setPixelCount=0,this._$linePixelsCache=null,this._$linePixelsCacheY=null;const e=r.$currentPlayer(),i=e._$cacheStore,s=i.generateKeys(this._$instanceId),n=i.get(s);n&&(n._$bitmapData&&delete n._$bitmapData,e._$context.frameBuffer.releaseTexture(n),i.set(s,null)),this._$buffer&&(this._$buffer=null),i.set(s,t),r.$poolArray(s),t._$bitmapData||(t._$bitmapData=this)}draw(t,e=null,i=null,s=C.NORMAL,n=null,a=!1){const o=this._$width,h=this._$height;if(!o||!h)return;const l=r.$currentPlayer()._$context,$=l.frameBuffer.currentAttachment,_=l.frameBuffer.createCacheAttachment(o,h,!1);if(l._$bind(_),r.$resetContext(l),l.setTransform(1,0,0,1,0,0),n){const t=n.x,e=n.y,i=n.width,r=n.height;l.save(),l._$enterClip(),l._$beginClipDef(),l.setTransform(1,0,0,1,0,0),l.beginPath(),l.moveTo(t,e),l.lineTo(t+i,e),l.lineTo(t+i,e+r),l.lineTo(t,e+r),l.lineTo(t,e),l.clip(!0),l._$endClipDef()}let c=e?e._$matrix:r.$MATRIX_ARRAY_IDENTITY,u=i?i._$colorTransform:r.$COLOR_ARRAY_IDENTITY;if(t instanceof b){const i=t._$transform.matrix;i.invert(),e&&(c=r.$multiplicationMatrix(c,i._$matrix)),t._$draw(l,c,u),r.$poolMatrix(i)}else{new Bitmap(t,PixelSnapping.AUTO,a)._$draw(l,c,u)}n&&(l.restore(),l._$leaveClip());const d=l.frameBuffer.getTextureFromCurrentAttachment(),g=l.frameBuffer.createTextureAttachmentFrom(this._$texture);l._$bind(g),l.frameBuffer.releaseAttachment(_,!1),r.$resetContext(l),l.setTransform(1,0,0,1,0,0),l._$imageSmoothingEnabled=a,l._$globalCompositeOperation=s,l.drawImage(d,0,0,o,h),$?l._$bind($):l.frameBuffer.unbind(),l.frameBuffer.releaseTexture(d),l.frameBuffer.releaseAttachment(g,!1)}_$toRGBA(t){return this._$transparent?r.$uintToRGBA(t):r.$intToRGBA(t)}_$getPixels(t,e,i,s,n="ARGB",a=null){switch(n){case"ARGB":case"RGBA":case"BGRA":break;default:throw new Error(`Unsupported byteOrder: ${n}`)}t=Math.max(t,0),e=Math.max(e,0);const o=r.$min(i,this.width-t),h=r.$min(s,this.height-e);if(o<=0||h<=0)return new Uint8Array(0);const l=a?a(o*h*4):new Uint8Array(o*h*4),$=r.$currentPlayer()._$context;if(!$)return l;const _=$._$shaderList._$bitmapData.getPixels[n].instance;$._$shaderList.bitmapShaderVariants.setGetPixelsUniform(_.uniform,o/this.width,-h/this.height,t/this.width,1-e/this.height);const c=$.frameBuffer.currentAttachment,u=$.frameBuffer.createCacheAttachment(o,h,!1);$._$bind(u),$._$frameBufferManager._$textureManager.bind0(this._$texture,!1),$.blend.disable(),_._$drawImage(),$.blend.enable();const d=$._$gl;return d.readPixels(0,0,o,h,d.RGBA,d.UNSIGNED_BYTE,l),c?$._$bind(c):$.frameBuffer.unbind(),$.frameBuffer.releaseAttachment(u),l}toImage(){const{width:t,height:e}=this,i=new Image;if(t||e){const s=r.$cacheStore().getCanvas();s.width=t,s.height=e;const n=new ImageData(t,e);n.data.set(this._$getPixels(0,0,t,e,"RGBA"));const a=s.getContext("2d");a.putImageData(n,0,0),i.width=t,i.height=e,i.src=a.canvas.toDataURL(),r.$cacheStore().destroy(a)}return i}toUint8Array(){return this._$buffer?this._$buffer:this._$getPixels(0,0,this.width,this.height,"RGBA")}}class M{static toString(){return"[class BitmapDataChannel]"}static get namespace(){return"next2d.display.BitmapDataChannel"}toString(){return"[object BitmapDataChannel]"}get namespace(){return"next2d.display.BitmapDataChannel"}static get ALPHA(){return 8}static get BLUE(){return 4}static get GREEN(){return 2}static get RED(){return 1}}class C{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}}class S{static toString(){return"[class CapsStyle]"}static get namespace(){return"next2d.display.CapsStyle"}toString(){return"[object CapsStyle]"}get namespace(){return"next2d.display.CapsStyle"}static get NONE(){return"none"}static get ROUND(){return"round"}static get SQUARE(){return"square"}}class R extends o{constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class w{static toString(){return"[class GradientType]"}static get namespace(){return"next2d.display.GradientType"}toString(){return"[object GradientType]"}get namespace(){return"next2d.display.GradientType"}static get LINEAR(){return"linear"}static get RADIAL(){return"radial"}}class O{constructor(t=null){this._$displayObject=t,this.clear()}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}beginBitmapFill(t,e=null,i=!0,s=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=r.$getArray()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$fills.push(O.BEGIN_PATH),this._$fillType=O.BITMAP_FILL,this._$fillBitmap=new B(t,e,i,s),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=r.$getArray()),t=r.$clamp(r.$toColorInt(t),0,16777215,0),e=r.$clamp(e,0,1,1),this._$maxAlpha=r.$max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$fills.push(O.BEGIN_PATH);const i=r.$intToRGBA(t,e);return this._$fillType=O.FILL_STYLE,this._$fillStyleR=i.R,this._$fillStyleG=i.G,this._$fillStyleB=i.B,this._$fillStyleA=i.A,this}beginGradientFill(t,e,i,s,n=null,a=U.PAD,o=F.RGB,h=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=r.$getArray());const l=i.length;for(let t=0;t<l;++t)this._$maxAlpha=r.$max(this._$maxAlpha,i[t]);return this._$doFill=!0,this._$canDraw=!0,this._$fills.push(O.BEGIN_PATH),this._$fillType=O.GRADIENT_FILL,this._$fillGradient=new I(t,e,i,s,n,a,o,h),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=0,this._$caps=S.NONE,this._$joints=L.ROUND,this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=r.$MAX_VALUE,this._$xMax=-r.$MAX_VALUE,this._$yMin=r.$MAX_VALUE,this._$yMax=-r.$MAX_VALUE,this._$recode&&r.$poolArray(this._$recode),this._$fills&&r.$poolArray(this._$fills),this._$lines&&r.$poolArray(this._$lines),this._$recode=null,this._$fills=null,this._$lines=null,this._$restart(),this}clone(){const t=new O;return t.copyFrom(this),t}copyFrom(t){t instanceof O&&(t._$fillGradient&&(this._$fillGradient=t._$fillGradient.clone()),t._$fillBitmap&&(this._$fillBitmap=t._$fillBitmap.clone()),this._$doFill=t._$doFill,this._$fillType=t._$fillType,this._$fillStyleR=t._$fillStyleR,this._$fillStyleG=t._$fillStyleG,this._$fillStyleB=t._$fillStyleB,this._$fillStyleA=t._$fillStyleA,t._$lineGradient&&(this._$lineGradient=t._$lineGradient.clone()),this._$doLine=t._$doLine,this._$lineType=t._$lineType,this._$caps=t._$caps,this._$joints=t._$caps,this._$miterLimit=t._$miterLimit,this._$lineWidth=t._$lineWidth,this._$lineStyleR=t._$lineStyleR,this._$lineStyleG=t._$lineStyleG,this._$lineStyleB=t._$lineStyleB,this._$lineStyleA=t._$lineStyleA,this._$xMin=t._$xMin,this._$xMax=t._$xMax,this._$yMin=t._$yMin,this._$yMax=t._$yMax,this._$maxAlpha=t._$maxAlpha,this._$pointerX=t._$pointerX,this._$pointerY=t._$pointerY,this._$canDraw=t._$canDraw,t._$fills&&(this._$fills=t._$fills.slice(0)),t._$lines&&(this._$lines=t._$lines.slice(0)),t._$recode&&(this._$recode=t._$recode.slice(0)))}cubicCurveTo(t,e,i,s,n,a){return n=+n||0,a=+a||0,this._$pointerX===n&&this._$pointerY===a||(t=+t||0,e=+e||0,i=+i||0,s=+s||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$setBounds(n,a),this._$margePath(r.$getArray(O.CUBIC,t,e,i,s,n,a)),this._$pointerX=n,this._$pointerY=a,this._$restart()),this}curveTo(t,e,i,s){return i=+i||0,s=+s||0,this._$pointerX===i&&this._$pointerY===s||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$margePath(r.$getArray(O.CURVE_TO,t,e,i,s)),this._$pointerX=i,this._$pointerY=s,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(r.$getArray(O.MOVE_TO,t+i,e,O.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,i,s){const n=(i=+i||0)/2,a=(s=+s||0)/2,o=(t=+t||0)+n,h=(e=+e||0)+a,l=t+i,$=e+s,_=4/3*(r.$SQRT2-1),c=_*n,u=_*a;return this.moveTo(o,e).cubicCurveTo(o+c,e,l,h-u,l,h).cubicCurveTo(l,h+u,o+c,$,o,$).cubicCurveTo(o-c,$,t,h+u,t,h).cubicCurveTo(t,h-u,o-c,e,o,e)}drawRect(t,e,i,r){const s=(t=+t||0)+(i=+i||0),n=(e=+e||0)+(r=+r||0);return this.moveTo(t,e).lineTo(t,n).lineTo(s,n).lineTo(s,e).lineTo(t,e)}drawRoundRect(t,e,i,s,n,a=NaN){t=+t||0,e=+e||0,i=+i||0,s=+s||0;const o=(n=+n||0)/2,h=(a=+a||n)/2,l=4/3*(r.$SQRT2-1),$=l*o,_=l*h,c=t+o,u=t+i,d=u-o,g=e+h,f=e+s,p=f-h;return this.moveTo(c,e).lineTo(d,e).cubicCurveTo(d+$,e,u,g-_,u,g).lineTo(u,p).cubicCurveTo(u,p+_,d+$,f,d,f).lineTo(c,f).cubicCurveTo(c-$,f,t,p+_,t,p).lineTo(t,g).cubicCurveTo(t,g-_,c-$,e,c,e)}endFill(){if(this._$doFill&&this._$fills.length>6)switch(this._$recode||(this._$recode=r.$getArray()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(O.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push.apply(this._$recode,this._$fills),this._$fillType){case O.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,O.END_FILL);break;case O.GRADIENT_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillGradient.toArray());break;case O.BITMAP_FILL:this._$recode.push(this._$fillType),this._$recode.push.apply(this._$recode,this._$fillBitmap.toArray())}return this._$fills&&(r.$poolArray(this._$fills),this._$fills=null),this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine)switch(this._$recode||(this._$recode=r.$getArray()),this._$recode.push.apply(this._$recode,this._$lines),r.$poolArray(this._$lines),this._$lines=null,this._$lineType){case O.STROKE_STYLE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,O.END_STROKE);break;case O.GRADIENT_STROKE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$miterLimit),this._$recode.push.apply(this._$recode,this._$lineGradient.toArray())}return this._$lineType=0,this._$lineWidth=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps=S.NONE,this._$joints=L.ROUND,this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineGradientStyle(t,e,i,s,n=null,a=U.PAD,o=F.RGB,h=0){if(!this._$doLine)return this;this._$lines||(this._$lines=r.$getArray());const l=i.length;for(let t=0;t<l;++t)this._$maxAlpha=r.$max(this._$maxAlpha,i[t]);return this._$lines.push(O.BEGIN_PATH),this._$lineType=O.GRADIENT_STROKE,this._$lineGradient=new I(t,e,i,s,n,a,o,h),this}lineStyle(t=1,e=0,i=1,s=S.ROUND,n=L.ROUND,a=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=r.$getArray()),e=r.$clamp(r.$toColorInt(e),0,16777215,0),i=r.$clamp(+i,0,1,1),this._$maxAlpha=r.$max(this._$maxAlpha,i),this._$doLine=!0,this._$canDraw=!0,this._$lines.push(O.BEGIN_PATH,O.MOVE_TO,this._$pointerX,this._$pointerY);const o=r.$intToRGBA(e,i);return this._$lineType=O.STROKE_STYLE,this._$lineStyleR=o.R,this._$lineStyleG=o.G,this._$lineStyleB=o.B,this._$lineStyleA=o.A,this._$lineWidth=t,this._$caps=`${s}`,this._$joints=`${n}`,this._$joints===L.MITER&&(this._$miterLimit=a),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(r.$getArray(O.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){return t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e),this._$margePath(r.$getArray(O.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,e){const i=this._$getBounds(),s=r.$boundsMatrix(i,e);let n=r.$ceil(r.$abs(s.xMax-s.xMin)),a=r.$ceil(r.$abs(s.yMax-s.yMin));switch(r.$poolBoundsObject(i),r.$poolBoundsObject(s),!0){case 0===n:case 0===a:case n===-r.$Infinity:case a===-r.$Infinity:case n===r.$Infinity:case a===r.$Infinity:return}r.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$doDraw(t,r.$COLOR_ARRAY_IDENTITY,!0),t.clip()}_$drawFilter(t,e,i,s,n,a,o){const h=this._$displayObject,l=[h._$instanceId,"f"];let $=r.$cacheStore().get(l);const _=h._$isFilterUpdated(a,o,i,s,n,!0);return $&&!_||($&&(r.$cacheStore().set(l,null),$.layerWidth=0,$.layerHeight=0,$._$offsetX=0,$._$offsetY=0,$.matrix=null,$.colorTransform=null,t.frameBuffer.releaseTexture($),$=null),e=h._$getFilterTexture(t,n,e,i,s),r.$cacheStore().set(l,e)),$&&(e=$),r.$poolArray(l),e}_$drawBitmap(t,e,i,s=C.NORMAL,n=null){if(!this._$maxAlpha)return;const a=r.$clamp(i[3]+i[7]/255,0,1),o=this._$displayObject;let h=e;const l=o._$transform._$rawMatrix();l!==r.$MATRIX_ARRAY_IDENTITY&&(h=r.$multiplicationMatrix(e,l));const $=this._$getBounds(),_=r.$boundsMatrix($,h),c=_.xMax,u=_.xMin,d=_.yMax,g=_.yMin;r.$poolBoundsObject(_);let x=r.$ceil(r.$abs(c-u)),b=r.$ceil(r.$abs(d-g));switch(!0){case 0===x:case 0===b:case x===-r.$Infinity:case b===-r.$Infinity:case x===r.$Infinity:case b===r.$Infinity:return}const T=Math.sqrt(h[0]*h[0]+h[1]*h[1]),v=Math.sqrt(h[2]*h[2]+h[3]*h[3]);if(0>u+x||0>g+b){if(!(n&&n.length&&o._$canApply(n)))return;{let t=new m(0,0,x,b);for(let e=0;e<n.length;++e)t=n[e]._$generateFilterRect(t,T,v);if(0>t.x+t.width||0>t.y+t.height)return}}const y=t.frameBuffer.currentAttachment;if(u>y.width||g>y.height)return;const E=t._$textureScale(x,b);E<1&&(x*=E,b*=E);const A=r.$cacheStore().generateKeys(o._$instanceId,[T,v],i);let M=r.$cacheStore().get(A);if(!M){const s=t.frameBuffer.createCacheAttachment(x,b,!0);switch(t._$bind(s),r.$resetContext(t),i[3]=1,!0){case 1!==l[0]:case 0!==l[1]:case 0!==l[2]:case 1!==l[3]:{const s=Math.atan2(e[1],e[0]);let n=0,a=0;if(s){const t=new f;t.translate(-x/2,-b/2),t.rotate(s),t.translate(x/2,b/2);const e=t.transformPoint(new p(0,0)),i=t.transformPoint(new p(x,0)),o=t.transformPoint(new p(0,b)),h=t.transformPoint(new p(x,b));n=r.$min(e.x,i.x,o.x,h.x),a=r.$min(e.y,i.y,o.y,h.y)}r.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],-n,-a),t.beginPath(),this._$runTransformCommand(t,l,i)}break;default:t.setTransform(h[0],h[1],h[2],h[3],h[4]-u,h[5]-g),this._$doDraw(t,i)}M=t.frameBuffer.getTextureFromCurrentAttachment(),r.$cacheStore().set(A,M),t.frameBuffer.releaseAttachment(s,!1),t._$bind(y)}let S=!1,R=0,w=0;if(n&&n.length){o._$canApply(n)&&(S=!0,M=this._$drawFilter(t,M,e,i,n,x,b),R=M._$offsetX,w=M._$offsetY)}r.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=s,t.setTransform(1,0,0,1,0,0),S?t.drawImage(M,u-R,g-w,M.width,M.height,i):t.drawImage(M,u,g,x,b,i),r.$poolArray(A),r.$poolBoundsObject($)}_$draw(t,e,i,s=C.NORMAL,n=null){if(!this._$maxAlpha)return;const a=r.$clamp(i[3]+i[7]/255,0,1),o=this._$displayObject;let h=null!==o._$scale9Grid,l=null;h&&(l=o._$transform._$rawMatrix(),h=h&&r.$abs(l[1])<.001&&r.$abs(l[2])<1e-4);const $=this._$getBounds(),_=r.$boundsMatrix($,e),c=_.xMax,u=_.xMin,d=_.yMax,g=_.yMin;r.$poolBoundsObject(_);let f=r.$ceil(r.$abs(c-u)),p=r.$ceil(r.$abs(d-g));switch(!0){case 0===f:case 0===p:case f===-r.$Infinity:case p===-r.$Infinity:case f===r.$Infinity:case p===r.$Infinity:return}const x=Math.sqrt(e[0]*e[0]+e[1]*e[1]),b=Math.sqrt(e[2]*e[2]+e[3]*e[3]);if(0>u+f||0>g+p){if(!(n&&n.length&&o._$canApply(n)))return;{let t=new m(0,0,f,p);for(let e=0;e<n.length;++e)t=n[e]._$generateFilterRect(t,x,b);if(0>t.x+t.width||0>t.y+t.height)return}}const T=t.frameBuffer.currentAttachment;if(u>T.width||g>T.height)return;const v=t._$textureScale(f,p);v<1&&(f*=v,p*=v);const y=r.$cacheStore().generateKeys(o._$instanceId,[x,b],i);let E=r.$cacheStore().get(y);if(!E){const s=t.frameBuffer.createCacheAttachment(f,p,!0);if(t._$bind(s),r.$resetContext(t),t.setTransform(e[0],e[1],e[2],e[3],e[4]-u,e[5]-g),h){const i=r.$currentPlayer(),s=i._$scale*i._$ratio,n=r.$getFloat32Array6(s,0,0,s,0,0),a=r.$multiplicationMatrix(n,l);r.$poolFloat32Array6(n);const h=o._$parent._$transform._$calculateConcatenatedMatrix()._$matrix,_=r.$getFloat32Array6(h[0],h[1],h[2],h[3],h[4]*s-u,h[5]*s-g),c=r.$multiplicationMatrix(_,a),d=c[4]-(e[4]-u),f=c[5]-(e[5]-g);r.$poolFloat32Array6(c);const p=r.$boundsMatrix($,a),m=+p.xMax,x=+p.xMin,b=+p.yMax,T=+p.yMin,v=r.$ceil(r.$abs(m-x)),y=r.$ceil(r.$abs(b-T));r.$poolBoundsObject(p),t.grid.enable(x,T,v,y,$,o._$scale9Grid,a[0],a[1],a[2],a[3],a[4],a[5],_[0],_[1],_[2],_[3],_[4]-d,_[5]-f),r.$poolFloat32Array6(a),r.$poolFloat32Array6(_)}i[3]=1,this._$doDraw(t,i,!1),h&&t.grid.disable(),E=t.frameBuffer.getTextureFromCurrentAttachment(),r.$cacheStore().set(y,E),t.frameBuffer.releaseAttachment(s,!1),t._$bind(T)}let A=!1,M=0,S=0;if(n&&n.length){o._$canApply(n)&&(A=!0,E=this._$drawFilter(t,E,e,i,n,f,p),M=E._$offsetX,S=E._$offsetY)}r.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=!0,t._$globalCompositeOperation=s,t.setTransform(1,0,0,1,0,0),A?t.drawImage(E,u-M,g-S,E.width,E.height,i):t.drawImage(E,u,g,f,p,i),r.$poolArray(y),l&&r.$poolMatrix(l),r.$poolBoundsObject($)}_$doDraw(t,e,i=!1){r.$resetContext(t),t.beginPath(),this._$runCommand(t,e,i)}_$hit(t,e,i,r=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,r,i)}_$getBounds(){const t=this._$displayObject;return t&&t._$bounds?r.$getBoundsObject(t._$bounds.xMin,t._$bounds.xMax,t._$bounds.yMin,t._$bounds.yMax):r.$getBoundsObject(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){this._$displayObject&&!this._$displayObject._$isUpdated()&&(this._$displayObject._$doChanged(),r.$isUpdated=!0,r.$cacheStore().removeCache(this._$displayObject._$instanceId))}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t,e){this._$xMin=r.$min(this._$xMin,t),this._$xMax=r.$max(this._$xMax,t),this._$yMin=r.$min(this._$yMin,e),this._$yMax=r.$max(this._$yMax,e)}_$setLineBounds(t,e){this._$xMin=r.$min(this._$xMin,r.$min(t,this._$pointerX)),this._$xMax=r.$max(this._$xMax,r.$max(t,this._$pointerX)),this._$yMin=r.$min(this._$yMin,r.$min(e,this._$pointerY)),this._$yMax=r.$max(this._$yMax,r.$max(e,this._$pointerY));const i=this._$lineWidth/2,s=.5*r.$PI,n=r.$atan2(e-this._$pointerY,t-this._$pointerX),a=r.$atan2(this._$pointerY-e,this._$pointerX-t),o=n+s,h=n-s,l=a+s,$=a-s;let _=t+i,c=-i+t,u=this._$pointerX+i,d=-i+this._$pointerX,g=e+i,f=-i+e,p=this._$pointerY+i,m=-i+this._$pointerY;r.$abs(o)%s!=0&&(_=t+r.$cos(o)*i),r.$abs(h)%s!=0&&(c=t+r.$cos(h)*i),r.$abs(l)%s!=0&&(u=this._$pointerX+r.$cos(l)*i),r.$abs($)%s!=0&&(d=this._$pointerX+r.$cos($)*i),o&&r.$abs(o)%r.$PI!=0&&(g=e+r.$sin(o)*i),h&&r.$abs(h)%r.$PI!=0&&(f=e+r.$sin(h)*i),l&&r.$abs(l)%r.$PI!=0&&(p=this._$pointerY+r.$sin(l)*i),$&&r.$abs($)%r.$PI!=0&&(m=this._$pointerY+r.$sin($)*i),this._$xMin=r.$min(this._$xMin,r.$min(_,r.$min(c,r.$min(u,d)))),this._$xMax=r.$max(this._$xMax,r.$max(_,r.$max(c,r.$max(u,d)))),this._$yMin=r.$min(this._$yMin,r.$min(g,r.$min(f,r.$min(p,m)))),this._$yMax=r.$max(this._$yMax,r.$max(g,r.$max(f,r.$max(p,m))));let x=0,b=0,T=0,v=0,y=0,E=0,A=0,M=0;switch(this._$caps){case S.ROUND:r.$abs(n)%s!=0&&(x=t+r.$cos(n)*i),n&&r.$abs(n)%r.$PI!=0&&(b=e+r.$sin(n)*i),r.$abs(a)%s!=0&&(T=this._$pointerX+r.$cos(a)*i),a&&r.$abs(a)%r.$PI!=0&&(v=this._$pointerY+r.$sin(a)*i),this._$xMin=r.$min(this._$xMin,r.$min(x,T)),this._$xMax=r.$max(this._$xMax,r.$max(x,T)),this._$yMin=r.$min(this._$yMin,r.$min(b,v)),this._$yMax=r.$max(this._$yMax,r.$max(b,v));break;case S.SQUARE:if(r.$abs(n)%s!=0){const t=r.$cos(n)*i;x=_+t,T=c+t}if(r.$abs(a)%s!=0){const t=r.$cos(a)*i;y=u+t,A=d+t}if(n&&r.$abs(n)%r.$PI!=0){const t=r.$sin(n)*i;b=g+t,v=f+t}if(a&&r.$abs(a)%r.$PI!=0){const t=r.$sin(a)*i;E=p+t,M=m+t}this._$xMin=r.$min(this._$xMin,r.$min(x,r.$min(T,r.$min(y,A)))),this._$xMax=r.$max(this._$xMax,r.$max(x,r.$max(T,r.$max(y,A)))),this._$yMin=r.$min(this._$yMin,r.$min(b,r.$min(v,r.$min(E,M)))),this._$yMax=r.$max(this._$yMax,r.$max(b,r.$max(v,r.$max(E,M))))}}_$margePath(t){this._$doFill&&this._$fills.push.apply(this._$fills,t),this._$doLine&&this._$lines.push.apply(this._$lines,t),r.$poolArray(t)}_$runTransformCommand(t,e,i=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;let s=Number.MAX_VALUE,n=-Number.MAX_VALUE,a=Number.MAX_VALUE,o=-Number.MAX_VALUE;const h=this._$recode,l=h.length;for(let $=0;$<l;)switch(h[$++]){case O.BEGIN_PATH:t.beginPath();break;case O.MOVE_TO:{const i=h[$++],l=h[$++],_=i*e[0]+l*e[2],c=i*e[1]+l*e[3];s=r.$min(_,s),n=r.$max(_,n),a=r.$min(c,a),o=r.$max(c,o),t.moveTo(_,c)}break;case O.LINE_TO:{const i=h[$++],l=h[$++],_=i*e[0]+l*e[2],c=i*e[1]+l*e[3];s=r.$min(_,s),n=r.$max(_,n),a=r.$min(c,a),o=r.$max(c,o),t.lineTo(_,c)}break;case O.CURVE_TO:{const i=h[$++],l=h[$++],_=h[$++],c=h[$++],u=i*e[0]+l*e[2],d=i*e[1]+l*e[3],g=_*e[0]+c*e[2],f=_*e[1]+c*e[3];s=r.$min(u,s),n=r.$max(u,n),a=r.$min(d,a),o=r.$max(d,o),s=r.$min(g,s),n=r.$max(g,n),a=r.$min(f,a),o=r.$max(f,o),t.quadraticCurveTo(u,d,g,f)}break;case O.CLOSE_PATH:t.closePath();break;case O.CUBIC:{const i=h[$++],l=h[$++],_=h[$++],c=h[$++],u=h[$++],d=h[$++],g=i*e[0]+l*e[2],f=i*e[1]+l*e[3],p=_*e[0]+c*e[2],m=_*e[1]+c*e[3],x=u*e[0]+d*e[2],b=u*e[1]+d*e[3];s=r.$min(g,s),n=r.$max(g,n),a=r.$min(f,a),o=r.$max(f,o),s=r.$min(p,s),n=r.$max(p,n),a=r.$min(m,a),o=r.$max(m,o),s=r.$min(x,s),n=r.$max(x,n),a=r.$min(b,a),o=r.$max(b,o),t.bezierCurveTo(g,f,p,m,x,b)}break;case O.ARC:{const i=h[$++],l=h[$++],_=h[$++],c=i*e[0]+l*e[2],u=i*e[1]+l*e[3];s=r.$min(c,s),n=r.$max(c,n),a=r.$min(u,a),o=r.$max(u,o),t.arc(c,u,_,0,2*r.$PI)}break;case O.BITMAP_FILL:{t._$matrix[6]-=s*t._$matrix[0]+a*t._$matrix[3],t._$matrix[7]-=s*t._$matrix[1]+a*t._$matrix[4],t.save();const e=h[$++],r=h[$++],n=h[$++],o=h[$++];t.fillStyle=t.createPattern(e._$texture,n,i),r&&t.transform(r[0],r[1],r[2],r[3],r[4],r[5]),t._$imageSmoothingEnabled=o,t.fill(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}_$runCommand(t,e=null,i=!1,s=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;const n=this._$recode,a=n.length;for(let o=0;o<a;)switch(n[o++]){case O.BEGIN_PATH:t.beginPath();break;case O.MOVE_TO:t.moveTo(n[o++],n[o++]);break;case O.LINE_TO:t.lineTo(n[o++],n[o++]);break;case O.CURVE_TO:t.quadraticCurveTo(n[o++],n[o++],n[o++],n[o++]);break;case O.FILL_STYLE:{if(i||s){o+=4;continue}const a=t._$contextStyle;a._$fillStyle[0]=1!==e[0]||0!==e[4]?r.$max(0,r.$min(n[o++]*e[0]+e[4],255))/255:n[o++]/255,a._$fillStyle[1]=1!==e[1]||0!==e[5]?r.$max(0,r.$min(n[o++]*e[1]+e[5],255))/255:n[o++]/255,a._$fillStyle[2]=1!==e[2]||0!==e[6]?r.$max(0,r.$min(n[o++]*e[2]+e[6],255))/255:n[o++]/255,a._$fillStyle[3]=1!==e[3]||0!==e[7]?r.$max(0,r.$min(n[o++]*e[3]+e[7],255))/255:n[o++]/255,t._$style=a}break;case O.END_FILL:if(s){if(t.isPointInPath(s.x,s.y))return!0;continue}i||t.fill();break;case O.STROKE_STYLE:{if(i||s){o+=8;continue}t.lineWidth=n[o++],t.lineCap=n[o++],t.lineJoin=n[o++],t.miterLimit=n[o++];const a=t._$contextStyle;a._$strokeStyle[0]=1!==e[0]||0!==e[4]?r.$max(0,r.$min(n[o++]*e[0]+e[4],255))/255:n[o++]/255,a._$strokeStyle[1]=1!==e[1]||0!==e[5]?r.$max(0,r.$min(n[o++]*e[1]+e[5],255))/255:n[o++]/255,a._$strokeStyle[2]=1!==e[2]||0!==e[6]?r.$max(0,r.$min(n[o++]*e[2]+e[6],255))/255:n[o++]/255,a._$strokeStyle[3]=1!==e[3]||0!==e[7]?r.$max(0,r.$min(n[o++]*e[3]+e[7],255))/255:n[o++]/255,t._$style=a}break;case O.END_STROKE:if(s){if(t.isPointInStroke(s.x,s.y))return!0;continue}i||t.stroke();break;case O.CLOSE_PATH:t.closePath();break;case O.CUBIC:t.bezierCurveTo(n[o++],n[o++],n[o++],n[o++],n[o++],n[o++]);break;case O.ARC:{const e=n[o++],i=n[o++],s=n[o++];t.arc(e,i,s,0,2*r.$PI)}break;case O.GRADIENT_FILL:{if(s){if(t.isPointInPath(s.x,s.y))return!0;o+=6;continue}if(i){o+=6;continue}const a=n[o++],h=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++];let u=null;if(a===w.LINEAR){const e=r.$linearGradientXY(l);u=t.createLinearGradient(e[0],e[1],e[2],e[3],_,$)}else t.save(),t.transform(l[0],l[1],l[2],l[3],l[4],l[5]),u=t.createRadialGradient(0,0,0,0,0,819.2,_,$,c);const d=h.length;for(let t=0;t<d;++t){const i=h[t];u.addColorStop(i.ratio,r.$getFloat32Array4(0|r.$max(0,r.$min(i.R*e[0]+e[4],255)),0|r.$max(0,r.$min(i.G*e[1]+e[5],255)),0|r.$max(0,r.$min(i.B*e[2]+e[6],255)),0|r.$max(0,r.$min(i.A*e[3]+e[7],255))))}t.fillStyle=u,t.fill(),a===w.RADIAL&&t.restore()}break;case O.GRADIENT_STROKE:{if(s){if(t.isPointInStroke(s.x,s.y))return!0;o+=12;continue}if(i){o+=12;continue}const a=n[o++],h=n[o++],l=n[o++],$=n[o++],_=n[o++],c=n[o++],u=n[o++],d=n[o++],g=n[o++],f=n[o++];let p=null;if(_===w.LINEAR){const e=r.$linearGradientXY(u);p=t.createLinearGradient(e[0],e[1],e[2],e[3],g,d)}else t.save(),t.transform(u[0],u[1],u[2],u[3],u[4],u[5]),p=t.createRadialGradient(0,0,0,0,0,819.2,g,d,f);const m=c.length;for(let t=0;t<m;++t){const i=c[t];p.addColorStop(i.ratio,r.$getFloat32Array4(0|r.$max(0,r.$min(i.R*e[0]+e[4],255)),0|r.$max(0,r.$min(i.G*e[1]+e[5],255)),0|r.$max(0,r.$min(i.B*e[2]+e[6],255)),0|r.$max(0,r.$min(i.A*e[3]+e[7],255))))}t.strokeStyle=p,t.lineWidth=a,t.lineCap=h,t.lineJoin=l,t.miterLimit=$,t.stroke(),_===w.RADIAL&&t.restore()}break;case O.BITMAP_FILL:{if(s){if(t.isPointInPath(s.x,s.y))return!0;o+=6;continue}if(i){o+=6;continue}t.save();const r=n[o++],a=n[o++],h=n[o++],l=n[o++];t.fillStyle=t.createPattern(r._$texture,h,e),a&&t.transform(a[0],a[1],a[2],a[3],a[4],a[5]),t._$imageSmoothingEnabled=l,t.fill(),t.restore(),t._$imageSmoothingEnabled=!1}}return!1}}class B{constructor(t,e=null,i=!0,r=!1){this._$bitmapData=t,this._$matrix=e,this._$repeat=!!i,this._$smooth=!!r}clone(){return new B(this._$bitmapData.clone(),this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){return r.$getArray(this._$bitmapData,this._$matrix,this._$repeat?"repeat":"no-repeat",this._$smooth)}}class I{constructor(t=w.LINEAR,e=null,i=null,s=null,n=null,a=U.PAD,o=F.RGB,h=0){if(this._$type=w.RADIAL===t?t:w.LINEAR,this._$colors=r.$isArray(e)?this._$toColorInt(e):null,this._$alphas=r.$isArray(i)?this._$toColorInt(i):null,this._$ratios=null,r.$isArray(s)){for(let t=0;t<s.length;++t)s[t]=r.$clamp(s[t],0,255,0);this._$ratios=s}switch(this._$matrix=n,a){case U.REFLECT:case U.REPEAT:this._$spreadMethod=a;break;default:this._$spreadMethod=U.PAD}this._$interpolationMethod=o===F.LINEAR_RGB?o:F.RGB,this._$focalPointRatio=+h||0,this._$colorStops=null}get colorStops(){if(!this._$colorStops){this._$colorStops=r.$getArray();const t=r.$min(r.$min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=r.$intToRGBA(this._$colors[e],this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:t.R,G:t.G,B:t.B,A:t.A}}}return this._$colorStops}_$toColorInt(t){const e=t.length;for(let i=0;i<e;++i)t[i]=r.$clamp(r.$toColorInt(t[i]),0,16777215,16777215);return t}toArray(){return r.$getArray(this._$type,this.colorStops,this._$matrix?this._$matrix._$matrix:r.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class F{static toString(){return"[class InterpolationMethod]"}static get namespace(){return"next2d.display.InterpolationMethod"}toString(){return"[object InterpolationMethod]"}get namespace(){return"next2d.display.InterpolationMethod"}static get LINEAR_RGB(){return"linearRGB"}static get RGB(){return"rgb"}}class L{static toString(){return"[class JointStyle]"}static get namespace(){return"next2d.display.JointStyle"}toString(){return"[object JointStyle]"}get namespace(){return"next2d.display.JointStyle"}static get BEVEL(){return"bevel"}static get MITER(){return"miter"}static get ROUND(){return"round"}}class P extends v{constructor(){super(),this._$loaderInfo=new D}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo._$content}get contentLoaderInfo(){return this._$loaderInfo}load(t){if(!(t&&t instanceof dt))return;const e=this.contentLoaderInfo;switch(t.responseDataFormat){case ut.JSON:case ut.ARRAY_BUFFER:break;default:return void(e.willTrigger(_.IO_ERROR)&&e.dispatchEvent(new _(_.IO_ERROR,!1,!1,"data format is json or arrayBuffer only.")))}e._$url=t.url,e._$format=t.responseDataFormat,r.$ajax({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(a.OPEN)&&e.dispatchEvent(new a(a.OPEN)),e.willTrigger(u.PROGRESS)&&e.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(u.PROGRESS)&&e.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){const e=this.contentLoaderInfo;e._$bytesLoaded=t.loaded,e._$bytesTotal=t.total,e.willTrigger(u.PROGRESS)&&e.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total));const i=r.$getArray(),s=r.$headerToArray(t.target.getAllResponseHeaders()),n=s.length;for(let t=0;t<n;++t){const e=s[t];i.push(new gt(e.name,e.value))}if(e.willTrigger($.HTTP_STATUS)){const r=new $($.HTTP_STATUS,!1,!1,t.target.status);r._$responseURL=t.target.responseURL,r._$responseHeaders=i,e.dispatchEvent(r)}if(199<t.target.status&&400>t.target.status)switch(e.format){case ut.JSON:{const e=JSON.parse(t.target.responseText);if("zlib"===e.type){if(r.$unzipWorkerActive)return void r.$unzipQueues.push({json:e,scope:this});r.$unzipWorkerActive=!0,r.$unzipWorker||(r.$unzipWorker=new Worker(r.$unzipURL));const t=new Uint8Array(e.buffer);r.$unzipWorker.onmessage=r.$unzipHandler.bind(this),r.$unzipWorker.postMessage(t,[t.buffer])}else this._$build(e)}break;case ut.ARRAY_BUFFER:this._$imageDecode(new Uint8Array(t.target.response))}else e.willTrigger(_.IO_ERROR)&&e.dispatchEvent(new _(_.IO_ERROR,!1,!1,t.target.statusText))}.bind(this)}})}loadImage(t){t.responseDataFormat=ut.ARRAY_BUFFER,this.load(t)}_$imageDecode(t){const e={image:new r.$Image,scope:this};e.image.decoding="async",e.image.src=r.$URL.createObjectURL(new r.$Blob([t],{type:`image/${r.$getImageType(t)}`})),r.$imageWorkerActive?r.$imageQueues.push(e):(r.$imageWorkerActive=!0,e.image.decode().then(r.$decodeImage.bind(e)).catch((()=>{throw new Error("image encoding error")})))}_$build(t){const e=this.contentLoaderInfo;e._$data=t;const i=t.characters[0];e._$content=new E,e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:i.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const s=r.$currentPlayer();s._$loaders.push(e),s._$loadStatus===te.LOAD_START&&(s._$loadStatus=te.LOAD_END)}}class D extends o{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format=ut.STRING}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get content(){return this._$content}get url(){return this._$url}get format(){return this._$format}set format(t){this._$format=t}}class N extends b{constructor(){super(),this._$graphics=null,this._$bounds=null,this._$bitmapId=0}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new O(this)),this._$graphics}_$build(t,e){const i=super._$build(t,e),s=this.graphics;if(i.recodes)if(i.bitmapId){this._$bitmapId=i.bitmapId;const t=e._$loaderInfo._$data.characters[i.bitmapId],n=r.$abs(t.bounds.xMax-t.bounds.xMin),a=r.$abs(t.bounds.yMax-t.bounds.yMin),o=new A(n,a,!0,0);t._$buffer||(t._$buffer=new Uint8Array(t.buffer),r.$poolArray(t.buffer),t.buffer=null),o._$buffer=t._$buffer.slice(),s._$recode=r.$getArray();const h=i.recodes,l=h.length-6;for(let t=0;t<l;++t)s._$recode.push(h[t]);s._$recode.push(O.BITMAP_FILL,o,null,"repeat",!1)}else s._$recode=i.recodes.slice(0);else{const t=r.$abs(i.bounds.xMax-i.bounds.xMin),e=r.$abs(i.bounds.yMax-i.bounds.yMin),n=new A(t,e,!0,0);i._$buffer||(i._$buffer=new Uint8Array(i.buffer),r.$poolArray(i.buffer),i.buffer=null),n._$buffer=i._$buffer.slice(0),s.beginBitmapFill(n,null,!1).drawRect(0,0,t,e)}return s._$maxAlpha=1,s._$canDraw=!0,s._$xMin=i.bounds.xMin,s._$xMax=i.bounds.xMax,s._$yMin=i.bounds.yMin,s._$yMax=i.bounds.yMax,i}_$getBounds(t=null){if(!this._$graphics)return r.$getBoundsObject(0,0,0,0);const e=this._$graphics._$getBounds();if(t){const i=r.$multiplicationMatrix(t,this._$transform._$rawMatrix()),s=r.$boundsMatrix(e,i);return r.$poolBoundsObject(e),s}return e}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let s=i;const n=this._$transform._$rawColorTransform();n!==r.$COLOR_ARRAY_IDENTITY&&(s=r.$multiplicationColor(i,n));if(!r.$clamp(s[3]+s[7]/255,0,1,0))return void(s!==i&&r.$poolFloat32Array8(s));const a=this._$filters||this.filters,o=this._$blendMode||this.blendMode;if(this._$bitmapId)this._$graphics._$drawBitmap(t,e,s,o,a);else{let i=e;const n=this._$transform._$rawMatrix();n!==r.$MATRIX_ARRAY_IDENTITY&&(i=r.$multiplicationMatrix(e,n)),this._$graphics._$draw(t,i,s,o,a),i!==e&&r.$poolFloat32Array6(i)}s!==i&&r.$poolFloat32Array8(s)}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();s!==r.$MATRIX_ARRAY_IDENTITY&&(i=r.$multiplicationMatrix(e,s)),this._$graphics._$clip(t,i),i!==e&&r.$poolFloat32Array6(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,s){let n=!1;if(this._$graphics&&this._$graphics._$canDraw&&this._$graphics._$getBounds()){let a=e;const o=this._$transform._$rawMatrix();o!==r.$MATRIX_ARRAY_IDENTITY&&(a=r.$multiplicationMatrix(e,o)),n=this._$graphics._$hit(t,a,i,s),a!==e&&r.$poolFloat32Array6(a)}return n}}class U{static toString(){return"[class SpreadMethod]"}static get namespace(){return"next2d.display.SpreadMethod"}toString(){return"[object SpreadMethod]"}get namespace(){return"next2d.display.SpreadMethod"}static get PAD(){return"pad"}static get REFLECT(){return"reflect"}static get REPEAT(){return"repeat"}}class k extends v{constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=r.$clamp(r.$toColorInt(t),0,16777215,16777215);const e=this._$player;if(e){const t=r.$uintToRGBA(this._$color);e._$context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=r.$clamp(+t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get stageHeight(){return this._$player?this._$player._$height/this._$player._$scale/this._$player._$ratio:0}get stageWidth(){return this._$player?this._$player._$width/this._$player._$scale/this._$player._$ratio:0}invalidate(){this._$invalidate=!0}}class G{static toString(){return"[class StageQuality]"}static get namespace(){return"next2d.display.StageQuality"}toString(){return"[object StageQuality]"}get namespace(){return"next2d.display.StageQuality"}static get HIGH(){return"high"}static get LOW(){return"low"}static get MEDIUM(){return"medium"}}class X{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,r.$isUpdated=!0}}class Y{static toString(){return"[class BitmapFilterType]"}static get namespace(){return"next2d.filters.BitmapFilterType"}toString(){return"[object BitmapFilterType]"}get namespace(){return"next2d.filters.BitmapFilterType"}static get FULL(){return"full"}static get INNER(){return"inner"}static get OUTER(){return"outer"}}class H{static toString(){return"[class BitmapFilterQuality]"}static get namespace(){return"next2d.filters.BitmapFilterQuality"}toString(){return"[object BitmapFilterQuality]"}get namespace(){return"next2d.filters.BitmapFilterQuality"}static get LOW(){return 1}static get MEDIUM(){return 2}static get HIGH(){return 3}}class j{static toString(){return"[class DisplacementMapFilterMode]"}static get namespace(){return"next2d.filters.DisplacementMapFilterMode"}toString(){return"[object DisplacementMapFilterMode]"}get namespace(){return"next2d.filters.DisplacementMapFilterMode"}static get CLAMP(){return"clamp"}static get COLOR(){return"color"}static get IGNORE(){return"ignore"}static get WRAP(){return"wrap"}}class V extends X{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=r.$clamp(+t,0,255,0))!==this._$blurX&&this._$doChanged(!0),this._$blurX=t}get blurY(){return this._$blurY}set blurY(t){(t=r.$clamp(+t,0,255,0))!==this._$blurY&&this._$doChanged(!0),this._$blurY=t}get quality(){return this._$quality}set quality(t){(t=r.$clamp(0|t,0,15,H.LOW))!==this._$quality&&this._$doChanged(!0),this._$quality=t}clone(){return new V(this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=null,i=null){const s=t.clone();if(!this._$quality)return s;const n=V.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,o=0>=this._$blurY?1:this._$blurY*n;switch(!0){case"number"==typeof e:case"number"==typeof i:a*=e,o*=i;break;default:a=r.$round(a),o=r.$round(o)}return s.x-=a,s.width+=2*a,s.y-=o,s.height+=2*o,s}_$isSame(t){return this._$quality===t._$quality&&(this._$blurX===t._$blurX&&this._$blurY===t._$blurY)}_$canApply(){return!(!this._$quality||!this._$blurX&&!this._$blurY)}_$applyFilter(t,e,i=!0){this._$doChanged(!1);const s=t.frameBuffer.currentAttachment,n=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return i?n:t.frameBuffer.createTextureFromCurrentAttachment();const a=r.$sqrt(e[0]*e[0]+e[1]*e[1]),o=r.$sqrt(e[2]*e[2]+e[3]*e[3]),h=new m(0,0,n.width,n.height),l=this._$generateFilterRect(h,a,o),$=0|r.$ceil(l.width),_=0|r.$ceil(l.height),c=r.$ceil(r.$abs(l.x)+.5*r.$abs($-l.width)),u=r.$ceil(r.$abs(l.y)+.5*r.$abs(_-l.height));t._$offsetX=+(c+t._$offsetX),t._$offsetY=+(u+t._$offsetY);const d=this._$blurX*a,g=this._$blurY*o;let f=1,p=1;d>128?f=.0625:d>64?f=.125:d>32?f=.25:d>16&&(f=.5),g>128?p=.0625:g>64?p=.125:g>32?p=.25:g>16&&(p=.5);const x=d*f,b=g*p;let T=r.$ceil($*f),v=r.$ceil(_*p);const y=t.frameBuffer.createTextureAttachment(T,v),E=[y,t.frameBuffer.createTextureAttachment(T,v)];let A=0;t._$bind(y),r.$resetContext(t),t.setTransform(f,0,0,p,0,0),t.drawImage(n,c,u,n.width,n.height),t.blend.toOneZero();let M=t.frameBuffer.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){A=(A+1)%2;const e=E[A];t._$bind(e),t._$applyBlurFilter(M,!0,x),M=t.frameBuffer.getTextureFromCurrentAttachment()}if(this._$blurY>0){A=(A+1)%2;const e=E[A];t._$bind(e),t._$applyBlurFilter(M,!1,b),M=t.frameBuffer.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==f||1!==p){const e=t.frameBuffer.createTextureAttachment($,_);t._$bind(e),r.$resetContext(t),t.imageSmoothingEnabled=!0,t.setTransform(1/f,0,0,1/p,0,0),t.drawImage(M,0,0,T,v),M=t.frameBuffer.getTextureFromCurrentAttachment(),r.$resetContext(t),t.setTransform(1,0,0,1,0,0),t.frameBuffer.releaseAttachment(E[0],!0),t.frameBuffer.releaseAttachment(E[1],!0),i?t.frameBuffer.releaseAttachment(s,!0):t.frameBuffer.releaseAttachment(e,!1)}else t.frameBuffer.releaseAttachment(E[(A+1)%2],!0),i?t.frameBuffer.releaseAttachment(s,!0):t.frameBuffer.releaseAttachment(E[A],!1);return M}}class z extends X{constructor(t=4,e=45,i=16777215,r=1,s=0,n=1,a=4,o=4,h=1,l=1,$="inner",_=!1){super(),this._$blurFilter=new V(a,o,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type=Y.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=r,this.shadowColor=s,this.shadowAlpha=n,this.strength=h,this.type=$,this.knockout=!!_}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=r.$clamp(+t,0,1,0))!==this._$highlightAlpha&&this._$doChanged(!0),this._$highlightAlpha=t}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,16777215))!==this._$highlightColor&&this._$doChanged(!0),this._$highlightColor=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=r.$clamp(+t,0,1,0))!==this._$shadowAlpha&&this._$doChanged(!0),this._$shadowAlpha=t}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$shadowColor&&this._$doChanged(!0),this._$shadowColor=t}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case Y.OUTER:case Y.INNER:this._$type=t;break;default:this._$type=Y.FULL}}clone(){return new z(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let s=t.clone();if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=+this.angle*r.$PI/180,a=r.$cos(n)*this.distance,o=r.$sin(n)*this.distance;let h=0|r.$abs(a),l=0|r.$abs(o);return 0>a&&h++,0>o&&l++,0===h&&0>o&&(h=1),0===l&&0>a&&(l=1),s.x-=h,s.width+=2*h,s.y-=l,s.height+=2*l,s}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$highlightColor===t._$highlightColor&&(this._$highlightAlpha===t._$highlightAlpha&&(this._$shadowColor===t._$shadowColor&&(this._$shadowAlpha===t._$shadowAlpha&&(this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))))))}_$canApply(){return!(!this._$strength||!this._$distance)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return s;const n=i.width,a=i.height,o=t._$offsetX,h=t._$offsetY,l=r.$sqrt(e[0]*e[0]+e[1]*e[1]),$=r.$sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*r.$Deg2Rad,c=+r.$cos(_)*this._$distance*l,u=+r.$sin(_)*this._$distance*$;let d=t.frameBuffer.createTextureAttachment(n,a);t._$bind(d),r.$resetContext(t),t.drawImage(s,0,0,n,a),t.globalCompositeOperation=C.ERASE,t.drawImage(s,2*c,2*u,n,a);const g=this._$blurFilter._$applyFilter(t,e,!1),f=g.width,p=g.height,m=r.$ceil(f+2*r.$abs(c)),x=r.$ceil(p+2*r.$abs(u)),b=this._$type===Y.INNER,T=b?n:m,v=b?a:x,y=r.$abs(c),E=r.$abs(u),A=(f-n)/2,M=(p-a)/2;let S,R,w,O;return b?(S=0,R=0,w=-A-c,O=-M-u):(S=y+A,R=E+M,w=y-c,O=E-u),t._$bind(i),t._$applyBitmapFilter(g,T,v,n,a,S,R,f,p,w,O,!1,this._$type,this._$knockout,this._$strength,null,null,null,r.$intToR(this._$highlightColor,this._$highlightAlpha,!0),r.$intToG(this._$highlightColor,this._$highlightAlpha,!0),r.$intToB(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,r.$intToR(this._$shadowColor,this._$shadowAlpha,!0),r.$intToG(this._$shadowColor,this._$shadowAlpha,!0),r.$intToB(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=o+S,t._$offsetY=h+R,t.frameBuffer.releaseTexture(g),t.frameBuffer.getTextureFromCurrentAttachment()}}class W extends X{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this._$doApply=!1,this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(r.$isArray(t)&&20===t.length){if(this._$matrix){const e=t.length;for(let i=0;i<e;++i)if(t[i]!==this._$matrix[i]){this._$doChanged(!0),this._$doApply=!0;break}}this._$matrix=t}}clone(){return new W(this._$matrix)}_$generateFilterRect(t){return t}_$isSame(t){const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$doApply}_$applyFilter(t){this._$doChanged(!1);const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment(),s=i.width,n=i.height,a=t.frameBuffer.createTextureAttachment(s,n);return t._$bind(a),r.$resetContext(t),t._$applyColorMatrixFilter(i,this._$matrix),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class q extends X{constructor(t=0,e=0,i=null,r=1,s=0,n=!0,a=!0,o=0,h=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=r,this.bias=s,this.preserveAlpha=n,this.clamp=a,this.color=o,this.alpha=h}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get bias(){return this._$bias}set bias(t){(t=+t)!==this._$bias&&this._$doChanged(!0),this._$bias=t}get clamp(){return this._$clamp}set clamp(t){(t=!!t)!==this._$clamp&&this._$doChanged(!0),this._$clamp=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get divisor(){return this._$divisor}set divisor(t){(t=+t)!==this._$divisor&&this._$doChanged(!0),this._$divisor=t}get matrix(){return this._$matrix}set matrix(t){this._$doChanged(!0),this._$matrix&&r.$poolArray(this._$matrix),this._$matrix=r.$getArray(),r.$isArray(t)&&(this._$matrix=t.slice(0))}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|r.$clamp(0|t,0,15,0))!==this._$matrixX&&this._$doChanged(!0),this._$matrixX=t}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|r.$clamp(0|t,0,15,0))!==this._$matrixY&&this._$doChanged(!0),this._$matrixY=t}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){(t=!!t)!==this._$preserveAlpha&&this._$doChanged(!0),this._$preserveAlpha=t}clone(){return new q(this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){if(this._$matrixX!==t._$matrixX)return!1;if(this._$matrixY!==t._$matrixY)return!1;if(this._$divisor!==t._$divisor)return!1;if(this._$bias!==t._$bias)return!1;if(this._$preserveAlpha!==t._$preserveAlpha)return!1;if(this._$clamp!==t._$clamp)return!1;if(this._$color!==t._$color)return!1;if(this._$alpha!==t._$alpha)return!1;const e=this._$matrix.length;for(let i=0;i<e;++i)if(this._$matrix[i]!==t._$matrix[i])return!1;return!0}_$canApply(){return this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$doChanged(!1);const e=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const i=t.frameBuffer.getTextureFromCurrentAttachment();return this._$canApply()?(t._$applyConvolutionFilter(i,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,r.$intToR(this._$color,this._$alpha,!1),r.$intToG(this._$color,this._$alpha,!1),r.$intToB(this._$color,this._$alpha,!1),this._$alpha),t.frameBuffer.releaseAttachment(e,!0),t.frameBuffer.getTextureFromCurrentAttachment()):i}}class K extends X{constructor(t=null,e=null,i=0,r=0,s=0,n=0,a="wrap",o=0,h=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode=j.WRAP,this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=r,this.scaleX=s,this.scaleY=n,this.mode=a,this.color=o,this.alpha=h}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get componentX(){return this._$componentX}set componentX(t){switch((t|=0)!==this._$componentX&&this._$doChanged(!0),this._$componentX=0,t){case M.ALPHA:case M.BLUE:case M.GREEN:case M.RED:this._$componentX=t}}get componentY(){return this._$componentY}set componentY(t){switch((t|=0)!==this._$componentY&&this._$doChanged(!0),this._$componentY=0,t){case M.ALPHA:case M.BLUE:case M.GREEN:case M.RED:this._$componentY=t}}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&this._$doChanged(!0),this._$mapBitmap=null,t instanceof A&&(this._$mapBitmap=t)}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&this._$doChanged(!0),this._$mapPoint=null,t instanceof p&&(this._$mapPoint=t)}get mode(){return this._$mode}set mode(t){switch((t+="")!==this._$mode&&this._$doChanged(!0),this._$mode=j.WRAP,t){case j.CLAMP:case j.COLOR:case j.IGNORE:this._$mode=t}}get scaleX(){return this._$scaleX}set scaleX(t){(t=r.$clamp(+t,-65535,65535,0))!==this._$scaleX&&this._$doChanged(!0),this._$scaleX=t}get scaleY(){return this._$scaleY}set scaleY(t){(t=r.$clamp(+t,-65535,65535,0))!==this._$scaleY&&this._$doChanged(!0),this._$scaleY=t}clone(){return new K(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$isSame(t){return this._$mapBitmap===t._$mapBitmap&&(this._$mapPoint.x===t._$mapPoint.x&&(this._$mapPoint.y===t._$mapPoint.y&&(this._$componentX===t._$componentX&&(this._$componentY===t._$componentY&&(this._$scaleX===t._$scaleX&&(this._$scaleY===t._$scaleY&&(this._$mode===t._$mode&&(this._$color===t._$color&&this._$alpha===t._$alpha))))))))}_$canApply(){return!(null===this._$mapBitmap||!this._$componentX&&!this._$componentY||!this._$scaleX&&!this._$scaleY)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return s;const n=r.$sqrt(e[0]*e[0]+e[1]*e[1]),a=r.$sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(s,this._$mapBitmap._$texture,s.width/n,s.height/a,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,r.$intToR(this._$color,this._$alpha,!0),r.$intToG(this._$color,this._$alpha,!0),r.$intToB(this._$color,this._$alpha,!0),this._$alpha),t.frameBuffer.releaseAttachment(i,!0),t.frameBuffer.getTextureFromCurrentAttachment()}}class Q extends X{constructor(t=4,e=45,i=0,r=1,s=4,n=4,a=1,o=1,h=!1,l=!1,$=!1){super(),this._$blurFilter=new V(s,n,o),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=r,this.strength=a,this.inner=h,this.knockout=l,this.hideObject=$}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,0))!==this._$color&&this._$doChanged(!0),this._$color=t}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get hideObject(){return this._$hideObject}set hideObject(t){(t=!!t)!==this._$hideObject&&this._$doChanged(!0),this._$hideObject=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new Q(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let s=t.clone();if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=+this._$angle*r.$Deg2Rad,a=+r.$cos(n)*this._$distance,o=+r.$sin(n)*this._$distance;let h=0,l=0,$=0,_=0;switch(a<0){case!0:h=0|r.$floor(a),$=0|-r.$round(a/2);break;default:h=0|r.$round(a/2),$=a/2|0}switch(o<0){case!0:l=0|r.$floor(o),_=0|-r.$round(o/2);break;default:l=0|r.$round(o/2),_=o/2|0}return s.x+=h,s.width+=$,s.y+=l,s.height+=_,s}_$isSame(t){return this._$distance===t._$distance&&(this._$angle===t._$angle&&(this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&(this._$hideObject===t._$hideObject&&this._$blurFilter._$isSame(t._$blurFilter))))))))}_$canApply(){return!(!this._$alpha||!this._$strength)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const s=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,$=h.height,_=t._$offsetX,c=t._$offsetY,u=_-a,d=c-o,g=+this._$angle*r.$Deg2Rad,f=+r.$cos(g)*this._$distance*r.$devicePixelRatio,p=+r.$sin(g)*this._$distance*r.$devicePixelRatio,m=this._$inner?s:l+r.$max(0,r.$abs(f)-u),x=this._$inner?n:$+r.$max(0,r.$abs(p)-d),b=r.$ceil(m),T=r.$ceil(x),v=(b-m)/2,y=(T-x)/2;let E,A,M,C,S,R;return this._$inner?(E=0,A=0,M=f-_,C=p-c):(E=r.$max(0,u-f)+v,A=r.$max(0,d-p)+y,M=(f>0?r.$max(0,f-u):0)+v,C=(p>0?r.$max(0,p-d):0)+y),this._$inner?(S=Y.INNER,R=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(S=Y.FULL,R=!0):(S=Y.OUTER,R=this._$knockout),t._$bind(i),t._$applyBitmapFilter(h,b,T,s,n,E,A,l,$,M,C,!0,S,R,this._$strength,null,null,null,r.$intToR(this._$color,this._$alpha,!0),r.$intToG(this._$color,this._$alpha,!0),r.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+E,t._$offsetY=o+A,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class J extends X{constructor(t=0,e=1,i=4,r=4,s=1,n=1,a=!1,o=!1){super(),this._$blurFilter=new V(i,r,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=s,this.inner=a,this.knockout=o}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=r.$clamp(+t,0,1,0))!==this._$alpha&&this._$doChanged(!0),this._$alpha=t}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=r.$clamp(r.$toColorInt(t),0,16777215,4))!==this._$color&&this._$doChanged(!0),this._$color=t}get inner(){return this._$inner}set inner(t){(t=!!t)!==this._$inner&&this._$doChanged(!0),this._$inner=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}clone(){return new J(this._$color,this._$alpha,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){const r=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(r,e,i):r}_$isSame(t){return this._$color===t._$color&&(this._$alpha===t._$alpha&&(this._$strength===t._$strength&&(this._$inner===t._$inner&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))))}_$canApply(){return!(!this._$alpha||!this._$strength)&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const s=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,$=h.height,_=t._$offsetX,c=t._$offsetY,u=this._$inner?s:l,d=this._$inner?n:$;let g,f,p,m;this._$inner?(g=0,f=0,p=-_,m=-c):(g=_-a,f=c-o,p=0,m=0);const x=this._$inner?Y.INNER:Y.OUTER;return t._$bind(i),t._$applyBitmapFilter(h,u,d,s,n,g,f,l,$,p,m,!0,x,this._$knockout,this._$strength,null,null,null,r.$intToR(this._$color,this._$alpha,!0),r.$intToG(this._$color,this._$alpha,!0),r.$intToB(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=o+f,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class Z extends X{constructor(t=4,e=45,i=null,r=null,s=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new V(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=Y.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=r,this.ratios=s,this.strength=o,this.type=l,this.knockout=$}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=r.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-r.$abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=r.$toColorInt(r.$abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i)t[i]=r.$clamp(+t[i],0,255,0);this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case Y.OUTER:case Y.FULL:this._$type=t;break;default:this._$type=Y.INNER}}clone(){return new Z(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t){let e=t.clone();if(!this._$canApply())return e;e=this._$blurFilter._$generateFilterRect(e);const i=+this.angle*r.$PI/180,s=r.$cos(i)*this._$distance,n=r.$sin(i)*this._$distance;let a=0|r.$abs(s),o=0|r.$abs(n);return 0>s&&a++,0>n&&o++,0===a&&0>n&&(a=1),0===o&&0>s&&(o=1),e.x-=a,e.width+=2*a,e.y-=o,e.height+=2*o,e}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$canApply(){return!!(0!==this._$strength&&0!==this._$distance&&this._$alphas&&this._$ratios&&this._$colors)}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=t.frameBuffer.getTextureFromCurrentAttachment();if(!this._$canApply())return s;const n=i.width,a=i.height,o=t._$offsetX,h=t._$offsetY,l=r.$sqrt(e[0]*e[0]+e[1]*e[1]),$=r.$sqrt(e[2]*e[2]+e[3]*e[3]),_=+this._$angle*r.$Deg2Rad,c=+r.$cos(_)*this._$distance*l,u=+r.$sin(_)*this._$distance*$;let d=t.frameBuffer.createTextureAttachment(n,a);t._$bind(d),r.$resetContext(t),t.drawImage(s,0,0,n,a),t.globalCompositeOperation=C.ERASE,t.drawImage(s,2*c,2*u,n,a);const g=this._$blurFilter._$applyFilter(t,e,!1),f=g.width,p=g.height,m=r.$ceil(f+2*r.$abs(c)),x=r.$ceil(p+2*r.$abs(u)),b=this._$type===Y.INNER,T=b?n:m,v=b?a:x,y=r.$abs(c),E=r.$abs(u),A=(f-n)/2,M=(p-a)/2;let S,R,w,O;return b?(S=0,R=0,w=-A-c,O=-M-u):(S=y+A,R=E+M,w=y-c,O=E-u),t._$bind(i),t._$applyBitmapFilter(g,T,v,n,a,S,R,f,p,w,O,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=o+S,t._$offsetY=h+R,t.frameBuffer.releaseTexture(g),t.frameBuffer.getTextureFromCurrentAttachment()}}class tt extends X{constructor(t=4,e=45,i=null,r=null,s=null,n=4,a=4,o=1,h=1,l="inner",$=!1){super(),this._$blurFilter=new V(n,a,h),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type=Y.INNER,this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=r,this.ratios=s,this.strength=o,this.type=l,this.knockout=$}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$colors&&this._$ratios?this._$alphas:null}set alphas(t){if(this._$alphas=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=+t[i];t[i]=r.$clamp(e,0,1,0)}this._$alphas=t.slice(0)}}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&this._$doChanged(!0),this._$angle=r.$clamp(t,-360,360,45)}get blurX(){return this._$blurFilter._$blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter._$blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$alphas&&this._$ratios?this._$colors:null}set colors(t){if(this._$colors=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){let e=0|t[i];e<0&&(e=16777216-r.$abs(e)%16777216),e>16777215&&(e%=16777216),t[i]=r.$toColorInt(r.$abs(e))}this._$colors=t.slice(0)}}get distance(){return this._$distance}set distance(t){(t=r.$clamp(+t,-255,255,4))!==this._$distance&&this._$doChanged(!0),this._$distance=t}get knockout(){return this._$knockout}set knockout(t){(t=!!t)!==this._$knockout&&this._$doChanged(!0),this._$knockout=t}get quality(){return this._$blurFilter._$quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$alphas&&this._$colors?this._$ratios:null}set ratios(t){if(this._$ratios=null,r.$isArray(t)){this._$doChanged(!0);const e=t.length;for(let i=0;i<e;++i){const e=r.$clamp(+t[i],0,255,0);t[i]=e}this._$ratios=t.slice(0)}}get strength(){return this._$strength}set strength(t){(t=r.$clamp(0|t,0,255,0))!==this._$strength&&this._$doChanged(!0),this._$strength=t}get type(){return this._$type}set type(t){switch((t+="")!==this._$type&&this._$doChanged(!0),t){case Y.OUTER:case Y.FULL:this._$type=t;break;default:this._$type=Y.INNER}}clone(){return new tt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter._$blurX,this._$blurFilter._$blurY,this._$strength,this._$blurFilter._$quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=null,i=null){let s=t.clone();if(!this._$canApply())return s;s=this._$blurFilter._$generateFilterRect(s,e,i);const n=+this.angle*r.$PI/180,a=+r.$cos(n)*this.distance,o=+r.$sin(n)*this.distance;let h=0,l=0,$=0,_=0;switch(a<0){case!0:h=0|r.$floor(a),$=0|-r.$round(a/2);break;default:h=0|r.$round(a/2),$=a/2|0}switch(o<0){case!0:l=0|r.$floor(o),_=0|-r.$round(o/2);break;default:l=0|r.$round(o/2),_=o/2|0}return s.x+=h,s.width+=$,s.y+=l,s.height+=_,s}_$canApply(){return!!(0!==this._$strength&&this._$alphas&&this._$ratios&&this._$colors)}_$isSame(t){if(this._$distance!==t._$distance)return!1;if(this._$angle!==t._$angle)return!1;for(let e=0;e<this._$colors.length;++e)if(this._$colors[e]!==t._$colors[e])return!1;for(let e=0;e<this._$alphas.length;++e)if(this._$alphas[e]!==t._$alphas[e])return!1;for(let e=0;e<this._$ratios.length;++e)if(this._$ratios[e]!==t._$ratios[e])return!1;return this._$strength===t._$strength&&(this._$type===t._$type&&(this._$knockout===t._$knockout&&this._$blurFilter._$isSame(t._$blurFilter)))}_$applyFilter(t,e){this._$doChanged(!1);const i=t.frameBuffer.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return t.frameBuffer.getTextureFromCurrentAttachment();const s=i.width,n=i.height,a=t._$offsetX,o=t._$offsetY,h=this._$blurFilter._$applyFilter(t,e,!1),l=h.width,$=h.height,_=t._$offsetX,c=t._$offsetY,u=_-a,d=c-o,g=r.$sqrt(e[0]*e[0]+e[1]*e[1]),f=r.$sqrt(e[2]*e[2]+e[3]*e[3]),p=+this._$angle*r.$Deg2Rad,m=+r.$cos(p)*this._$distance*g,x=+r.$sin(p)*this._$distance*f,b=this.type===Y.INNER,T=b?s:l+r.$max(0,r.$abs(m)-u),v=b?n:$+r.$max(0,r.$abs(x)-d),y=r.$ceil(T),E=r.$ceil(v),A=(y-T)/2,M=(E-v)/2;let C,S,R,w;return b?(C=0,S=0,R=m-_,w=x-c):(C=r.$max(0,u-m)+A,S=r.$max(0,d-x)+M,R=(m>0?r.$max(0,m-u):0)+A,w=(x>0?r.$max(0,x-d):0)+M),t._$bind(i),t._$applyBitmapFilter(h,y,E,s,n,C,S,l,$,R,w,!0,this.type,this.knockout,this._$strength,this.ratios,this.colors,this.alphas,0,0,0,0,0,0,0,0),t._$offsetX=a+C,t._$offsetY=o+S,t.frameBuffer.releaseTexture(h),t.frameBuffer.getTextureFromCurrentAttachment()}}class et{static toString(){return"[class TextFormatAlign]"}static get namespace(){return"next2d.text.TextFormatAlign"}toString(){return"[object TextFormatAlign]"}get namespace(){return"next2d.text.TextFormatAlign"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get RIGHT(){return"right"}}class it{static toString(){return"[class TextFieldAutoSize]"}static get namespace(){return"next2d.text.TextFieldAutoSize"}toString(){return"[object TextFieldAutoSize]"}get namespace(){return"next2d.text.TextFieldAutoSize"}static get CENTER(){return"center"}static get LEFT(){return"left"}static get NONE(){return"none"}static get RIGHT(){return"right"}}class rt extends T{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$selectable=!0,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0,this._$textColor=null;const t=new nt;t._$setDefault(this),this._$defaultTextFormat=t,this._$decisionTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict=null,this._$isHTML=!1,this._$textData=null,this._$renew=!0,this._$textHeight=null,this._$textWidth=null,this._$widthTable=null,this._$textarea=null,this._$autoSize=it.NONE,this._$autoFontSize=!1,this._$textAppending=!1,this._$heightTable=null,this._$textFormatTable=[],this._$textAreaActive=!1,this._$totalWidth=null,this._$objectTable=null,this._$imageData=null,this._$scroll=!1,this._$type=st.STATIC,this._$textHeightTable=null}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}static get TEXT(){return"text"}static get BREAK(){return"break"}static get WRAP(){return"wrap"}static get IMAGE(){return"image"}get autoFontSize(){return this._$autoFontSize}set autoFontSize(t){this._$autoFontSize=!!t}get autoSize(){return this._$autoSize}set autoSize(t){switch(t){case it.CENTER:case it.LEFT:case it.RIGHT:this._$autoSize=t;break;default:this._$autoSize=it.NONE}this._$reload()}get background(){return this._$background}set background(t){this._$background=!!t,this._$reset()}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){this._$backgroundColor=r.$clamp(r.$toColorInt(t),0,16777215,16777215),this._$reset()}get border(){return this._$border}set border(t){this._$border=!!t,this._$reset()}get borderColor(){return this._$borderColor}set borderColor(t){this._$borderColor=r.$clamp(r.$toColorInt(t),0,16777215,0),this._$reset()}get defaultTextFormat(){return this._$defaultTextFormat}set defaultTextFormat(t){t instanceof nt&&(t._$merge(this._$defaultTextFormat),t._$textField=this,this._$defaultTextFormat=t)}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=`${t}`,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable=[],this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1,this._$getTextData();const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=0,r=0;for(;t>r&&(i+=this._$textHeightTable[r],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){this._$multiline=!!t,this._$reset()}get numLines(){return null===this._$textData&&this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=`${t}`}get scroll(){return this._$scroll}set scroll(t){this._$scroll=!!t}get scrollH(){return this._$scrollH}set scrollH(t){t=r.$clamp(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger(a.SCROLL)&&this.dispatchEvent(new a(a.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){t=r.$clamp(0|t,1,this.maxScrollV),this._$scrollV!==t&&(this._$scrollV=t,this._$reset(),this.willTrigger(a.SCROLL)&&this.dispatchEvent(new a(a.SCROLL,!0)))}get selectable(){return this._$selectable}set selectable(t){this._$selectable=!!t}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData(),i=0|e.length;for(let r=1;r<i;++r){const i=e[r];switch(i.mode){case rt.TEXT:t+=i.text;break;case rt.BREAK:t+="\r"}}return!this._$isHTML&&this._$initText&&(t+="\r"),this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$cacheText="",this._$isHTML=!1,this._$textAppending||(this._$textFormatTable=[]),this._$reload())}get textColor(){return this._$defaultTextFormat.color}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(""===this.text)return 0;if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();let t=0|this._$decisionTextFormat._$leading;const e=this._$textHeightTable.length;1===e&&(this._$textHeight+=t);for(let t=0;t<e;++t)this._$textHeight+=this._$textHeightTable[t]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=r.$max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get type(){return this._$type}set type(t){(t+="")===st.STATIC?(this._$type=t,this._$textarea=null):this._$type=st.INPUT}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap=!!t}get width(){return super.width}set width(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this._$getBounds(null),i=r.$abs(e.xMin);this._$originBounds.xMax=t+i,this._$originBounds.xMin=i,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}}get height(){return super.height}set height(t){if(t=+t,!r.$isNaN(t)&&t>-1){const e=this._$getBounds(null),i=r.$abs(e.yMin);this._$originBounds.yMax=t+i,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this._$textAppending=!0,this.text=e+`${t}`,this._$textAppending=!1}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),r=e>-1?e:i.length;let s=!1,n=new nt,a=t>-1?t:0;for(;a<r;++a){if(i[a].mode===rt.BREAK)continue;const t=i[a].textFormat;s?(n._$align=n._$align!==t._$align?null:t._$align,n._$blockIndent=n._$blockIndent!==t._$blockIndent?null:t._$blockIndent,n._$bold=n._$bold!==t._$bold?null:t._$bold,n._$color=n._$color!==t._$color?null:t._$color,n._$font=n._$font!==t._$font?null:t._$font,n._$indent=n._$indent!==t._$indent?null:t._$indent,n._$italic=n._$italic!==t._$italic?null:t._$italic,n._$leading=n._$leading!==t._$leading?null:t._$leading,n._$leftMargin=n._$leftMargin!==t._$leftMargin?null:t._$leftMargin,n._$letterSpacing=n._$letterSpacing!==t._$letterSpacing?null:t._$letterSpacing,n._$rightMargin=n._$rightMargin!==t._$rightMargin?null:t._$rightMargin,n._$size=n._$size!==t._$size?null:t._$size,n._$underline=n._$underline!==t._$underline?null:t._$underline):(s=!0,n=t._$clone())}return n}getLineText(t){if(!this._$text&&!this._$htmlText)return"";t|=0;let e="";const i=this._$getTextData();for(let r=0;r<i.length;r++){const s=i[r];if(s.yIndex>t)break;s.yIndex===t&&(s.mode===rt.TEXT&&(e+=s.text))}return e}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const r=this.text;t>=r.length?e>=r.length&&e>=t&&(this.text=r+`${i}`):this.text=r.substr(0,t)+`${i}`+r.substr(e,r.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const r=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:{const e=r.length;for(let i=0;i<e;++i)this._$textFormatTable[i]=t._$clone()}break;case e>-1&&-1===i:{let i=e+1,s=r[i];s.mode===rt.WRAP&&(s=r[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let s=0;for(let n=e;n<i;++n){const e=r[n];e&&(e.mode!==rt.WRAP&&e.mode!==rt.BREAK?this._$textFormatTable[n+s]=t._$clone():(++i,--s))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(null===this._$textData){this._$textData=[],this._$imageData=[],this._$heightTable=[],this._$textHeightTable=[],this._$objectTable=[],this._$widthTable=[];let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),r.$P_TAG.innerHTML!==e&&(r.$P_TAG.textContent="",r.$P_TAG.insertAdjacentHTML("afterbegin",e));let s=this._$decisionTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}this._$totalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=this._$getTextHeight(s),this._$widthTable[0]=0;const n={mode:rt.BREAK,x:0,yIndex:0,textFormat:s._$clone()};this._$objectTable[0]=n,this._$textData[0]=n,this._$parseTag(r.$P_TAG,s._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")],i=e.length;for(let r=0;r<i;++r){this._$totalWidth=0;let i=this.defaultTextFormat;const s=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[s]=0,this._$textHeightTable[s]=this._$getTextHeight(i),this._$widthTable[s]=0,s&&(this._$heightTable[s]=this._$heightTable[s-1],this._$textHeightTable[s]=this._$textHeightTable[s-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(i),i=t}const n={mode:rt.BREAK,x:0,yIndex:s,textFormat:i._$clone()};i=this.defaultTextFormat,this._$objectTable[s]=n,this._$textData[this._$textData.length]=n;const a=e[r];a&&(t=this._$parseText(a,i,t))}}}return this._$textData}_$parseTag(t,e,i){const s=t.childNodes,n=s.length;for(let t=0;t<n;++t){let n=e._$clone();const a=s[t];if(3!==a.nodeType)switch(a.nodeName){case"P":{if(a.hasAttribute("align")&&(n._$align=a.getAttribute("align").toLowerCase()),this._$parseTag(a,n,i),!this._$multiline)break;this._$totalWidth=this._$getImageOffsetX();const t=this._$heightTable.length;if(this._$heightTable[t]=0,this._$textHeightTable[t]=0,this._$widthTable[t]=0,t&&(this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(n),n=t}const e={mode:rt.BREAK,x:0,yIndex:t,textFormat:n};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"B":n._$bold=!0,this._$parseTag(a,n,i);break;case"I":n._$italic=!0,this._$parseTag(a,n,i);break;case"U":n._$underline=!0,this._$parseTag(a,n,i);break;case"FONT":a.hasAttribute("face")&&(n._$font=a.getAttribute("face")),a.hasAttribute("size")&&(n._$size=0|a.getAttribute("size")),a.hasAttribute("color")&&(n._$color=r.$toColorInt(a.getAttribute("color"))),a.hasAttribute("letterSpacing")&&(n.letterSpacing=0|a.getAttribute("letterSpacing")),this._$parseTag(a,n,i);break;case"TEXTFORMAT":a.hasAttribute("blockindent")&&(n._$blockIndent=0|a.getAttribute("blockindent")),a.hasAttribute("indent")&&(n._$indent=0|a.getAttribute("indent")),a.hasAttribute("leading")&&(n._$leading=0|a.getAttribute("leading")),a.hasAttribute("leftmargin")&&(n._$leftMargin=0|a.getAttribute("leftmargin")),a.hasAttribute("rightmargin")&&(n._$rightMargin=0|a.getAttribute("rightmargin")),this._$parseTag(a,n,i);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0,this._$totalWidth=this._$getImageOffsetX(),n._$indent=0;const e={mode:rt.BREAK,x:0,yIndex:t,textFormat:n};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"IMG":{const t=a.getAttribute("src")||"",e=a.getAttribute("width")||0,i=a.getAttribute("height")||0,s=a.getAttribute("vspace")||0,o=a.getAttribute("hspace")||0;let h=0;for(let t=0;t<this._$textHeightTable.length;t++)h+=this._$textHeightTable[t];const l={mode:rt.IMAGE,src:t,loaded:!1,x:0,y:h,width:e,height:i,hspace:o,vspace:s,textFormat:n};if(this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],e=t.y+t.height+2*t.vspace;l.y=r.$max(h,e)}this._$textData[this._$textData.length]=l,this._$imageData[this._$imageData.length]=l,this._$loadImage(l)}break;default:this._$parseTag(a,n,i)}else i=this._$parseText(a.nodeValue,n)}}_$parseText(t,e,i){let s=this._$heightTable.length-1|0,n=e._$clone(),a=r.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0;const o=r.$currentPlayer();if(o){const t=o._$scale*o._$ratio;a=r.$getFloat32Array6(t,0,0,t,0,0)}const h=r.$multiplicationMatrix(this._$transform.concatenatedMatrix._$matrix,a),l=(this._$originBounds.xMax-this._$originBounds.xMin)*(h[0]/h[3]);r.$poolFloat32Array6(a),r.$poolFloat32Array6(h);const $=l-n._$widthMargin()-4;for(let a=0;a<t.length;++a){if(n=e._$clone(),this._$textData.length+i in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+i]._$clone();t._$merge(n),n=t}const o={mode:rt.TEXT,text:t[a],x:0,width:0,fontScale:0,yIndex:s,textFormat:n};let h=null;this._$multiline&&(h="\n"===o.text||"\r"===o.text||"\n\r"===o.text);let l=s?n._$leading:0,_=0,c=0,u=0,d=null;if(r.$textContext.font=n._$generateFontStyle(),_=r.$textContext.measureText(o.text).width+n._$letterSpacing,c=this._$getTextHeight(n),u=c+l,o.height=c,h||this._$wordWrap&&this._$totalWidth+_>$){this._$widthTable[++s]=0,o.yIndex=s,this._$heightTable[s]=this._$heightTable[s-1],this._$textHeightTable[s]=this._$textHeightTable[s-1],this._$totalWidth=this._$getImageOffsetX(),n=n._$clone(),n._$indent=0;d={mode:h?rt.BREAK:rt.WRAP,x:0,yIndex:s,textFormat:n},this._$objectTable[s]=d,h||--i;let t=o.text,e=0,a=!0;const $=/[0-9a-zA-Z?!;:.,]/g;for(;t.match($);){++e;const i=this._$textData[this._$textData.length-e];if(i.mode!==rt.TEXT){a=!1;break}t=i.text}if(e>1&&this._$textData[this._$textData.length-e+1].text.match(/[0-9a-zA-Z]/g)&&--e,e>0&&a){const t=this._$textData.length-e;this._$textData.splice(t,0,d);let i=1,n=this._$textData[t-i];for(this._$widthTable[s-1]=0,this._$heightTable[s-1]=0,this._$textHeightTable[s-1]=0;n.mode===rt.TEXT;)c=this._$getTextHeight(n.textFormat),u=c+l,this._$widthTable[s-1]+=n.width,this._$heightTable[s-1]=r.$max(this._$heightTable[s-1],c),this._$textHeightTable[s-1]=r.$max(this._$textHeightTable[s-1],u),++i,n=this._$textData[t-i];for(i=1;this._$textData.length>t+i;)n=this._$textData[t+i],++i,c=this._$getTextHeight(n.textFormat),u=c+l,this._$heightTable[s]=r.$max(this._$heightTable[s],c),this._$textHeightTable[s]=r.$max(this._$textHeightTable[s],u),n.x=this._$totalWidth,n.yIndex=s,this._$totalWidth+=n.width}else this._$textData[this._$textData.length]=d}h||(o.width=_,o.x=this._$totalWidth,this._$totalWidth+=_,this._$widthTable[s]=r.$max(this._$widthTable[s],this._$totalWidth),this._$heightTable[s]=r.$max(this._$heightTable[s],c),this._$textHeightTable[s]=r.$max(this._$textHeightTable[s],u),this._$textData[this._$textData.length]=o)}return i}_$getTextHeight(t){if(!r.$DIV){const t=r.$document.createElement("div");t.innerHTML="a",t.style.position="absolute",t.style.top="-9999px",t.style.left="-9999px",t.style.padding="0",t.style.margin="0",t.style.padding="0",t.style.border="0",t.style.outline="0",t.style.verticalAlign="bottom",t.style.lineHeight="100%",r.$DIV=t,r.$document.body.appendChild(r.$DIV)}const e=r.$DIV.style;return e.fontSize=`${t._$size}px`,e.fontFamily=t._$font,e.fontWeight=t._$bold?"bold":"normal",r.$DIV.clientHeight}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],r=i.height+2*i.vspace;if(i.y<=t&&t<i.y+r)return i.width+2*i.hspace}return 0}_$reset(){this._$renew=!0,this._$textData=null,this._$imageData=null,this._$textHeight=null,this._$textWidth=null,this._$heightTable=null,this._$textHeightTable=null,this._$widthTable=null,this._$objectTable=null,this._$totalWidth=null,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),r.$isUpdated=!0,r.$cacheStore().removeCache(this._$instanceId)}_$reload(){this._$reset(),this._$getTextData(),this._$resize()}_$resize(){if(this._$autoSize!==it.NONE){const t=this._$defaultTextFormat,e=this.textWidth+4+t._$leftMargin+t._$rightMargin;if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case it.LEFT:case it.CENTER:this._$bounds.xMax=e+this._$bounds.xMin;break;case it.RIGHT:this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}}_$getAlignOffset(t,e){const i=this._$widthTable[t.yIndex],s=t.textFormat,n=s._$blockIndent+s._$leftMargin>0?s._$blockIndent+s._$leftMargin:0;switch(!0){case!1===this._$wordWrap&&i>e:return r.$max(0,n);case s._$align===et.CENTER:case this._$autoSize===it.CENTER:return r.$max(0,e/2-n-s._$rightMargin-i/2);case s._$align===et.RIGHT:case this._$autoSize===it.RIGHT:return r.$max(0,e-n-i-s._$rightMargin-2);default:return r.$max(0,n+2)}}_$getBounds(t=null){if(t){const e=r.$multiplicationMatrix(t,this._$correctMatrix(this._$transform._$rawMatrix()));return r.$boundsMatrix(this._$bounds,e)}return r.$boundsMatrix(this._$bounds,this._$correctMatrix(r.$MATRIX_ARRAY_IDENTITY))}_$correctMatrix(t){switch(this._$autoSize){case it.CENTER:{const e=this.textWidth+4,i=(this._$originBounds.xMax-this._$originBounds.xMin)/2-e/2;return r.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}case it.RIGHT:{const e=this.textWidth+4,i=this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin);return r.$getFloat32Array6(t[0],t[1],t[2],t[3],t[4]+i,t[5])}default:return t}}_$build(t,e){const i=super._$build(t,e),r=this.defaultTextFormat;switch(r.font=i.font,r.size=i.size,r.align=i.align,r.color=i.color,r.leading=i.leading,r.letterSpacing=i.letterSpacing,r.leftMargin=i.leftMargin,r.rightMargin=i.rightMargin,i.fontType){case 1:r.bold=!0;break;case 2:r.italic=!0;break;case 3:r.bold=!0,r.italic=!0}switch(this._$type=i.inputType,this._$multiline=i.multiline,this._$wordWrap=i.wordWrap,this._$border=i.border,this._$scroll=i.scroll,this._$bounds.xMin=i.originBounds.xMin,this._$bounds.xMax=i.originBounds.xMax,this._$bounds.yMin=i.originBounds.yMin,this._$bounds.yMax=i.originBounds.yMax,this._$originBounds.xMin=i.originBounds.xMin,this._$originBounds.xMax=i.originBounds.xMax,this._$originBounds.yMin=i.originBounds.yMin,this._$originBounds.yMax=i.originBounds.yMax,i.autoSize){case 1:this.autoSize=i.align;break;case 2:this.autoFontSize=!0}this.text=i.text}_$clip(t,e){const i=this._$getBounds(),s=i.xMax,n=i.xMin,a=i.yMax,o=i.yMin;r.$poolBoundsObject(i);let h=r.$ceil(r.$abs(s-n)),l=r.$ceil(r.$abs(a-o));if(!h||!l)return;let $=e;const _=this._$transform._$rawMatrix();_!==r.$MATRIX_ARRAY_IDENTITY&&($=r.$multiplicationMatrix(e,_)),r.$resetContext(t),t.setTransform($[0],$[1],$[2],$[3],$[4],$[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(h,0),t.lineTo(h,l),t.lineTo(0,l),t.lineTo(0,0),t.clip(!0),$!==e&&r.$poolFloat32Array6($)}_$draw(t,e,i){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let s=i;const n=this._$transform._$rawColorTransform();n!==r.$COLOR_ARRAY_IDENTITY&&(s=r.$multiplicationColor(i,n));const a=r.$clamp(s[3]+s[7]/255,0,1);if(!a)return;let o=e;const h=this._$transform._$rawMatrix();h!==r.$MATRIX_ARRAY_IDENTITY&&(o=r.$multiplicationMatrix(e,h));const l=this._$getBounds(null),$=r.$boundsMatrix(l,o),_=+$.xMax,c=+$.xMin,u=+$.yMax,d=+$.yMin;r.$poolBoundsObject($),r.$poolBoundsObject(l);let g=r.$ceil(r.$abs(_-c)),f=r.$ceil(r.$abs(u-d));if(!g||!f)return;if(0>c+g||0>d+f)return;const p=t.frameBuffer.currentAttachment;if(c>p.width||d>p.height)return;const m=+r.$sqrt(o[0]*o[0]+o[1]*o[1]),x=+r.$sqrt(o[2]*o[2]+o[3]*o[3]),b=r.$getArray();b[0]=m,b[1]=x;const T=r.$cacheStore(),v=T.generateKeys(this._$instanceId,b,s);let y=T.get(v);if(y&&(this._$renew||this._$isUpdated())&&(T.set(v,null),T.destroy(y),y=null),g+=4*r.$devicePixelRatio,f+=4*r.$devicePixelRatio,!y){this._$renew=!1,s[3]=1;const i=T.getCanvas();i.width=g,i.height=f;const n=i.getContext("2d");if(this._$background||this._$border){if(n.beginPath(),n.rotate(r.$atan2(e[1],e[0])),n.moveTo(0,0),n.lineTo(g,0),n.lineTo(g,f),n.lineTo(0,f),n.lineTo(0,0),this._$background){const t=r.$generateColorTransform(r.$intToRGBA(this._$backgroundColor),s);n.fillStyle=`rgba(${t.R},${t.G},${t.B},${t.A})`,n.fill()}if(this._$border){const t=r.$generateColorTransform(r.$intToRGBA(this._$borderColor),s);n.lineWidth=1,n.strokeStyle=`rgba(${t.R},${t.G},${t.B},${t.A})`,n.stroke()}}n.save(),n.beginPath();const a=r.$atan2(e[1],e[0]);a&&n.rotate(a),n.moveTo(2,2),n.lineTo(g-2,2),n.lineTo(g-2,f-2),n.lineTo(2,f-2),n.lineTo(2,2),n.clip(),n.beginPath(),n.setTransform(e[0],e[1],e[2],e[3],0,0),this._$doDraw(n,e,s,!1,g/e[0]),n.restore(),y=t.frameBuffer.createTextureFromCanvas(n.canvas),T.set(v,y),T.destroy(n)}r.$poolArray(v),r.$poolArray(b);let E=!1,A=0,M=0;const C=this._$filters||this.filters;if(C&&C.length){const s=this._$canApply(C);if(s){E=!0;const n=[this._$instanceId,"f"];let a=r.$cacheStore().get(n);const o=this._$isFilterUpdated(g,f,e,i,C,s);a&&!o||(a&&(r.$cacheStore().set(n,null),a.layerWidth=0,a.layerHeight=0,a._$offsetX=0,a._$offsetY=0,a.matrix=null,a.colorTransform=null,t.frameBuffer.releaseTexture(a),a=null),y=this._$getFilterTexture(t,C,y,e,i),r.$cacheStore().set(n,y)),a&&(y=a),r.$poolArray(n),A=y._$offsetX,M=y._$offsetY}}r.$resetContext(t),t._$globalAlpha=a,t._$globalCompositeOperation=this._$blendMode||this.blendMode,t.setTransform(1,0,0,1,0,0),E?t.drawImage(y,c-A,d-M,y.width,y.height,s):t.drawImage(y,c,d,g,f,s)}_$doDraw(t,e,i,s,n){const a=this._$getTextData(),o=s?0:this.width,h=s?0:this.height;let l=0,$=0,_=0;const c=a.length;for(let u=0;u<c;++u){let c=a[u];if(0===c.width)continue;const d=l+c.x;if(!s&&this._$autoSize===it.NONE&&($>h||d>o))continue;let g=c.textFormat;if(!s){const e=r.$generateColorTransform(r.$intToRGBA(c.textFormat._$color),i);t.fillStyle=`rgba(${e.R},${e.G},${e.B},${e.A})`}const f=0|c.yIndex;switch(c.mode){case rt.BREAK:case rt.WRAP:if(_++,this.scrollV>_)continue;if($+=this._$textHeightTable[f],l=this._$getAlignOffset(this._$objectTable[f],n),g._$underline){const s=c.textFormat._$size/12,n=r.$generateColorTransform(r.$intToRGBA(g._$color),i);t.lineWidth=r.$max(1,1/r.$min(e[0],e[3])),t.strokeStyle=`rgba(${n.R},${n.G},${n.B},${n.A})`,t.beginPath(),t.moveTo(l,$-s),t.lineTo(l+this._$widthTable[f],$-s),t.stroke()}break;case rt.TEXT:{if(this.scrollV>_)continue;let e=$-this._$heightTable[0];r.$isSafari||(e+=c.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=g._$generateFontStyle(),t.fillText(c.text,d,e)}break;case rt.IMAGE:if(!c.loaded)continue;t.beginPath(),t.drawImage(c.image,c.x,c.y,c.width,c.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let s=e;const n=this._$transform._$rawMatrix();n!==r.$MATRIX_ARRAY_IDENTITY&&(s=r.$multiplicationMatrix(e,n));const a=this._$getBounds(null),o=r.$boundsMatrix(a,s),h=+o.xMax,l=+o.xMin,$=+o.yMax,_=+o.yMin;r.$poolBoundsObject(o),r.$poolBoundsObject(a);const c=r.$ceil(r.$abs(h-l)),u=r.$ceil(r.$abs($-_));return t.setTransform(1,0,0,1,l,_),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,u),t.lineTo(0,u),t.lineTo(0,0),s!==e&&r.$poolFloat32Array6(s),t.isPointInPath(i.x,i.y)}}class st{static toString(){return"[class TextFieldType]"}static get namespace(){return"next2d.text.TextFieldType"}toString(){return"[object TextFieldType]"}get namespace(){return"next2d.text.TextFieldType"}static get INPUT(){return"input"}static get STATIC(){return"static"}}class nt{constructor(t=null,e=null,i=null,r=null,s=null,n=null,a=null,o=null,h=null,l=null,$=null,_=null){this._$font=t,this._$size=e,this._$color=i,this._$bold=r,this._$italic=s,this._$underline=n,this._$align=a,this._$leftMargin=o,this._$rightMargin=h,this._$indent=l,this._$leading=$,this._$blockIndent=_,this._$letterSpacing=0,this._$textField=null}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){switch(t){case et.CENTER:case et.RIGHT:case et.LEFT:this._$align=t;break;default:this._$align=null}this._$textField&&(this._$textField._$renew=!0)}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t,this._$textField&&(this._$textField._$renew=!0)}get bold(){return this._$bold}set bold(t){this._$bold=!!t,this._$textField&&(this._$textField._$renew=!0)}get color(){return this._$color}set color(t){this._$color=r.$clamp(r.$toColorInt(t),0,16777215,0),this._$textField&&(this._$textField._$renew=!0)}get font(){return this._$font}set font(t){this._$font=`${t}`,this._$textField&&(this._$textField._$renew=!0)}get indent(){return this._$indent}set indent(t){this._$indent=t,this._$textField&&(this._$textField._$renew=!0)}get italic(){return this._$italic}set italic(t){this._$italic=!!t,this._$textField&&(this._$textField._$renew=!0)}get leading(){return this._$leading}set leading(t){this._$leading=t,this._$textField&&(this._$textField._$renew=!0)}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t,this._$textField&&(this._$textField._$renew=!0)}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t,this._$textField&&(this._$textField._$renew=!0)}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t,this._$textField&&(this._$textField._$renew=!0)}get size(){return this._$size}set size(t){this._$size=0|t,this._$textField&&(this._$textField._$renew=!0)}get underline(){return this._$underline}set underline(t){this._$underline=!!t,this._$textField&&(this._$textField._$renew=!0)}_$clone(){const t=new nt(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t._$textField=this._$textField,t}_$setDefault(t=null){this._$align=et.LEFT,this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="Times New Roman",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1,this._$textField=t}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t.color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){return this._$indent+this._$leftMargin+this._$rightMargin}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','system-ui','sans-serif'`}}class at extends o{constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$buffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=r.$getArray(),this._$volume=1,this._$loop=!1}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=r.$min(ot.volume,r.$clamp(t,0,1,1));const e=this._$sources.length;if(e&&r.$audioContext)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume}}clone(){const t=new at;return t.volume=this.volume,t.loop=this.loop,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){r.$ajax({format:ut.ARRAY_BUFFER,url:t.url,method:t.method,data:t.data,headers:t.headers,credentials:t.withCredentials,event:{loadstart:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(a.OPEN)&&this.dispatchEvent(new a(a.OPEN)),this.willTrigger(u.PROGRESS)&&this.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),progress:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(u.PROGRESS)&&this.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total))}.bind(this),loadend:function(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(u.PROGRESS)&&this.dispatchEvent(new u(u.PROGRESS,!1,!1,t.loaded,t.total)),199<t.target.status&&400>t.target.status?(this._$buffer=new Uint8Array(t.target.response),r.$audioContext?r.$decodeAudioData(this):r.$audios.push(this),r.$currentPlayer()._$loaders.push(this)):this.willTrigger(_.IO_ERROR)&&this.dispatchEvent(new _(_.IO_ERROR,!1,!1,t.target.statusText,t.target.status))}.bind(this)}})}play(t=0){const e=this._$character?this._$character.audioBuffer:this._$audioBuffer;if(r.$audioContext&&e)this._$createBufferSource(t);else{const e=function(t,i=0){if(null!==(this._$character?this._$character.audioBuffer:this._$audioBuffer)&&null!==r.$audioContext){const e=(r.$performance.now()-t)/1e3;return void this._$createBufferSource(i,e)}(0,r.$requestAnimationFrame)(e)}.bind(this,r.$performance.now(),t);(0,r.$requestAnimationFrame)(e)}}stop(){const t=this._$sources.length;if(t){if(r.$audioContext){const e=r.$currentPlayer();for(let i=0;i<t;++i){const t=this._$sources[i];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect(),e._$sources.splice(e._$sources.indexOf(t),1)}}this._$sources.length=0}}_$build(t,e){this._$character=e._$loaderInfo._$data.characters[t.characterId],this._$character.init||(this._$character.init=!0,this._$character.buffer=new Uint8Array(this._$character.buffer),r.$audioContext?r.$decodeAudioData(this):r.$audios.push(this)),this._$loop=t.loop,this._$volume=r.$min(ot.volume,t.volume)}_$createBufferSource(t=0,e=0){const i=r.$audioContext.createBufferSource();i._$startTime=t,i.onended=this._$endEventHandler.bind(this),i.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,i._$gainNode=r.$audioContext.createGain(),i._$gainNode.connect(r.$audioContext.destination);const s=r.$min(ot.volume,this._$volume);i._$gainNode.gain.value=s,i._$volume=s,i.connect(i._$gainNode),i.start(0|t,e);r.$currentPlayer()._$sources.push(i),this._$sources.push(i)}_$endEventHandler(t){const e=t.target;this._$sources.splice(this._$sources.indexOf(e),1);const i=r.$currentPlayer();i._$sources.splice(i._$sources.indexOf(e),1),this._$loop?this._$createBufferSource():(r.$audioContext&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),this.willTrigger(a.SOUND_COMPLETE)&&this.dispatchEvent(new a(a.SOUND_COMPLETE)))}}class ot{static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static get volume(){return r.$soundMixerVolume}static set volume(t){r.$soundMixerVolume=r.$clamp(t,0,1,1);const e=r.$currentPlayer()._$sources;for(let t=0;t<e.length;++t){const i=e[t];i._$gainNode.gain.value=r.$min(r.$soundMixerVolume,i._$volume)}const i=r.$currentPlayer()._$videos;for(let t=0;t<i.length;++t){const e=i[t];e._$video.volume=r.$min(e.volume,r.$soundMixerVolume)}}static stopAll(){const t=r.$currentPlayer()._$sounds;for(let e=0;e<t.length;++e)t[e].stop();const e=r.$currentPlayer()._$videos;for(let t=0;t<e.length;++t)e[t].pause()}}class ht{constructor(t=1,e=!1){this._$volume=1,this._$loop=!1,this.volume=t,this.loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=!!t}get volume(){return this._$volume}set volume(t){this._$volume=r.$clamp(+t,0,1,0)}}class lt extends b{constructor(t=320,e=240){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=r.$getBoundsObject(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$stop=!0,this._$wait=!1,this._$volume=1}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=!!t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video?(this._$video.removeEventListener("canplaythrough",this._$start),this._$video.addEventListener("canplaythrough",this._$start)):this._$initializeVideo(),this._$video.src=t,this._$video.load()}get videoHeight(){return this._$bounds.yMax}get videoWidth(){return this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=r.$min(ot.volume,r.$clamp(t,0,1,1)),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$texture&&r.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$video&&this._$video.pause(),this._$start=null,this._$update=null,this._$sound=null,this._$video=null,this._$texture=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause();(0,r.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(r.$currentPlayer()._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),this.dispatchEvent(new d(d.PAUSE),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=r.$currentPlayer();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){if(this._$video&&this._$stop){this._$stop=!1,this._$video.volume=r.$min(this._$volume,ot.volume),this._$video.play();const t=r.$requestAnimationFrame;this._$timerId=t(this._$update),this.dispatchEvent(new d(d.PLAY),!1,!1,this._$bytesLoaded,this._$bytesTotal);const e=r.$currentPlayer();-1===e._$videos.indexOf(this)&&e._$videos.push(this)}}seek(t){this._$video&&(this._$video.currentTime=t,this.dispatchEvent(new d(d.SEEK),!1,!1,this._$bytesLoaded,this._$bytesTotal))}_$initializeVideo(){this._$video=r.$document.createElement("video"),this._$update=function(){const t=r.$currentPlayer();if(!this._$stage){this._$video.pause();return(0,r.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1,this._$texture&&(t._$context.frameBuffer.releaseTexture(this._$texture),this._$texture=null),void t._$videos.splice(t._$videos.indexOf(this),1)}t._$draw(0),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this._$texture=t._$context.frameBuffer.createTextureFromVideo(this._$video,this._$smoothing,this._$texture),this.dispatchEvent(new d(d.PROGRESS),!1,!1,this._$bytesLoaded,this._$bytesTotal),this._$doChanged());const e=r.$requestAnimationFrame;this._$timerId=e(this._$update)}.bind(this),this._$sound=function(){const t=r.$isTouch?r.$TOUCH_END:r.$MOUSE_UP;r.$currentPlayer()._$canvas.removeEventListener(t,this._$sound),this._$video.muted=!1}.bind(this),this._$video.muted=!0,this._$video.autoplay=!1,this._$video.crossOrigin="anonymous",this._$video.type="video/mp4",r.$isTouch&&this._$video.setAttribute("playsinline",""),this._$start=function(){if(this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration,r.$audioContext)this._$video.muted=!1;else{const t=r.$isTouch?r.$TOUCH_END:r.$MOUSE_UP;r.$currentPlayer()._$canvas.addEventListener(t,this._$sound)}if(this._$autoPlay){const t=r.$currentPlayer();-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$wait=!0,this._$doChanged()}}.bind(this),this._$video.addEventListener("canplaythrough",this._$start),this._$video.addEventListener("ended",function(){if(this._$loop)return void(this._$video.currentTime=0);this.dispatchEvent(new d(d.PLAY_END),!1,!1,this._$bytesLoaded,this._$bytesTotal);(0,r.$cancelAnimationFrame)(this._$timerId),this._$timerId=-1}.bind(this))}_$build(t,e){const i=super._$build(t,e);this._$loop=i.loop,this._$autoPlay=i.autoPlay,this._$bounds=i.bounds,this._$video||this._$initializeVideo(),this._$video.src=URL.createObjectURL(new Blob([new Uint8Array(i.buffer)],{type:"video/mp4"})),this._$video.volume=r.$min(i.volume,ot.volume),this._$video.load()}_$clip(t,e){let i=this._$bounds.xMax,s=this._$bounds.yMax;if(!i||!s)return;let n=e;const a=this._$transform._$rawMatrix();a!==r.$MATRIX_ARRAY_IDENTITY&&(n=r.$multiplicationMatrix(e,a)),r.$resetContext(t),t.setTransform(n[0],n[1],n[2],n[3],n[4],n[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(!0),n!==e&&r.$poolFloat32Array6(n)}_$draw(t,e,i){if(!this._$visible)return;if(this._$wait){this._$stop=!1,this._$video.play(),this.dispatchEvent(new d(d.PLAY_START),!1,!1,this._$bytesLoaded,this._$bytesTotal);const t=r.$requestAnimationFrame;this._$timerId=t(this._$update),this._$wait=!1}if(!this._$texture)return;let s=i;const n=this._$transform._$rawColorTransform();n!==r.$COLOR_ARRAY_IDENTITY&&(s=r.$multiplicationColor(i,n));const a=r.$clamp(s[3]+s[7]/255,0,1,0);if(!a)return void(s!==i&&r.$poolFloat32Array8(s));let o=e;const h=this._$transform._$rawMatrix();h!==r.$MATRIX_ARRAY_IDENTITY&&(o=r.$multiplicationMatrix(e,h));const l=r.$boundsMatrix(this._$bounds,o),$=+l.xMax,_=+l.xMin,c=+l.yMax,u=+l.yMin;r.$poolBoundsObject(l);let g=r.$ceil(r.$abs($-_)),f=r.$ceil(r.$abs(c-u));if(!g||!f)return;let p=this._$texture,m=0,x=0;const b=this._$filters||this.filters;if(b&&b.length){const s=this._$canApply(b);if(s){const n=[this._$instanceId,"f"];let a=r.$cacheStore().get(n);const o=this._$isFilterUpdated(g,f,e,i,b,s);a&&!o||(a&&(r.$cacheStore().set(n,null),a.layerWidth=0,a.layerHeight=0,a._$offsetX=0,a._$offsetY=0,a.matrix=null,a.colorTransform=null,t.frameBuffer.releaseTexture(a),a=null),p=this._$getFilterTexture(t,b,this._$texture,e,i),r.$cacheStore().set(n,p)),a&&(p=a),r.$poolArray(n),m=p._$offsetX,x=p._$offsetY}}r.$resetContext(t),t._$globalAlpha=a,t._$imageSmoothingEnabled=this._$smoothing,t._$globalCompositeOperation=this._$blendMode||this.blendMode,t.setTransform(o[0],o[1],o[2],o[3],o[4],o[5]),t.drawImage(p,-m,-x,p.width,p.height,s)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i){let s=e;const n=this._$transform._$rawMatrix();n!==r.$MATRIX_ARRAY_IDENTITY&&(s=r.$multiplicationMatrix(e,n));const a=this._$getBounds(null),o=r.$boundsMatrix(a,s),h=+o.xMax,l=+o.xMin,$=+o.yMax,_=+o.yMin;r.$poolBoundsObject(o),r.$poolBoundsObject(a);const c=r.$ceil(r.$abs(h-l)),u=r.$ceil(r.$abs($-_));return t.setTransform(1,0,0,1,l,_),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,u),t.lineTo(0,u),t.lineTo(0,0),s!==e&&r.$poolFloat32Array6(s),t.isPointInPath(i.x,i.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();i!==r.$MATRIX_ARRAY_IDENTITY&&(e=r.$multiplicationMatrix(t,i));const s=r.$boundsMatrix(this._$bounds,e);return e!==t&&r.$poolFloat32Array6(e),s}return r.$getBoundsObject(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}}class $t{static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,r){return t/r*i+e}static inQuad(t,e,i,r){return(t/=r)*t*i+e}static outQuad(t,e,i,r){return-(t/=r)*(t-2)*i+e}static inOutQuad(t,e,i,r){return(t/=r/2)<1?t*t*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,r){return(t/=r)*t*t*i+e}static outCubic(t,e,i,r){return t/=r,(--t*t*t+1)*i+e}static inOutCubic(t,e,i,r){return(t/=r/2)<1?t*t*t*i/2+e:((t-=2)*t*t+2)*i/2+e}static inQuart(t,e,i,r){return(t/=r)*t*t*t*i+e}static outQuart(t,e,i,r){return t/=r,(--t*t*t*t-1)*-i+e}static inOutQuart(t,e,i,r){return(t/=r/2)<1?t*t*t*t*i/2+e:((t-=2)*t*t*t-2)*-i/2+e}static inQuint(t,e,i,r){return(t/=r)*t*t*t*t*i+e}static outQuint(t,e,i,r){return t/=r,(--t*t*t*t*t+1)*i+e}static inOutQuint(t,e,i,r){return(t/=r/2)<1?t*t*t*t*t*i/2+e:((t-=2)*t*t*t*t+2)*i/2+e}static inSine(t,e,i,r){return-i*Math.cos(t/r*(Math.PI/2))+i+e}static outSine(t,e,i,r){return i*Math.sin(t/r*(Math.PI/2))+e}static inOutSine(t,e,i,r){return-i/2*(Math.cos(Math.PI*t/r)-1)+e}static inExpo(t,e,i,r){return i*Math.pow(2,10*(t/r-1))+e}static outExpo(t,e,i,r){return i*(1-Math.pow(2,-10*t/r))+e}static inOutExpo(t,e,i,r){return(t/=r/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*(t-1)))+e}static inCirc(t,e,i,r){return(1-Math.sqrt(1-(t/=r)*t))*i+e}static outCirc(t,e,i,r){return t/=r,Math.sqrt(1- --t*t)*i+e}static inOutCirc(t,e,i,r){return(t/=2*r)<1?(Math.sqrt(1-t*t)-1)/-2*i+e:(Math.sqrt(1-(t-=2)*t)+1)/2*i+e}static inBack(t,e,i,r){return(2.70158*(t/=r)*t*t-1.70158*t*t)*i+e}static outBack(t,e,i,r){return(1+2.70158*Math.pow((t/=r)-1,3)+1.70158*Math.pow(t-1,2))*i+e}static inOutBack(t,e,i,r){let s=1.70158;return(t/=r/2)<1?t*t*((1+(s*=1.525))*t-s)*i/2+e:((t-=2)*t*((1+(s*=1.525))*t+s)+2)*i/2+e}static inElastic(t,e,i,r){return 0==(t/=r)?e:1===t?i+e:-Math.pow(2,(t*=10)-10)*Math.sin((t-10.75)*(2*Math.PI/3))*i+e}static outElastic(t,e,i,r){return 0==(t/=r)?e:1===t?i+e:(Math.pow(2,-10*t)*Math.sin((10*t-.75)*(2*Math.PI/3))+1)*i+e}static inOutElastic(t,e,i,r){return 0==(t/=r)?e:1===t?i+e:t<.5?-Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2*i+e:(Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*(2*Math.PI/4.5))/2+1)*i+e}static outBounce(t,e,i,r){return(t/=r)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,r){return i-$t.outBounce(r-t,0,i,r)+e}static inOutBounce(t,e,i,r){return t<r/2?$t.inBounce(2*t,e,i/2,r):$t.outBounce(2*t-r,e+i/2,i/2,r)}}class _t extends o{constructor(t,e=null,i=null,r=0,s=1,n=null){super(),this._$target=t,this._$delay=r,this._$duration=s,this._$ease=n||$t.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$to=i,this._$update=null}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$stopFlag=!1,this._$startTime=r.$performance.now(),this._$update=this.update.bind(this),this._$names=this.entries(this._$from),this.addEventListener(a.ENTER_FRAME,this._$update)}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],r=i[1];r&&"object"==typeof r&&(i[1]=this.entries(r))}return e}start(){if(this._$delay){(0,r.$setTimeout)(function(){this.initialize()}.bind(this),1e3*this._$delay)}else this.initialize()}stop(){this._$stopFlag=!0,this.removeEventListener(a.ENTER_FRAME,this._$update),this.hasEventListener(a.STOP)&&this.dispatchEvent(new a(a.STOP))}update(){this._$stopFlag?this.removeEventListener(a.ENTER_FRAME,this._$update):(this._$currentTime=.001*(r.$performance.now()-this._$startTime),this.updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener(a.UPDATE)&&this.dispatchEvent(new a(a.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener(a.ENTER_FRAME,this._$update),this.hasEventListener(a.COMPLETE)&&this.dispatchEvent(new a(a.COMPLETE))))}updateProperty(t,e,i,r){for(let s=0;s<r.length;++s){const n=r[s],a=n[0],o=n[1];if(o&&"object"==typeof o){this.updateProperty(t[a],e[a],i[a],o);continue}const h=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,h,i[a]-h,this._$duration):t[a]=i[a]}}}class ct{static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,r=0,s=1,n=null){return new _t(t,e,i,r,s,n)}}class ut{static toString(){return"[class URLLoaderDataFormat]"}static get namespace(){return"next2d.net.URLLoaderDataFormat"}toString(){return"[object URLLoaderDataFormat]"}get namespace(){return"next2d.net.URLLoaderDataFormat"}static get ARRAY_BUFFER(){return"arraybuffer"}static get JSON(){return"json"}}class dt{constructor(t=""){this._$url=t,this._$contentType="application/json",this._$data=null,this._$method=ft.GET,this._$requestHeaders=r.$getArray(),this._$userAgent=r.$navigator.userAgent,this._$responseDataFormat=ut.JSON,this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){switch((t+="").toUpperCase()){case ft.DELETE:case ft.HEAD:case ft.OPTIONS:case ft.POST:case ft.PUT:this._$method=t;break;default:this._$method=ft.GET}}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){r.$isArray(t)&&(this._$requestHeaders=t)}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=r.$currentPlayer();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get userAgent(){return this._$userAgent}get responseDataFormat(){return this._$responseDataFormat}set responseDataFormat(t){this._$responseDataFormat=`${t}`}get withCredentials(){return this._$withCredentials}get headers(){const t={"Content-Type":`${this._$contentType}`},e=this._$requestHeaders.length;for(let i=0;i<e;++i){const e=this._$requestHeaders[i];e instanceof gt&&(t[e.name]=e.value)}return t}}class gt{constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}get value(){return this._$value}}class ft{static toString(){return"[class URLRequestMethod]"}static get namespace(){return"next2d.net.URLRequestMethod"}toString(){return"[object URLRequestMethod]"}get namespace(){return"next2d.net.URLRequestMethod"}static get DELETE(){return"DELETE"}static get GET(){return"GET"}static get HEAD(){return"HEAD"}static get OPTIONS(){return"OPTIONS"}static get POST(){return"POST"}static get PUT(){return"PUT"}}class pt{constructor(){this._$pool=r.$getArray(),this._$store=r.$getMap(),this._$lifeCount=2,this._$delayLifeCheck=this.lifeCheck.bind(this);(0,r.$setTimeout)(this._$delayLifeCheck,5e3)}reset(){const t=this._$store.values();for(const e of t){const t=e.values();for(const e of t)this.destroy(e);r.$poolMap(e)}this._$store.clear()}destroy(t){if(t)switch(t.constructor){case r.$WebGLTexture:{const e=r.$currentPlayer(),i=t._$bitmapData;i&&(i._$buffer=i._$getPixels(0,0,i.width,i.height,"RGBA"),delete t._$bitmapData),e._$context&&e._$context.frameBuffer.releaseTexture(t)}break;case r.$CanvasRenderingContext2D:{const e=t.canvas,i=e.width,r=e.height;t.clearRect(0,0,i+1,r+1),e.width=e.height=1,this._$pool.push(e)}}}getCanvas(){return this._$pool.pop()||r.$document.createElement("canvas")}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t),i=e.values();for(const t of i)this.destroy(t);r.$poolMap(e),this._$store.delete(t)}}generateLifeKey(t,e){return`${t}:${e}`}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){const t=this._$store.get(e);if(t.has(i)){const e=`life_${i}`;return 1===t.has(e)&&t.set(e,this._$lifeCount),t.get(i)}}return null}set(t,e){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,r.$getMap());const n=this._$store.get(i);if(!e)return n.delete(s),n.delete(`life_${s}`),void(n.size||(r.$poolMap(n),this._$store.delete(i)));const a=n.get(s);a&&a!==e&&this.destroy(a),n.set(s,e),n.set(`life_${s}`,this._$lifeCount)}generateShapeKeys(t,e,i=null){let s="";switch(!0){case 1!==e[0]:case 0!==e[1]:case 0!==e[2]:case 1!==e[3]:s=`${e[0]}_${e[1]}_${e[2]}_${e[3]}`}i&&(s+=this.colorToString(i));const n=r.$getArray();return n[0]=`${t}`,n[1]=s?this.generateHash(s):"_0",n}generateKeys(t,e=null,i=null){let s="";e&&(s+=`${e[0]}_${e[1]}`),i&&(s+=this.colorToString(i));const n=r.$getArray();return n[1]=s?this.generateHash(s):"_0",n[0]=`${t}`,n}colorToString(t=null){switch(!0){case 1!==t[0]:case 1!==t[1]:case 1!==t[2]:case 0!==t[4]:case 0!==t[5]:case 0!==t[6]:case 0!==t[7]:return`_${t[0]}_${t[1]}_${t[2]}_${t[4]}_${t[5]}_${t[6]}_${t[7]}`;default:return""}}generateHash(t){let e=0;const i=t.length;for(let r=0;r<i;r++){e=(e<<5)-e+t.charCodeAt(r),e|=0}return`_${e}`}lifeCheck(){for(const[t,e]of this._$store){for(const[t,i]of e){const r=`life_${t}`,s=e.get(r)-1;s?e.set(r,s):(this.destroy(i),e.delete(t),e.delete(`life_${t}`))}e.size||(r.$poolMap(e),this._$store.delete(t))}(0,r.$setTimeout)(this._$delayLifeCheck,5e3)}}class mt{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n`}}class xt{static SOLID_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n`}static BITMAP_CLIPPED(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${mt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static BITMAP_PATTERN(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = ${t.texture2D()}(u_texture, uv);\n    ${mt.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    ${t.fragColor()} = src;\n}`}static MASK(t){return`${t.version()}\n${t.extensionDerivatives()}\nprecision mediump float;\n\n${t.varyingIn()} vec2 v_bezier;\n${t.outColor()}\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        ${t.fragColor()} = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n`}}class bt{static FILL_COLOR(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = u_mediump;\n}\n\n`}static COPY_SRC_TEX(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    ${t.fragColor()} = ${t.texture2D()}(u_src_tex, v_src_tex_coord);\n}\n\n`}static COPY_CHANNEL(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_ch = u_mediump[0];\n    vec4 dst_ch = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    // src_color \n    float src_value = dot(src_color, src_ch);\n\n    // \n    vec4 mixed = mix(dst_color, vec4(src_value), dst_ch);\n\n#if ${t}\n    ${e.fragColor()} = vec4(mixed.rgb * mixed.a, mixed.a);\n#else\n    ${e.fragColor()} = vec4(mixed.rgb, 1.0);\n#endif\n}\n\n`}static MERGE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.varyingIn()} vec2 v_dst_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    vec4 dst_color = ${e.texture2D()}(u_textures[1], v_dst_tex_coord);\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);\n\n    vec4 merged = mix(dst_color, src_color, u_mediump);\n\n#if ${t}\n    ${e.fragColor()} = vec4(merged.rgb * merged.a, merged.a);\n#else\n    ${e.fragColor()} = vec4(merged.rgb, 1.0);\n#endif\n}\n\n`}static COPY_PIXELS_WITH_ALPHA_BITMAP_DATA(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.varyingIn()} vec2 v_alpha_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src_color = ${t.texture2D()}(u_textures[0], v_src_tex_coord);\n    float alpha = ${t.texture2D()}(u_textures[1], v_alpha_tex_coord).a;\n\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n    alpha *= src_color.a;\n\n    ${t.fragColor()} = vec4(src_color.rgb * alpha, alpha);\n}\n\n`}static PALETTE_MAP(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_textures[0], v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n                                                //  256*4\n    vec4 map_r = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.r*255.0)/256.0, 0.125));\n    vec4 map_g = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.g*255.0)/256.0, 0.375));\n    vec4 map_b = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.b*255.0)/256.0, 0.625));\n    vec4 map_a = ${e.texture2D()}(u_textures[1], vec2((0.5+src_color.a*255.0)/256.0, 0.875));\n\n    // u_plt_tex(u_textures[1])  BGRA  .bgra\n    // TODO  ARGB  .gbar\n    vec4 color = (map_r + map_g + map_b + map_a).bgra;\n\n    // fract  1.0, 2.0, ...  0.0  1.0 \n    vec4 color_fract = fract(color);\n    color = color_fract + sign(color) - sign(color_fract);\n\n#if ${t}\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#else\n    ${e.fragColor()} = vec4(color.rgb, 1.0);\n#endif\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t}\n    ${e.fragColor()} = src_color;\n#else\n    ${e.fragColor()} = vec4(src_color.rgb, 1.0);\n#endif\n}\n\n`}static COLOR_TRANSFORM(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 ct_mul = u_mediump[0];\n    vec4 ct_add = u_mediump[1];\n\n    vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);\n\n    vec4 color = clamp(ct_mul * src_color + ct_add, 0.0, 1.0);\n\n    color = vec4(color.rgb * color.a, color.a);\n\n#if !${t}\n    color.a = 1.0;\n#endif\n\n    ${e.fragColor()} = color * sign(src_color.a);  // \n}\n\n`}static bitwiseAnd(){return"\n#if __VERSION__ < 130\n// 8bit\nint bitwiseAnd(int a, int b) {\n    //ivec4 c1 = ivec4(1,2,4,8);\n    //ivec4 c2 = ivec4(16,32,64,128);\n\n    //ivec4 a1 = ivec4(a) / c1;\n    //ivec4 a2 = ivec4(a) / c2;\n    //ivec4 b1 = ivec4(b) / c1;\n    //ivec4 b2 = ivec4(b) / c2;\n\n    //ivec4 r = (a1-a1/2*2) * (b1-b1/2*2) * c1\n    //        + (a2-a2/2*2) * (b2-b2/2*2) * c2;\n\n    //return r.x + r.y + r.z + r.w;\n\n    //  intrakusanint\n    //  float\n\n    vec4 a0 = vec4(float(a));\n    vec4 b0 = vec4(float(b));\n    vec4 a1 = floor(a0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 a2 = floor(a0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n    vec4 b1 = floor(b0 * vec4(1.0, 0.5, 0.25, 0.125));\n    vec4 b2 = floor(b0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));\n\n    return int(dot((a1-floor(a1*0.5)*2.0)*(b1-floor(b1*0.5)*2.0), vec4(1.0,2.0,4.0,8.0))\n             + dot((a2-floor(a2*0.5)*2.0)*(b2-floor(b2*0.5)*2.0), vec4(16.0,32.0,64.0,128.0)));\n}\n\nivec4 bitwiseAnd(ivec4 a, ivec4 b) {\n    return ivec4(bitwiseAnd(a.r, b.r),\n                 bitwiseAnd(a.g, b.g),\n                 bitwiseAnd(a.b, b.b),\n                 bitwiseAnd(a.a, b.a));\n}\n#else\n#define bitwiseAnd(a, b) ((a)&(b))\n#endif\n"}static THRESHOLD(t,e,i,r){return e|=0,i|=0,`${r.version()}\n#if __VERSION__ < 130\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump[2]; // u_threshold(u_mediump[0]) JS\nuniform ivec4 u_integer;\n\n${r.varyingIn()} vec2 v_src_tex_coord;\n\n#if __VERSION__ < 130\n#define outColor0 gl_FragData[0]\n#define outColor1 gl_FragData[1]\n#else\nlayout (location = 0) out vec4 outColor0;\nlayout (location = 1) out vec4 outColor1;\n#endif\n\n${bt.bitwiseAnd()}\n\nbool less(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) < 0.0;\n}\n\nbool greater(vec4 x) {\n    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) > 0.0;\n}\n\nbool lessEqual(vec4 x) {\n    return !greater(x);\n}\n\nbool greaterEqual(vec4 x) {\n    return !less(x);\n}\n\n//  equal  thresholdEqual \nbool thresholdEqual(vec4 x) {\n    return all(equal(x, u_mediump[0]));\n}\n\n//  notEqual  thresholdNotEqual \nbool thresholdNotEqual(vec4 x) {\n    return any(notEqual(x, u_mediump[0]));\n}\n\nvoid main() {\n    // Flash Player\n\n    vec4 src_color = ${r.texture2D()}(u_src_tex, v_src_tex_coord);\n    ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), u_integer);\n\n    if (${t}(vec4(masked))) {\n        outColor0 = u_mediump[1];\n        outColor1 = vec4(1.0);\n    } else {\n#if ${e}\n    #if ${i}\n        outColor0 = src_color;\n    #else\n        outColor0 = vec4(src_color.rgb, 1.0);\n    #endif\n        outColor1 = vec4(0.0);\n#else\n        discard;\n#endif\n    }\n}\n\n`}static THRESHOLD_SUBTOTAL(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_src_tex_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2 src_tex_step   = u_mediump.xy;\n    float subtotal_loop = u_mediump.z;\n\n    float subtotal = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 4095.0; ++i) {      //  4095.0 \n        if (j++ >= subtotal_loop) {           // BitmapData.prototype.threshold \n            break;\n        }\n#else\n    for (float i = 0.0; i < subtotal_loop; ++i) {\n#endif\n        subtotal += ${t.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i).a;\n    }\n\n    vec4 v1 = floor(subtotal * vec4(1.0, 0.00390625, 0.0000152587890625, 5.960464477539063e-8));  // vec4(1.0, 1.0/256.0, 1.0/65536.0, 1.0/16777216.0)\n    vec4 v2 = vec4(v1.yzw, 0.0);\n    ${t.fragColor()} = (v1 - v2*256.0) * 0.00392156862745098;  // 1.0/255.0\n}\n\n`}static GET_COLOR_BOUNDS_RECT(t,e){return t|=0,`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\nuniform vec4 u_mediump;\nuniform ivec4 u_integer[2];\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\n${bt.bitwiseAnd()}\n\nvoid main() {\n    vec2 src_tex_step = u_mediump.xy;\n    float scan_loop   = u_mediump.z;\n    ivec4 mask  = u_integer[0];\n    ivec4 color = u_integer[1];\n\n    float found = 0.0;\n\n#if __VERSION__ < 130\n    float j = 0.0;\n    for (float i = 0.0; i < 8191.0; ++i) {      // BitmapData  8191 \n        if (j++ >= scan_loop) {\n            break;\n        }\n#else\n    for (float i = 0.0; i < scan_loop; ++i) {\n#endif\n        vec4 src_color = ${e.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i);\n        ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), mask);\n\n#if ${t}\n        if (all(equal(masked, color))) {\n#else\n        if (any(notEqual(masked, color))) {\n#endif\n            found = 1.0;\n            break;\n        }\n    }\n\n    ${e.fragColor()} = vec4(found);\n}\n\n`}static NOISE(t){return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[3];\n\n${t.outColor()}\n\n// https://stackoverflow.com/a/28095165\n//\n// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio\n\nvec4 gold_noise(vec2 xy, vec4 seed) {\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvoid main() {\n    vec4 seed = u_mediump[0];\n    vec4 amp  = u_mediump[1];\n    vec4 low  = u_mediump[2];\n\n    vec4 noise = gold_noise(gl_FragCoord.xy, seed);\n    vec4 color = noise * amp + low;\n    ${t.fragColor()} = vec4(color.rgb * color.a, color.a);\n}\n\n`}static GET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb / max(0.0001, color.a), color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr / max(0.0001, color.a), color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.a, color.rgb / max(0.0001, color.a));\n#endif\n}\n\n`}static SET_PIXELS(t,e){switch(t){case"RGBA":t=1;break;case"BGRA":t=2;break;default:t=0}return`${e.version()}\nprecision mediump float;\n\nuniform sampler2D u_src_tex;\n\n${e.varyingIn()} vec2 v_src_tex_coord;\n${e.outColor()}\n\nvoid main() {\n    vec4 color = ${e.texture2D()}(u_src_tex, v_src_tex_coord);\n\n#if ${t} == 1  // RGBA\n    ${e.fragColor()} = vec4(color.rgb * color.a, color.a);\n#elif ${t} == 2  // BGRA\n    ${e.fragColor()} = vec4(color.bgr * color.a, color.a);\n#else  // ARGB\n    ${e.fragColor()} = vec4(color.gba * color.r, color.r);\n#endif\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_dst_tex;\n\n${t.varyingIn()} vec2 v_dst_tex_coord;\n${t.varyingIn()} vec4 v_color;\n${t.outColor()}\n\nvoid main() {\n    float da = ${t.texture2D()}(u_dst_tex, v_dst_tex_coord).a;\n    float a = v_color.a;\n\n    ${t.fragColor()} = max( a, 0.0) * v_color\n                     + max(-a, 0.0) * vec4(v_color.rgb * da, da);\n}\n\n`}}class Tt{static TEMPLATE(t,e){const i=e?"uniform vec4 u_mediump[2];":"",r=e?mt.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${i}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec4 src = ${t.texture2D()}(u_texture, v_coord);\n    ${r}\n    ${t.fragColor()} = src;\n}\n\n`}}class vt{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class yt{static TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static BLEND(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static BLEND_CLIP(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\n${t.varyingOut()} vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}}class Et{static POSITION_ONLY(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_DST_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_dst_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static SRC_AND_ALPHA_TEX_COORD(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform vec4 u_highp[7];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n${t.varyingOut()} vec2 v_alpha_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(u_highp[3].xyz, u_highp[4].xyz, u_highp[5].xyz);\n    mat3 alpha_tex_matrix = mat3(\n        u_highp[6].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w),\n        vec3(u_highp[3].w, u_highp[4].w, u_highp[5].w)\n    );\n\n    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n    v_alpha_tex_coord = (alpha_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}static PIXEL_DISSOLVE_COLOR(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[3];\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static PIXEL_DISSOLVE_TEXTURE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n\nuniform mat3 u_highp[5];\n\n${t.varyingOut()} vec2 v_src_tex_coord;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n    mat3 src_tex_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)\n    );\n\n    v_src_tex_coord = (u_src_tex_matrix * vec3(a_vertex, 1.0)).xy;\n\n    vec2 position = (u_matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n\n    gl_PointSize = 1.0;\n}\n\n`}static SET_PIXEL_QUEUE(t){return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec4 a_color;\n\nuniform mat3 u_highp[3];\n\n${t.varyingOut()} vec2 v_dst_tex_coord;\n${t.varyingOut()} vec4 v_color;\n\nvoid main() {\n    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);\n\n    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    v_color = a_color;\n\n    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n`}}class At{static TEMPLATE(t,e,i,r,s){const n=r?this.ATTRIBUTE_BEZIER_ON(t):"",a=r?this.VARYING_BEZIER_ON(t):i?this.VARYING_UV_ON(t):"",o=r?this.STATEMENT_BEZIER_ON():i?this.STATEMENT_UV_ON():"",h=s?vt.FUNCTION_GRID_ON(i?5:0):vt.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${n}\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${o}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(t){return`\n${t.attribute(1)} vec2 a_bezier;\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static VARYING_BEZIER_ON(t){return`\n${t.varyingOut()} vec2 v_bezier;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class Mt{static TEMPLATE(t,e,i,r,s){const n=i-1,a=r?this.VARYING_UV_ON(t):"",o=r?this.STATEMENT_UV_ON():"",h=s?vt.FUNCTION_GRID_ON(r?5:0):vt.FUNCTION_GRID_OFF();return`${t.version()}\n\n${t.attribute(0)} vec2 a_vertex;\n${t.attribute(1)} vec2 a_option1;\n${t.attribute(2)} vec2 a_option2;\n${t.attribute(3)} float a_type;\n\nuniform vec4 u_highp[${e}];\n\n${a}\n\n${h}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${n}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${n}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${n}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // \n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // \n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // B\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // A\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // A\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // B\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // \n        float face = u_highp[${n}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${o}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(t){return`\n${t.varyingOut()} vec2 v_uv;\n`}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class Ct{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBitmapShader(){return this._$collection.has("b")||this._$collection.set("b",new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),Tt.TEMPLATE(this._$keyword,0,0,!1))),this._$collection.get("b")}setBitmapUniform(){}setGetPixelsUniform(t,e,i,r,s){const n=t.highp;n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n[12]=e,n[13]=0,n[14]=0,n[16]=0,n[17]=i,n[18]=0,n[3]=r,n[7]=s,n[11]=1}setSetPixelsUniform(t,e,i,r,s,n,a,o,h){const l=t.highp;l[0]=e,l[1]=0,l[2]=0,l[4]=0,l[5]=i,l[6]=0,l[8]=r,l[9]=s,l[10]=1,l[12]=n,l[13]=0,l[14]=0,l[16]=0,l[17]=a,l[18]=0,l[3]=o,l[7]=h,l[11]=1}setColorTransformUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4]/255,i[5]=e[5]/255,i[6]=e[6]/255,i[7]=e[7]/255}setManipulatePixelsUniform(t,e,i,r,s,n){const a=t.highp;a[0]=e[0],a[1]=e[1],a[2]=e[2],a[4]=e[3],a[5]=e[4],a[6]=e[5],a[8]=e[6],a[9]=e[7],a[10]=e[8],s?(a[12]=r[0],a[13]=r[1],a[14]=r[2],a[16]=r[3],a[17]=r[4],a[18]=r[5],a[20]=r[6],a[21]=r[7],a[22]=r[8],a[24]=n[0],a[25]=n[1],a[26]=n[2],a[3]=n[3],a[7]=n[4],a[11]=n[5],a[15]=n[6],a[19]=n[7],a[23]=n[8]):i&&(a[12]=r[0],a[13]=r[1],a[14]=r[2],a[16]=r[3],a[17]=r[4],a[18]=r[5],a[3]=r[6],a[7]=r[7],a[11]=r[8])}setCopyChannelUniform(t,e,i){const r=t.textures;r[0]=0,r[1]=1;const s=t.mediump;s[0]=1&e,s[1]=e>>1&1,s[2]=e>>2&1,s[3]=e>>3&1,s[4]=1&i,s[5]=i>>1&1,s[6]=i>>2&1,s[7]=i>>3&1}setCopyPixelsUniform(t,e){if(e){const e=t.textures;e[0]=0,e[1]=1}}setFillRectUniform(t,e,i,r,s){const n=t.mediump;n[0]=e,n[1]=i,n[2]=r,n[3]=s}setGetColorBoundsRectUniform(t,e,i,r,s,n){const a=t.highp;a[0]=1,a[1]=0,a[2]=0,a[4]=0,a[5]=1,a[6]=0,a[8]=0,a[9]=0,a[10]=1,a[12]=e[0],a[13]=e[1],a[14]=e[2],a[16]=e[3],a[17]=e[4],a[18]=e[5],a[3]=e[6],a[7]=e[7],a[11]=e[8];const o=t.mediump;o[0]=i[0],o[1]=i[1],o[2]=r;const h=t.integer;h[0]=s[0],h[1]=s[1],h[2]=s[2],h[3]=s[3],h[4]=n[0],h[5]=n[1],h[6]=n[2],h[7]=n[3]}setMergeUniform(t,e,i,r,s){const n=t.textures;n[0]=0,n[1]=1;const a=t.mediump;a[0]=e,a[1]=i,a[2]=r,a[3]=s}setNoiseUniform(t,e,i,r,s,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=r,u[3]=s,u[4]=n,u[5]=a,u[6]=o,u[7]=h,u[8]=l,u[9]=$,u[10]=_,u[11]=c}setPaletteMapUniform(t){const e=t.textures;e[0]=0,e[1]=2}setPixelDissolveUniform(t,e,i,r,s){const n=t.mediump;n[0]=e,n[1]=i,n[2]=r,n[3]=s}setFlushSetPixelQueueUniform(t){const e=t.highp;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=-1,e[5]=0,e[6]=0,e[7]=1,e[8]=1}setThresholdUniform(t,e,i,r,s,n,a,o,h,l,$,_,c){const u=t.mediump;u[0]=e,u[1]=i,u[2]=r,u[3]=s,u[4]=n,u[5]=a,u[6]=o,u[7]=h;const d=t.integer;d[0]=l,d[1]=$,d[2]=_,d[3]=c}}class St{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getNormalBlendShader(t){const e="n"+(t?"y":"n");return this._$collection.has(e)||this._$collection.set(e,new Wt(this._$gl,this._$context,yt.BLEND(this._$keyword),Tt.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getClipShader(){return this._$collection.has("c")||this._$collection.set("c",new Wt(this._$gl,this._$context,yt.BLEND_CLIP(this._$keyword),Tt.TEMPLATE(this._$keyword,!1))),this._$collection.get("c")}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;return this._$collection.has(i)||this._$collection.set(i,new Wt(this._$gl,this._$context,yt.BLEND(this._$keyword),class{static TEMPLATE(t,e,i){let r;switch(e){case C.SUBTRACT:r=this.FUNCTION_SUBTRACT();break;case C.MULTIPLY:r=this.FUNCTION_MULTIPLY();break;case C.LIGHTEN:r=this.FUNCTION_LIGHTEN();break;case C.DARKEN:r=this.FUNCTION_DARKEN();break;case C.OVERLAY:r=this.FUNCTION_OVERLAY();break;case C.HARDLIGHT:r=this.FUNCTION_HARDLIGHT();break;case C.DIFFERENCE:r=this.FUNCTION_DIFFERENCE();break;case C.INVERT:r=this.FUNCTION_INVERT();break;default:r=this.FUNCTION_NORMAL()}const s=i?"uniform vec4 u_mediump[2];":"",n=i?mt.STATEMENT_COLOR_TRANSFORM_ON(0):"";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${s}\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${r}\n\nvoid main() {\n    vec4 dst = ${t.texture2D()}(u_textures[0], v_coord);\n    vec4 src = ${t.texture2D()}(u_textures[1], v_coord);\n    ${n}\n    ${t.fragColor()} = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}.TEMPLATE(this._$keyword,t,e))),this._$collection.get(i)}setNormalBlendUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,f){const p=t.highp;if(p[0]=e,p[1]=i,p[2]=r,p[3]=s,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}setClipUniform(t,e,i,r,s,n,a,o){const h=t.highp;h[0]=e,h[1]=i,h[2]=r,h[3]=s,h[4]=n[0],h[5]=n[1],h[6]=n[2],h[8]=n[3],h[9]=n[4],h[10]=n[5],h[12]=n[6],h[13]=n[7],h[14]=n[8],h[7]=a,h[11]=o}setBlendUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,f){const p=t.textures;p[0]=0,p[1]=1;const m=t.highp;if(m[0]=e,m[1]=i,m[2]=r,m[3]=s,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=o,h){const e=t.mediump;e[0]=l,e[1]=$,e[2]=_,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class Rt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getBlurFilterShader(t){const e=`b${t}`;return this._$collection.has(e)||this._$collection.set(e,new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e){const i=e.toFixed(1);return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${i}; i += 1.0) {\n        color += ${t.texture2D()}(u_texture, v_coord + offset * i);\n        color += ${t.texture2D()}(u_texture, v_coord - offset * i);\n    }\n    color += ${t.texture2D()}(u_texture, v_coord + offset * ${i}) * fraction;\n    color += ${t.texture2D()}(u_texture, v_coord - offset * ${i}) * fraction;\n    color /= samples;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,t))),this._$collection.get(e)}getBitmapFilterShader(t,e,i,s,n,a,o){const h=`f${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}${s}${n?"y":"n"}${a?"y":"n"}`;if(!this._$collection.has(h)){let l=1;t&&l++,o&&l++;let $=(t?4:0)+(e?4:0)+(a?1:0);o||($+=i?4:8),$=r.$ceil($/4),this._$collection.set(h,new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r,s,n,a,o,h,l){let $=0;const _=r?this.STATEMENT_BASE_TEXTURE_TRANSFORM(t,$++):"",c=s?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(t,$++):this.STATEMENT_BLUR_TEXTURE(t),u=a===Y.INNER,d=$;let g,f,p=4*$;switch(l?g=n?this.STATEMENT_GLOW(t,!1,r,h,l,d,p):this.STATEMENT_BEVEL(t,r,s,h,l,d,p):n?(p+=4,g=this.STATEMENT_GLOW(t,u,r,h,l,d,p)):(p+=8,g=this.STATEMENT_BEVEL(t,r,s,h,l,d,p)),a){case Y.OUTER:f=o?"blur - blur * base.a":"base + blur - blur * base.a";break;case Y.FULL:f=o?"blur":"base - base * blur.a + blur";break;case Y.INNER:default:f="blur"}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[${e}];\nuniform vec4 u_mediump[${i}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${mt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${_}\n    ${c}\n    ${g}\n    ${t.fragColor()} = ${f};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t,e){return`\n    vec2 base_scale  = u_mediump[${e}].xy;\n    vec2 base_offset = u_mediump[${e}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), ${t.texture2D()}(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(t){return`\n    vec4 blur = ${t.texture2D()}(u_textures[0], v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t,e){return`\n    vec2 blur_scale  = u_mediump[${e}].xy;\n    vec2 blur_offset = u_mediump[${e}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,r,s,n,a){return`\n    ${e?"blur.a = 1.0 - blur.a;":""}\n    ${r?this.STATEMENT_GLOW_STRENGTH(a):""}\n    ${s?this.STATEMENT_GLOW_GRADIENT_COLOR(t,i):this.STATEMENT_GLOW_SOLID_COLOR(n)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${r.$floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,r,s,n,a){return`\n    ${i?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t):this.STATEMENT_BLUR_TEXTURE_2(t)}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${r?this.STATEMENT_BEVEL_STRENGTH(a):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${s?this.STATEMENT_BEVEL_GRADIENT_COLOR(t,e):this.STATEMENT_BEVEL_SOLID_COLOR(n)}\n`}static STATEMENT_BLUR_TEXTURE_2(t){return`\n    vec4 blur2 = ${t.texture2D()}(u_textures[0], 1.0 - v_coord);\n`}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(t){return`\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), ${t.texture2D()}(u_textures[0], pq), isInside(pq));\n`}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${r.$floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t,e){const i=e?2:1;return`\n    blur = ${t.texture2D()}(u_textures[${i}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}.TEMPLATE(this._$keyword,l,$,t,e,i,s,n,a,o)))}return this._$collection.get(h)}getColorMatrixFilterShader(){return this._$collection.has("m")||this._$collection.set("m",new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),class{static TEMPLATE(t){return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = ${t.texture2D()}(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword))),this._$collection.get("m")}getConvolutionFilterShader(t,e,i,s){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${i?"y":"n"}${s?"y":"n"}`;if(!this._$collection.has(n)){const a=(s?1:2)+r.$ceil(t*e/4);this._$collection.set(n,new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s,n,a){const o=r.$floor(.5*i),h=r.$floor(.5*s),l=i*s;let $="";const _=a?1:2;for(let t=0;t<l;++t){$+=`\n    result += getWeightedColor(${t}, u_mediump[${_+r.$floor(t/4)}][${t%4}]);\n`}const c=n?`result.a = ${t.texture2D()}(u_texture, v_coord).a;`:"",u=a?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${mt.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${i};\n    int i_mod_x = i - ${i} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${o}, ${h} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = ${t.texture2D()}(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${u}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${$}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${c}\n\n    result.rgb *= result.a;\n    ${t.fragColor()} = result;\n}\n\n`}}.TEMPLATE(this._$keyword,a,t,e,i,s)))}return this._$collection.get(n)}getDisplacementMapFilterShader(t,e,i){const r=`d${t}${e}${i}`;if(!this._$collection.has(r)){const s=i===j.COLOR?3:2;this._$collection.set(r,new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,r,s){let n,a,o;switch(i){case M.RED:n="map_color.r";break;case M.GREEN:n="map_color.g";break;case M.BLUE:n="map_color.b";break;case M.ALPHA:n="map_color.a";break;default:n="0.5"}switch(r){case M.RED:a="map_color.r";break;case M.GREEN:a="map_color.g";break;case M.BLUE:a="map_color.b";break;case M.ALPHA:a="map_color.a";break;default:a="0.5"}switch(s){case j.CLAMP:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], uv);\n`;break;case j.IGNORE:o=`\n    vec4 source_color =${t.texture2D()}(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n`;break;case j.COLOR:o=`\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, ${t.texture2D()}(u_textures[0], uv), isInside(uv));\n`;break;case j.WRAP:default:o=`\n    vec4 source_color = ${t.texture2D()}(u_textures[0], fract(uv));\n`}return`${t.version()}\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\n${mt.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = ${t.texture2D()}(u_textures[1], st);\n\n    vec2 offset = vec2(${n}, ${a}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${o}\n\n    ${t.fragColor()} = mix(${t.texture2D()}(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}.TEMPLATE(this._$keyword,s,t,e,i)))}return this._$collection.get(r)}setBlurFilterUniform(t,e,i,r,s,n){const a=t.mediump;r?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=s,a[3]=n}setBitmapFilterUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,f,p,m,x,b,T,v,y,E){let A;T?(A=t.textures,A[0]=0,A[1]=1,E&&(A[2]=2)):E&&(A=t.textures,A[0]=0,A[1]=2);const M=t.mediump;let C=0;T&&(M[C]=e/r,M[C+1]=i/s,M[C+2]=n/r,M[C+3]=(i-s-a)/s,C+=4),v&&(M[C]=e/o,M[C+1]=i/h,M[C+2]=l/o,M[C+3]=(i-h-$)/h,C+=4),E||(_?(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,C+=4):(M[C]=u,M[C+1]=d,M[C+2]=g,M[C+3]=f,M[C+4]=p,M[C+5]=m,M[C+6]=x,M[C+7]=b,C+=8)),y&&(M[C++]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,r,s,n,a,o,h,l,$){const _=t.mediump;_[0]=1/e,_[1]=1/i,_[2]=1/s,_[3]=n/255;let c=4;a||(_[c]=o,_[c+1]=h,_[c+2]=l,_[c+3]=$,c+=4);const u=r.length;for(let t=0;t<u;t++)_[c++]=r[t]}setDisplacementMapFilterUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=r/e,g[1]=s/i,g[2]=n/e,g[3]=(s-i-a)/i,g[4]=o/r,g[5]=-h/s,l===j.COLOR&&(g[8]=$,g[9]=_,g[10]=c,g[11]=u)}}class wt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientLUTShader(t,e){const i=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(!this._$collection.has(i)){const s=r.$ceil(5*t/4);this._$collection.set(i,new Wt(this._$gl,this._$context,yt.TEXTURE(this._$keyword),class{static TEMPLATE(t,e,i,s){let n="";for(let t=1;t<i;t++){const e=t-1,s=t,a=`u_mediump[${i+r.$floor(e/4)}][${e%4}]`,o=`u_mediump[${i+r.$floor(s/4)}][${s%4}]`;n+=`\n    if (t <= ${o}) {\n        return mix(u_mediump[${e}], u_mediump[${s}], (t - ${a}) / (${o} - ${a}));\n    }\n`}const a=s?"color = pow(color, vec4(0.45454545));":"";return`${t.version()}\nprecision mediump float;\n\nuniform vec4 u_mediump[${e}];\n\n${t.varyingIn()} vec2 v_coord;\n${t.outColor()}\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${i}][0]) {\n        return u_mediump[0];\n    }\n    ${n}\n    return u_mediump[${i-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${a}\n    color.rgb *= color.a;\n\n    ${t.fragColor()} = color;\n}\n\n`}}.TEMPLATE(this._$keyword,s,t,e)))}return this._$collection.get(i)}setGradientLUTUniformForShape(t,e,i,r,s){let n=0;const a=t.mediump;for(let t=i;t<r;t++){const i=e[t][1];a[n++]=s[i[0]],a[n++]=s[i[1]],a[n++]=s[i[2]],a[n++]=s[i[3]]}for(let t=i;t<r;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,r,s,n){let a=0;const o=t.mediump;for(let t=s;t<n;t++){const e=i[t];o[a++]=(e>>16)/255,o[a++]=(e>>8&255)/255,o[a++]=(255&e)/255,o[a++]=r[t]}for(let t=s;t<n;t++)o[a++]=e[t]}}class Ot{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getGradientShapeShader(t,e,i,r,s){const n=this.createCollectionKey(t,e,i,r,s);if(!this._$collection.has(n)){let a=(e?13:5)+(t?1:0)+1;const o=a-1;let h;h=t?Mt.TEMPLATE(this._$keyword,a,o,!0,e):At.TEMPLATE(this._$keyword,a,!0,!1,e),this._$collection.set(n,new Wt(this._$gl,this._$context,h,class{static TEMPLATE(t,e,i,r,s,n){const a=r?this.STATEMENT_GRADIENT_TYPE_RADIAL(i,s):this.STATEMENT_GRADIENT_TYPE_LINEAR(i);let o;switch(n){case"reflect":o="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":o="fract(t)";break;default:o="clamp(t, 0.0, 1.0)"}return`${t.version()}\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${e}];\n\n${t.varyingIn()} vec2 v_uv;\n${t.outColor()}\n\nvoid main() {\n    vec2 p = v_uv;\n    ${a}\n    t = ${o};\n    ${t.fragColor()} = ${t.texture2D()}(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}.TEMPLATE(this._$keyword,a,o,i,r,s)))}return this._$collection.get(n)}createCollectionKey(t,e,i,r,s){const n=t?"y":"n",a=e?"y":"n",o=i?"y":"n",h=i&&r?"y":"n";let l=0;switch(s){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${o}${h}${l}`}setGradientShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=o[0],d[13]=o[1],d[14]=o[2],d[16]=o[3],d[17]=o[4],d[18]=o[5],d[11]=o[6],d[15]=o[7],d[19]=o[8],d[3]=h,d[7]=l;let g=20;n&&(d[g]=$.parentMatrixA,d[g+1]=$.parentMatrixB,d[g+2]=$.parentMatrixC,d[g+4]=$.parentMatrixD,d[g+5]=$.parentMatrixE,d[g+6]=$.parentMatrixF,d[g+8]=$.parentMatrixG,d[g+9]=$.parentMatrixH,d[g+10]=$.parentMatrixI,d[g+12]=$.ancestorMatrixA,d[g+13]=$.ancestorMatrixB,d[g+14]=$.ancestorMatrixC,d[g+16]=$.ancestorMatrixD,d[g+17]=$.ancestorMatrixE,d[g+18]=$.ancestorMatrixF,d[g+20]=$.ancestorMatrixG,d[g+21]=$.ancestorMatrixH,d[g+22]=$.ancestorMatrixI,d[g+11]=$.parentViewportX,d[g+15]=$.parentViewportY,d[g+19]=$.parentViewportW,d[g+23]=$.parentViewportH,d[g+24]=$.minXST,d[g+25]=$.minYST,d[g+26]=$.minXPQ,d[g+27]=$.minYPQ,d[g+28]=$.maxXST,d[g+29]=$.maxYST,d[g+30]=$.maxXPQ,d[g+31]=$.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=r,d[g+2]=s,g+=4),_?(d[g]=c[5],d[g+1]=u):(d[g]=c[0],d[g+1]=c[1],d[g+2]=c[2],d[g+3]=c[3])}}class Bt{constructor(t,e,i){this._$context=t,this._$gl=e,this._$keyword=i,this._$collection=new Map}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=(e?8:3)+(t?1:0),s=r;let n;n=t?Mt.TEMPLATE(this._$keyword,r,s,!1,e):At.TEMPLATE(this._$keyword,r,!1,!1,e),this._$collection.set(i,new Wt(this._$gl,this._$context,n,xt.SOLID_COLOR(this._$keyword)))}return this._$collection.get(i)}getBitmapShapeShader(t,e,i){const r=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(!this._$collection.has(r)){const s=(i?13:5)+(t?1:0),n=s;let a;a=t?Mt.TEMPLATE(this._$keyword,s,n,!0,i):At.TEMPLATE(this._$keyword,s,!0,!1,i);const o=e?xt.BITMAP_PATTERN(this._$keyword):xt.BITMAP_CLIPPED(this._$keyword);this._$collection.set(r,new Wt(this._$gl,this._$context,a,o))}return this._$collection.get(r)}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(!this._$collection.has(i)){const r=(e?8:3)+(t?1:0),s=r;let n;n=t?Mt.TEMPLATE(this._$keyword,r,s,!1,e):At.TEMPLATE(this._$keyword,r,!1,!0,e),this._$collection.set(i,new Wt(this._$gl,this._$context,n,xt.MASK(this._$keyword)))}return this._$collection.get(i)}setSolidColorShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_){const c=t.highp;let u;n?(c[0]=l.parentmatrix_a,c[1]=l.parentmatrix_b,c[2]=l.parentmatrix_c,c[4]=l.parentmatrix_d,c[5]=l.parentmatrix_e,c[6]=l.parentmatrix_f,c[8]=l.parentmatrix_g,c[9]=l.parentmatrix_h,c[10]=l.parentmatrix_i,c[12]=l.ancestormatrix_a,c[13]=l.ancestormatrix_b,c[14]=l.ancestormatrix_c,c[16]=l.ancestormatrix_d,c[17]=l.ancestormatrix_e,c[18]=l.ancestormatrix_f,c[20]=l.ancestormatrix_g,c[21]=l.ancestormatrix_h,c[22]=l.ancestormatrix_i,c[3]=o,c[7]=h,c[11]=l.parentViewportX,c[15]=l.parentViewportY,c[19]=l.parentViewportW,c[23]=l.parentViewportH,c[24]=l.minXST,c[25]=l.minYST,c[26]=l.minXPQ,c[27]=l.minYPQ,c[28]=l.maxXST,c[29]=l.maxYST,c[30]=l.maxXPQ,c[31]=l.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=o,c[7]=h,u=12),e&&(c[u]=i,c[u+1]=r,c[u+2]=s);const d=t.mediump;d[0]=$[0],d[1]=$[1],d[2]=$[2],d[3]=$[3]*_}setBitmapShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,f,p,m,x,b){const T=t.highp;let v;T[0]=a[0],T[1]=a[1],T[2]=a[2],T[4]=a[3],T[5]=a[4],T[6]=a[5],T[8]=a[6],T[9]=a[7],T[10]=a[8],T[12]=o[0],T[13]=o[1],T[14]=o[2],T[16]=o[3],T[17]=o[4],T[18]=o[5],T[11]=o[6],T[15]=o[7],T[19]=o[8],T[3]=h,T[7]=l,v=20,n&&(T[v]=$.parentmatrix_a,T[v+1]=$.parentmatrix_b,T[v+2]=$.parentmatrix_c,T[v+4]=$.parentmatrix_d,T[v+5]=$.parentmatrix_e,T[v+6]=$.parentmatrix_f,T[v+8]=$.parentmatrix_g,T[v+9]=$.parentmatrix_h,T[v+10]=$.parentmatrix_i,T[v+12]=$.ancestormatrix_a,T[v+13]=$.ancestormatrix_b,T[v+14]=$.ancestormatrix_c,T[v+16]=$.ancestormatrix_d,T[v+17]=$.ancestormatrix_e,T[v+18]=$.ancestormatrix_f,T[v+20]=$.ancestormatrix_g,T[v+21]=$.ancestormatrix_h,T[v+22]=$.ancestormatrix_i,T[v+11]=$.parentViewportX,T[v+15]=$.parentViewportY,T[v+19]=$.parentViewportW,T[v+23]=$.parentViewportH,T[v+24]=$.minXST,T[v+25]=$.minYST,T[v+26]=$.minXPQ,T[v+27]=$.minYPQ,T[v+28]=$.maxXST,T[v+29]=$.maxYST,T[v+30]=$.maxXPQ,T[v+31]=$.maxYPQ,v=52),e&&(T[v]=i,T[v+1]=r,T[v+2]=s);const y=t.mediump;y[0]=_,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=f,y[8]=p,y[9]=m,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.highp;e?(d[0]=u.parentmatrix_a,d[1]=u.parentmatrix_b,d[2]=u.parentmatrix_c,d[4]=u.parentmatrix_d,d[5]=u.parentmatrix_e,d[6]=u.parentmatrix_f,d[8]=u.parentmatrix_g,d[9]=u.parentmatrix_h,d[10]=u.parentmatrix_i,d[12]=u.ancestormatrix_a,d[13]=u.ancestormatrix_b,d[14]=u.ancestormatrix_c,d[16]=u.ancestormatrix_d,d[17]=u.ancestormatrix_e,d[18]=u.ancestormatrix_f,d[20]=u.ancestormatrix_g,d[21]=u.ancestormatrix_h,d[22]=u.ancestormatrix_i,d[3]=_,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=r,d[2]=s,d[4]=n,d[5]=a,d[6]=o,d[8]=h,d[9]=l,d[10]=$,d[3]=_,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const r=t.highp;r[0]=1,r[1]=0,r[2]=0,r[4]=0,r[5]=1,r[6]=0,r[8]=0,r[9]=0,r[10]=1,r[3]=e,r[7]=i}}class It{constructor(){this._$rgb=F.RGB,this._$mode=U.PAD,this._$focalPointRatio=0,this._$points=r.$getFloat32Array6(),this._$stops=r.$getArray(),this._$type=null}linear(t,e,i,r,s=F.RGB,n=U.PAD){return this._$type=w.LINEAR,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=r,this._$rgb=s,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,n,a,o=F.RGB,h=U.PAD,l=0){return this._$type=w.RADIAL,this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=n,this._$points[5]=a,this._$rgb=o,this._$mode=h,this._$focalPointRatio=r.$clamp(l,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push([t,e]),this._$stops.sort((function(t,e){switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}}))}}class Ft{constructor(t=null,e=null,i=null){this._$initialization(t,e,i)}_$initialization(t=null,e=null,i=null){return this._$texture=t,this._$repeat=e,this._$color_transform=i,this}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$color_transform}}class Lt{constructor(t,e){this._$gl=t;const i=e?r.$min(r.$currentPlayer().getSamples(),t.getParameter(t.MAX_SAMPLES)):0;this._$isWebGL2Context=e,this._$maxTextureSize=r.$min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new kt,this._$style=this._$contextStyle,this._$fillBuffer=null,this._$strokeBuffer=null,this._$cacheCurrentBounds={x:0,y:0,w:0,h:0},this._$cacheCurrentBuffer=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation=C.NORMAL,this._$matrix=r.$getFloat32Array9(1,0,0,0,1,0,0,0,1),this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new Yt(t,e,i),this._$path=new Ut,this._$grid=new Dt,this._$offsetX=0,this._$offsetY=0,this._$blends=[],this._$positions=[],this._$isLayer=!1,this._$shaderList=new qt(this,t),this._$gradientLUT=new Kt(this,t),this._$vao=new zt(t,e),this._$pbo=new Ht(t,e),this._$mask=new Nt(this,t),this._$blend=new Pt(this,t),this._$canvasPatternToWebGL=new Ft,this._$canvasGradientToWebGL=new It}get canvas(){return this._$gl.canvas}get fillStyle(){return this._$style._$fillStyle}set fillStyle(t){this._$style._$fillStyle.constructor===Float32Array&&r.$poolFloat32Array4(this._$style._$fillStyle),this._$style._$fillStyle=t}get strokeStyle(){return this._$style._$strokeStyle}set strokeStyle(t){this._$style._$strokeStyle.constructor===Float32Array&&r.$poolFloat32Array4(this._$style._$strokeStyle),this._$style._$strokeStyle=t}get lineWidth(){return this._$style._$lineWidth}set lineWidth(t){this._$style._$lineWidth=t}get lineCap(){return this._$style._$lineCap}set lineCap(t){switch(t){case S.NONE:case S.SQUARE:this._$style._$lineCap=t;break;default:this._$style._$lineCap=S.ROUND}}get lineJoin(){return this._$style._$lineJoin}set lineJoin(t){switch(t){case L.BEVEL:case L.MITER:this._$style._$lineJoin=t;break;default:this._$style._$lineJoin=L.ROUND}}get miterLimit(){return this._$style._$miterLimit}set miterLimit(t){this._$style._$miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=r.$clamp(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=r.$toBoolean(t)}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get pbo(){return this._$pbo}get blend(){return this._$blend}_$bind(t){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,r=t.width,s=t.height;this._$viewportWidth===r&&this._$viewportHeight===s||(this._$viewportWidth=r,this._$viewportHeight=s,this._$gl.viewport(0,0,r,s)),(e.dirty||i&&i.dirty)&&(e.dirty=!1,i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}fillRect(t,e,i,s){if(!i||!s)return;this._$viewportWidth=i,this._$viewportHeight=s;let n=!1;if(!this._$fillBuffer){n=!0;const a=this._$path.createRectVertices(t,e,i,s);this._$fillBuffer=this._$vao.createFill(a),r.$poolArray(a.pop()),r.$poolArray(a)}const a=this._$grid.enabled,o=this._$shaderList.shapeShaderVariants,h=o.getSolidColorShapeShader(!1,a),l=h.uniform;o.setSolidColorShapeUniform(l,!1,0,0,0,a,this._$matrix,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha),h._$fill(this._$fillBuffer),n&&(this._$vao.release(this._$fillBuffer),r.$poolArray(this._$fillBuffer.indexRanges)),this.beginPath()}setTransform(t,e,i,r,s,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=r,this._$matrix[6]=s,this._$matrix[7]=n}transform(t,e,i,r,s,n){const a=this._$matrix[0],o=this._$matrix[1],h=this._$matrix[3],l=this._$matrix[4],$=this._$matrix[6],_=this._$matrix[7];this._$matrix[0]=t*a+e*h,this._$matrix[1]=t*o+e*l,this._$matrix[3]=i*a+r*h,this._$matrix[4]=i*o+r*l,this._$matrix[6]=s*a+n*h+$,this._$matrix[7]=s*o+n*l+_}drawImage(t,e,i,r,s,n=null){let a=1,o=1,h=1,l=this._$globalAlpha,$=0,_=0,c=0;n&&(a=n[0],o=n[1],h=n[2],$=n[4]/255,_=n[5]/255,c=n[6]/255),this._$blend.drawImage(t,e,i,r,s,a,o,h,l,$,_,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,r=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=r,this._$gl.clearColor(t,e,i,r)}clearRect(t,e,i,r){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,r),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,r){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,r),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$startClip(t,e){return this._$mask._$startClip(t,e)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin(),this._$isGraphics&&(this._$fillBuffer&&(this.vao.release(this._$fillBuffer),this.vao.release(this._$fillBuffer.boundObject),r.$poolArray(this._$fillBuffer.indexRanges),r.$poolArray(this._$fillBuffer.boundObject.indexRanges)),this._$strokeBuffer&&this.vao.release(this._$strokeBuffer)),this._$isGraphics=!1,this._$fillBuffer=null,this._$strokeBuffer=null}quadraticCurveTo(t,e,i,r){this._$path.quadTo(t,e,i,r)}bezierCurveTo(t,e,i,r,s,n){this._$path.cubicTo(t,e,i,r,s,n)}_$getVertices(){return this._$path.vertices}fill(){let t,e,i,s=this._$matrix;switch(!0){case this.fillStyle.constructor===It:switch(this.fillStyle._$type){case w.LINEAR:break;default:s=this._$stack[this._$stack.length-1]}break;case this.fillStyle.constructor===Ft:s=this._$stack[this._$stack.length-1]}const n=this._$grid.enabled;switch(!0){case this.fillStyle.constructor===It:{const a=this.fillStyle,o=a._$stops,h="linearRGB"===a._$rgb;if(t=this._$gradientLUT.generateForShape(o,h),this._$frameBufferManager._$textureManager.bind0(t,!0),e=this._$shaderList.gradientShapeShaderVariants,a._$type===w.LINEAR)i=e.getGradientShapeShader(!1,n,!1,!1,a._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,a._$points,0);else{const t=0!==a._$focalPointRatio;i=e.getGradientShapeShader(!1,n,!0,t,a._$mode),e.setGradientShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,a._$points,a._$focalPointRatio)}}break;case this.fillStyle.constructor===Ft:{const a=this.fillStyle,o=a.colorTransform;t=a.texture,this._$frameBufferManager._$textureManager.bind0(t,this._$imageSmoothingEnabled),e=this._$shaderList.shapeShaderVariants,i=e.getBitmapShapeShader(!1,""!==a.repeat,n),o?e.setBitmapShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,o[0],o[1],o[2],this._$globalAlpha,o[4]/255,o[5]/255,o[6]/255,0):e.setBitmapShapeUniform(i.uniform,!1,0,0,0,n,s,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,t.width,t.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:e=this._$shaderList.shapeShaderVariants,i=e.getSolidColorShapeShader(!1,this._$grid.enabled),e.setSolidColorShapeUniform(i.uniform,!1,0,0,0,n,s,this._$viewportWidth,this._$viewportHeight,this._$grid,this.fillStyle,this._$globalAlpha)}const a=this._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,n);if(a.setMaskShapeUniform(o.uniform,n,s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],this._$viewportWidth,this._$viewportHeight,this._$grid),!this._$fillBuffer){const t=this._$getVertices();if(!t.length)return;const e=r.$getArray();for(let i=0;i<t.length;++i){const r=t[i];9>r.length||e.push(r)}if(!e.length)return;this._$isGraphics=!0,this._$fillBuffer=this._$vao.createFill(e);const i=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(i),r.$poolArray(i.pop()),r.$poolArray(i)}this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),o._$fill(this._$fillBuffer),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),i._$fill(this._$fillBuffer.boundObject),this._$gl.disable(this._$gl.STENCIL_TEST)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}_$unionStencilMask(t,e,i){this._$mask._$unionStencilMask(t,e,i)}closePath(){this._$path.close()}stroke(){if(!this._$strokeBuffer){const t=this._$getVertices();if(!t.length)return;const e=r.$getArray();for(let i=0;i<t.length;++i){const r=t[i];6>r.length||e.push(r)}if(!e.length)return;this._$isGraphics=!0,this._$strokeBuffer=this._$vao.createStroke(t,this.lineCap,this.lineJoin)}let t=this._$matrix;switch(!0){case this.strokeStyle.constructor===It:switch(this.strokeStyle._$type){case w.LINEAR:break;default:t=this._$stack[this._$stack.length-1]}break;case this.strokeStyle.constructor===Ft:t=this._$stack[this._$stack.length-1]}let e=r.$sign(t[0]*t[4]);e>0&&0!==t[1]&&0!==t[3]&&(e=-r.$sign(t[1]*t[3]));let i,s,n=.5*this.lineWidth;this._$grid.enabled?(n*=r.$getSameScaleBase(),i=r.$abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),s=r.$abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(i=r.$abs(t[0]+t[3]),s=r.$abs(t[1]+t[4]));const a=r.$min(i,s),o=r.$max(i,s);let h,l,$;n*=o*(1-.3*r.$cos(.5*r.$PI*(a/o))),n=r.$max(1,n);const _=this._$grid.enabled;switch(!0){case this.strokeStyle.constructor===It:{const i=this.strokeStyle,s=i._$stops,a="linearRGB"===i._$rgb;if(h=this._$gradientLUT.generateForShape(s,a),this._$frameBufferManager._$textureManager.bind0(h,!0),l=this._$shaderList.gradientShapeShaderVariants,i._$type===w.LINEAR)$=l.getGradientShapeShader(!0,_,!1,!1,i._$mode),l.setGradientShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,i._$points,0);else{const s=0!==i._$focalPointRatio;$=l.getGradientShapeShader(!0,_,!0,s,i._$mode),l.setGradientShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,i._$points,i._$focalPointRatio)}}break;case this.strokeStyle.constructor===Ft:{const i=this.strokeStyle,s=i.colorTransform;h=i.texture,this._$frameBufferManager._$textureManager.bind0(h),l=this._$shaderList.shapeShaderVariants,$=l.getBitmapShapeShader(!0,""!==i.repeat,this._$grid.enabled),s?l.setBitmapShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,h.width,h.height,s[0],s[1],s[2],this._$globalAlpha,s[4]/255,s[5]/255,s[6]/255,0):l.setBitmapShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,r.$inverseMatrix(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,h.width,h.height,1,1,1,this._$globalAlpha,0,0,0,0)}break;default:l=this._$shaderList.shapeShaderVariants,$=l.getSolidColorShapeShader(!0,this._$grid.enabled),l.setSolidColorShapeUniform($.uniform,!0,n,e,this.miterLimit,_,t,this._$viewportWidth,this._$viewportHeight,this._$grid,this.strokeStyle,this._$globalAlpha)}$._$stroke(this._$strokeBuffer)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(t=!1){const e=this._$shaderList.shapeShaderVariants,i=e.getMaskShapeShader(!1,!1),s=i.uniform;if(e.setMaskShapeUniform(s,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),!this._$fillBuffer){this._$fillBuffer=this._$vao.createFill(this._$getVertices());const t=this._$path.getBoundsVertices();this._$fillBuffer.boundObject=this._$vao.createFill(t),r.$poolArray(t.pop()),r.$poolArray(t)}this._$mask._$onClip(this._$matrix,this._$viewportWidth,this._$viewportHeight)||(i._$fill(this._$fillBuffer),t&&(this._$vao.release(this._$fillBuffer),this._$vao.release(this._$fillBuffer.boundObject),r.$poolArray(this._$fillBuffer.indexRanges),r.$poolArray(this._$fillBuffer.boundObject.indexRanges),this._$fillBuffer=null),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(r.$getFloat32Array9(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){this._$stack.length&&(r.$poolFloat32Array9(this._$matrix),this._$matrix=this._$stack.pop()),this._$mask._$onRestore()}createPattern(t,e,i){return this._$canvasPatternToWebGL._$initialization(t,e,i)}createLinearGradient(t,e,i,r,s=F.RGB,n=U.PAD){return this._$canvasGradientToWebGL.linear(t,e,i,r,s,n)}createRadialGradient(t,e,i,r,s,n,a=F.RGB,o=U.PAD,h=0){return this._$canvasGradientToWebGL.radial(t,e,i,r,s,n,a,o,h)}_$applyBlurFilter(t,e,i){const s=this._$frameBufferManager.currentAttachment,n=s.width,a=s.height;this._$frameBufferManager._$textureManager.bind0(t,!0);const o=r.$ceil(.5*i),h=1-(o-.5*i),l=1+i,$=this._$shaderList.filterShaderVariants,_=$.getBlurFilterShader(o);$.setBlurFilterUniform(_.uniform,n,a,e,h,l),_._$drawImage()}_$applyBitmapFilter(t,e,i,r,s,n,a,o,h,l,$,_,c,u,d,g,f,p,m,x,b,T,v,y,E,A){const M=c===Y.INNER,C=this._$frameBufferManager.currentAttachment,S=this._$frameBufferManager.getTextureFromCurrentAttachment();let R;const w=null!==g;let O;w&&(R=this._$gradientLUT.generateForFilter(g,f,p)),M?w?this._$frameBufferManager._$textureManager.bind02(t,R,!0):this._$frameBufferManager._$textureManager.bind0(t):(O=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(O),w?this._$frameBufferManager._$textureManager.bind012(t,S,R,!0):this._$frameBufferManager._$textureManager.bind01(t,S));const B=!(M||c===Y.FULL&&u),I=!(e===o&&i===h&&0===l&&0===$),F=!(1===d),L=this._$shaderList.filterShaderVariants,P=L.getBitmapFilterShader(B,I,_,c,u,F,w);L.setBitmapFilterUniform(P.uniform,e,i,r,s,n,a,o,h,l,$,_,d,m,x,b,T,v,y,E,A,B,I,F,w),M?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),P._$drawImage(),M||this._$frameBufferManager.releaseAttachment(C,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager._$textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,r=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(r.uniform,e),this.blend.reset(),r._$drawImage()}_$applyConvolutionFilter(t,e,i,r,s,n,a,o,h,l,$,_){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager._$textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,o);g.setConvolutionFilterUniform(f.uniform,c,u,r,s,n,o,h,l,$,_),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,r,s,n,a,o,h,l,$,_,c,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),s||(s={x:0,y:0}),this._$frameBufferManager._$textureManager.bind01(t,e);const p=this._$shaderList.filterShaderVariants,m=p.getDisplacementMapFilterShader(n,a,l);p.setDisplacementMapFilterUniform(m.uniform,e.width,e.height,i,r,s.x,s.y,o,h,l,$,_,c,u),this.blend.reset(),m._$drawImage()}getImageData(t,e,i,s){const n=i*s*4,a=r.$getUint8Array(n);this._$gl.readPixels(t,s-(s-e),i,s,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,a);for(let t=0;t<n;t+=4){const e=a[t+3];e&&(a[t]=255&r.$min(255*a[t]/e,255),a[t+1]=255&r.$min(255*a[t+1]/e,255),a[t+2]=255&r.$min(255*a[t+2]/e,255))}return a}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){r.$poolBoundsObject(this._$positions.pop()),this._$isLayer=r.$toBoolean(this._$blends.pop())}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$textureScale(t,e){const i=r.$max(t,e);return i>this._$maxTextureSize?this._$maxTextureSize/i:1}changeSamples(t=4){if(this._$isWebGL2Context){t=r.$min(t,this._$gl.getParameter(this._$gl.MAX_SAMPLES));const e=this._$frameBufferManager;e._$objectPool=[],e._$colorBufferPool._$objectPool=[],e._$stencilBufferPool._$objectPool=[],e._$colorBufferPool._$samples=t}}}class Pt{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case C.ADD:this.toAdd();break;case C.SCREEN:this.toScreen();break;case C.ALPHA:this.toAlpha();break;case C.ERASE:this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,i,s,n,a,o,h,l,$,_,c,u,d,g,f,p,m){const x=this._$context._$frameBufferManager.currentAttachment,b=1!==a||1!==o||1!==h||1!==l||0!==$||0!==_||0!==c||0!==u,T=this._$context._$shaderList.blendShaderVariants;switch(d){case C.NORMAL:case C.LAYER:case C.ADD:case C.SCREEN:case C.ALPHA:case C.ERASE:case"copy":{this._$context._$frameBufferManager._$textureManager.bind0(t,m);const x=T.getNormalBlendShader(b);T.setNormalBlendUniform(x.uniform,e,i,s,n,p,g,f,b,a,o,h,l,$,_,c,u);const v=p[0],y=p[1],E=p[3],A=p[4],M=p[6],C=p[7];if(1!==v||0!==y||0!==E||1!==A){const t=e+s,a=i+n,o=+(t*v+a*E+M),h=+(t*v+i*E+M),l=+(e*v+a*E+M),$=+(e*v+i*E+M),_=+(t*y+a*A+C),c=+(t*y+i*A+C),u=+(e*y+a*A+C),d=+(e*y+i*A+C),p=r.$MAX_VALUE,m=+r.$min(r.$min(r.$min(r.$min(p,o),h),l),$),x=+r.$max(r.$max(r.$max(r.$max(-p,o),h),l),$),b=+r.$min(r.$min(r.$min(r.$min(p,_),c),u),d),T=+r.$max(r.$max(r.$max(r.$max(-p,_),c),u),d),S=r.$max(0,0|m),R=r.$max(0,0|b),w=r.$min(r.$max(0,g-S),r.$ceil(r.$abs(x-m))),O=r.$min(r.$max(0,f-R),r.$ceil(r.$abs(T-b)));if(!w||!O)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(S,r.$max(0,f-(R+O)),w+1,O+1)}else{const t=r.$max(0,e+M|0),a=r.$max(0,i+C|0),o=r.$min(r.$max(0,g-t),s),h=r.$min(r.$max(0,f-a),n);if(!o||!h)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,r.$max(0,f-(a+h)),o+1,h+1)}this.toOperation(d),x._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const v=r.$max(0,e+p[6]|0),y=r.$max(0,i+p[7]|0),E=r.$min(r.$max(0,g-v),s),A=r.$min(r.$max(0,f-y),n);if(!E||!A)return;const M=this._$context._$frameBufferManager.getTextureFromCurrentAttachment(),C=this._$context._$frameBufferManager.createTextureAttachment(s,n);this._$context._$bind(C),this._$context._$frameBufferManager._$textureManager.bind0(M);const S=T.getClipShader(),R=S.uniform;T.setClipUniform(R,e,i,s,n,r.$inverseMatrix(p),g,f),this.reset(),S._$drawImage();const w=this._$context._$frameBufferManager.getTextureFromCurrentAttachment();this._$context._$bind(x),this._$context._$frameBufferManager._$textureManager.bind01(w,t,m);const O=T.getBlendShader(d,b);T.setBlendUniform(O.uniform,e,i,s,n,p,g,f,b,a,o,h,l,$,_,c,u),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(v,r.$max(0,f-(y+A)),E,A),this.toOneZero(),O._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),this._$context._$frameBufferManager.releaseAttachment(C,!0)}}}}class Dt{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}disable(){this.enabled=!1}}class Nt{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$clipStatus=!1,this._$containerClip=!1,this._$poolClip=[],this._$currentClip=!1}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context._$frameBufferManager,e=t.getTextureFromCurrentAttachment(),i=t.currentAttachment;this._$context._$bind(this._$context._$cacheCurrentBuffer),this._$context._$cacheCurrentBuffer=null,this._$context._$blend.disable();const s=this._$context._$cacheCurrentBounds.x,n=this._$context._$cacheCurrentBounds.y,a=this._$context._$cacheCurrentBounds.w,o=this._$context._$cacheCurrentBounds.h;r.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(e,s,n,a,o),this._$context._$blend.enable(),t.releaseAttachment(i,!0)}_$startClip(t,e){const i=r.$multiplicationMatrix(e,t._$transform._$rawMatrix()),s=t._$getBounds(null),n=r.$boundsMatrix(s,i);r.$poolFloat32Array9(i),r.$poolBoundsObject(s);let a=n.xMin,o=n.yMin,h=r.$abs(n.xMax-n.xMin),l=r.$abs(n.yMax-n.yMin);r.$poolBoundsObject(n);const $=this._$context._$frameBufferManager,_=$.currentAttachment;if(h+a>_.texture.width&&(h-=h-_.texture.width+a),l+o>_.texture.height&&(l-=l-_.texture.height+o),0>a&&(h+=a,a=0),0>o&&(l+=o,o=0),0>=h||0>=l)return null;h=r.$ceil(h),l=r.$ceil(l),this._$context._$cacheCurrentBounds.x=a,this._$context._$cacheCurrentBounds.y=o,this._$context._$cacheCurrentBounds.w=h,this._$context._$cacheCurrentBounds.h=l;const c=$.getTextureFromCurrentAttachment();this._$context._$cacheCurrentBuffer=_;const u=r.$currentPlayer(),d=!this._$context._$isWebGL2Context||u._$quality!==G.LOW&&u._$quality!==G.MIDDLE?0:r.$min(r.$HIGH_SAMPLES,this._$gl.getParameter(this._$gl.MAX_SAMPLES)),g=$.createCacheAttachment(h,l,!0,d);return this._$context._$bind(g),r.$resetContext(this._$context),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(c,-a,-o,c.width,c.height),r.$getFloat32Array9(e[0],e[1],e[2],e[3],e[4]-a,e[5]-o)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context._$frameBufferManager.currentAttachment;t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context._$frameBufferManager.currentAttachment;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context._$frameBufferManager.currentAttachment.clipLevel;let e=0;for(let i=0;i<t;++i)e|=(1<<t-i)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&e,e),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context._$frameBufferManager.currentAttachment;if(--t.clipLevel,t.mask=r.$toBoolean(t.clipLevel),!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context._$cacheCurrentBuffer&&this._$endClip());const e=t.width,i=t.height,s=this._$context._$path.createRectVertices(0,0,e,i),n=this._$context._$vao.createFill(s);r.$poolArray(s.pop()),r.$poolArray(s);const a=this._$context._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,!1),h=o.uniform;a.setMaskShapeUniformIdentity(h,e,i);const l=n.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),o._$containerClip(n,l.first,l.count),this._$context._$vao.release(n),r.$poolArray(n.indexRanges),this._$context._$endClipDef()}_$drawContainerClip(){const t=this._$context._$frameBufferManager.currentAttachment,e=t.clipLevel,i=this._$poolClip.length,r=this._$context._$shaderList.shapeShaderVariants,s=r.getMaskShapeShader(!1,!1),n=s.uniform;let a=e;const o=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);for(let t=0;t<i;++t){const t=this._$poolClip.shift();r.setMaskShapeUniform(n,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const i=t.fillBuffer.indexRanges.length;for(let e=0;e<i;++e){const i=t.fillBuffer.indexRanges[e];this._$gl.stencilMask(1<<a-1),s._$containerClip(t.fillBuffer,i.first,i.count)}++a,a>7&&(this._$context._$unionStencilMask(e,o,h),a=e)}a>e+1&&this._$context._$unionStencilMask(e,o,h)}_$unionStencilMask(t,e,i){const s=this._$context._$path.createRectVertices(0,0,e,i),n=this._$context._$vao.createFill(s);r.$poolArray(s.pop()),r.$poolArray(s);const a=this._$context._$shaderList.shapeShaderVariants,o=a.getMaskShapeShader(!1,!1),h=o.uniform;a.setMaskShapeUniformIdentity(h,e,i);const l=n.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),o._$containerClip(n,l.first,l.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT)),this._$context._$vao.release(n),r.$poolArray(n.indexRanges)}_$onClip(t,e,i){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip[this._$poolClip.length]={fillBuffer:this._$context._$fillBuffer,matrixA:t[0],matrixB:t[1],matrixC:t[2],matrixD:t[3],matrixE:t[4],matrixF:t[5],matrixG:t[6],matrixH:t[7],matrixI:t[8],viewportWidth:e,viewportHeight:i},!0)}_$onSave(){this._$clips[this._$clips.length]=this._$clipStatus}_$onRestore(){this._$clips.length&&(this._$clipStatus=r.$toBoolean(this._$clips.pop()))}}class Ut{constructor(){this._$currentPath=[],this._$vertices=[],this._$bounds={xMin:0,xMax:0,yMin:0,yMax:0},this._$resetBounds()}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)r.$poolArray(this._$vertices.pop());this._$resetBounds()}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,r){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,r)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,r,!1))}cubicTo(t,e,i,s,n,a){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(n,a))return;const o=this._$currentPath[this._$currentPath.length-3],h=this._$currentPath[this._$currentPath.length-2];(class{static cubicToQuad(t,e,i,s,n,a,o,h){this._$split2Cubic(t,e,i,s,n,a,o,h,0,16),this._$split2Cubic(r.$bezierConverterBuffer[0],r.$bezierConverterBuffer[1],r.$bezierConverterBuffer[2],r.$bezierConverterBuffer[3],r.$bezierConverterBuffer[4],r.$bezierConverterBuffer[5],r.$bezierConverterBuffer[6],r.$bezierConverterBuffer[7],0,8),this._$split2Cubic(r.$bezierConverterBuffer[16],r.$bezierConverterBuffer[17],r.$bezierConverterBuffer[18],r.$bezierConverterBuffer[19],r.$bezierConverterBuffer[20],r.$bezierConverterBuffer[21],r.$bezierConverterBuffer[22],r.$bezierConverterBuffer[23],16,24),this._$split2Quad(r.$bezierConverterBuffer[0],r.$bezierConverterBuffer[1],r.$bezierConverterBuffer[2],r.$bezierConverterBuffer[3],r.$bezierConverterBuffer[4],r.$bezierConverterBuffer[5],r.$bezierConverterBuffer[6],r.$bezierConverterBuffer[7],0),this._$split2Quad(r.$bezierConverterBuffer[8],r.$bezierConverterBuffer[9],r.$bezierConverterBuffer[10],r.$bezierConverterBuffer[11],r.$bezierConverterBuffer[12],r.$bezierConverterBuffer[13],r.$bezierConverterBuffer[14],r.$bezierConverterBuffer[15],8),this._$split2Quad(r.$bezierConverterBuffer[16],r.$bezierConverterBuffer[17],r.$bezierConverterBuffer[18],r.$bezierConverterBuffer[19],r.$bezierConverterBuffer[20],r.$bezierConverterBuffer[21],r.$bezierConverterBuffer[22],r.$bezierConverterBuffer[23],16),this._$split2Quad(r.$bezierConverterBuffer[24],r.$bezierConverterBuffer[25],r.$bezierConverterBuffer[26],r.$bezierConverterBuffer[27],r.$bezierConverterBuffer[28],r.$bezierConverterBuffer[29],r.$bezierConverterBuffer[30],r.$bezierConverterBuffer[31],24)}static _$split2Cubic(t,e,i,s,n,a,o,h,l,$){const _=.125*(t+3*(i+n)+o),c=.125*(e+3*(s+a)+h),u=.125*(o+n-i-t),d=.125*(h+a-s-e);r.$bezierConverterBuffer[l]=t,r.$bezierConverterBuffer[l+1]=e,r.$bezierConverterBuffer[l+2]=.5*(t+i),r.$bezierConverterBuffer[l+3]=.5*(e+s),r.$bezierConverterBuffer[l+4]=_-u,r.$bezierConverterBuffer[l+5]=c-d,r.$bezierConverterBuffer[l+6]=_,r.$bezierConverterBuffer[l+7]=c,r.$bezierConverterBuffer[$]=_,r.$bezierConverterBuffer[$+1]=c,r.$bezierConverterBuffer[$+2]=_+u,r.$bezierConverterBuffer[$+3]=c+d,r.$bezierConverterBuffer[$+4]=.5*(n+o),r.$bezierConverterBuffer[$+5]=.5*(a+h),r.$bezierConverterBuffer[$+6]=o,r.$bezierConverterBuffer[$+7]=h}static _$split2Quad(t,e,i,s,n,a,o,h,l){const $=.125*(t+3*(i+n)+o),_=.125*(e+3*(s+a)+h);r.$bezierConverterBuffer[l]=.25*t+.75*i,r.$bezierConverterBuffer[l+1]=.25*e+.75*s,r.$bezierConverterBuffer[l+2]=$,r.$bezierConverterBuffer[l+3]=_,r.$bezierConverterBuffer[l+4]=.75*n+.25*o,r.$bezierConverterBuffer[l+5]=.75*a+.25*h,r.$bezierConverterBuffer[l+6]=o,r.$bezierConverterBuffer[l+7]=h}}).cubicToQuad(o,h,t,e,i,s,n,a);const l=r.$bezierConverterBuffer.length;for(let t=0;t<l;)this.quadTo(r.$bezierConverterBuffer[t++],r.$bezierConverterBuffer[t++],r.$bezierConverterBuffer[t++],r.$bezierConverterBuffer[t++])}drawCircle(t,e,i){const r=i,s=.5522847498307936*i;this.cubicTo(t+r,e+s,t+s,e+r,t,e+r),this.cubicTo(t-s,e+r,t-r,e+s,t-r,e),this.cubicTo(t-r,e-s,t-s,e-r,t,e-r),this.cubicTo(t+s,e-r,t+r,e-s,t+r,e)}close(){if(this._$currentPath.length<=6)return;const t=this._$currentPath[0],e=this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=this._$currentPath[this._$currentPath.length-3],r=this._$currentPath[this._$currentPath.length-2];return t===i&&e===r}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t),this._$currentPath.push(e),this._$currentPath.push(i),this._$bounds.xMin=r.$min(t,this._$bounds.xMin),this._$bounds.xMax=r.$max(t,this._$bounds.xMax),this._$bounds.yMin=r.$min(e,this._$bounds.yMin),this._$bounds.yMax=r.$max(e,this._$bounds.yMax)}_$pushCurrentPathToVertices(){this._$currentPath.length<=3?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=r.$getArray())}_$resetBounds(){const t=r.$MAX_VALUE;this._$bounds.xMin=t,this._$bounds.xMax=-t,this._$bounds.yMin=t,this._$bounds.yMax=-t}getBoundsVertices(){return r.$getArray(r.$getArray(this._$bounds.xMin,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMin,!1,this._$bounds.xMax,this._$bounds.yMax,!1,this._$bounds.xMin,this._$bounds.yMax,!1))}createRectVertices(t,e,i,s){return r.$getArray(r.$getArray(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class kt{constructor(){this._$fillStyle=new r.$window.Float32Array([1,1,1,1]),this._$strokeStyle=new r.$window.Float32Array([1,1,1,1]),this._$lineWidth=1,this._$lineCap=0,this._$lineJoin=0,this._$miterLimit=5}}class Gt{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=[]}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();return t.stencil=this._$gl.createRenderbuffer(),t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}return this._$objectPool.shift()}create(t,e,i=0){t=r.$max(256,r.$upperPowerOfTwo(t)),e=r.$max(256,r.$upperPowerOfTwo(e));const s=this._$getColorBuffer(t*e);return(s.width<t||s.height<e||i&&s.samples!==i)&&(t=r.$max(t,s.width),e=r.$max(e,s.height),s.samples=i||this._$samples,s.width=t,s.height=e,s.area=t*e,s.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,s),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,s.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,i||this._$samples,this._$gl.STENCIL_INDEX8,t,e)),s}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,i=this._$objectPool.length;for(;r.$abs(i-e)>1;){const s=r.$floor((i+e)/2);t<=this._$objectPool[s].area?i=s:e=s}return i}}const Xt={vertices:null};Xt.subhulls=new Array(512),Xt.subhullsIndex=0,Xt.extremePoints=new Array(32),Xt.extremePointsIndex=0,Xt.t=0,Xt.hulls=[new Array(16),new Array(64),new Array(256)],Xt.hullsIndex=0;class Yt{constructor(t,e,i){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),this._$frameBufferTexture=null,this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new Vt(t,e),this._$colorBufferPool=null,this._$stencilBufferPool=new jt(t),e&&(this._$frameBufferTexture=t.createFramebuffer(),this._$colorBufferPool=new Gt(t,i),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer))}get currentAttachment(){return this._$currentAttachment}createCacheAttachment(t,e,i=!1,r=0){const s=this._$objectPool.length?this._$objectPool.pop():{},n=this._$textureManager.create(t,e);return s.width=t,s.height=e,this._$isWebGL2Context&&i?(s.color=this._$colorBufferPool.create(t,e,r),s.texture=n,s.msaa=!0,s.stencil=s.color.stencil):(s.color=n,s.texture=n,s.msaa=!1,s.stencil=this._$stencilBufferPool.create(n.width,n.height)),s.mask=!1,s.clipLevel=0,s.isActive=!0,s}createTextureAttachment(t,e){const i=this._$objectPool.length?this._$objectPool.pop():{},r=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=r,i.texture=r,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.length?this._$objectPool.pop():{};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t,e=!1){t.isActive&&(t.msaa?this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):(this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment.msaa)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,r=!1,s=!0){return this._$textureManager.create(t,e,i,r,s)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t){return this._$textureManager.createFromImage(t)}createAlphaTextureFromPixels(t,e,i){return this._$textureManager.createAlpha(t,e,i)}createTextureFromVideo(t,e=!1,i=null){return this._$textureManager.createFromVideo(t,e,i)}createTextureFromCurrentAttachment(){const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class Ht{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[]}_$getPixelBufferObject(t){if(!this._$objectPool.length){const t=this._$gl.createBuffer();return t.size=0,t}for(let e=0;e<this._$objectPool.length;e++){const i=this._$objectPool[e];if(i.size===t)return this._$objectPool.splice(e,1),i}return this._$objectPool.shift()}readPixelsAsync(t,e,i,r){if(!this._$isWebGL2Context)return null;const s=i*r*4,n=this._$getPixelBufferObject(s);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,n),n.size!==s&&(n.size=s,this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER,s,this._$gl.DYNAMIC_COPY)),this._$gl.readPixels(t,e,i,r,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,0),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),n}getBufferSubDataAsync(t){const e=r.$getUint8Array(t.size);return this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,t),this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER,0,e),this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER,null),this._$objectPool.push(t),e}release(t){this._$objectPool.push(t)}}class jt{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let r=0;r<i;r++){const i=this._$objectPool[r];if(i.width===t&&i.height===e)return this._$objectPool.splice(r,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t)}}}class Vt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(e,i){const r=this._$gl.createTexture();return r.width=0,r.height=0,r.area=0,r.dirty=!0,r.smoothing=!0,r._$offsetX=0,r._$offsetY=0,this.bind0(r,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$isWebGL2Context&&(r.width=e,r.height=i,r.area=e*i,r.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,e,i),t.glstats&&glstats.ontex(r.area)),r}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const r=this._$objectPool[i];if(r.width===t&&r.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=r.area,this.bind0(r,!1),r}return this._$createTexture(t,e)}createAlpha(t,e,i){return this._$alphaTexture?this.bind0(this._$alphaTexture):(this._$alphaTexture=this._$gl.createTexture(),this.bind0(this._$alphaTexture),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,this._$gl.NEAREST),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,this._$gl.NEAREST)),this._$alphaTexture.width=t,this._$alphaTexture.height=e,this._$alphaTexture.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.ALPHA,t,e,0,this._$gl.ALPHA,this._$gl.UNSIGNED_BYTE,i),this._$alphaTexture}create(e,i,r=null,s=!1,n=!0){const a=this._$getTexture(e,i);return s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,a.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,e,i,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,r),t.glstats&&glstats.ontex(a.area)):r&&(a.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,e,i,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,r)),s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),a}createFromImage(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1,null)}createFromVideo(t,e=!1,i=null){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e,i)}_$createFromElement(e,i,r,s=!1,n=null){const a=n||this._$getTexture(e,i);return a.dirty=!1,this.bind0(a,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),a.width!==e||a.height!==i?(a.width=e,a.height=i,a.area=e*i,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,r),t.glstats&&glstats.ontex(a.area)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,r),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),a}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2|0)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,r=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,r),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i,s){const n=i!==this._$boundTextures[t],a=null!==s&&s!==i.smoothing;if((n||a)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),n&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),a){i.smoothing=s;const t=s&&r.$currentPlayer()._$quality!==G.LOW?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class zt{constructor(t,e){this._$gl=t,this._$isWebGL2Context=e,this._$fillVertexArrayPool=[],this._$strokeVertexArrayPool=[],this._$boundVertexArray=null,this._$extension=e?null:t.getExtension("OES_vertex_array_object"),this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new r.$window.Float32Array([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$createVertexArray(){return this._$isWebGL2Context?this._$gl.createVertexArray():this._$extension.createVertexArrayOES()}_$getVertexArray(t,e){const i=this._$createVertexArray();this.bind(i);const r=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,r),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length)return this._$fillVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length)return this._$strokeVertexArrayPool.pop();const t=this._$createVertexArray();this.bind(t);const e=this._$gl.createBuffer();t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=class{static generate(t){let e=0;for(let i=0;i<t.length;i++)e+=12*(t[i].length/3-2);this._$vertexBufferData=new r.$Float32Array(e),this._$indexRanges=r.$getArray(),this._$currentIndex=0;for(let e=0;e<t.length;e++){const i=this._$currentIndex;this._$generateMesh(t[e]);const r=this._$currentIndex-i;this._$indexRanges.push({first:i,count:r})}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const r=t.length-5;for(let s=3;s<r;s+=3){let r=4*i;t[s+2]?(e[r++]=t[s-3],e[r++]=t[s-2],e[r++]=0,e[r++]=0,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=0,e[r++]=t[s+3],e[r++]=t[s+4],e[r++]=1,e[r++]=1):t[s+5]?(e[r++]=t[0],e[r++]=t[1],e[r++]=.5,e[r++]=.5,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=.5,e[r++]=t[s+6],e[r++]=t[s+7],e[r++]=.5,e[r++]=.5):(e[r++]=t[0],e[r++]=t[1],e[r++]=.5,e[r++]=.5,e[r++]=t[s],e[r++]=t[s+1],e[r++]=.5,e[r++]=.5,e[r++]=t[s+3],e[r++]=t[s+4],e[r++]=.5,e[r++]=.5),i+=3}this._$currentIndex=i}}.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=r.$upperPowerOfTwo(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const s=class{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new r.$Float32Array(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new r.$Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const r=this._$vertexBufferPos;this._$generateLineJoin(i,r),this._$generateLineCap(i,r)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new r.$Float32Array(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new r.$Int16Array(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,r,s,n){const a=11;let o=t,h=e;for(let l=1;l<a;l++){const $=l/a,_=1-$,c=(t*_+i*$)*_+(i*_+s*$)*$,u=(e*_+r*$)*_+(r*_+n*$)*$;this._$addLineSegmentMesh(o,h,c,u,2),o=c,h=u}this._$addLineSegmentMesh(o,h,s,n)}static _$addLineSegmentMesh(t,e,i,r,s=1){const n=this._$vertexBufferPos/7,a=n+1,o=n+2,h=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let $=this._$indexBufferPos;l[$++]=n,l[$++]=a,l[$++]=h,l[$++]=h,l[$++]=o,l[$++]=n,this._$indexBufferPos=$,this._$expandVertexBufferIfNeeded(28);const _=this._$vertexBufferData;let c=this._$vertexBufferPos;_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=r,_[c++]=1,_[c++]=1,_[c++]=1,_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=r,_[c++]=-1,_[c++]=-1,_[c++]=1,_[c++]=i,_[c++]=r,_[c++]=t,_[c++]=e,_[c++]=-1,_[c++]=-1,_[c++]=s,_[c++]=i,_[c++]=r,_[c++]=t,_[c++]=e,_[c++]=1,_[c++]=1,_[c++]=s,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,r=e-55;for(let e=t;e<r;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,i,s,n,a,o,h,l,$,_){const c=i-t,u=s-e,d=a-i,g=o-s,f=r.$cross(c,u,d,g);if(!(r.$abs(f)<1e-4))if(2!==n)switch(this._$lineJoin){case L.ROUND:this._$addRoundJoinMesh(i,s);break;case L.MITER:this._$addMiterJoinMesh(i,s,t,e,a,o,$,h,l,_);break;default:this._$addBevelJoinMesh(i,s,$,h,l,_)}else this._$addBevelJoinMesh(i,s,$,h,l,_)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const r=this._$indexBufferData;let s=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;r[s++]=i,r[s++]=e,r[s++]=e+1}r[s++]=i,r[s++]=i+18,r[s++]=i+1,this._$indexBufferPos=s,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,r,s,n,a,o,h,l){const $=this._$vertexBufferPos/7,_=$+1,c=$+2,u=$+3,d=$+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=$,g[f++]=a,g[f++]=_,g[f++]=$,g[f++]=_,g[f++]=c,g[f++]=$,g[f++]=c,g[f++]=o,g[f++]=$,g[f++]=h,g[f++]=u,g[f++]=$,g[f++]=u,g[f++]=d,g[f++]=$,g[f++]=d,g[f++]=l,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const p=this._$vertexBufferData;let m=this._$vertexBufferPos;p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=r,p[m++]=s,p[m++]=n,p[m++]=0,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=r,p[m++]=s,p[m++]=n,p[m++]=21,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=r,p[m++]=s,p[m++]=n,p[m++]=22,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=r,p[m++]=s,p[m++]=n,p[m++]=23,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=r,p[m++]=s,p[m++]=n,p[m++]=24,this._$vertexBufferPos=m}static _$addBevelJoinMesh(t,e,i,r,s,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let h=this._$indexBufferPos;o[h++]=a,o[h++]=i,o[h++]=r,o[h++]=a,o[h++]=s,o[h++]=n,this._$indexBufferPos=h,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let $=this._$vertexBufferPos;l[$++]=t,l[$++]=e,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,l[$++]=0,this._$vertexBufferPos=$}static _$generateLineCap(t,e){const i=this._$vertexBufferData,r=i[t],s=i[t+1],n=i[t+2],a=i[t+3],o=i[e-7],h=i[e-6],l=i[e-5],$=i[e-4],_=t/7,c=e/7;r!==o||s!==h?(this._$addLineCapMesh(r,s,n,a,_,_+1),this._$addLineCapMesh(o,h,l,$,c-1,c-2)):this._$addLineJoinMesh(l,$,r,s,n,a,c-2,c-1,_,_+1)}static _$addLineCapMesh(t,e,i,r,s,n){switch(this._$lineCap){case S.ROUND:this._$addRoundJoinMesh(t,e);break;case S.SQUARE:this._$addSquareCapMesh(t,e,i,r,s,n)}}static _$addSquareCapMesh(t,e,i,r,s,n){const a=this._$vertexBufferPos/7,o=a+1;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let l=this._$indexBufferPos;h[l++]=s,h[l++]=a,h[l++]=o,h[l++]=o,h[l++]=n,h[l++]=s,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const $=this._$vertexBufferData;let _=this._$vertexBufferPos;$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=r,$[_++]=-1,$[_++]=-1,$[_++]=10,$[_++]=t,$[_++]=e,$[_++]=i,$[_++]=r,$[_++]=1,$[_++]=1,$[_++]=10,this._$vertexBufferPos=_}}.generate(t,e,i),n=s.vertexBufferData,a=s.indexBufferData,o=this._$getStrokeVertexArray();return o.indexCount=a.length,this.bind(o),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,o.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,o.indexBuffer),o.vertexLength<n.length&&(o.vertexLength=r.$upperPowerOfTwo(n.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*o.vertexLength,this._$gl.DYNAMIC_DRAW)),o.indexLength<a.length&&(o.indexLength=r.$upperPowerOfTwo(a.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*o.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,n),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,a),o}release(t){t.indexBuffer?this._$strokeVertexArrayPool.push(t):this._$fillVertexArrayPool.push(t)}bind(t){if(t){if(t===this._$boundVertexArray)return;this._$boundVertexArray=t}else this._$boundVertexArray=null;this._$isWebGL2Context?this._$gl.bindVertexArray(t):this._$extension.bindVertexArrayOES(t)}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class Wt{constructor(t,e,i,r){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,r),this._$uniform=new Zt(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(t,e){const r=this._$gl.createProgram();r.id=i++;const s=this._$gl.createShader(this._$gl.VERTEX_SHADER);if(this._$gl.shaderSource(s,t),this._$gl.compileShader(s),!this._$gl.getShaderParameter(s,this._$gl.COMPILE_STATUS)){const e=this._$gl.getShaderInfoLog(s);throw new Error("vertex shader compilation failed: "+e+"\n"+t)}const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);if(this._$gl.shaderSource(n,e),this._$gl.compileShader(n),!this._$gl.getShaderParameter(n,this._$gl.COMPILE_STATUS)){const t=this._$gl.getShaderInfoLog(n);throw new Error("fragment shader compilation failed: "+t+"\n"+e)}if(this._$context._$isWebGL2Context||(this._$gl.bindAttribLocation(r,0,"a_vertex"),this._$gl.bindAttribLocation(r,1,"a_bezier"),this._$gl.bindAttribLocation(r,1,"a_option1"),this._$gl.bindAttribLocation(r,2,"a_option2"),this._$gl.bindAttribLocation(r,3,"a_type")),this._$gl.attachShader(r,s),this._$gl.attachShader(r,n),this._$gl.linkProgram(r),!this._$gl.getProgramParameter(r,this._$gl.LINK_STATUS)){const i=this._$gl.getProgramInfoLog(r);throw new Error("link program failed: "+i+"\n"+t+"\n========\n"+e)}return this._$gl.detachShader(r,s),this._$gl.detachShader(r,n),this._$gl.deleteShader(s),this._$gl.deleteShader(n),r}_$attachProgram(){this._$context._$shaderList._$currentProgramId!==this._$program.id&&(this._$context._$shaderList._$currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(e,i){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(e,i),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawElements(this._$gl.TRIANGLES,e.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(e){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e);const i=e.indexRanges[e.indexRanges.length-1],r=i.first+i.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,r)}_$containerClip(e,i,r){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.TRIANGLES,i,r)}_$drawPoints(e,i,r){t.glstats&&glstats.ondraw(),this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(e),this._$gl.drawArrays(this._$gl.POINTS,i,r)}}class qt{constructor(t,e){const i=new Qt(e,t._$isWebGL2Context);this._$currentProgramId=-1,this._$shapeShaderVariants=new Bt(t,e,i),this._$bitmapShaderVariants=new Ct(t,e,i),this._$gradientShapeShaderVariants=new Ot(t,e,i),this._$gradientLUTShaderVariants=new wt(t,e,i),this._$filterShaderVariants=new Rt(t,e,i),this._$blendShaderVariants=new St(t,e,i);const r={opaque:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.COLOR_TRANSFORM.bind(null,!1)),transparent:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.COLOR_TRANSFORM.bind(null,!0))},s={opaque:new Jt(t,e,i,Et.SRC_AND_DST_TEX_COORD,bt.COPY_CHANNEL.bind(null,!1)),transparent:new Jt(t,e,i,Et.SRC_AND_DST_TEX_COORD,bt.COPY_CHANNEL.bind(null,!0))},n={opaque:new Jt(t,e,i,Et.SRC_AND_DST_TEX_COORD,bt.MERGE.bind(null,!1)),transparent:new Jt(t,e,i,Et.SRC_AND_DST_TEX_COORD,bt.MERGE.bind(null,!0))},a={opaque:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.PALETTE_MAP.bind(null,!1)),transparent:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.PALETTE_MAP.bind(null,!0))},o={color:new Jt(t,e,i,Et.POSITION_ONLY,bt.FILL_COLOR),texture:{opaque:new Jt(t,e,i,Et.PIXEL_DISSOLVE_TEXTURE,bt.PIXEL_DISSOLVE_TEXTURE.bind(null,!1)),transparent:new Jt(t,e,i,Et.PIXEL_DISSOLVE_TEXTURE,bt.PIXEL_DISSOLVE_TEXTURE.bind(null,!0))}},h=new Jt(t,e,i,Et.SRC_TEX_COORD,bt.COPY_SRC_TEX),l={withAlphaBitmapData:new Jt(t,e,i,Et.SRC_AND_ALPHA_TEX_COORD,bt.COPY_PIXELS_WITH_ALPHA_BITMAP_DATA),noAlphaBitmapData:h},$=new Jt(t,e,i,Et.POSITION_ONLY,bt.FILL_COLOR),_=new Jt(t,e,i,Et.POSITION_ONLY,bt.NOISE),c=function(r){return{discardSource:{opaque:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.THRESHOLD.bind(null,r,!1,!1)),transparent:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.THRESHOLD.bind(null,r,!1,!0))},copySource:{opaque:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.THRESHOLD.bind(null,r,!0,!1)),transparent:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.THRESHOLD.bind(null,r,!0,!0))}}},u={less:c("less"),lessEqual:c("lessEqual"),greater:c("greater"),greaterEqual:c("greaterEqual"),equal:c("thresholdEqual"),notEqual:c("thresholdNotEqual"),subtotal:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.THRESHOLD_SUBTOTAL)},d={findColor:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.GET_COLOR_BOUNDS_RECT.bind(null,!0)),findNotColor:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.GET_COLOR_BOUNDS_RECT.bind(null,!1))},g={RGBA:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.GET_PIXELS.bind(null,"RGBA")),BGRA:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.GET_PIXELS.bind(null,"BGRA")),ARGB:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.GET_PIXELS.bind(null,"ARGB"))},f={RGBA:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.SET_PIXELS.bind(null,"RGBA")),BGRA:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.SET_PIXELS.bind(null,"BGRA")),ARGB:new Jt(t,e,i,Et.SRC_TEX_COORD,bt.SET_PIXELS.bind(null,"ARGB"))},p=new Jt(t,e,i,Et.SET_PIXEL_QUEUE,bt.SET_PIXEL_QUEUE);this._$bitmapData={colorTransform:r,copyChannel:s,merge:n,paletteMap:a,pixelDissolve:o,copyPixels:l,scroll:h,fillRect:$,noise:_,threshold:u,getColorBoundsRect:d,getPixels:g,setPixels:f,setPixelQueue:p}}get shapeShaderVariants(){return this._$shapeShaderVariants}get bitmapShaderVariants(){return this._$bitmapShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Kt{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=r.$floor(.75*this._$gl.getParameter(this._$gl.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new r.$Float32Array(256),this._$rgbIdentityTable=new r.$Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=r.$pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const i=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const s=t.length,n=this._$context._$shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let i=0;i<s;i+=this._$maxLength-1){const o=r.$min(i+this._$maxLength,s),h=n.getGradientLUTShader(o-i,e),l=h.uniform;n.setGradientLUTUniformForShape(l,t,i,o,a),h._$drawGradient(0===i?0:t[i][0],o===s?1:t[o-1][0])}return this._$context._$bind(i),this._$attachment.texture}generateForFilter(t,e,i){const s=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context._$shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let s=0;s<n;s+=this._$maxLength-1){const o=r.$min(s+this._$maxLength,n),h=a.getGradientLUTShader(o-s,!1),l=h.uniform;a.setGradientLUTUniformForFilter(l,t,e,i,s,o),h._$drawGradient(0===s?0:t[s],o===n?1:t[o-1])}return this._$context._$bind(s),this._$attachment.texture}}class Qt{constructor(t,e){this._$isWebGL2Context=e,e||t.getExtension("OES_standard_derivatives")}version(){return this._$isWebGL2Context?"#version 300 es":""}attribute(t){return this._$isWebGL2Context?`layout (location = ${t}) in`:"attribute"}varyingOut(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"out":"varying"}varyingIn(t=!1){return this._$isWebGL2Context?(t?"centroid ":"")+"in":"varying"}outColor(){return this._$isWebGL2Context?"out vec4 o_color;":""}fragColor(){return this._$isWebGL2Context?"o_color":"gl_FragColor"}texture2D(){return this._$isWebGL2Context?"texture":"texture2D"}extensionDerivatives(){return this._$isWebGL2Context?"":"#extension GL_OES_standard_derivatives : enable"}}class Jt{constructor(t,e,i,r,s){this._$context=t,this._$gl=e,this._$keyword=i,this._$vertexSource=r,this._$fragmentSource=s,this._$instance=null}get instance(){return this._$instance||(this._$instance=new Wt(this._$gl,this._$context,this._$vertexSource(this._$keyword),this._$fragmentSource(this._$keyword))),this._$instance}}class Zt{constructor(t,e){this._$gl=t,this._$array=[],this._$map=new Map;const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t),r=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,s={},n=this._$gl.getUniformLocation(e,r);if(i.type!==this._$gl.SAMPLER_2D||1!==i.size){switch(i.type){case this._$gl.FLOAT_VEC4:s.method=this._$gl.uniform4fv.bind(this._$gl,n),s.array=new Float32Array(4*i.size),s.assign=-1;break;case this._$gl.INT_VEC4:s.method=this._$gl.uniform4iv.bind(this._$gl,n),s.array=new Int32Array(4*i.size),s.assign=-1;break;case this._$gl.SAMPLER_2D:s.method=this._$gl.uniform1iv.bind(this._$gl,n),s.array=new Int32Array(i.size),s.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(s),this._$map.set(r,s)}}}getArray(t){return this._$map.get(t).array}get textures(){return this._$map.get("u_textures").array}get highp(){return this._$map.get("u_highp").array}get mediump(){return this._$map.get("u_mediump").array}get integer(){return this._$map.get("u_integer").array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array))}}}class te{constructor(){this._$stage=new k,this._$stage._$player=this,this._$cacheStore=new pt,this._$mode="loader",this._$actionOffset=0,this._$actions=r.$getArray(),this._$loaders=r.$getArray(),this._$sounds=r.$getMap(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$mouseWheelEvent=null,this._$ratio=r.$devicePixelRatio,this._$stopFlag=!0,this._$startTime=0,this._$fps=60,this._$isLoad=!1,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=new r.$window.Float32Array([1,0,0,1,0,0]),this._$backgroundColor="transparent",this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$textarea=null,this._$broadcastEvents=r.$getMap(),this._$context=null,this._$canvas=null,this._$buffer=null,this._$optionWidth=0,this._$optionHeight=0,this._$tagId=null,this._$bgcolor="",this._$base="",this._$quality=G.HIGH,this._$sources=r.$getArray(),this._$videos=r.$getArray(),this._$bindRun=this._$run.bind(this),this._$timerId=-1,this._$loadId=-1}static get LOAD_START(){return 1}static get LOAD_END(){return 2}get broadcastEvents(){return this._$broadcastEvents}get base(){return this._$base}set base(t){if("string"==typeof t)if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${r.$location.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else{const e=t.split("?")[0].split("/");e.pop(),this._$base=`${e.join("/")}/`}}get stage(){return this._$stage}get contentElementId(){return`${r.$PREFIX}`}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}play(){if(this._$stopFlag){if(this._$stopFlag=!1,this._$timerId>-1){(0,r.$cancelAnimationFrame)(this._$timerId)}this._$startTime=r.$performance.now(),this._$fps=1e3/this._$stage._$frameRate;const t=r.$requestAnimationFrame;this._$timerId=t(this._$bindRun)}}stop(){(0,r.$cancelAnimationFrame)(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,r.$cacheStore().reset()}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this._$bgcolor=t.bgcolor||this._$bgcolor,this.base=t.base||this._$base),this._$initialize()}_$updateLoadStatus(){if(this._$loadStatus===te.LOAD_END)return void this._$loaded();const t=r.$requestAnimationFrame;this._$loadId=t(this._$updateLoadStatus.bind(this))}_$loaded(){const t=r.$document.getElementById(this.contentElementId);if(t){this._$bgcolor&&(this._$backgroundColor=this._$bgcolor),this._$context&&(this._$backgroundColor&&"transparent"!==this._$backgroundColor?this._$context._$setColor(this._$backgroundColor[0],this._$backgroundColor[1],this._$backgroundColor[2],this._$backgroundColor[3]):this._$context._$setColor(0,0,0,0)),this._$deleteNode(),t.appendChild(this._$canvas),this.play(),this._$stage._$prepareActions(),this._$broadcastEvents.has(a.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new a(a.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(a.EXIT_FRAME)&&this._$dispatchEvent(new a(a.EXIT_FRAME));const e=0|this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t instanceof D&&(t._$lock=!1),t.hasEventListener(a.INIT)&&t.dispatchEvent(new a(a.INIT)),t.hasEventListener(a.COMPLETE)&&t.dispatchEvent(new a(a.COMPLETE)),t._$player=null}this._$broadcastEvents.has(a.ACTIVATE)&&this._$dispatchEvent(new a(a.ACTIVATE)),this._$doAction(),this._$draw()}}_$initialize(){const t=r.$document;if("loading"===t.readyState){const t=function(e){e.target.removeEventListener("DOMContentLoaded",t),this._$initialize()}.bind(this);return void r.$window.addEventListener("DOMContentLoaded",t)}const e=this.contentElementId;if(null===this._$tagId)t.body.insertAdjacentHTML("beforeend",`<div id="${e}"></div>`);else{const i=t.getElementById(this._$tagId);if(!i)return void alert("Not Found Tag ID:"+this._$tagId);if(t.getElementById(e))this._$deleteNode();else{const r=t.createElement("div");r.id=e,r.tabIndex=-1,i.appendChild(r)}}this._$canvas||this._$initializeCanvas();const i=t.getElementById(e),s=i.parentNode;if(s){this._$initStyle(i),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===s.tagName?r.$window.innerWidth:s.offsetWidth,e=this._$optionHeight?this._$optionHeight:"BODY"===s.tagName?r.$window.innerHeight:s.offsetHeight;"loader"===this._$mode&&t&&e&&(this._$baseWidth=t,this._$baseHeight=e,this._$resize())}"loader"===this._$mode?(this._$loadStatus=te.LOAD_START,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(e){const i=e.style;i.position="relative",i.top="0",i.left="0",i.backgroundColor="transparent",i.overflow="hidden",i.padding="0",i.margin="0",i.userSelect="none",i.outline="none";const r=this._$optionWidth,s=this._$optionHeight,n=e.parentNode;if("BODY"===n.tagName)return i.width=r?`${r}px`:`${t.innerWidth}px`,void(i.height=s?`${s}px`:`${t.innerHeight}px`);i.width=r?`${r}px`:`${n.offsetWidth}px`,i.height=s?`${s}px`:`${n.offsetHeight}px`}_$buildWait(){const t=r.$document.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=r.$document.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=r.$document.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){const e=r.$document.createElement("canvas");e.width=1,e.height=1,this._$canvas=e;const i={stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1};let s=!0,n=e.getContext("webgl2",i);if(n||(n=e.getContext("webgl",i)||e.getContext("experimental-webgl",i),s=!1),n?this._$context=new Lt(n,s):alert("WebGL setting is off. Please turn the setting on."),t.glstats&&glstats.init(n,s,r.$isChrome,r.$isFireFox),r.$isTouch){const t=function(e){e.target.removeEventListener(r.$TOUCH_START,t),r.$loadAudioData()};e.addEventListener(r.$TOUCH_START,t),e.addEventListener(r.$TOUCH_START,function(t){r.$event=t,r.$eventType=r.$TOUCH_START,this._$hitTest()}.bind(this)),e.addEventListener(r.$TOUCH_MOVE,function(t){r.$event=t,r.$eventType=r.$TOUCH_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(r.$TOUCH_END,function(t){r.$event=t,r.$eventType=r.$TOUCH_END,this._$hitTest()}.bind(this))}else{const t=function(e){e.target.removeEventListener(r.$MOUSE_DOWN,t),r.$loadAudioData()};e.addEventListener(r.$MOUSE_DOWN,t),e.addEventListener(r.$MOUSE_DOWN,function(t){r.$event=t,r.$eventType=r.$MOUSE_DOWN,t.button||this._$hitTest()}.bind(this)),e.addEventListener(r.$DOUBLE_CLICK,function(t){r.$event=t,r.$eventType=r.$DOUBLE_CLICK,t.button||this._$hitTest()}.bind(this)),e.addEventListener(r.$MOUSE_LEAVE,function(t){r.$event=t,r.$eventType=r.$MOUSE_LEAVE,this._$hitTest(),r.$event=null,this._$stageX=-1,this._$stageY=-1}.bind(this)),e.addEventListener(r.$MOUSE_UP,function(t){r.$event=t,r.$eventType=r.$MOUSE_UP,t.button||this._$hitTest()}.bind(this)),e.addEventListener(r.$MOUSE_MOVE,function(t){r.$event=t,r.$eventType=r.$MOUSE_MOVE,this._$hitTest()}.bind(this)),e.addEventListener(r.$MOUSE_WHEEL,function(t){this._$mouseWheelEvent=t}.bind(this))}const a=e.style;a.position="absolute",a.top="0",a.left="0",a.webkitTapHighlightColor="rgba(0,0,0,0)",a.backfaceVisibility="hidden",a.transformOrigin="0 0",1!==r.$devicePixelRatio&&(a.transform=`scale(${1/r.$devicePixelRatio})`)}_$resize(){const t=r.$document.getElementById(this.contentElementId);if(t){const e=t.parentNode,i=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?r.$window.innerWidth:e.offsetWidth?e.offsetWidth:r.$parseFloat(e.style.width),s=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?r.$window.innerHeight:e.offsetHeight?e.offsetHeight:r.$parseFloat(e.style.height),n="BODY"===e.tagName?r.$window.innerWidth:e.offsetWidth,a=r.$min(i/this._$baseWidth,s/this._$baseHeight);let o=this._$baseWidth*a|0,h=this._$baseHeight*a|0;const l=t.style;if(l.width=`${o}px`,l.height=`${h}px`,l.top="0",l.left=n/2-o/2+"px",o!==this._$width/this._$ratio||h!==this._$height/this._$ratio){if(o=o*r.$devicePixelRatio|0,h=h*r.$devicePixelRatio|0,this._$scale=a,this._$width=o,this._$height=h,this._$canvas.width=o,this._$canvas.height=h,this._$canvas.style.transform=1===this._$ratio&&1===r.$devicePixelRatio?"":`scale(${1/this._$ratio})`,this._$context){this._$context._$gl.viewport(0,0,o,h);const t=this._$context._$frameBufferManager;this._$buffer&&(t.unbind(),t.releaseAttachment(this._$buffer,!0)),this._$buffer=t.createCacheAttachment(o,h,!1),t._$stencilBufferPool._$maxWidth=o,t._$stencilBufferPool._$maxHeight=h,t._$textureManager._$maxWidth=o,t._$textureManager._$maxHeight=h}const t=this._$scale*this._$ratio;this._$matrix[0]=t,this._$matrix[3]=t,this._$stage._$doChanged(),this._$cacheStore.reset()}}}getSamples(){switch(this._$quality){case G.HIGH:return r.$HIGH_SAMPLES;case G.MEDIUM:return r.$MEDIUM_SAMPLES;default:return r.$LOW_SAMPLES}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t._$eventPhase=h.AT_TARGET;const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(t._$currentTarget=i.target,t._$listener=i.listener,i.listener.call(r.$window,t),t._$stopImmediatePropagation)break}return r.$poolArray(e),!0}}_$wheelEvent(){const t=this._$mouseWheelEvent;t&&(t.defaultPrevented||(r.$event=t,r.$eventType=r.$MOUSE_WHEEL,this._$hitTest()),this._$mouseWheelEvent=null)}_$run(e=0){if(this._$stopFlag)return;t.stats&&stats.begin(),t.glstats&&glstats.begin(),this._$wheelEvent(),this._$doAction();let i=e-this._$startTime;i>this._$fps&&(this._$startTime=e-i%this._$fps,this._$action(),this._$draw(0),!this._$hitTestStart&&"up"===this._$state&&r.$event&&this._$stageX>-1&&this._$stageY>-1&&this._$pointerCheck()),t.stats&&stats.end(),t.glstats&&glstats.end();const s=r.$requestAnimationFrame;this._$timerId=s(this._$bindRun)}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath(),this._$stage._$mouseHit(r.$hitContext,r.$MATRIX_ARRAY_IDENTITY,this._$hitObject,!0);let i=null,s=null,n=!1,a=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(c.MOUSE_OUT)&&t.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==i){let r=null;if(this._$rollOverObject)for(s=this._$rollOverObject,s.willTrigger(c.ROLL_OUT)&&s.dispatchEvent(new c(c.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),r=s._$parent;r&&r._$root!==r&&r!==i;){if(r._$mouseEnabled&&r._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===r){t=!0;break}e=e._$parent}if(!t&&r._$parent===i._$parent&&r._$index>i._$index&&(t=!0),t)break}r.willTrigger(c.ROLL_OUT)&&r.dispatchEvent(new c(c.ROLL_OUT,!1,!1,r.mouseX,r.mouseY)),r=r._$parent}for(s=i;s.willTrigger(c.ROLL_OVER)&&s.dispatchEvent(new c(c.ROLL_OVER,!1,!1,s.mouseX,s.mouseY)),s=s._$parent,s&&s!==r&&s.stage!==s;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i.willTrigger(c.MOUSE_OVER)&&i.dispatchEvent(new c(c.MOUSE_OVER,!0,!1,i.mouseX,i.mouseY)),this._$mouseOverTarget=i}if("up"===this._$state&&(this._$clickTarget=null),!r.$isTouch&&"up"===this._$state)for(s=i;s&&s.root!==s;){switch(!0){case s instanceof rt:s._$type===st.INPUT&&(n=!0);break;case s.buttonMode:a=!0}if(n||a)break;s=s._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(c.MOUSE_OUT)&&i.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,i.mouseX,i.mouseY))),this._$rollOverObject)for(s=this._$rollOverObject;s&&s.root!==s;)s.willTrigger(c.ROLL_OUT)&&s.dispatchEvent(new c(c.ROLL_OUT,!1,!1,s.mouseX,s.mouseY)),s=s._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case n:this._$canvas.style.cursor="text";break;case a:this._$canvas.style.cursor="pointer";break;case!r.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has(a.ENTER_FRAME)&&this._$dispatchEvent(new a(a.ENTER_FRAME)),this._$broadcastEvents.has(a.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new a(a.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has(a.EXIT_FRAME)&&this._$dispatchEvent(new a(a.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new a(a.RENDER))),e){for(let i=0;i<e;++i){const e=t[i];e.hasEventListener(a.INIT)&&e.dispatchEvent(new a(a.INIT)),e.hasEventListener(a.COMPLETE)&&e.dispatchEvent(new a(a.COMPLETE))}r.$poolArray(t)}this._$doAction()}_$draw(){const t=this._$canvas,e=t.width,i=t.height,s=this._$context;if(this._$stage._$updated&&s&&e>0&&i>0){if(s._$bind(this._$buffer),r.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,e,i),s.beginPath(),this._$stage._$draw(s,this._$matrix,r.$COLOR_ARRAY_IDENTITY,!1),this._$stage._$updated=!1,this._$sounds.size){const t=this._$sounds.values();for(let e of t)e._$soundPlay();this._$sounds.clear()}const t=s.frameBuffer.getTextureFromCurrentAttachment();s.frameBuffer.unbind(),r.$resetContext(s),s.setTransform(1,0,0,1,0,0),s.clearRect(0,0,e,i),s.drawImage(t,0,0,e,i),s._$bind(this._$buffer)}}_$doAction(){for(;this._$actions.length;){r.$actionProcess=!0;const t=this._$actions.pop();t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;t._$actionProcess=!0;const i=t._$actions.get(e),s=i.length;for(let e=0;e<s;++e)i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}r.$actionProcess=!1}_$hitTest(){if(this._$stopFlag)return;this._$hitTestStart=!0,r.$isUpdated=!1;const t=r.$event;let e=null,i=null,s=null,n=r.$window.pageXOffset,a=r.$window.pageYOffset;const o=r.$document.getElementById(this.contentElementId);if(o){const t=o.getBoundingClientRect();n+=t.left,a+=t.top}let h=0,$=0;if(r.$isTouch){const e=t.changedTouches[0];h=e.pageX,$=e.pageY}else h=t.pageX,$=t.pageY;h=(h-n)/this._$scale,$=($-a)/this._$scale,t._$stageX=h,t._$stageY=$,this._$stageX=h,this._$stageY=$,this._$hitObject.x=h,this._$hitObject.y=$,this._$hitObject.pointer="",this._$hitObject.hit=null,r.$hitContext.setTransform(1,0,0,1,0,0),r.$hitContext.beginPath(),this._$stage._$mouseHit(r.$hitContext,r.$MATRIX_ARRAY_IDENTITY,this._$hitObject,!0);let _=!1,u=!1,d=!1;switch(r.$eventType){case r.$TOUCH_MOVE:case r.$MOUSE_MOVE:if(r.$dropTarget){const t=r.$dropTarget._$dragMousePoint();let e=t.x,i=t.y;r.$dragRules.lock||(e+=r.$dragRules.position.x,i+=r.$dragRules.position.y);const s=r.$dragRules.bounds;s&&(e=r.$clamp(e,s.left,s.right),i=r.$clamp(i,s.top,s.bottom)),r.$dropTarget.x=e,r.$dropTarget.y=i}break;case r.$TOUCH_START:case r.$MOUSE_DOWN:this._$state="down",d="pointer"===this._$canvas.style.cursor,u=!0;break;case r.$TOUCH_END:case r.$MOUSE_UP:case r.$DOUBLE_CLICK:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case r.$eventType===r.$MOUSE_LEAVE:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(c.MOUSE_OUT)&&e.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,e.mouseX,e.mouseY))),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(c.ROLL_OUT)&&i.dispatchEvent(new c(c.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,r.$eventType){case r.$MOUSE_WHEEL:this._$stage.hasEventListener(c.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new c(c.MOUSE_WHEEL,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$TOUCH_START:case r.$MOUSE_DOWN:this._$stage.hasEventListener(c.MOUSE_DOWN)&&this._$stage.dispatchEvent(new c(c.MOUSE_DOWN,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$TOUCH_END:case r.$MOUSE_UP:this._$textarea&&(s=this._$textarea._$instance,this._$textarea.dispatchEvent(new r.$window.Event("swf2js_blur")),s.willTrigger(l.FOCUS_OUT)&&s.dispatchEvent(new l(l.FOCUS_OUT,!0)),this._$textarea=null,this.stage.focus=null),this._$stage.hasEventListener(c.CLICK)&&this._$stage.dispatchEvent(new c(c.CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY)),this._$stage.hasEventListener(c.MOUSE_UP)&&this._$stage.dispatchEvent(new c(c.MOUSE_UP,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$TOUCH_MOVE:case r.$MOUSE_MOVE:this._$stage.hasEventListener(c.MOUSE_MOVE)&&this._$stage.dispatchEvent(new c(c.MOUSE_MOVE,!0,!1,this._$stage.mouseX,this._$stage.mouseY));break;case r.$DOUBLE_CLICK:this._$stage.hasEventListener(c.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new c(c.DOUBLE_CLICK,!0,!1,this._$stage.mouseX,this._$stage.mouseY))}break;default:switch(e=this._$hitObject.hit,r.$eventType){case r.$TOUCH_MOVE:case r.$MOUSE_MOVE:if(e.willTrigger(c.MOUSE_MOVE)&&e.dispatchEvent(new c(c.MOUSE_MOVE,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(c.MOUSE_OUT)&&t.dispatchEvent(new c(c.MOUSE_OUT,!0,!1,t.mouseX,t.mouseY))}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(c.ROLL_OUT)&&i.dispatchEvent(new c(c.ROLL_OUT,!1,!1,i.mouseX,i.mouseY)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(h,$)){let i=!1,r=e;for(;r&&r._$root!==r;){if(r===t){i=!0;break}r=r._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(c.ROLL_OUT)&&t.dispatchEvent(new c(c.ROLL_OUT,!1,!1,t.mouseX,t.mouseY)),t=t._$parent}for(i=e;i.willTrigger(c.ROLL_OVER)&&i.dispatchEvent(new c(c.ROLL_OVER,!1,!1,i.mouseX,i.mouseY)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(c.MOUSE_OVER)&&e.dispatchEvent(new c(c.MOUSE_OVER,!0,!1,e.mouseX,e.mouseY)),this._$mouseOverTarget=e}"up"===this._$state&&(this._$clickTarget=null);break;case r.$TOUCH_START:case r.$MOUSE_DOWN:this.stage._$focus!==e&&(this._$stage.focus=e instanceof rt?e:null),e.willTrigger(c.MOUSE_DOWN)&&e.dispatchEvent(new c(c.MOUSE_DOWN,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=e;break;case r.$TOUCH_END:case r.$MOUSE_UP:e.willTrigger(c.MOUSE_UP)&&e.dispatchEvent(new c(c.MOUSE_UP,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget===e&&e.willTrigger(c.CLICK)&&e.dispatchEvent(new c(c.CLICK,!0,!1,e.mouseX,e.mouseY)),this._$clickTarget=null;break;case r.$MOUSE_WHEEL:e.willTrigger(c.MOUSE_WHEEL)&&e.dispatchEvent(new c(c.MOUSE_WHEEL)),e instanceof rt&&(e.scrollV+=t.deltaY);break;case r.$DOUBLE_CLICK:e.willTrigger(c.DOUBLE_CLICK)&&e.dispatchEvent(new c(c.DOUBLE_CLICK))}if(!u&&!r.$isTouch&&"up"===this._$state)for(i=e;i&&i.root!==i;){if(i instanceof rt){if(i._$type===st.INPUT){_=!0;break}}else if(i._$buttonMode){d=!0;break}i=i._$parent}}switch(!0){case _:this._$canvas.style.cursor="text";break;case d:this._$canvas.style.cursor="pointer";break;case!r.$isTouch&&"up"===this._$state:this._$canvas.style.cursor="auto"}!r.$actionProcess&&this._$actions.length>1&&this._$doAction(),r.$isUpdated&&(t.preventDefault(),this._$stage._$prepareActions(),r.$actionProcess||this._$doAction()),this._$hitTestStart=!1}}r.$window.next2d=new class{constructor(){this._$player=new te}load(t,e=null){if("develop"===t){const e=r.$location.search.substr(1).split("&")[0];if(!e)return;t=`${r.$location.origin}/${e}`}if(!t)return;e&&"base"in e||(this._$player.base=t),this._$player.setOptions(e);const i=new P,s=i.contentLoaderInfo;s.addEventListener(_.IO_ERROR,(function(t){t.target.removeEventListener(_.IO_ERROR,t.listener),alert("Error: "+t.message)})),s.addEventListener(a.COMPLETE,(function(t){const e=t.target;e.removeEventListener(a.COMPLETE,t.listener);const i=r.$currentPlayer(),s=i.stage,n=e._$data.stage;i.width=n.width,i.height=n.height,i.stage.frameRate=n.fps;const o=r.$intToRGBA(0|`0x${n.bgColor.substr(1)}`);i._$context._$setColor(o.R/255,o.G/255,o.B/255,1),i._$backgroundColor=[o.R/255,o.G/255,o.B/255,1],s.addChild(e.content),i._$resize()})),i.load(new dt(t))}createRootMovieClip(t=240,e=240,i=60,r=null){const s=this._$player;return s._$loadStatus=te.LOAD_END,s._$mode="create",s._$stage.frameRate=0|i,s.width=0|t,s.height=0|e,s.setOptions(r),s._$stage.addChild(new E)}},r.$packages(r.$window.next2d),console.log("%c next2d.js %c 1.0.0 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729","")}(window);