(()=>{"use strict";let t=0;const e=1/0,i=Math,s=Array,r=Map,n=Number,a=Float32Array,h=Int32Array,o=Int16Array,l=OffscreenCanvas,_=isNaN,$=requestAnimationFrame,c=cancelAnimationFrame,u=performance,d=setTimeout,g=clearTimeout,f=new a([1,0,0,1,0,0]),p=new a([1,1,1,1,0,0,0,0]),m=-32768,x=32767,b=i.PI/180,v=180/i.PI,T=[],y=[],E=[],M=[],A=[],w=[],C=[],S=[],F=new l(1,1).getContext("2d"),B=(t=0,e=0,i=0,s=0)=>{const r=S.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return r.xMin=t,r.xMax=e,r.yMin=i,r.yMax=s,r},R=t=>{S.push(t)},I=(t=0,e=0,i=0,s=0)=>{const r=y.pop()||new a(4);return r[0]=t,r[1]=e,r[2]=i,r[3]=s,r},L=t=>{y.push(t)},P=(t=0,e=0,i=0,s=0,r=0,n=0)=>{const h=E.pop()||new a(6);return h[0]=t,h[1]=e,h[2]=i,h[3]=s,h[4]=r,h[5]=n,h},O=t=>{E.push(t)},k=(t=1,e=1,i=1,s=1,r=0,n=0,h=0,o=0)=>{const l=M.pop()||new a(8);return l[0]=t,l[1]=e,l[2]=i,l[3]=s,l[4]=r,l[5]=n,l[6]=h,l[7]=o,l},N=t=>{M.push(t)},D=(t=0,e=0,i=0,s=0,r=0,n=0,h=0,o=0,l=0)=>{const _=A.pop()||new a(9);return _[0]=t,_[1]=e,_[2]=i,_[3]=s,_[4]=r,_[5]=n,_[6]=h,_[7]=o,_[8]=l,_},U=(...t)=>{const e=w.pop()||[];return t.length&&e.push(...t),e},G=(t=null)=>{t&&(t.length&&(t.length=0),w.push(t))},V=t=>{t.size&&t.clear(),C.push(t)},Y=()=>C.pop()||new r,X=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),z=t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],s=819.2*t[0]-819.2*t[2]+t[4],r=-819.2*t[0]+819.2*t[2]+t[4],n=-819.2*t[1]-819.2*t[3]+t[5],a=819.2*t[1]-819.2*t[3]+t[5];let h=r-e,o=-819.2*t[1]+819.2*t[3]+t[5]-n;const l=i.sqrt(h*h+o*o);l?(h/=l,o/=l):(h=0,o=0);const _=(s-e)*h+(a-n)*o;return I(e+_*h,n+_*o,s,a)},H=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return D(t[4]*e,0-t[1]*e,0,0-t[3]*e,t[0]*e,0,i*e,s*e,1)},W=(t,e,s,r=null)=>{const n=+t;return _(n)&&null!==r?r:i.min(i.max(e,_(n)?0:n),s)},j=(t,e)=>P(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),q=(t,e)=>k(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),K=(t,e)=>{const s=t.xMax*e[0]+t.yMax*e[2]+e[4],r=t.xMax*e[0]+t.yMin*e[2]+e[4],a=t.xMin*e[0]+t.yMax*e[2]+e[4],h=t.xMin*e[0]+t.yMin*e[2]+e[4],o=t.xMax*e[1]+t.yMax*e[3]+e[5],l=t.xMax*e[1]+t.yMin*e[3]+e[5],_=t.xMin*e[1]+t.yMax*e[3]+e[5],$=t.xMin*e[1]+t.yMin*e[3]+e[5],c=i.min(n.MAX_VALUE,s,r,a,h),u=i.max(0-n.MAX_VALUE,s,r,a,h),d=i.min(n.MAX_VALUE,o,l,_,$),g=i.max(0-n.MAX_VALUE,o,l,_,$);return B(c,u,d,g)},Q=t=>{if(!F)return 0;F.fillStyle=t;const e=+`0x${F.fillStyle.slice(1)}`;return F.fillStyle="rgba(0, 0, 0, 1)",e},J=t=>_(+t)?Q(`${t}`):+t,Z=t=>({A:t>>>24,R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t}),tt=(t,e,i)=>(t>>16)*(i?e:1)/255,et=(t,e,i)=>(t>>8&255)*(i?e:1)/255,it=(t,e,i)=>(255&t)*(i?e:1)/255,st=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),rt=(t,e,i=!1,s=!1)=>{let r="";return i&&(r="italic "),s&&(r+="bold "),`${r}${e}px '${t}','sans-serif'`},nt=t=>{t.color&&N(t.color),t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.filters=null,t.blendMode="normal",T.push(t)};class at{_$x;_$y;constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return i.sqrt(i.pow(this.x,2)+i.pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=W(+t,m,x,0)}get y(){return this._$y}set y(t){this._$y=W(+t,m,x,0)}add(t){return new at(this.x+t.x,this.y+t.y)}clone(){return new at(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return i.sqrt(i.pow(t._$x-e._$x,2)+i.pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new at(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new at(t*i.cos(e),t*i.sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new at(this.x-t.x,this.y-t.y)}}class ht{_$matrix;constructor(t=1,e=0,i=0,s=1,r=0,n=0){this._$matrix=P(1,0,0,1,0,0),this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}static toString(){return"[class Matrix]"}static get namespace(){return"next2d.geom.Matrix"}toString(){return`(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`}get namespace(){return"next2d.geom.Matrix"}get a(){return this._$matrix[0]}set a(t){this._$matrix[0]=W(+t,m,x,0)}get b(){return this._$matrix[1]}set b(t){this._$matrix[1]=W(+t,m,x,0)}get c(){return this._$matrix[2]}set c(t){this._$matrix[2]=W(+t,m,x,0)}get d(){return this._$matrix[3]}set d(t){this._$matrix[3]=W(+t,m,x,0)}get tx(){return this._$matrix[4]}set tx(t){this._$matrix[4]=W(+t,m,x,0)}get ty(){return this._$matrix[5]}set ty(t){this._$matrix[5]=W(+t,m,x,0)}_$clone(){return this.clone()}clone(){return Vi(this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5])}concat(t){const e=this._$matrix,i=t._$matrix;let s=e[0]*i[0],r=0,n=0,a=e[3]*i[3],h=e[4]*i[0]+i[4],o=e[5]*i[3]+i[5];(e[1]||e[2]||i[1]||i[2])&&(s+=e[1]*i[2],a+=e[2]*i[1],r+=e[0]*i[1]+e[1]*i[3],n+=e[2]*i[0]+e[3]*i[2],h+=e[5]*i[2],o+=e[4]*i[1]),this.a=s,this.b=r,this.c=n,this.d=a,this.tx=h,this.ty=o}copyFrom(t){this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty}createBox(t,e,i=0,s=0,r=0){this.identity(),this.rotate(i),this.scale(t,e),this.translate(s,r)}createGradientBox(t,e,i=0,s=0,r=0){this.createBox(t/1638.4,e/1638.4,i,s+t/2,r+e/2)}deltaTransformPoint(t){return new at(t.x*this._$matrix[0]+t.y*this._$matrix[2],t.x*this._$matrix[1]+t.y*this._$matrix[3])}identity(){this._$matrix[0]=1,this._$matrix[1]=0,this._$matrix[2]=0,this._$matrix[3]=1,this._$matrix[4]=0,this._$matrix[5]=0}invert(){const t=this._$matrix[0],e=this._$matrix[1],i=this._$matrix[2],s=this._$matrix[3],r=this._$matrix[4],n=this._$matrix[5];if(0===e&&0===i)this.a=1/t,this.b=0,this.c=0,this.d=1/s,this.tx=-this.a*r,this.ty=-this.d*n;else{const a=t*s-e*i;if(a){const h=1/a;this.a=s*h,this.b=-e*h,this.c=-i*h,this.d=t*h,this.tx=-(this.a*r+this.c*n),this.ty=-(this.b*r+this.d*n)}}}rotate(t){const e=this._$matrix[0],s=this._$matrix[1],r=this._$matrix[2],n=this._$matrix[3],a=this._$matrix[4],h=this._$matrix[5];this.a=e*i.cos(t)-s*i.sin(t),this.b=e*i.sin(t)+s*i.cos(t),this.c=r*i.cos(t)-n*i.sin(t),this.d=r*i.sin(t)+n*i.cos(t),this.tx=a*i.cos(t)-h*i.sin(t),this.ty=a*i.sin(t)+h*i.cos(t)}scale(t,e){this.a*=t,this.c*=t,this.tx*=t,this.b*=e,this.d*=e,this.ty*=e}setTo(t,e,i,s,r,n){this.a=t,this.b=e,this.c=i,this.d=s,this.tx=r,this.ty=n}transformPoint(t){return new at(t.x*this._$matrix[0]+t.y*this._$matrix[2]+this._$matrix[4],t.x*this._$matrix[1]+t.y*this._$matrix[3]+this._$matrix[5])}translate(t,e){this.tx+=t,this.ty+=e}}class ot{_$colorTransform;constructor(t=1,e=1,i=1,s=1,r=0,n=0,a=0,h=0){this._$colorTransform=k(),this.redMultiplier=t,this.greenMultiplier=e,this.blueMultiplier=i,this.alphaMultiplier=s,this.redOffset=r,this.greenOffset=n,this.blueOffset=a,this.alphaOffset=h}static toString(){return"[class ColorTransform]"}static get namespace(){return"next2d.geom.ColorTransform"}toString(){return"(redMultiplier="+this._$colorTransform[0]+", greenMultiplier="+this._$colorTransform[1]+", blueMultiplier="+this._$colorTransform[2]+", alphaMultiplier="+this._$colorTransform[3]+", redOffset="+this._$colorTransform[4]+", greenOffset="+this._$colorTransform[5]+", blueOffset="+this._$colorTransform[6]+", alphaOffset="+this._$colorTransform[7]+")"}get namespace(){return"next2d.geom.ColorTransform"}get alphaMultiplier(){return this._$colorTransform[3]}set alphaMultiplier(t){this._$colorTransform[3]=W(+t,0,1,0)}get alphaOffset(){return this._$colorTransform[7]}set alphaOffset(t){this._$colorTransform[7]=W(0|t,-255,255,0)}get blueMultiplier(){return this._$colorTransform[2]}set blueMultiplier(t){this._$colorTransform[2]=W(+t,0,1,0)}get blueOffset(){return this._$colorTransform[6]}set blueOffset(t){this._$colorTransform[6]=W(0|t,-255,255,0)}get greenMultiplier(){return this._$colorTransform[1]}set greenMultiplier(t){this._$colorTransform[1]=W(+t,0,1,0)}get greenOffset(){return this._$colorTransform[5]}set greenOffset(t){this._$colorTransform[5]=W(0|t,-255,255,0)}get redMultiplier(){return this._$colorTransform[0]}set redMultiplier(t){this._$colorTransform[0]=W(+t,0,1,0)}get redOffset(){return this._$colorTransform[4]}set redOffset(t){this._$colorTransform[4]=W(0|t,-255,255,0)}concat(t){const e=q(this._$colorTransform,t._$colorTransform);this.redMultiplier=e[0],this.greenMultiplier=e[1],this.blueMultiplier=e[2],this.alphaMultiplier=e[3],this.redOffset=e[4],this.greenOffset=e[5],this.blueOffset=e[6],this.alphaOffset=e[7],N(e)}_$clone(){return Xi(this._$colorTransform[0],this._$colorTransform[1],this._$colorTransform[2],this._$colorTransform[3],this._$colorTransform[4],this._$colorTransform[5],this._$colorTransform[6],this._$colorTransform[7])}}class lt{_$name;_$value;constructor(t="",e=""){this._$name=`${t}`,this._$value=`${e}`}static toString(){return"[class URLRequestHeader]"}static get namespace(){return"next2d.net.URLRequestHeader"}toString(){return"[object URLRequestHeader]"}get namespace(){return"next2d.net.URLRequestHeader"}get name(){return this._$name}get value(){return this._$value}}class _t{static toString(){return"[class EventPhase]"}static get namespace(){return"next2d.events.EventPhase"}toString(){return"[object EventPhase]"}get namespace(){return"next2d.events.EventPhase"}static get AT_TARGET(){return 2}static get BUBBLING_PHASE(){return 3}static get CAPTURING_PHASE(){return 1}}class $t{_$type;_$bubbles;_$cancelable;_$target;_$currentTarget;_$listener;_$eventPhase;_$stopImmediatePropagation;_$stopPropagation;constructor(t,e=!1,i=!1){this._$type=`${t}`,this._$bubbles=e,this._$cancelable=i,this._$target=null,this._$currentTarget=null,this._$eventPhase=_t.AT_TARGET,this._$listener=null,this._$stopImmediatePropagation=!1,this._$stopPropagation=!1}static toString(){return"[class Event]"}static get namespace(){return"next2d.events.Event"}toString(){return this.formatToString("Event","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.Event"}static get ACTIVATE(){return"activate"}static get ADDED(){return"added"}static get ADDED_TO_STAGE(){return"addedToStage"}static get CHANGE(){return"change"}static get COMPLETE(){return"complete"}static get DEACTIVATE(){return"deactivate"}static get ENTER_FRAME(){return"enterFrame"}static get EXIT_FRAME(){return"exitFrame"}static get FRAME_CONSTRUCTED(){return"frameConstructed"}static get FRAME_LABEL(){return"frameLabel"}static get INIT(){return"init"}static get LOAD(){return"load"}static get MOUSE_LEAVE(){return"mouseLeave"}static get REMOVED(){return"removed"}static get REMOVED_FROM_STAGE(){return"removedFromStage"}static get RENDER(){return"render"}static get RESIZE(){return"resize"}static get SCROLL(){return"scroll"}static get OPEN(){return"open"}static get STOP(){return"stop"}static get SOUND_COMPLETE(){return"soundComplete"}static get UPDATE(){return"update"}get bubbles(){return this._$bubbles}get cancelable(){return this._$cancelable}get currentTarget(){return this._$currentTarget}set currentTarget(t){this._$currentTarget=t}get eventPhase(){return this._$eventPhase}set eventPhase(t){this._$eventPhase=t}get listener(){return this._$listener}set listener(t){this._$listener=t}get target(){return this._$target?this._$target:this._$currentTarget}set target(t){this._$target=t}get type(){return this._$type}formatToString(...t){let e=`[${t[0]}`;for(let i=1;i<t.length;++i){const s=t[i];e+=` ${s}=`;const r=this[s];e+="string"==typeof r?`"${r}"`:`${r}`}return`${e}]`}stopImmediatePropagation(){this._$stopImmediatePropagation=!0}stopPropagation(){this._$stopPropagation=!0}}let ct=0;const ut=()=>ct++;let dt=0,gt=null;const ft=(t=null)=>{gt=t};let pt="";const mt=t=>{pt=t};let xt=null;const bt=()=>xt,vt=(t=null)=>{xt=t};let Tt=!1;const yt=(t=!0)=>{Tt=t};let Et=1;const Mt=()=>Et;class At{_$events;constructor(){this._$events=null}static toString(){return"[class EventDispatcher]"}static get namespace(){return"next2d.events.EventDispatcher"}toString(){return"[object EventDispatcher]"}get namespace(){return"next2d.events.EventDispatcher"}addEventListener(t,e,i=!1,s=0){const r=Ui();let n,a=!1;switch(t=`${t}`){case $t.ENTER_FRAME:case $t.EXIT_FRAME:case $t.FRAME_CONSTRUCTED:case $t.RENDER:case $t.ACTIVATE:case $t.DEACTIVATE:case"keyDown":case"keyUp":r.broadcastEvents.size&&r.broadcastEvents.has(t)||r.broadcastEvents.set(t,U()),n=r.broadcastEvents.get(t)||U(),a=!0;break;default:this._$events||(this._$events=Y()),this._$events.size&&this._$events.has(t)||this._$events.set(t,U()),n=this._$events.get(t)||U()}let h=n.length;for(let t=0;t<h;++t){const s=n[t];i===s.useCapture&&s.target===this&&s.listener===e&&(h=t)}n[h]={listener:e,priority:s,useCapture:i,target:this},n.length>1&&n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),a?r.broadcastEvents.set(t,n):(this._$events||(this._$events=Y()),this._$events.set(t,n))}dispatchEvent(t){switch(t.type){case $t.ENTER_FRAME:case $t.EXIT_FRAME:case $t.FRAME_CONSTRUCTED:case $t.RENDER:case $t.ACTIVATE:case $t.DEACTIVATE:case"keyDown":case"keyUp":{const e=Ui();if(e&&e.broadcastEvents.size&&e.broadcastEvents.has(t.type)){const i=e.broadcastEvents.get(t.type);for(let e=0;e<i.length;++e){const s=i[e];if(s.target===this){t.eventPhase=_t.AT_TARGET,t.currentTarget=s.target;try{t.listener=s.listener,s.listener.call(null,t)}catch(t){return console.error(t),!1}}}return!0}}break;default:{let e=null;this._$events&&this._$events.size&&this._$events.has(t.type)&&(e=this._$events.get(t.type),e&&(e=e.slice(0))),e||(e=U());const i=U();if("parent"in this){let e=this.parent;for(;e;){if(e.hasEventListener(t.type)){const s=e._$events?e._$events.get(t.type):void 0;s&&i.push(s)}e=e.parent}}if(t.target=this,e.length||i.length){if(t.eventPhase=_t.CAPTURING_PHASE,i.length)switch(!0){case t._$stopImmediatePropagation:case t._$stopPropagation:break;default:i.reverse();for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(i.useCapture){t.currentTarget=i.target,ft(i.target.loaderInfo);try{t.listener=i.listener,i.listener.call(null,t)}catch(t){return console.error(t),!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}i.reverse()}if(t.eventPhase=_t.AT_TARGET,!t._$stopImmediatePropagation&&!t._$stopPropagation){const i=e.length;for(let s=0;s<i;++s){const i=e[s];if(!i.useCapture){t.currentTarget=i.target,ft(i.target.loaderInfo);try{t.listener=i.listener,i.listener.call(null,t)}catch(t){return console.error(t),!1}if(t._$stopImmediatePropagation)break}}}switch(t.eventPhase=_t.BUBBLING_PHASE,!0){case t._$stopImmediatePropagation:case t._$stopPropagation:case!t.bubbles:break;default:for(let e=0;e<i.length;++e){const s=i[e];for(let e=0;e<s.length;++e){const i=s[e];if(!i.useCapture){t.currentTarget=i.target,ft(i.target.loaderInfo);try{t.listener=i.listener,i.listener.call(null,t)}catch(t){return console.error(t),!1}if(t._$stopImmediatePropagation)break}}if(t._$stopImmediatePropagation)break}}return G(e),G(i),!0}G(e),G(i)}}return!1}hasEventListener(t){switch(t=`${t}`){case $t.ENTER_FRAME:case $t.EXIT_FRAME:case $t.FRAME_CONSTRUCTED:case $t.RENDER:case $t.ACTIVATE:case $t.DEACTIVATE:case"keyDown":case"keyUp":{const e=Ui();if(e&&e.broadcastEvents.size&&e.broadcastEvents.has(t)){const i=e.broadcastEvents.get(t)||U();for(let t=0;t<i.length;t++)if(i[t].target===this)return!0}return!1}default:return!!(this._$events&&this._$events.size&&this._$events.has(t))}}removeEventListener(t,e,i=!1){if(!e)return;if(t=`${t}`,!this.hasEventListener(t))return;const s=Ui();let r=null,n=!1;switch(t){case $t.ENTER_FRAME:case $t.EXIT_FRAME:case $t.FRAME_CONSTRUCTED:case $t.RENDER:case $t.ACTIVATE:case $t.DEACTIVATE:case"keyDown":case"keyUp":n=!0,s&&(r=s.broadcastEvents.get(t)||U());break;default:this._$events&&this._$events.size&&this._$events.has(t)&&(r=this._$events.get(t)||U())}if(r){for(let t=0;t<r.length;++t){const s=r[t];if(i===s.useCapture&&s.listener===e){r.splice(t,1);break}}if(r.length)r.length>1&&r.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),n?s.broadcastEvents.set(t,r):(this._$events||(this._$events=Y()),this._$events.set(t,r));else if(n)s.broadcastEvents.delete(t);else{if(!this._$events)return;this._$events.delete(t),this._$events.size||(V(this._$events),this._$events=null)}}}removeAllEventListener(t,e=!1){if(t=`${t}`,!this.hasEventListener(t))return;const i=Ui();let s=null,r=!1;switch(t){case $t.ENTER_FRAME:case $t.EXIT_FRAME:case $t.FRAME_CONSTRUCTED:case $t.RENDER:case $t.ACTIVATE:case $t.DEACTIVATE:case"keyDown":case"keyUp":r=!0,i&&(s=i.broadcastEvents.get(t)||U());break;default:this._$events&&this._$events.size&&this._$events.has(t)&&(s=this._$events.get(t)||U())}if(!s)return;const n=U();for(let t=0;t<s.length;++t){const i=s[t];e!==i.useCapture&&n.push(i)}if(n.length)n.length>1&&n.sort((function(t,e){switch(!0){case t.priority>e.priority:return-1;case t.priority<e.priority:return 1;default:return 0}})),r?i.broadcastEvents.set(t,n):(this._$events||(this._$events=Y()),this._$events.set(t,n));else if(r)i.broadcastEvents.delete(t);else{if(!this._$events)return;this._$events.delete(t),this._$events.size||(V(this._$events),this._$events=null)}}willTrigger(t){if(this.hasEventListener(t))return!0;if("parent"in this){let e=this.parent;for(;e;){if(e.hasEventListener(t))return!0;e=e.parent}}return!1}}class wt{_$x;_$y;_$width;_$height;constructor(t=0,e=0,i=0,s=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,s)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new at(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=W(+t,m,x,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new at(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new at(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=W(+t,m,x,0)}get x(){return this._$x}set x(t){this._$x=W(+t,m,x,0)}get y(){return this._$y}set y(t){this._$y=W(+t,m,x,0)}clone(){return new wt(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=i.max(this.x,t.x),s=i.max(this.y,t.y),r=i.min(this.right,t.right)-e,n=i.min(this.bottom,t.bottom)-s;return r>0&&n>0?new wt(e,s,r,n):new wt(0,0,0,0)}intersects(t){const e=i.max(this.x,t.x),s=i.max(this.y,t.y),r=i.min(this.right,t.right),n=i.min(this.bottom,t.bottom);return r-e>0&&n-s>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new wt(i.min(this.x,t.x),i.min(this.y,t.y),i.max(this.right-t.left,t.right-this.left),i.max(this.bottom-t.top,t.bottom-this.top))}}class Ct{_$updated;constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,yt()}}class St extends Ct{_$blurX;_$blurY;_$quality;constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=W(+t,0,255,0))!==this._$blurX&&(this._$blurX=t,this._$doChanged())}get blurY(){return this._$blurY}set blurY(t){(t=W(+t,0,255,0))!==this._$blurY&&(this._$blurY=t,this._$doChanged())}get quality(){return this._$quality}set quality(t){(t=W(0|t,0,15,1))!==this._$quality&&(this._$quality=t,this._$doChanged())}clone(){return new St(this._$blurX,this._$blurY,this._$quality)}_$toArray(){return U(1,this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=0,s=0){const r=t.clone();if(!this._$quality)return r;const n=St.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,h=0>=this._$blurY?1:this._$blurY*n;return e?a*=e:a=i.round(a),s?h*=s:h=i.round(h),r.x-=a,r.width+=2*a,r.y-=h,r.height+=2*h,r}_$canApply(){return 0!==this._$blurX&&0!==this._$blurY}_$applyFilter(t,e,s=!0){this._$updated=!1;const r=t.frameBuffer,n=r.currentAttachment,a=r.getTextureFromCurrentAttachment();if(!this._$canApply())return s?a:r.createTextureFromCurrentAttachment();const h=i.sqrt(e[0]*e[0]+e[1]*e[1]),o=i.sqrt(e[2]*e[2]+e[3]*e[3]),l=new wt(0,0,a.width,a.height),_=this._$generateFilterRect(l,h,o),$=0|i.ceil(_.width),c=0|i.ceil(_.height),u=i.ceil(i.abs(_.x)+.5*i.abs($-_.width)),d=i.ceil(i.abs(_.y)+.5*i.abs(c-_.height));t._$offsetX=u+t._$offsetX,t._$offsetY=d+t._$offsetY;const g=this._$blurX*h,f=this._$blurY*o;let p=1,m=1;g>128?p=.0625:g>64?p=.125:g>32?p=.25:g>16&&(p=.5),f>128?m=.0625:f>64?m=.125:f>32?m=.25:f>16&&(m=.5);const x=g*p,b=f*m,v=i.ceil($*p),T=i.ceil(c*m),y=r.createTextureAttachment(v,T),E=[y,r.createTextureAttachment(v,T)];let M=0;t._$bind(y),t.reset(),t.setTransform(p,0,0,m,0,0),t.drawImage(a,u,d,a.width,a.height),t.blend.toOneZero();let A=r.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){M=(M+1)%2;const e=E[M];t._$bind(e),t._$applyBlurFilter(A,!0,x),A=r.getTextureFromCurrentAttachment()}if(this._$blurY>0){M=(M+1)%2;const e=E[M];t._$bind(e),t._$applyBlurFilter(A,!1,b),A=r.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==p||1!==m){const e=r.createTextureAttachment($,c);t._$bind(e),t.reset(),t.imageSmoothingEnabled=!0,t.setTransform(1/p,0,0,1/m,0,0),t.drawImage(A,0,0,v,T),A=r.getTextureFromCurrentAttachment(),t.reset(),t.setTransform(1,0,0,1,0,0),r.releaseAttachment(E[0],!0),r.releaseAttachment(E[1],!0),s?r.releaseAttachment(n,!0):r.releaseAttachment(e,!1)}else r.releaseAttachment(E[(M+1)%2],!0),s?r.releaseAttachment(n,!0):r.releaseAttachment(E[M],!1);return A}}class Ft extends Ct{_$blurFilter;_$distance;_$angle;_$highlightColor;_$highlightAlpha;_$shadowColor;_$shadowAlpha;_$strength;_$type;_$knockout;constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,h=4,o=1,l=1,_="inner",$=!1){super(),this._$blurFilter=new St(a,h,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=s,this.shadowColor=r,this.shadowAlpha=n,this.strength=o,this.type=_,this.knockout=$}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=W(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=W(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=W(+t,0,1,0))!==this._$highlightAlpha&&(this._$highlightAlpha=t,this._$doChanged())}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=W(J(t),0,16777215,16777215))!==this._$highlightColor&&(this._$highlightColor=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=W(+t,0,1,0))!==this._$shadowAlpha&&(this._$shadowAlpha=t,this._$doChanged())}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=W(J(t),0,16777215,0))!==this._$shadowColor&&(this._$shadowColor=t,this._$doChanged())}get strength(){return this._$strength}set strength(t){(t=W(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){(t=`${t}`)!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new Ft(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return U(0,this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*b,a=i.abs(i.cos(n)*this._$distance),h=i.abs(i.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-h,r.height+=2*h,r}_$canApply(){return this._$strength>0&&0!==this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;if(!r)throw new Error("the current attachment is null.");t.setTransform(1,0,0,1,0,0);const n=s.getTextureFromCurrentAttachment();if(!this._$canApply())return n;const a=r.width,h=r.height,o=t._$offsetX,l=t._$offsetY,_=i.sqrt(e[0]*e[0]+e[1]*e[1]),$=i.sqrt(e[2]*e[2]+e[3]*e[3]),c=this._$angle*b,u=i.cos(c)*this._$distance*_,d=i.sin(c)*this._$distance*$,g=s.createTextureAttachment(a,h);t._$bind(g),t.reset(),t.drawImage(n,0,0,a,h),t.globalCompositeOperation="erase",t.drawImage(n,2*u,2*d,a,h);const f=this._$blurFilter._$applyFilter(t,e,!1),p=f.width,m=f.height,x=i.ceil(p+2*i.abs(u)),v=i.ceil(m+2*i.abs(d)),T="inner"===this._$type,y=T?a:x,E=T?h:v,M=i.abs(u),A=i.abs(d),w=(p-a)/2,C=(m-h)/2,S=T?0:M+w,F=T?0:A+C,B=T?-w-u:M-u,R=T?-C-d:A-d;return t._$bind(r),s.releaseAttachment(g,!0),t._$applyBitmapFilter(f,y,E,a,h,S,F,p,m,B,R,!1,this._$type,this._$knockout,this._$strength,null,null,null,tt(this._$highlightColor,this._$highlightAlpha,!0),et(this._$highlightColor,this._$highlightAlpha,!0),it(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,tt(this._$shadowColor,this._$shadowAlpha,!0),et(this._$shadowColor,this._$shadowAlpha,!0),it(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=o+S,t._$offsetY=l+F,s.releaseTexture(f),s.getTextureFromCurrentAttachment()}}class Bt extends Ct{_$matrix;constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(t&&s.isArray(t)&&20===t.length){for(let e=0;e<20;++e)if(t[e]!==this._$matrix[e]){this._$doChanged();break}this._$matrix=t}}clone(){return new Bt(this._$matrix)}_$toArray(){return U(2,this._$matrix)}_$generateFilterRect(t){return t}_$canApply(){return!0}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment(),r=s.width,n=s.height,a=e.createTextureAttachment(r,n);return t._$bind(a),t.reset(),t._$applyColorMatrixFilter(s,this._$matrix),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()}}class Rt extends Ct{_$matrixX;_$matrixY;_$matrix;_$divisor;_$bias;_$preserveAlpha;_$clamp;_$color;_$alpha;constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,h=0,o=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=s,this.bias=r,this.preserveAlpha=n,this.clamp=a,this.color=h,this.alpha=o}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=W(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get bias(){return this._$bias}set bias(t){t!==this._$bias&&(this._$bias=0|t,this._$doChanged())}get clamp(){return this._$clamp}set clamp(t){t!==this._$clamp&&(this._$clamp=!!t,this._$doChanged())}get color(){return this._$color}set color(t){(t=W(J(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get divisor(){return this._$divisor}set divisor(t){t!==this._$divisor&&(this._$divisor=0|t,this._$doChanged())}get matrix(){return this._$matrix}set matrix(t){s.isArray(this._$matrix)&&G(this._$matrix),this._$matrix=s.isArray(t)?t:null,this._$doChanged()}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|W(0|t,0,15,0))!==this._$matrixX&&(this._$matrixX=t,this._$doChanged())}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|W(0|t,0,15,0))!==this._$matrixY&&(this._$matrixY=t,this._$doChanged())}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){t!==this._$preserveAlpha&&(this._$preserveAlpha=!!t,this._$doChanged())}clone(){return new Rt(this._$matrixX,this._$matrixY,this._$matrix?this._$matrix.slice():null,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$toArray(){return U(3,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$matrix&&this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment();return this._$canApply()&&this._$matrix?(t._$applyConvolutionFilter(s,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,tt(this._$color,this._$alpha,!1),et(this._$color,this._$alpha,!1),it(this._$color,this._$alpha,!1),this._$alpha),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()):s}}class It extends Ct{_$mapBitmap;_$mapPoint;_$componentX;_$componentY;_$scaleX;_$scaleY;_$mode;_$color;_$alpha;constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",h=0,o=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode="wrap",this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=s,this.scaleX=r,this.scaleY=n,this.mode=a,this.color=h,this.alpha=o}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=W(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get color(){return this._$color}set color(t){(t=W(J(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get componentX(){return this._$componentX}set componentX(t){t!==this._$componentX&&(this._$componentX=t,this._$doChanged())}get componentY(){return this._$componentY}set componentY(t){t!==this._$componentY&&(this._$componentY=t,this._$doChanged())}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&(this._$mapBitmap=t,this._$doChanged())}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&(this._$mapPoint=t,this._$doChanged())}get mode(){return this._$mode}set mode(t){t!==this._$mode&&(this._$mode=t,this._$doChanged())}get scaleX(){return this._$scaleX}set scaleX(t){(t=W(+t,-65535,65535,0))!==this._$scaleX&&(this._$scaleX=t,this._$doChanged())}get scaleY(){return this._$scaleY}set scaleY(t){(t=W(+t,-65535,65535,0))!==this._$scaleY&&(this._$scaleY=t,this._$doChanged())}clone(){return new It(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$toArray(){return U(4,this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$mapBitmap&&this._$componentX>0&&this._$componentY>0&&0!==this._$scaleX&&0!==this._$scaleY}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=s.getTextureFromCurrentAttachment();if(!this._$canApply()||!r||!this._$mapBitmap)return n;const a=this._$mapBitmap.getTexture();if(!a)return n;const h=i.sqrt(e[0]*e[0]+e[1]*e[1]),o=i.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(n,a,n.width/h,n.height/o,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,tt(this._$color,this._$alpha,!0),et(this._$color,this._$alpha,!0),it(this._$color,this._$alpha,!0),this._$alpha),s.releaseAttachment(r,!0),s.getTextureFromCurrentAttachment()}}class Lt extends Ct{_$blurFilter;_$distance;_$angle;_$color;_$alpha;_$strength;_$inner;_$knockout;_$hideObject;constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,h=1,o=!1,l=!1,_=!1){super(),this._$blurFilter=new St(r,n,h),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=s,this.strength=a,this.inner=o,this.knockout=l,this.hideObject=_}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=W(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=W(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=W(J(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get distance(){return this._$distance}set distance(t){(t=W(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get hideObject(){return this._$hideObject}set hideObject(t){t!==this._$hideObject&&(this._$hideObject=!!t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=W(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new Lt(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$toArray(){return U(5,this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*b,a=i.cos(n)*this._$distance*2,h=i.sin(n)*this._$distance*2;return r.x=i.min(r.x,a),r.width+=i.abs(a),r.y=i.min(r.y,h),r.height+=i.abs(h),r}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const s=t.frameBuffer,r=s.currentAttachment;if(!r)throw new Error("the current attachment is null.");if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return s.getTextureFromCurrentAttachment();const n=r.width,a=r.height,h=t._$offsetX,o=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,$=l.height,c=t._$offsetX,u=t._$offsetY,d=c-h,g=u-o,f=i.sqrt(e[0]*e[0]+e[1]*e[1]),p=i.sqrt(e[2]*e[2]+e[3]*e[3]),m=this._$angle*b,x=i.cos(m)*this._$distance*f,v=i.sin(m)*this._$distance*p,T=this._$inner?n:_+i.max(0,i.abs(x)-d),y=this._$inner?a:$+i.max(0,i.abs(v)-g),E=i.ceil(T),M=i.ceil(y),A=(E-T)/2,w=(M-y)/2,C=this._$inner?0:i.max(0,d-x)+A,S=this._$inner?0:i.max(0,g-v)+w,F=this._$inner?x-c:(x>0?i.max(0,x-d):0)+A,B=this._$inner?v-u:(v>0?i.max(0,v-g):0)+w;let R,I;return this._$inner?(R="inner",I=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(R="full",I=!0):(R="outer",I=this._$knockout),t._$bind(r),t._$applyBitmapFilter(l,E,M,n,a,C,S,_,$,F,B,!0,R,I,this._$strength,null,null,null,tt(this._$color,this._$alpha,!0),et(this._$color,this._$alpha,!0),it(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=h+C,t._$offsetY=o+S,s.releaseTexture(l),s.getTextureFromCurrentAttachment()}}class Pt extends Ct{_$blurFilter;_$color;_$alpha;_$strength;_$inner;_$knockout;constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,h=!1){super(),this._$blurFilter=new St(i,s,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=r,this.inner=a,this.knockout=h}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=W(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=W(J(t),0,16777215,4))!==this._$color&&(this._$color=t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=W(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new Pt(this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$toArray(){return U(6,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){const s=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t.frameBuffer,s=i.currentAttachment;if(!s)throw new Error("the current attachment is null.");if(this._$updated=!1,t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const r=s.width,n=s.height,a=t._$offsetX,h=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),l=o.width,_=o.height,$=t._$offsetX,c=t._$offsetY,u=this._$inner?r:l,d=this._$inner?n:_,g=this._$inner?0:$-a,f=this._$inner?0:c-h,p=this._$inner?-$:0,m=this._$inner?-c:0,x=this._$inner?"inner":"outer";return t._$bind(s),t._$applyBitmapFilter(o,u,d,r,n,g,f,l,_,p,m,!0,x,this._$knockout,this._$strength,null,null,null,tt(this._$color,this._$alpha,!0),et(this._$color,this._$alpha,!0),it(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=h+f,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class Ot extends Ct{_$blurFilter;_$distance;_$angle;_$colors;_$alphas;_$ratios;_$strength;_$type;_$knockout;constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,l="inner",_=!1){super(),this._$blurFilter=new St(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=l,this.knockout=_}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,s.isArray(t)){for(let e=0;e<t.length;++e){const i=t[e];t[e]=W(+i,0,1,0)}this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=W(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=W(J(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=W(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=W(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=W(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new Ot(this._$distance,this._$angle,this._$colors?this._$colors.slice():null,this._$alphas?this._$alphas.slice():null,this._$ratios?this._$ratios.slice():null,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return U(7,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*b,a=i.abs(i.cos(n)*this._$distance),h=i.abs(i.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-h,r.height+=2*h,r}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=s.getTextureFromCurrentAttachment();if(!this._$canApply()||!r)return n;const a=r.width,h=r.height,o=t._$offsetX,l=t._$offsetY,_=i.sqrt(e[0]*e[0]+e[1]*e[1]),$=i.sqrt(e[2]*e[2]+e[3]*e[3]),c=+this._$angle*b,u=+i.cos(c)*this._$distance*_,d=+i.sin(c)*this._$distance*$,g=s.createTextureAttachment(a,h);t._$bind(g),t.reset(),t.drawImage(n,0,0,a,h),t.globalCompositeOperation="erase",t.drawImage(n,2*u,2*d,a,h);const f=this._$blurFilter._$applyFilter(t,e,!1),p=f.width,m=f.height,x=i.ceil(p+2*i.abs(u)),v=i.ceil(m+2*i.abs(d)),T="inner"===this._$type,y=T?a:x,E=T?h:v,M=i.abs(u),A=i.abs(d),w=(p-a)/2,C=(m-h)/2,S=T?0:M+w,F=T?0:A+C,B=T?-w-u:M-u,R=T?-C-d:A-d;return t._$bind(r),t._$applyBitmapFilter(f,y,E,a,h,S,F,p,m,B,R,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=o+S,t._$offsetY=l+F,s.releaseAttachment(g,!0),s.getTextureFromCurrentAttachment()}}class kt extends Ct{_$blurFilter;_$distance;_$angle;_$colors;_$alphas;_$ratios;_$strength;_$type;_$knockout;constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,l="inner",_=!1){super(),this._$blurFilter=new St(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=l,this.knockout=_}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=W(+t[e],0,1,0);this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=W(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=W(J(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=W(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=W(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=W(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new kt(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return U(8,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*b,a=i.abs(i.cos(n)*this._$distance),h=i.abs(i.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-h,r.height+=2*h,r}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply()||!r)return s.getTextureFromCurrentAttachment();const n=r.width,a=r.height,h=t._$offsetX,o=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,$=l.height,c=t._$offsetX,u=t._$offsetY,d=c-h,g=u-o,f=i.sqrt(e[0]*e[0]+e[1]*e[1]),p=i.sqrt(e[2]*e[2]+e[3]*e[3]),m=+this._$angle*b,x=+i.cos(m)*this._$distance*f,v=+i.sin(m)*this._$distance*p,T="inner"===this.type,y=T?n:_+i.max(0,i.abs(x)-d),E=T?a:$+i.max(0,i.abs(v)-g),M=i.ceil(y),A=i.ceil(E),w=(M-y)/2,C=(A-E)/2,S=T?0:i.max(0,d-x)+w,F=T?0:i.max(0,g-v)+C,B=T?x-c:(x>0?i.max(0,x-d):0)+w,R=T?v-u:(v>0?i.max(0,v-g):0)+C;return t._$bind(r),t._$applyBitmapFilter(l,M,A,n,a,S,F,_,$,B,R,!0,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=h+S,t._$offsetY=o+F,s.releaseTexture(l),s.getTextureFromCurrentAttachment()}}class Nt{_$displayObject;_$matrix;_$colorTransform;_$blendMode;_$filters;constructor(t){this._$displayObject=t,this._$matrix=null,this._$colorTransform=null,this._$blendMode=null,this._$filters=null}static toString(){return"[class Transform]"}static get namespace(){return"next2d.geom.Transform"}toString(){return"[object Transform]"}get namespace(){return"next2d.geom.Transform"}get colorTransform(){if(this._$colorTransform)return this._$colorTransform._$clone();const t=this._$displayObject._$getPlaceObject();if(t&&t.colorTransform){const e=t.colorTransform;return Xi(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7])}return this._$transform(),this._$colorTransform||(this._$colorTransform=Xi()),this._$colorTransform._$clone()}set colorTransform(t){this._$transform(null,t._$colorTransform)}get concatenatedColorTransform(){let t=this._$rawColorTransform(),e=this._$displayObject._$parent;for(;e;)t=q(e._$transform._$rawColorTransform(),t),e=e._$parent;return Xi(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7])}get matrix(){if(this._$matrix)return this._$matrix._$clone();const t=this._$displayObject._$getPlaceObject();if(t&&t.matrix){const e=t.matrix;return Vi(e[0],e[1],e[2],e[3],e[4],e[5])}return this._$transform(),this._$matrix||(this._$matrix=Vi()),this._$matrix._$clone()}set matrix(t){this._$transform(t._$matrix,null)}get concatenatedMatrix(){let t=this._$rawMatrix(),e=this._$displayObject._$parent;for(;e;)t=j(e._$transform._$rawMatrix(),t),e=e._$parent;return Vi(t[0],t[1],t[2],t[3],t[4],t[5])}pixelBounds(){if(!this._$displayObject)return new wt(0,0,0,0);const t=this._$displayObject._$getBounds(null),e=new wt(t.xMin,t.yMin,+i.abs(t.xMax-t.xMin),+i.abs(t.yMax-t.yMin));return R(t),e}_$rawMatrix(){if(null!==this._$matrix)return this._$matrix._$matrix;const t=this._$displayObject._$getPlaceObject();if(t&&t.matrix){if(s.isArray(t.matrix)){const e=t.matrix;t.matrix=P(e[0],e[1],e[2],e[3],e[4],e[5]),G(e)}return t.matrix}return f}_$rawColorTransform(){if(null!==this._$colorTransform)return this._$colorTransform._$colorTransform;const t=this._$displayObject._$getPlaceObject();if(t&&t.colorTransform){if(s.isArray(t.colorTransform)){const e=t.colorTransform;t.colorTransform=k(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7]),G(e)}return t.colorTransform}return p}_$transform(t=null,e=null,i=null,s=""){const r=this._$displayObject._$getPlaceObject();this._$setMatrix(t,r),this._$setColorTransform(e,r),this._$setFilters(i,r),this._$setBlendMode(s,r)}_$setMatrix(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),yt()),this._$matrix||(this._$matrix=Vi(1,0,0,1,0,0),!t&&e&&e.matrix&&(t=e.matrix)),t){const e=this._$matrix._$matrix;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5]}}_$setColorTransform(t=null,e=null){if((t||e)&&(this._$displayObject._$doChanged(),yt()),this._$colorTransform||(this._$colorTransform=Xi(1,1,1,1,0,0,0,0),!t&&e&&e.colorTransform&&(t=e.colorTransform)),t){const e=this._$colorTransform._$colorTransform;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7]}}_$setFilters(t=null,e=null){if(s.isArray(t))return this._$filters&&G(this._$filters),this._$filters=t.slice(0),this._$displayObject._$doChanged(),void yt();if(!this._$filters)if(e){if(e.filters){this._$filters=e.filters.slice(0);for(let t=0;t<this._$filters.length;++t)this._$filters[t]=this._$filters[t].clone()}else if(e.surfaceFilterList){e.filters=this._$buildFilter(e.surfaceFilterList),this._$filters=e.filters.slice(0);for(let t=0;t<this._$filters.length;++t)this._$filters[t]=this._$filters[t].clone()}}else this._$filters=U()}_$buildFilter(t){const e=U(),i=t.length;for(let s=0;s<i;++s){const i=t[s];switch(null===i.params[0]&&i.params.shift(),i.class){case"BevelFilter":e.push(new Ft(...i.params));break;case"BlurFilter":e.push(new St(...i.params));break;case"ColorMatrixFilter":e.push(new Bt(...i.params));break;case"ConvolutionFilter":e.push(new Rt(...i.params));break;case"DisplacementMapFilter":e.push(new It(...i.params));break;case"DropShadowFilter":e.push(new Lt(...i.params));break;case"GlowFilter":e.push(new Pt(...i.params));break;case"GradientBevelFilter":e.push(new Ot(...i.params));break;case"GradientGlowFilter":e.push(new kt(...i.params))}}return e}_$setBlendMode(t="",e=null){if(t)return this._$blendMode=t,this._$displayObject._$doChanged(),void yt();this._$blendMode||(e&&e.blendMode?this._$blendMode=e.blendMode:this._$blendMode="normal")}}class Dt extends At{_$instanceId;_$id;_$stage;_$parent;_$scale9Grid;_$characterId;_$active;_$isMask;_$updated;_$added;_$addedStage;_$filters;_$blendMode;_$transform;_$hitObject;_$isNext;_$created;_$posted;_$clipDepth;_$name;_$mask;_$visible;_$root;_$loaderInfo;_$scaleX;_$scaleY;_$variables;_$placeObject;_$rotation;_$changePlace;_$currentPlaceId;_$placeId;_$startFrame;_$endFrame;constructor(){super(),this._$id=-1,this._$instanceId=ut(),this._$characterId=0,this._$active=!1,this._$isMask=!1,this._$updated=!0,this._$added=!1,this._$addedStage=!1,this._$filters=null,this._$blendMode=null,this._$hitObject=null,this._$isNext=!0,this._$created=!1,this._$posted=!1,this._$clipDepth=0,this._$name="",this._$visible=!0,this._$mask=null,this._$scale9Grid=null,this._$parent=null,this._$stage=null,this._$root=null,this._$loaderInfo=null,this._$placeId=-1,this._$startFrame=1,this._$endFrame=0,this._$transform=new Nt(this),this._$variables=null,this._$placeObject=null,this._$currentPlaceId=-1,this._$changePlace=!1,this._$scaleX=null,this._$scaleY=null,this._$rotation=null}get alpha(){const t=this._$transform._$rawColorTransform();return t[3]+t[7]/255}set alpha(t){t=W(t,0,1,0);const e=this._$transform.colorTransform;e._$colorTransform[3]=t,e._$colorTransform[7]=0,this._$transform.colorTransform=e,zi(e)}get blendMode(){if(this._$blendMode)return this._$blendMode;const t=this._$transform;if(t._$blendMode)return this._$blendMode=t._$blendMode,t._$blendMode;const e=this._$getPlaceObject();return e&&e.blendMode?(this._$blendMode=e.blendMode,e.blendMode):(this._$blendMode="normal","normal")}set blendMode(t){this._$transform._$transform(null,null,null,t),this._$blendMode=t}get filters(){if(this._$filters){const t=U();for(let e=0;e<this._$filters.length;++e)t[e]=this._$filters[e].clone();return t}const t=this._$transform;if(t._$filters){const e=U(),i=U();for(let s=0;s<t._$filters.length;++s){const r=t._$filters[s];e[s]=r.clone(),i[s]=r.clone()}return this._$filters=e,i}const e=this._$getPlaceObject();if(e&&e.surfaceFilterList){e.filters||(e.filters=t._$buildFilter(e.surfaceFilterList));const i=U(),s=U();for(let t=0;t<e.filters.length;++t){const r=e.filters[t];i[t]=r.clone(),s[t]=r.clone()}return this._$filters=i,s}const i=U();return this._$filters=i,i}set filters(t){t||(t=U()),this._$transform._$transform(null,null,t),this._$filters=t}get height(){const t="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),s=K(t,this._$transform._$rawMatrix());R(t);const r=i.abs(s.yMax-s.yMin);switch(R(s),r){case 0:case e:case-1/0:return 0;default:return+r.toFixed(2)}}set height(t){if(!_(t=+t)&&t>-1){const s="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),r=this.rotation,n=r?K(s,this._$transform._$rawMatrix()):s;r&&R(s);const a=i.abs(n.yMax-n.yMin);switch(R(n),a){case 0:case e:case-1/0:this.scaleY=0;break;default:this.scaleY=t/a}}}get loaderInfo(){return this._$loaderInfo}get mask(){return this._$mask}set mask(t){t!==this._$mask&&(this._$mask&&(Zi&&this._$mask.stage&&this._$mask._$removeWorkerInstance(),this._$mask._$isMask=!1,this._$mask=null),t&&(Zi&&"_$createWorkerInstance"in t&&"function"==typeof t._$createWorkerInstance&&t._$createWorkerInstance(),t._$isMask=!0,this._$mask=t),this._$doChanged())}get mouseX(){return bt()?this.globalToLocal(Gi()).x:0}get mouseY(){return bt()?this.globalToLocal(Gi()).y:0}get name(){return this._$name?this._$name:`instance${this._$instanceId}`}set name(t){this._$name=`${t}`;const e=this._$parent;if(e&&e._$names){e._$names.clear();const t=e._$getChildren();for(let i=0;i<t.length;++i){const s=t[i];s._$name&&e._$names.set(s.name,s)}}}get parent(){return this._$parent}get root(){return this._$root}get rotation(){if(null!==this._$rotation)return this._$rotation;const t=this._$transform._$rawMatrix();return i.atan2(t[1],t[0])*v}set rotation(t){if(t=W(t%360,-360,360,0),this._$rotation===t)return;const e=this._$transform,s=e.matrix,r=i.sqrt(s.a*s.a+s.b*s.b),n=i.sqrt(s.c*s.c+s.d*s.d);if(0===t)s.a=r,s.b=0,s.c=0,s.d=n;else{let e=i.atan2(s.b,s.a),a=i.atan2(0-s.c,s.d);const h=t*b;a=a+h-e,e=h,s.b=r*i.sin(e),1===s.b||-1===s.b?s.a=0:s.a=r*i.cos(e),s.c=-n*i.sin(a),1===s.c||-1===s.c?s.d=0:s.d=n*i.cos(a)}e.matrix=s,Yi(s),this._$rotation=t}get scale9Grid(){return this._$scale9Grid}set scale9Grid(t){this._$scale9Grid!==t&&(this._$scale9Grid=t,this._$doChanged(),yt())}get scaleX(){if(null!==this._$scaleX)return this._$scaleX;const t=this._$transform._$rawMatrix();let e=i.sqrt(t[0]*t[0]+t[1]*t[1]);if(!n.isInteger(e)){const t=e.toString(),i=t.indexOf("e");-1!==i&&(e=+t.slice(0,i)),e=+e.toFixed(4)}return 0>t[0]?-1*e:e}set scaleX(t){if(t=W(+t,m,x),!n.isInteger(t)){const e=t.toString(),i=e.indexOf("e");-1!==i&&(t=+e.slice(0,i)),t=+t.toFixed(4)}if(this._$scaleX===t)return;const e=this._$transform,s=e.matrix;if(0===s.b||_(s.b))s.a=t;else{let e=i.atan2(s.b,s.a);e===-i.PI&&(e=0),s.b=t*i.sin(e),s.a=t*i.cos(e)}e.matrix=s,Yi(s),this._$scaleX=t}get scaleY(){if(null!==this._$scaleY)return this._$scaleY;const t=this._$transform._$rawMatrix();let e=i.sqrt(t[2]*t[2]+t[3]*t[3]);if(!n.isInteger(e)){const t=e.toString(),i=t.indexOf("e");-1!==i&&(e=+t.slice(0,i)),e=+e.toFixed(4)}return 0>t[3]?-1*e:e}set scaleY(t){if(t=W(+t,m,x),!n.isInteger(t)){const e=t.toString(),i=e.indexOf("e");-1!==i&&(t=+e.slice(0,i)),t=+t.toFixed(4)}if(this._$scaleY===t)return;const e=this._$transform,s=e.matrix;if(0===s.c||_(s.c))s.d=t;else{let e=i.atan2(-s.c,s.d);e===-i.PI&&(e=0),s.c=-t*i.sin(e),s.d=t*i.cos(e)}e.matrix=s,Yi(s),this._$scaleY=t}get stage(){if(this._$stage)return this._$stage;const t=this._$parent;return t?t._$stage:null}get transform(){return this._$transform}set transform(t){this._$transform=t}get visible(){return this._$visible}set visible(t){this._$visible!==t&&(this._$visible=!!t,this._$doChanged(),yt())}get width(){const t="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),s=K(t,this._$transform._$rawMatrix());R(t);const r=i.abs(s.xMax-s.xMin);switch(R(s),!0){case 0===r:case r===e:case r===-1/0:return 0;default:return+r.toFixed(2)}}set width(t){if(!_(t=+t)&&t>-1){const s="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),r=this.rotation,n=r?K(s,this._$transform._$rawMatrix()):s;r&&R(s);const a=i.abs(n.xMax-n.xMin);switch(R(n),!0){case 0===a:case a===e:case a===-1/0:this.scaleX=0;break;default:this.scaleX=t/a}}}get x(){return this._$transform._$rawMatrix()[4]}set x(t){const e=this._$transform,i=e.matrix;i.tx=t,e.matrix=i,Yi(i)}get y(){return this._$transform._$rawMatrix()[5]}set y(t){const e=this._$transform,i=e.matrix;i.ty=t,e.matrix=i,Yi(i)}getBounds(t=null){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),s=this._$transform.concatenatedMatrix,r=K(e,s._$matrix);Yi(s),R(e);const n=B(r.xMin,r.xMax,r.yMin,r.yMax);R(r),t||(t=this);const a=t._$transform.concatenatedMatrix;a.invert();const h=K(n,a._$matrix);R(n),Yi(a);const o=h.xMin,l=h.yMin,_=h.xMax,$=h.yMax;return R(h),new wt(o,l,i.abs(_-o),i.abs($-l))}globalToLocal(t){const e=this._$transform.concatenatedMatrix;e.invert();const i=new at(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return Yi(e),i}hitTestObject(t){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),s=this._$transform.concatenatedMatrix,r=K(e,s._$matrix);Yi(s),R(e);const n=t._$getBounds(null),a=t._$transform.concatenatedMatrix,h=K(n,a._$matrix);Yi(a),R(n);const o=i.max(r.xMin,h.xMin),l=i.max(r.yMin,h.yMin),_=i.min(r.xMax,h.xMax),$=i.min(r.yMax,h.yMax);return R(r),R(h),_-o>=0&&$-l>=0}hitTestPoint(t,e,i=!1){if(i){let i=f,s=this._$parent;for(;s;)i=j(s._$transform._$rawMatrix(),i),s=s._$parent;Di.setTransform(1,0,0,1,0,0),Di.beginPath();let r=!1;return"_$hit"in this&&"function"==typeof this._$hit&&(r=this._$hit(Di,i,{x:t,y:e},!0)),i!==f&&O(i),r}const s="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),r=K(s,this._$transform._$rawMatrix());R(s);const n=new wt(r.xMin,r.yMin,r.xMax-r.xMin,r.yMax-r.yMin);R(r);const a=this._$parent?this._$parent.globalToLocal(new at(t,e)):new at(t,e);return n.containsPoint(a)}localToGlobal(t){const e=this._$transform.concatenatedMatrix,i=new at(t.x*e.a+t.y*e.c+e.tx,t.x*e.b+t.y*e.d+e.ty);return Yi(e),i}getLocalVariable(t){return this._$variables?this._$variables.has(t)?this._$variables.get(t):void 0:null}setLocalVariable(t,e){this._$variables||(this._$variables=Y()),this._$variables.set(t,e)}hasLocalVariable(t){return!!this._$variables&&this._$variables.has(t)}deleteLocalVariable(t){this._$variables&&this._$variables.has(t)&&(this._$variables.delete(t),this._$variables.size||(V(this._$variables),this._$variables=null))}getGlobalVariable(t){return xi.has(t)?xi.get(t):null}setGlobalVariable(t,e){xi.set(t,e)}hasGlobalVariable(t){return xi.has(t)}deleteGlobalVariable(t){xi.has(t)&&xi.delete(t)}clearGlobalVariable(){return xi.clear()}_$getPlaceObject(){if(!this._$placeObject){const t=this._$placeId;if(-1===t)return null;const e=this._$parent;if(!e||!e._$placeObjects)return null;const i=e._$placeMap;if(!i||!i.length)return null;const s=i["currentFrame"in e?e.currentFrame:1];if(!s)return null;const r=0|s[t],n=e._$placeObjects[r];return n?(this._$changePlace=r!==this._$currentPlaceId,this._$currentPlaceId=r,this._$placeObject=n,n):null}return this._$placeObject}_$baseBuild(t,e){const i=e._$loaderInfo;if(!i||!i._$data)throw new Error("the loaderInfo or data is nul.");return this._$parent=e,this._$root=e._$root,this._$stage=e._$stage,this._$loaderInfo=i,this._$characterId=0|t.characterId,this._$clipDepth=0|t.clipDepth,this._$startFrame=0|t.startFrame,this._$endFrame=0|t.endFrame,this._$name=t.name||"",i._$data.characters[t.characterId]}_$isUpdated(){return this._$updated}_$updateState(){this._$isNext=!0;const t=this._$parent;t&&t._$updateState()}_$doChanged(){Zi&&this._$created&&Zi.postMessage({command:"doChanged",instanceId:this._$instanceId}),this._$posted=!1,this._$isNext=!0,this._$updated=!0;const t=this._$parent;t&&t._$doChanged()}_$drawFilter(t,e,i,s,r,n){const a=Ui().cacheStore,h=[this._$instanceId,"f"],o=a.get(h),l=this._$isFilterUpdated(r,n,i,s,!0);if(o&&!l)return o;if(o&&(a.set(h,null),o.layerWidth=0,o.layerHeight=0,o._$offsetX=0,o._$offsetY=0,o.matrix=null,o.colorTransform=null,t.frameBuffer.releaseTexture(o)),!o||l){const o=this._$applyFilter(t,s,e,i,r,n);return a.set(h,o),o}return o}_$getLayerBounds(t=null){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds(t):B();if(!t)return e;const i=this._$filters||this.filters;if(!i.length)return e;let s=new wt(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);R(e);for(let t=0;t<i.length;++t)s=i[t]._$generateFilterRect(s,0,0);return B(s.x,s.x+s.width,s.y,s.y+s.height)}_$executeAddedEvent(){this._$parent&&(this._$added||(this.willTrigger($t.ADDED)&&this.dispatchEvent(new $t($t.ADDED,!0)),this._$added=!0),this._$addedStage||null===this._$stage||(this.willTrigger($t.ADDED_TO_STAGE)&&this.dispatchEvent(new $t($t.ADDED_TO_STAGE)),this._$addedStage=!0))}_$prepareActions(){this._$nextFrame()}_$nextFrame(){return this._$executeAddedEvent(),this._$isNext=!1,!this._$posted&&Zi&&this._$postProperty(),!1}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$isFilterUpdated(t,e,s,r=null,n=!1,a=0,h=0){if(this._$isUpdated())return!0;if(n&&r)for(let t=0;t<r.length;++t)if(r[t]._$isUpdated())return!0;const o=Ui().cacheStore.get([this._$instanceId,"f"]);switch(!0){case null===o:case o.filterState!==n:case o.layerWidth!==i.ceil(t):case o.layerHeight!==i.ceil(e):case o.matrix!==s[0]+"_"+s[1]+"_"+s[2]+"_"+s[3]+"_"+a+"_"+h:return!0}return!1}_$applyFilter(t,e,s,r,n,a){const h=+i.sqrt(r[0]*r[0]+r[1]*r[1]),o=+i.sqrt(r[2]*r[2]+r[3]*r[3]),l=i.atan2(r[1],r[0]),_=i.atan2(-r[2],r[3]),$=P(i.cos(l),i.sin(l),-i.sin(_),i.cos(_),n/2,a/2),c=P(1,0,0,1,-s.width/2,-s.height/2),u=j($,c);O($),O(c);const d=t.frameBuffer,g=d.currentAttachment,f=d.createCacheAttachment(n,a);t._$bind(f),t.reset(),t.setTransform(u[0],u[1],u[2],u[3],u[4],u[5]),O(u),t.drawImage(s,0,0,s.width,s.height),t._$offsetX=0,t._$offsetY=0;const p=P(h,0,0,o,0,0);let m=null;for(let i=0;i<e.length;++i)m=e[i]._$applyFilter(t,p);if(O(p),!m)return s;const x=t._$offsetX,b=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,m._$offsetX=x,m._$offsetY=b,m.matrix=r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3],m.filterState=!0,m.layerWidth=n,m.layerHeight=a,t._$bind(g),d.releaseAttachment(f,!1),m}_$shouldClip(t){const e="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds(t):B(),s=i.abs(e.xMax-e.xMin),r=i.abs(e.yMax-e.yMin);return R(e),!(!s||!r)}_$startClip(t,e){let i=null;if(!t.cacheAttachment){let s=e;const r=this._$transform._$rawMatrix();1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(s=j(e,r));const n="_$getBounds"in this&&"function"==typeof this._$getBounds?this._$getBounds():B(),a=K(n,s);if(R(n),i=t._$startClip(e,a),R(a),s!==e&&O(s),!i)return!1}t._$enterClip(),t._$beginClipDef();let s=!1;return"_$children"in this&&(s=!0,t._$updateContainerClipFlag(!0)),this._$clip(t,i||e),this._$updated=!1,s&&(t._$updateContainerClipFlag(!1),t._$drawContainerClip()),t._$endClipDef(),i}_$removeWorkerInstance(){Zi&&Zi.postMessage({command:"remove",instanceId:this._$instanceId})}_$createMessage(){const t={command:"setProperty",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,visible:this._$visible,isMask:this._$isMask,clipDepth:this._$clipDepth,depth:this._$placeId,maskId:-1},e=this._$mask;if(e){t.maskId=e._$instanceId;let i=f,s=e._$parent;for(;s;)i=j(s._$transform._$rawMatrix(),i),s=s._$parent;t.maskMatrix=i}if(this._$visible){const e=this._$transform,i=e._$rawMatrix();1!==i[0]&&(t.a=i[0]),0!==i[1]&&(t.b=i[1]),0!==i[2]&&(t.c=i[2]),1!==i[3]&&(t.d=i[3]),0!==i[4]&&(t.tx=i[4]),0!==i[5]&&(t.ty=i[5]);const s=e._$rawColorTransform();1!==s[0]&&(t.f0=s[0]),1!==s[1]&&(t.f1=s[1]),1!==s[2]&&(t.f2=s[2]),1!==s[3]&&(t.f3=s[3]),0!==s[4]&&(t.f4=s[4]),0!==s[5]&&(t.f5=s[5]),0!==s[6]&&(t.f6=s[6]),0!==s[7]&&(t.f7=s[7]);const r=this._$filters||this.filters;if(r&&r.length){const e=U();for(let t=0;t<r.length;++t)e.push(r[t]._$toArray());t.filters=e}const n=this._$blendMode||this.blendMode;"normal"!==n&&(t.blendMode=n);const a=this._$scale9Grid;if(a&&this._$isUpdated()){const e=this._$parent._$transform.concatenatedMatrix;t.matrixBase=e._$matrix.slice(),Yi(e),t.grid={x:a.x,y:a.y,w:a.width,h:a.height}}}return t}}class Ut extends Dt{_$mouseEnabled;constructor(){super(),this._$mouseEnabled=!0}get mouseEnabled(){return this._$mouseEnabled}set mouseEnabled(t){this._$mouseEnabled=!!t}}class Gt extends Ut{_$placeMap;_$placeObjects;_$controller;_$dictionary;_$children;_$needsChildren;_$mouseChildren;_$wait;_$names;constructor(){return super(),this._$placeMap=null,this._$placeObjects=null,this._$controller=null,this._$dictionary=null,this._$children=U(),this._$needsChildren=!0,this._$mouseChildren=!0,this._$wait=!0,this._$names=Y(),new Proxy(this,{get:(t,e)=>t._$names.size&&t._$names.has(e)?t._$names.get(e):t[e]})}get mouseChildren(){return this._$mouseChildren}set mouseChildren(t){this._$mouseChildren=!!t}get numChildren(){return this._$needsChildren?this._$getChildren().length:this._$children.length}addChild(t){return t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId)),this._$getChildren().push(t),t._$name&&this._$names.set(t._$name,t),this._$addChild(t)}addChildAt(t,e){t._$parent&&t._$parent._$remove(t,!(t._$parent._$instanceId===this._$instanceId));const i=this._$getChildren(),s=i.length;if(0>e||e>s)throw new RangeError(`RangeError: addChildAt: index error: ${e}`);if(s&&s>e){i.splice(e,0,t);for(let t=0;t<e;++t){const e=i[t];e._$name&&this._$names.set(e._$name,e)}}else i.push(t),t._$name&&this._$names.set(t._$name,t);return this._$addChild(t)}contains(t){if(this._$instanceId===t._$instanceId)return!0;const e=this._$getChildren();for(let i=0;i<e.length;++i){const s=e[i];if(s._$instanceId===t._$instanceId)return!0;if(s instanceof Gt&&s.contains(t))return!0}return!1}getChildAt(t){const e=this._$getChildren();if(0>t||t>e.length)throw new RangeError(`RangeError: getChildAt: index error: ${t}`);return t in e?e[t]:null}getChildByName(t){if(!t)return null;const e=this._$getChildren();for(let i=0;i<e.length;++i){const s=e[i];if(s.name===t)return s}return null}getChildIndex(t){if(t._$parent!==this)throw new Error("ArgumentError: getChildIndex: not child");const e=this._$getChildren().indexOf(t);if(-1===e)throw new Error("ArgumentError: getChildIndex: not found.");return e}removeChild(t){if(t._$parent!==this)throw new Error("ArgumentError: removeChild: not child");return this._$remove(t)}removeChildAt(t){return this._$remove(this.getChildAt(t))}removeChildren(t=0,e=2147483647){const s=this._$getChildren();if(s.length){t=W(t,0,2147483646,0)-1,e=W(e,1,134217727,134217727);for(let r=i.min(e,s.length-1);r>t;--r)this._$remove(s[r])}}setChildIndex(t,e){const i=this.getChildIndex(t);if(i===e)return;const s=this._$getChildren();s.splice(i,1),s.splice(e,0,t),Zi&&this._$postChildrenIds(),this._$doChanged()}swapChildren(t,e){const i=this._$getChildren(),s=this.getChildIndex(t),r=this.getChildIndex(e);i[s]=e,i[r]=t,Zi&&this._$postChildrenIds(),this._$doChanged()}swapChildrenAt(t,e){this.swapChildren(this.getChildAt(t),this.getChildAt(e))}_$getBounds(t=null){let e=f;if(t){e=t;const i=this._$transform._$rawMatrix();1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=j(t,i))}const s="_$graphics"in this?this._$graphics:null,r=this._$needsChildren?this._$getChildren():this._$children;if(!r.length&&!s){const i=B(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&O(e),i}const a=n.MAX_VALUE;let h=a,o=-a,l=a,_=-a;if(s){const t=s._$getBounds(),i=K(t,e);R(t),h=i.xMin,o=i.xMax,l=i.yMin,_=i.yMax,R(i)}for(let t=0;t<r.length;++t){const s=r[t]._$getBounds(e);h=i.min(h,s.xMin),o=i.max(o,s.xMax),l=i.min(l,s.yMin),_=i.max(_,s.yMax),R(s)}return t&&e!==t&&O(e),B(h,o,l,_)}_$getLayerBounds(t=null){let e=f;if(t){e=t;const i=this._$transform._$rawMatrix();i!==f&&(e=j(t,i))}const s="_$graphics"in this?this._$graphics:null,r=this._$needsChildren?this._$getChildren():this._$children;if(!r.length&&!s){const i=B(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&O(e),i}const a=n.MAX_VALUE;let h=a,o=-a,l=a,_=-a;if(s){const t=s._$getBounds(),i=K(t,e);R(t),h=+i.xMin,o=+i.xMax,l=+i.yMin,_=+i.yMax,R(i)}for(let t=0;t<r.length;++t){const s=r[t]._$getLayerBounds(e);h=i.min(h,s.xMin),o=i.max(o,s.xMax),l=i.min(l,s.yMin),_=i.max(_,s.yMax),R(s)}if(t&&e!==t&&O(e),!t)return B(h,o,l,_);const $=this._$filters||this.filters;if(!$.length)return B(h,o,l,_);let c=new wt(h,l,o-h,_-l);for(let t=0;t<$.length;++t)c=$[t]._$generateFilterRect(c,0,0);return h=c.x,o=c.x+c.width,l=c.y,_=c.y+c.height,B(h,o,l,_)}_$getChildren(){if(this._$needsChildren){this._$needsChildren=!1;const t=this._$children;if(!this._$controller)return t;const e="_$currentFrame"in this?this._$currentFrame:1,i=this._$controller[e];if(!t.length){if(i)for(let e=0;e<i.length;++e){const s=this._$createInstance(i[e]);s._$placeId=e;const r=s.loopConfig;r&&(s._$currentFrame=s._$getLoopFrame(r)),t.push(s),s._$name&&this._$names.set(s._$name,s)}return t}const s=Ui().cacheStore,r=!!Zi&&!!this._$stage,n=Y(),a=Y();let h=0;const o=U();for(let l=0;l<t.length;++l){const _=t[l],$=_._$parent;if(!$||$._$instanceId!==this._$instanceId)continue;const c=_._$instanceId,u=_._$startFrame,d=_._$endFrame;if(1===u&&0===d||u<=e&&d>e){if(_._$isNext=!0,_._$placeObject=null,_._$filters=null,_._$blendMode=null,-1===_._$id){o.push(_),_._$name&&this._$names.set(_._$name,_);continue}const t=i[h];if(_._$id===t){_._$placeId=h,o.push(_),_._$name&&this._$names.set(_._$name,_),a.has(t)&&a.delete(t),n.set(t,!0),h++,r&&_._$postProperty();continue}a.set(_._$id,_)}else r&&_._$removeWorkerInstance(),s.setRemoveTimer(c),_._$loaderInfo&&_._$characterId&&s.setRemoveTimer(`${_._$loaderInfo._$id}@${_._$characterId}`),_.willTrigger($t.REMOVED)&&_.dispatchEvent(new $t($t.REMOVED,!0)),_.willTrigger($t.REMOVED_FROM_STAGE)&&_.dispatchEvent(new $t($t.REMOVED_FROM_STAGE,!0)),_._$added=!1,_._$addedStage=!1,_._$active=!1,_._$updated=!0,_._$filters=null,_._$blendMode=null,_._$isNext=!0,_._$placeObject=null,_._$created=!1,_._$posted=!1,_ instanceof Gt&&(_._$executeRemovedFromStage(),_._$removeParentAndStage())}if(i)for(let t=0;t<i.length;++t){const e=i[t];if(n.has(e))continue;const s=a.has(e)?a.get(e):this._$createInstance(e);s._$placeId=t;const r=s.loopConfig;r&&(s._$currentFrame=s._$getLoopFrame(r)),o.push(s),s._$name&&this._$names.set(s._$name,s)}V(n),V(a),t.length=0,t.push(...o),G(o)}return this._$children}_$clearChildren(){this._$doChanged(),yt(),this._$names.clear(),this._$needsChildren=!0}_$addChild(t){return t._$parent=this,t._$stage&&t._$root||(t._$stage=this._$stage,t._$root=this._$root),t instanceof Gt&&(t._$setParentAndStage(),t._$wait=!0),t._$added||(t.willTrigger($t.ADDED)&&t.dispatchEvent(new $t($t.ADDED,!0)),t._$added=!0),null===this._$stage||t._$addedStage||(t.willTrigger($t.ADDED_TO_STAGE)&&t.dispatchEvent(new $t($t.ADDED_TO_STAGE)),t._$addedStage=!0,t instanceof Gt&&t._$executeAddedToStage(),Zi&&(t._$createWorkerInstance(),t._$postProperty(),this._$postChildrenIds())),this._$doChanged(),t._$active=!0,t._$updated=!0,t._$isNext=!0,t}_$setParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=0;e<t.length;++e){const i=t[e];i._$root=this._$root,i._$stage=this._$stage,i instanceof Gt&&(i._$setParentAndStage(),i._$wait=!0)}}_$executeAddedToStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=U();for(let i=0;i<t.length;++i){const s=t[i];s&&(e.push(s._$instanceId),s._$addedStage||(Zi&&(s._$createWorkerInstance(),s._$postProperty()),s.willTrigger($t.ADDED_TO_STAGE)&&s.dispatchEvent(new $t($t.ADDED_TO_STAGE)),s._$addedStage=!0),s instanceof Gt&&s._$executeAddedToStage())}Zi&&this._$postChildrenIds(e),G(e)}_$remove(t,e=!0){t._$transform._$transform();const i=this._$needsChildren?this._$getChildren():this._$children,s=this.getChildIndex(t);if(i.splice(s,1),this._$names.delete(t.name),e){t.willTrigger($t.REMOVED)&&t.dispatchEvent(new $t($t.REMOVED,!0)),null!==this._$stage&&(Zi&&(t._$removeWorkerInstance(),this._$postChildrenIds()),t.willTrigger($t.REMOVED_FROM_STAGE)&&t.dispatchEvent(new $t($t.REMOVED_FROM_STAGE)),t instanceof Gt&&t._$executeRemovedFromStage());const e=Ui().cacheStore;e.setRemoveTimer(t._$instanceId),t._$loaderInfo&&t._$characterId&&e.setRemoveTimer(`${t._$loaderInfo._$id}@${t._$characterId}`),t instanceof Gt&&t._$removeParentAndStage(),t._$stage=null,t._$parent=null,t._$root=null,t._$active=!1,t._$wait=!0,t._$updated=!0,t._$added=!1,t._$addedStage=!1,t._$created=!1,t._$posted=!1,this._$doChanged()}return t}_$executeRemovedFromStage(){const t=this._$getChildren().slice(0);for(let e=0;e<t.length;++e){const i=t[e];i&&(i._$addedStage&&(Zi&&i._$removeWorkerInstance(),i.willTrigger($t.REMOVED_FROM_STAGE)&&i.dispatchEvent(new $t($t.REMOVED_FROM_STAGE)),i._$created=!1,i._$posted=!1,i._$addedStage=!1),i instanceof Gt&&i._$executeRemovedFromStage())}}_$removeParentAndStage(){const t=this._$needsChildren?this._$getChildren():this._$children,e=Ui().cacheStore;for(let i=0;i<t.length;++i){const s=t[i];e.setRemoveTimer(s._$instanceId),s._$loaderInfo&&s._$characterId&&e.setRemoveTimer(`${s._$loaderInfo._$id}@${s._$characterId}`),s instanceof Gt&&s._$removeParentAndStage(),s._$stage=null,s._$root=null,s._$addedStage=!1}if("_$sounds"in this){const t=this._$sounds;if(t.size)for(const e of t.values())for(let t=0;t<e.length;++t)e[t].stop()}this._$needsChildren=!0}_$prepareActions(){const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$executeAddedEvent()}_$nextFrame(){let t=!1;const e=this._$getChildren();for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$executeAddedEvent(),this._$isNext=t,!this._$posted&&Zi&&this._$postProperty(),this._$isNext}_$clip(t,e){let i=e;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=j(e,s));const r="_$graphics"in this?this._$graphics:null;r&&r._$canDraw&&r._$clip(t,i);const n=this._$getChildren();for(let e=0;e<n.length;++e){const s=n[e];s._$isMask||(s._$clip(t,i),s._$updated=!1)}i!==e&&O(i)}_$preDraw(t,e){let s=e;const r=this._$transform._$rawMatrix();if((r!==Ei&&1!==r[0]||0!==r[1]||0!==r[2]||1!==r[3]||0!==r[4]||0!==r[5])&&(s=j(e,r)),!s[0]&&!s[1]||!s[2]&&!s[3])return null;const n=T.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,blendMode:"normal",filters:null,layerWidth:0,layerHeight:0};n.matrix=s;const a=this._$filters||this.filters,h=this._$blendMode||this.blendMode;if(a.length>0||"normal"!==h){const e=this._$getBounds(null),o=K(e,s);R(e);const l=+o.xMax,_=+o.xMin,$=+o.yMax,c=+o.yMin;R(o);const u=i.abs(l-_),d=i.abs($-c);if(0>=u||0>=d)return nt(n),null;if(0>_+u||0>c+d)return nt(n),null;const g=t.frameBuffer.currentAttachment;if(!g||!g.texture||_>g.width||c>g.height)return nt(n),null;n.basePosition.x=r[4],n.basePosition.y=r[5];const f=this._$getLayerBounds(null),p=K(f,s);let m=i.abs(p.xMax-p.xMin),x=i.abs(p.yMax-p.yMin);R(p);let b=s[4]-i.floor(_),v=s[5]-i.floor(c),T=i.floor(_),y=i.floor(c),E=_,M=c;if(m!==u||x!==d){const t=P(s[0],s[1],s[2],s[3],0,0),e=K(f,t);O(t),b+=-i.floor(e.xMin)-b,v+=-i.floor(e.yMin)-v,T-=-i.floor(e.xMin)-(s[4]-T),y-=-i.floor(e.yMin)-(s[5]-y),E-=-e.xMin-(s[4]-E),M-=-e.yMin-(s[5]-M),R(e)}if(R(f),n.position.dx=T>0?T:0,n.position.dy=y>0?y:0,m+E>g.texture.width&&(m-=m-g.texture.width+E),x+M>g.texture.height&&(x-=x-g.texture.height+M),0>T&&(b+=T,m+=E),0>y&&(v+=y,x+=M),0>=m||0>=x||!m||!x)return nt(n),null;t._$startLayer(B(E,0,M,0)),n.canApply=this._$canApply(a);const A=this._$isFilterUpdated(m,x,s,a,n.canApply,n.basePosition.x,n.basePosition.y);t._$saveCurrentMask(),A&&t._$saveAttachment(i.ceil(m),i.ceil(x),!1),n.isFilter=!0,n.isUpdated=A,n.color=k(),n.baseMatrix=s,n.filters=a,n.blendMode=h,n.layerWidth=m,n.layerHeight=x,n.matrix=P(s[0],s[1],s[2],s[3],b,v)}return n}_$postDraw(t,e,i,s){const r=U(this._$instanceId,"f"),n=Ui().cacheStore,a=t.frameBuffer;let h=null;if(s.isUpdated){h=a.getTextureFromCurrentAttachment();const t=n.get(r);t&&(n.set(r,null),a.releaseTexture(t))}else if(h=n.get(r),!h)throw new Error("the texture is null.");s.canApply||(h._$offsetX=0,h._$offsetY=0);let o=h._$offsetX,l=h._$offsetY;if(s.isUpdated&&s.canApply){const i=n.get(r);i&&(n.set(r,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,a.releaseTexture(i));const _=s.filters;if(_&&_.length){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<_.length;++i)h=_[i]._$applyFilter(t,e);o=t._$offsetX,l=t._$offsetY,t._$offsetX=0,t._$offsetY=0,h._$offsetX=o,h._$offsetY=l}}if(s.isUpdated){h.filterState=s.canApply;const t=s.baseMatrix;t&&(h.matrix=`${t[0]}_${t[1]}_${t[2]}_${t[3]}`),h.layerWidth=s.layerWidth,h.layerHeight=s.layerHeight}n.set(r,h),G(r),s.isUpdated&&t._$restoreAttachment(),t.reset(),t.globalAlpha=W(i[3]+i[7]/255,0,1),t.globalCompositeOperation=s.blendMode,t.setTransform(1,0,0,1,0,0),t.drawImage(h,-o+s.position.dx,-l+s.position.dy,h.width,h.height,i),t._$endLayer(),t._$restoreCurrentMask(),s.baseMatrix!==e&&O(s.baseMatrix),O(s.matrix),nt(s)}_$draw(t,e,s){if(!this._$visible)return;const r=this._$transform;let n=s;const a=r._$rawColorTransform();if((a!==p&&1!==a[0]||1!==a[1]||1!==a[2]||1!==a[3]||0!==a[4]||0!==a[5]||0!==a[6]||0!==a[7])&&(n=q(s,a)),!W(n[3]+n[7]/255,0,1,0))return;const h=this._$getChildren(),o=h.length,l="_$graphics"in this?this._$graphics:null;if(!(o||l&&l._$canDraw))return;const _=this._$preDraw(t,e);if(!_)return;if(_.isFilter&&!_.isUpdated)return void this._$postDraw(t,e,n,_);let $=_.matrix;const c=_.isFilter&&_.color?_.color:n;l&&l._$canDraw&&l._$draw(t,$,c);let u=!0,d=0;const g=U(),m=U(),x=U(),b=U(),v=Ui(),T=t.isLayer,y=this._$isUpdated();for(let e=0;e<o;++e){const s=h[e];if(y&&(s._$placeObject=null),s._$isMask)continue;const n=s._$blendMode||s.blendMode;if(("alpha"===n||"erase"===n)&&!T)continue;if(d&&(s._$placeId>d||s._$clipDepth>0)){if(t.restore(),u&&(t._$leaveClip(),g.length)){const t=g.pop();t&&(O($),$=t)}d=x.length&&x.pop()||0,u=!!b.pop()}if(!u)continue;if(s._$clipDepth>0){if(t.save(),d&&x.push(d),b.push(u),d=s._$clipDepth,u=s._$shouldClip($),u){const e=s._$startClip(t,$);if(!1===e){u=!1;continue}e instanceof Float32Array&&(g.push($),$=e)}continue}const a=s._$mask;if(a){let e;if(a._$updated=!1,this===a._$parent)e=$;else{e=f;let i=a._$parent;for(;i;)e=j(i._$transform._$rawMatrix(),e),i=i._$parent;const s=v.scaleX,r=P(s,0,0,s,0,0);if(e=j(r,e),O(r),t.isLayer){const i=t.getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t.cacheBounds&&(e[4]-=t.cacheBounds.xMin,e[5]-=t.cacheBounds.yMin)}if(!a._$shouldClip(e))continue;const s=a._$startClip(t,e);if(t.save(),!1===s){t.restore();continue}if(s instanceof Float32Array){if(m.push($),this!==a._$parent){const e=r._$rawMatrix();s[0]=i.abs($[0])*i.sign(e[0]),s[1]=i.abs($[1])*i.sign(e[1]),s[2]=i.abs($[2])*i.sign(e[2]),s[3]=i.abs($[3])*i.sign(e[3]),s[4]=$[4]-t.cacheBounds.xMin,s[5]=$[5]-t.cacheBounds.yMin}$=s}}if(s._$draw(t,$,c),s._$updated=!1,a&&(t.restore(),t._$leaveClip(),m.length)){const t=m.pop();t&&(O($),$=t)}}if(d&&(t.restore(),b.pop()&&t._$leaveClip()),G(g),G(m),G(x),G(b),_.isFilter)return this._$postDraw(t,e,n,_);_.matrix!==e&&O(_.matrix),n!==s&&N(n),nt(_)}_$mouseHit(t,e,i,s=!0){let r=e;const n=this._$transform._$rawMatrix();n!==f&&(r=j(e,n));const a=this._$getChildren(),h=U(),o=U(),l=Y();let _=0,$=0;for(let t=0;t<a.length;++t){const e=a[t];(e._$visible||e._$hitObject)&&(e._$clipDepth?($=h.length,_=e._$clipDepth,h.push(e)):(_&&e._$placeId>_&&($=0,_=0),$&&l.set(e._$instanceId,$),o.push(e)))}const c=this._$mouseChildren&&s;let u=!1;const d=this._$root===this;for(;o.length;){const e=o.pop();if(e._$isMask)continue;if(d&&!(e instanceof Ut))continue;if(l.has(e._$instanceId)){const s=l.get(e._$instanceId);if(!s)continue;if(!h[s]._$hit(t,r,i,!0))continue}const s=e._$mask;if(s)if(this===s._$parent){if(!s._$hit(t,r,i,!0))continue}else{let e=f,r=s._$parent;for(;r;)e=j(r._$transform._$rawMatrix(),e),r=r._$parent;if(!s._$hit(t,e,i,!0))continue}if(e._$mouseHit(t,r,i,c)||e._$hitArea&&e._$hitArea._$mouseHit(t,r,i,c)){if(e._$root===e)return!0;if(!c)return!0;if(u=!0,e instanceof Ut){if(!e.mouseEnabled&&!e._$hitObject)continue;return Li||i.pointer||("_$text"in e&&"type"in e&&"input"===e.type&&(i.pointer="text"),"buttonMode"in e&&"useHandCursor"in e&&e.buttonMode&&e.useHandCursor&&(i.pointer="pointer")),i.hit||(i.hit=!e.mouseEnabled&&e._$hitObject?e._$hitObject:e),!0}}}if(G(h),G(o),V(l),!u){const e="_$graphics"in this?this._$graphics:null;e&&(u=e._$hit(t,r,i))}return r!==e&&O(r),u}_$hit(t,e,i,s=!1){let r=e;const n=this._$transform._$rawMatrix();n!==f&&(r=j(e,n));const a=this._$getChildren();for(let e=a.length;e>-1;--e){const n=a[e];if(!n._$isMask&&n._$hit(t,r,i,s))return!0}let h=!1;const o="_$graphics"in this?this._$graphics:null;return o&&(h=o._$hit(t,r,i)),r!==e&&O(r),h}_$createInstance(t){if(!this._$dictionary)throw new Error("the dictionary is null.");const e=this._$dictionary[t],i=this._$loaderInfo;if(!i||!i._$data)throw new Error("the loaderInfo or data is null.");const s=i._$data.characters[e.characterId],r=Ji(s.extends);return r._$build(e,this),r._$id=t,r}_$outCheck(t,e){let i=f,s=this._$parent;for(;s;)i=j(s._$transform._$rawMatrix(),i),s=s._$parent;Di.setTransform(1,0,0,1,0,0),Di.beginPath();const r={x:t,y:e,pointer:"",hit:null};return this._$mouseHit(Di,i,r)}_$createWorkerInstance(){if(this._$created||!Zi)return;this._$created=!0;const t=U(),e={command:"createDisplayObjectContainer",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1},i="_$graphics"in this?this._$graphics:null;if(i){const s=i._$getRecodes();t.push(s.buffer),e.recodes=s,e.maxAlpha=i._$maxAlpha,e.canDraw=i._$canDraw,e.xMin=i._$xMin,e.yMin=i._$yMin,e.xMax=i._$xMax,e.yMax=i._$yMax}Zi.postMessage(e,t)}_$postProperty(){if(!Zi)return;this._$postChildrenIds();const t=U(),e=this._$createMessage(),i="_$graphics"in this?this._$graphics:null;if(i&&!i._$buffer){e.maxAlpha=i._$maxAlpha,e.canDraw=i._$canDraw;const s=i._$getRecodes();e.recodes=s,t.push(s.buffer);const r=this._$getBounds();e.xMin=r.xMin,e.yMin=r.yMin,e.xMax=r.xMax,e.yMax=r.yMax}Zi.postMessage(e,t),G(t),this._$posted=!0,this._$updated=!1}_$postChildrenIds(t=null){if(Zi)if(t)Zi.postMessage({command:"setChildren",instanceId:this._$instanceId,children:t});else{const e=this._$getChildren();t=U();for(let i=0;i<e.length;++i)t.push(e[i]._$instanceId);Zi.postMessage({command:"setChildren",instanceId:this._$instanceId,children:t}),G(t)}}}const Vt=window,Yt=Vt.devicePixelRatio,Xt=Vt.document,zt=RegExp;class Ht extends Gt{_$player;_$invalidate;_$color;_$frameRate;constructor(){super(),this._$player=null,this._$root=this,this._$stage=this,this._$invalidate=!0,this._$color=4294967295,this._$frameRate=60}static toString(){return"[class Stage]"}static get namespace(){return"next2d.display.Stage"}toString(){return"[object Stage]"}get namespace(){return"next2d.display.Stage"}get color(){return this._$color}set color(t){this._$color=W(J(t),0,16777215,16777215);const e=this._$player;if(e&&e.context){const t=Z(this._$color);e.context._$setColor(t.R/255,t.G/255,t.B/255,t.A/255)}}get frameRate(){return this._$frameRate}set frameRate(t){this._$frameRate=W(+t,1,60,60),this._$player&&!this._$player._$stopFlag&&(this._$player.stop(),this._$player.play())}get player(){return this._$player}get canvasHeight(){return this._$player?this._$player._$height/Yt:0}get canvasWidth(){return this._$player?this._$player._$width/Yt:0}get currentStageHeight(){return this._$player?this._$player.height*this._$player._$scale:0}get currentStageWidth(){return this._$player?this._$player.width*this._$player._$scale:0}get stageHeight(){return this._$player?this._$player.height:0}get stageWidth(){return this._$player?this._$player.width:0}invalidate(){this._$invalidate=!0}_$addChild(t){return t._$stage=this,t._$root=t,super._$addChild(t)}}class Wt{_$pool;_$store;_$timerMap;_$context;constructor(){this._$pool=[],this._$store=new Map,this._$timerMap=new Map,this._$context=null}set context(t){this._$context=t}reset(){for(const t of this._$store.values()){for(const e of t.values())this.destroy(e);V(t)}this._$store.clear()}destroy(t=null){if(t)if(t instanceof WebGLTexture)$((()=>{this._$context&&this._$context.frameBuffer.releaseTexture(t)}));else if(t instanceof CanvasRenderingContext2D){const e=t.canvas,i=e.width,s=e.height;t.clearRect(0,0,i+1,s+1),e.width=e.height=1,this._$pool.push(e)}}getCanvas(){return this._$pool.pop()||document.createElement("canvas")}remove(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t);i.has(e)&&(i.delete(e),i.size||(V(i),this._$store.delete(t)))}stopTimer(t){t=`${t}`,this._$timerMap.has(t)&&(g(this._$timerMap.get(t)),this._$timerMap.delete(t))}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const t of e.values())this.destroy(t);e.clear(),V(e),this._$store.delete(t)}this._$timerMap.delete(t)}setRemoveTimer(t){if(t=`${t}`,this.stopTimer(t),this._$store.has(t)){const e=d((()=>{this.removeCache(t)}),5e3);this._$timerMap.set(t,e)}}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){this.stopTimer(e);const t=this._$store.get(e);if(t.has(i))return t.get(i)}return null}set(t,e=null){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,Y());const r=this._$store.get(i);if(!e)return r.delete(s),void(r.size||(V(r),this._$store.delete(i)));const n=r.get(s);n&&n!==e&&this.destroy(n),r.set(s,e)}has(t){const e=`${t[0]}`;return!!this._$store.has(e)&&this._$store.get(e).has(`${t[1]}`)}generateKeys(t,e=null,i=null){let s="";e&&(s+=`${e.join("_")}`),i&&(s+=this.colorToString(i));const r=U();return r[1]=s?this.generateHash(s):"_0",r[0]=`${t}`,r}colorToString(t){return 0===t[7]?"":`_${t[7]}`}generateHash(t){let e=0;const i=t.length;for(let s=0;s<i;s++)e=(e<<5)-e+t.charCodeAt(s),e|=0;return`_${e}`}}class jt extends $t{constructor(t,e=!0,i=!1){return super(t,e,i),new Proxy(this,{get:(t,e)=>{if(e in t)return t[e];const i=bt();return i&&e in i?i[e]:void 0}})}static toString(){return"[class MouseEvent]"}static get namespace(){return"next2d.events.MouseEvent"}toString(){return this.formatToString("MouseEvent","type","bubbles","cancelable","eventPhase","localX","localY","stageX","stageY","ctrlKey","altKey","shiftKey","buttonDown","delta","commandKey","controlKey","clickCount")}get namespace(){return"next2d.events.MouseEvent"}static get CLICK(){return"click"}static get DOUBLE_CLICK(){return"dblclick"}static get MOUSE_DOWN(){return"mouseDown"}static get MOUSE_MOVE(){return"mouseMove"}static get MOUSE_OUT(){return"mouseOut"}static get MOUSE_OVER(){return"mouseOver"}static get MOUSE_UP(){return"mouseUp"}static get MOUSE_WHEEL(){return"mouseWheel"}static get ROLL_OUT(){return"rollOut"}static get ROLL_OVER(){return"rollOver"}}class qt{_$rgb;_$mode;_$type;_$focalPointRatio;_$points;_$stops;constructor(){this._$rgb="rgb",this._$mode="pad",this._$type="linear",this._$focalPointRatio=0,this._$points=P(),this._$stops=U()}dispose(){const t=this._$stops;for(let e=0;e<t.length;++e)L(t[e][1]);O(this._$points)}get mode(){return this._$mode}get type(){return this._$type}get rgb(){return this._$rgb}get points(){return this._$points}get focalPointRatio(){return this._$focalPointRatio}get stops(){return this._$stops.sort(((t,e)=>{switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}})),this._$stops}linear(t,e,i,s,r="rgb",n="pad"){return this._$type="linear",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,r,n,a="rgb",h="pad",o=0){return this._$type="radial",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=r,this._$points[5]=n,this._$rgb=a,this._$mode=h,this._$focalPointRatio=W(o,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push(U(t,e))}}class Kt{_$context;_$texture;_$repeat;_$colorTransform;constructor(t,e,i,s){this._$context=t,this._$texture=e,this._$repeat=i,this._$colorTransform=s}dispose(){this._$context.frameBuffer.releaseTexture(this._$texture)}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$colorTransform}}class Qt{_$fillStyle;_$strokeStyle;_$lineWidth;_$lineCap;_$lineJoin;_$miterLimit;constructor(){this._$fillStyle=I(1,1,1,1),this._$strokeStyle=I(1,1,1,1),this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5}get miterLimit(){return this._$miterLimit}set miterLimit(t){this._$miterLimit=t}get lineWidth(){return this._$lineWidth}set lineWidth(t){this._$lineWidth=t}get lineCap(){return this._$lineCap}set lineCap(t){this._$lineCap=t}get lineJoin(){return this._$lineJoin}set lineJoin(t){this._$lineJoin=t}get fillStyle(){return this._$fillStyle}set fillStyle(t){this._$fillStyle instanceof a&&L(this._$fillStyle),this._$fillStyle=t}get strokeStyle(){return this._$strokeStyle}set strokeStyle(t){this._$strokeStyle instanceof a&&L(this._$strokeStyle),this._$strokeStyle=t}clear(){this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5,this._$clearFill(),this._$clearStroke()}_$clearFill(){return this._$fillStyle instanceof qt||this._$fillStyle instanceof Kt?(this._$fillStyle.dispose(),void(this._$fillStyle=I(1,1,1,1))):void this._$fillStyle.fill(1)}_$clearStroke(){return this._$strokeStyle instanceof qt||this._$strokeStyle instanceof Kt?(this._$strokeStyle.dispose(),void(this._$strokeStyle=I(1,1,1,1))):void this._$strokeStyle.fill(1)}}class Jt{_$gl;_$objectPool;_$boundTextures;_$objectPoolArea;_$activeTexture;_$maxWidth;_$maxHeight;constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(t,e){const i=this._$gl.createTexture();return i.width=0,i.height=0,i.area=0,i.dirty=!0,i.smoothing=!0,i._$offsetX=0,i._$offsetY=0,this.bind0(i,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,t,e),i}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}create(t,e,i=null,s=!1,r=!0){const n=this._$getTexture(t,e);return s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,t,e,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):i&&(n.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,t,e,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)),s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),n}createFromImage(t,e=!1){return this._$createFromElement(t.width,t.height,t,e)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1)}createFromVideo(t,e=!1){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e)}_$createFromElement(t,e,i,s=!1){const r=this._$getTexture(t,e);return r.dirty=!1,this.bind0(r,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r.width!==t||r.height!==e?(r.width=t,r.height=e,r.area=t*e,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPool.length&&this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i=null,s=null){const r=i!==this._$boundTextures[t],n=null!==s&&null!==i&&s!==i.smoothing;if((r||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),r&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i&&(i.smoothing=!!s);const t=s?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class Zt{_$gl;_$objectPool;_$objectPoolArea;_$maxWidth;_$maxHeight;constructor(t){this._$gl=t,this._$objectPool=U(),this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}set maxWidth(t){this._$maxWidth=t}set maxHeight(t){this._$maxHeight=t}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the stencil buffer is null.");return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;++s){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();if(t)return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();t&&(this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t))}}}class te{_$gl;_$objectPool;_$samples;constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=U()}set samples(t){this._$samples=t}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the color buffer is null.");const e=this._$gl.createRenderbuffer();if(!e)throw new Error("the stencil buffer is null.");return t.stencil=e,t.samples=0,t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}const i=this._$objectPool.shift();if(!i)throw new Error("the color buffer is void.");return i}create(t,e,s=0){t=i.max(256,X(t)),e=i.max(256,X(e));const r=this._$getColorBuffer(t*e);return s||(s=this._$samples),(r.width<t||r.height<e||r.samples!==s)&&(t=i.max(t,r.width),e=i.max(e,r.height),r.samples=s,r.width=t,r.height=e,r.area=t*e,r.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,s,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,s,this._$gl.STENCIL_INDEX8,t,e)),r}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,s=this._$objectPool.length;for(;i.abs(s-e)>1;){const r=i.floor((s+e)/2);t<=this._$objectPool[r].area?s=r:e=r}return s}}class ee{_$gl;_$objectPool;_$frameBuffer;_$frameBufferTexture;_$currentAttachment;_$isBinding;_$textureManager;_$stencilBufferPool;_$colorBufferPool;constructor(t,e){this._$gl=t,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer),this._$frameBufferTexture=t.createFramebuffer(),this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new Jt(t),this._$stencilBufferPool=new Zt(t),this._$colorBufferPool=new te(t,e)}get currentAttachment(){return this._$currentAttachment}get textureManager(){return this._$textureManager}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(t,e)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}setMaxSize(t,e){this._$stencilBufferPool._$maxWidth=t,this._$stencilBufferPool._$maxHeight=e,this._$textureManager._$maxWidth=t,this._$textureManager._$maxHeight=e}createTextureAttachment(t,e){const i=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!0};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t=null,e=!1){t&&t.isActive&&(t.msaa?t.color instanceof WebGLRenderbuffer&&this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&t.texture&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?t.color instanceof WebGLRenderbuffer&&(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):t.color instanceof WebGLTexture&&(t.color&&this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");if(!this._$currentAttachment.msaa&&this._$currentAttachment.texture)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;if(!i)throw new Error("the texture is null.");return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t,e=!1){return this._$textureManager.createFromImage(t,e)}createTextureFromVideo(t,e=!1){return this._$textureManager.createFromVideo(t,e)}createTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class ie{_$bezierConverterBuffer;constructor(){this._$bezierConverterBuffer=new a(32)}cubicToQuad(t,e,i,s,r,n,a,h){this._$split2Cubic(t,e,i,s,r,n,a,h,0,16),this._$split2Cubic(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0,8),this._$split2Cubic(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16,24),this._$split2Quad(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0),this._$split2Quad(this._$bezierConverterBuffer[8],this._$bezierConverterBuffer[9],this._$bezierConverterBuffer[10],this._$bezierConverterBuffer[11],this._$bezierConverterBuffer[12],this._$bezierConverterBuffer[13],this._$bezierConverterBuffer[14],this._$bezierConverterBuffer[15],8),this._$split2Quad(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16),this._$split2Quad(this._$bezierConverterBuffer[24],this._$bezierConverterBuffer[25],this._$bezierConverterBuffer[26],this._$bezierConverterBuffer[27],this._$bezierConverterBuffer[28],this._$bezierConverterBuffer[29],this._$bezierConverterBuffer[30],this._$bezierConverterBuffer[31],24)}_$split2Cubic(t,e,i,s,r,n,a,h,o,l){const _=.125*(t+3*(i+r)+a),$=.125*(e+3*(s+n)+h),c=.125*(a+r-i-t),u=.125*(h+n-s-e);this._$bezierConverterBuffer[o]=t,this._$bezierConverterBuffer[o+1]=e,this._$bezierConverterBuffer[o+2]=.5*(t+i),this._$bezierConverterBuffer[o+3]=.5*(e+s),this._$bezierConverterBuffer[o+4]=_-c,this._$bezierConverterBuffer[o+5]=$-u,this._$bezierConverterBuffer[o+6]=_,this._$bezierConverterBuffer[o+7]=$,this._$bezierConverterBuffer[l]=_,this._$bezierConverterBuffer[l+1]=$,this._$bezierConverterBuffer[l+2]=_+c,this._$bezierConverterBuffer[l+3]=$+u,this._$bezierConverterBuffer[l+4]=.5*(r+a),this._$bezierConverterBuffer[l+5]=.5*(n+h),this._$bezierConverterBuffer[l+6]=a,this._$bezierConverterBuffer[l+7]=h}_$split2Quad(t,e,i,s,r,n,a,h,o){const l=.125*(t+3*(i+r)+a),_=.125*(e+3*(s+n)+h);this._$bezierConverterBuffer[o]=.25*t+.75*i,this._$bezierConverterBuffer[o+1]=.25*e+.75*s,this._$bezierConverterBuffer[o+2]=l,this._$bezierConverterBuffer[o+3]=_,this._$bezierConverterBuffer[o+4]=.75*r+.25*a,this._$bezierConverterBuffer[o+5]=.75*n+.25*h,this._$bezierConverterBuffer[o+6]=a,this._$bezierConverterBuffer[o+7]=h}}class se{_$currentPath;_$vertices;_$bezierConverter;constructor(){this._$currentPath=U(),this._$vertices=U(),this._$bezierConverter=new ie}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)G(this._$vertices.pop())}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,r,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(r,n))return;const a=+this._$currentPath[this._$currentPath.length-3],h=+this._$currentPath[this._$currentPath.length-2];this._$bezierConverter.cubicToQuad(a,h,t,e,i,s,r,n);const o=this._$bezierConverter._$bezierConverterBuffer;for(let t=0;t<32;)this.quadTo(o[t++],o[t++],o[t++],o[t++])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=+this._$currentPath[0],e=+this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=+this._$currentPath[this._$currentPath.length-3],s=+this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t,e,i)}_$pushCurrentPathToVertices(){this._$currentPath.length<4?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=U())}createRectVertices(t,e,i,s){return U(U(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class re{enabled;parentMatrixA;parentMatrixB;parentMatrixC;parentMatrixD;parentMatrixE;parentMatrixF;parentMatrixG;parentMatrixH;parentMatrixI;ancestorMatrixA;ancestorMatrixB;ancestorMatrixC;ancestorMatrixD;ancestorMatrixE;ancestorMatrixF;ancestorMatrixG;ancestorMatrixH;ancestorMatrixI;parentViewportX;parentViewportY;parentViewportW;parentViewportH;minXST;minYST;minXPQ;minYPQ;maxXST;maxYST;maxXPQ;maxYPQ;constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,s,r,n,a,h,o,l,_,$,c,u,d,g,f,p,m,x){const b=n.xMax-n.xMin,v=n.yMax-n.yMin,T=a.width,y=a.height,E=i.abs(i.ceil(b*h)),M=i.abs(i.ceil(v*h)),A=T>0?(a.x-n.xMin)/b:1e-5,w=y>0?(a.y-n.yMin)/v:1e-5,C=T>0?(a.x+a.width-n.xMin)/b:.99999,S=y>0?(a.y+a.height-n.yMin)/v:.99999;let F=E*A/s,B=M*w/r,R=(s-E*(1-C))/s,I=(r-M*(1-S))/r;if(F>=R){const t=A/(A+(1-C));F=i.max(t-1e-5,0),R=i.min(t+1e-5,1)}if(B>=I){const t=w/(w+(1-S));B=i.max(t-1e-5,0),I=i.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=o,this.parentMatrixB=l,this.parentMatrixD=_,this.parentMatrixE=$,this.parentMatrixG=c,this.parentMatrixH=u,this.ancestorMatrixA=d,this.ancestorMatrixB=g,this.ancestorMatrixD=f,this.ancestorMatrixE=p,this.ancestorMatrixG=m,this.ancestorMatrixH=x,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=s,this.parentViewportH=r,this.minXST=A,this.minYST=w,this.minXPQ=F,this.minYPQ=B,this.maxXST=C,this.maxYST=S,this.maxXPQ=R,this.maxYPQ=I}disable(){this.enabled=!1}}class ne{_$gl;_$array;_$map;constructor(t,e){this._$gl=t,this._$array=[],this._$map=Y();const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t);if(!i)throw new Error("the WebGLActiveInfo is null.");const s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r=this._$gl.getUniformLocation(e,s);if(!r)throw new Error("the WebGLUniformLocation is null.");if(i.type===this._$gl.SAMPLER_2D&&1===i.size)continue;const n={};switch(i.type){case this._$gl.FLOAT_VEC4:n.method=this._$gl.uniform4fv.bind(this._$gl,r),n.array=new a(4*i.size),n.assign=-1;break;case this._$gl.INT_VEC4:n.method=this._$gl.uniform4iv.bind(this._$gl,r),n.array=new h(4*i.size),n.assign=-1;break;case this._$gl.SAMPLER_2D:n.method=this._$gl.uniform1iv.bind(this._$gl,r),n.array=new h(i.size),n.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(n),this._$map.set(s,n)}}getArray(t){const e=this._$map.get(t);if(!e||!e.array)throw new Error("the UniformData is null.");return e.array}get textures(){const t=this._$map.get("u_textures");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get highp(){const t=this._$map.get("u_highp");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get mediump(){const t=this._$map.get("u_mediump");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get integer(){const t=this._$map.get("u_integer");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];void 0!==t.method&&void 0!==t.assign&&(t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array)))}}}class ae{_$gl;_$context;_$program;_$uniform;constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new ne(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(e,i){const s=this._$gl.createProgram();if(!s)throw new Error("WebGL program error");s.id=t++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);if(!r)throw new Error("WebGL vertex shader error");this._$gl.shaderSource(r,e),this._$gl.compileShader(r);const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);if(!n)throw new Error("WebGL fragment shader error");return this._$gl.shaderSource(n,i),this._$gl.compileShader(n),this._$gl.attachShader(s,r),this._$gl.attachShader(s,n),this._$gl.linkProgram(s),this._$gl.detachShader(s,r),this._$gl.detachShader(s,n),this._$gl.deleteShader(r),this._$gl.deleteShader(n),s}_$attachProgram(){const t=this._$context.shaderList;t.currentProgramId!==this._$program.id&&(t.currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(t,e){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(t,e),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawElements(this._$gl.TRIANGLES,t.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t);const e=t.indexRanges,i=e[e.length-1],s=i.first+i.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,s)}_$containerClip(t,e,i){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.TRIANGLES,e,i)}_$drawPoints(t,e,i){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.POINTS,e,i)}}class he{static FUNCTION_GRID_OFF(){return"\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\n\n    return position;\n}\n\n"}static FUNCTION_GRID_ON(t){return`\n\nvec2 applyMatrix(in vec2 vertex) {\n    mat3 parent_matrix = mat3(\n        u_highp[${t}].xyz,\n        u_highp[${t+1}].xyz,\n        u_highp[${t+2}].xyz\n    );\n    mat3 ancestor_matrix = mat3(\n        u_highp[${t+3}].xyz,\n        u_highp[${t+4}].xyz,\n        u_highp[${t+5}].xyz\n    );\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\n    vec4 grid_min = u_highp[${t+6}];\n    vec4 grid_max = u_highp[${t+7}];\n\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\n    position = (position - parent_offset) / parent_size;\n\n    vec4 ga = grid_min;\n    vec4 gb = grid_max  - grid_min;\n    vec4 gc = vec4(1.0) - grid_max;\n\n    vec2 pa = position;\n    vec2 pb = position - grid_min.st;\n    vec2 pc = position - grid_max.st;\n\n    position = (ga.pq / ga.st) * min(pa, ga.st)\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\n\n    position = position * parent_size + parent_offset;\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\n\n    return position;\n}\n\n`}}class oe{static TEMPLATE(t,e,i,s){const r=e-1,n=i?this.VARYING_UV_ON():"",a=i?this.STATEMENT_UV_ON():"";return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\nlayout (location = 1) in vec2 a_option1;\nlayout (location = 2) in vec2 a_option2;\nlayout (location = 3) in float a_type;\n\nuniform vec4 u_highp[${t}];\n\n${n}\n\n${s?he.FUNCTION_GRID_ON(i?5:0):he.FUNCTION_GRID_OFF()}\n\nfloat crossVec2(in vec2 v1, in vec2 v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n}\n\nvec2 perpendicularVec2(in vec2 v1) {\n    float face = u_highp[${r}][1];\n\n    return face * vec2(v1.y, -v1.x);\n}\n\nvec2 calculateNormal(in vec2 direction) {\n    vec2 normalized = normalize(direction);\n    return perpendicularVec2(normalized);\n}\n\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\n    return (o1 + t * v1);\n}\n\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\n    float miter_limit = u_highp[${r}][2];\n\n    vec2 a = applyMatrix(a_option1);\n    vec2 b = applyMatrix(a_option2);\n\n    v1 = convex * (position - a);\n    v2 = convex * (b - position);\n    o1 = calculateNormal(v1) + a;\n    o2 = calculateNormal(v2) + position;\n\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\n    return normalize(anchor) * min(length(anchor), miter_limit);\n}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n    float half_width = u_highp[${r}][0];\n\n    vec2 position = applyMatrix(a_vertex);\n    vec2 offset = vec2(0.0);\n    vec2 v1, v2, o1, o2;\n\n    if (a_type == 1.0 || a_type == 2.0) { // \n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\n    } else if (a_type == 10.0) { // \n        offset = normalize(position - applyMatrix(a_option1));\n        offset += a_option2 * perpendicularVec2(offset);\n    } else if (a_type == 21.0) { // B\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type == 22.0) { // A\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 23.0) { // A\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\n    } else if (a_type == 24.0) { // B\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\n    } else if (a_type >= 30.0) { // \n        float face = u_highp[${r}][1];\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\n    }\n    \n    offset *= half_width;\n    position += offset;\n    ${a}\n\n    position /= viewport;\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n`}static VARYING_UV_ON(){return"\nout vec2 v_uv;\n"}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\n    v_uv += offset;\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\n"}}class le{static TEMPLATE(t,e,i,s){const r=i?this.ATTRIBUTE_BEZIER_ON():"",n=i?this.VARYING_BEZIER_ON():e?this.VARYING_UV_ON():"",a=i?this.STATEMENT_BEZIER_ON():e?this.STATEMENT_UV_ON():"";return`#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n${r}\n\nuniform vec4 u_highp[${t}];\n\n${n}\n\n${s?he.FUNCTION_GRID_ON(e?5:0):he.FUNCTION_GRID_OFF()}\n\nvoid main() {\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\n\n    ${a}\n\n    vec2 pos = applyMatrix(a_vertex) / viewport;\n    pos = pos * 2.0 - 1.0;\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\n}\n\n`}static ATTRIBUTE_BEZIER_ON(){return"\nlayout (location = 1) in vec2 a_bezier;\n"}static VARYING_UV_ON(){return"\nout vec2 v_uv;\n"}static VARYING_BEZIER_ON(){return"\nout vec2 v_bezier;\n"}static STATEMENT_UV_ON(){return"\n    mat3 uv_matrix = mat3(\n        u_highp[0].xyz,\n        u_highp[1].xyz,\n        u_highp[2].xyz\n    );\n    mat3 inverse_matrix = mat3(\n        u_highp[3].xyz,\n        u_highp[4].xyz,\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\n    );\n\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\n"}static STATEMENT_BEZIER_ON(){return"\n    v_bezier = a_bezier;\n"}}class _e{static FUNCTION_IS_INSIDE(){return"\n\nfloat isInside(in vec2 uv) {\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\n}\n\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\n    vec4 mul = u_mediump[${t}];\n    vec4 add = u_mediump[${t+1}];\n\n    src.rgb /= max(0.0001, src.a);\n    src = clamp(src * mul + add, 0.0, 1.0);\n    src.rgb *= src.a;\n`}}class $e{static SOLID_COLOR(){return"#version 300 es\nprecision mediump float;\n\nuniform vec4 u_mediump;\n\nout vec4 o_color;\n\nvoid main() {\n    o_color = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\n}\n\n"}static BITMAP_CLIPPED(){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\n\n    vec4 src = texture(u_texture, uv);\n    ${_e.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    o_color = src;\n}`}static BITMAP_PATTERN(){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[3];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\n    \n    vec4 src = texture(u_texture, uv);\n    ${_e.STATEMENT_COLOR_TRANSFORM_ON(1)}\n    o_color = src;\n}`}static MASK(){return"#version 300 es\nprecision mediump float;\n\nin vec2 v_bezier;\nout vec4 o_color;\n\nvoid main() {\n    vec2 px = dFdx(v_bezier);\n    vec2 py = dFdy(v_bezier);\n\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\n\n    if (alpha > 0.0) {\n        o_color = vec4(min(alpha, 1.0));\n    } else {\n        discard;\n    }    \n}\n\n"}}class ce{_$context;_$gl;_$collection;constructor(t,e){this._$context=t,this._$gl=e,this._$collection=Y()}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?oe.TEMPLATE(s,r,!1,e):le.TEMPLATE(s,!1,!1,e);const a=new ae(this._$gl,this._$context,n,$e.SOLID_COLOR());return this._$collection.set(i,a),a}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r=(i?13:5)+(t?1:0),n=r;let a;a=t?oe.TEMPLATE(r,n,!0,i):le.TEMPLATE(r,!0,!1,i);const h=e?$e.BITMAP_PATTERN():$e.BITMAP_CLIPPED(),o=new ae(this._$gl,this._$context,a,h);return this._$collection.set(s,o),o}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?oe.TEMPLATE(s,r,!1,e):le.TEMPLATE(s,!1,!0,e);const a=new ae(this._$gl,this._$context,n,$e.MASK());return this._$collection.set(i,a),a}setSolidColorShapeUniform(t,e,i,s,r,n,a,h,o,l,_,$){const c=t.highp;let u;n?(c[0]=l.parentMatrixA,c[1]=l.parentMatrixB,c[2]=l.parentMatrixC,c[4]=l.parentMatrixD,c[5]=l.parentMatrixE,c[6]=l.parentMatrixF,c[8]=l.parentMatrixG,c[9]=l.parentMatrixH,c[10]=l.parentMatrixI,c[12]=l.ancestorMatrixA,c[13]=l.ancestorMatrixB,c[14]=l.ancestorMatrixC,c[16]=l.ancestorMatrixD,c[17]=l.ancestorMatrixE,c[18]=l.ancestorMatrixF,c[20]=l.ancestorMatrixG,c[21]=l.ancestorMatrixH,c[22]=l.ancestorMatrixI,c[3]=h,c[7]=o,c[11]=l.parentViewportX,c[15]=l.parentViewportY,c[19]=l.parentViewportW,c[23]=l.parentViewportH,c[24]=l.minXST,c[25]=l.minYST,c[26]=l.minXPQ,c[27]=l.minYPQ,c[28]=l.maxXST,c[29]=l.maxYST,c[30]=l.maxXPQ,c[31]=l.maxYPQ,u=32):(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[4]=a[3],c[5]=a[4],c[6]=a[5],c[8]=a[6],c[9]=a[7],c[10]=a[8],c[3]=h,c[7]=o,u=12),e&&(c[u]=i,c[u+1]=s,c[u+2]=r);const d=t.mediump;d[0]=_[0],d[1]=_[1],d[2]=_[2],d[3]=_[3]*$}setBitmapShapeUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u,d,g,f,p,m,x,b){const v=t.highp;let T;v[0]=a[0],v[1]=a[1],v[2]=a[2],v[4]=a[3],v[5]=a[4],v[6]=a[5],v[8]=a[6],v[9]=a[7],v[10]=a[8],v[12]=h[0],v[13]=h[1],v[14]=h[2],v[16]=h[3],v[17]=h[4],v[18]=h[5],v[11]=h[6],v[15]=h[7],v[19]=h[8],v[3]=o,v[7]=l,T=20,n&&(v[T]=_.parentMatrixA,v[T+1]=_.parentMatrixB,v[T+2]=_.parentMatrixC,v[T+4]=_.parentMatrixD,v[T+5]=_.parentMatrixE,v[T+6]=_.parentMatrixF,v[T+8]=_.parentMatrixG,v[T+9]=_.parentMatrixH,v[T+10]=_.parentMatrixI,v[T+12]=_.ancestorMatrixA,v[T+13]=_.ancestorMatrixB,v[T+14]=_.ancestorMatrixC,v[T+16]=_.ancestorMatrixD,v[T+17]=_.ancestorMatrixE,v[T+18]=_.ancestorMatrixF,v[T+20]=_.ancestorMatrixG,v[T+21]=_.ancestorMatrixH,v[T+22]=_.ancestorMatrixI,v[T+11]=_.parentViewportX,v[T+15]=_.parentViewportY,v[T+19]=_.parentViewportW,v[T+23]=_.parentViewportH,v[T+24]=_.minXST,v[T+25]=_.minYST,v[T+26]=_.minXPQ,v[T+27]=_.minYPQ,v[T+28]=_.maxXST,v[T+29]=_.maxYST,v[T+30]=_.maxXPQ,v[T+31]=_.maxYPQ,T=52),e&&(v[T]=i,v[T+1]=s,v[T+2]=r);const y=t.mediump;y[0]=$,y[1]=c,y[4]=u,y[5]=d,y[6]=g,y[7]=f,y[8]=p,y[9]=m,y[10]=x,y[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u=null){const d=t.highp;e&&u?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=$,d[7]=c,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=h,d[8]=o,d[9]=l,d[10]=_,d[3]=$,d[7]=c)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class ue{static TEMPLATE(t,e,i,s,r){const n=i?this.STATEMENT_GRADIENT_TYPE_RADIAL(e,s):this.STATEMENT_GRADIENT_TYPE_LINEAR(e);let a;switch(r){case"reflect":a="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":a="fract(t)";break;default:a="clamp(t, 0.0, 1.0)"}return`#version 300 es\nprecision highp float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_highp[${t}];\n\nin vec2 v_uv;\nout vec4 o_color;\n\nvoid main() {\n    vec2 p = v_uv;\n    ${n}\n    t = ${a};\n    o_color = texture(u_texture, vec2(t, 0.5));\n}\n\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\n    vec2 a = u_highp[${t}].xy;\n    vec2 b = u_highp[${t}].zw;\n\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\n    float radius = u_highp[${t}][0];\n\n    vec2 coord = p / radius;\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\n    float t = length(coord);\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\n\n    vec2 dir = normalize(coord - focal);\n\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, focal);\n    float c = dot(focal, focal) - 1.0;\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\n`}}class de{_$context;_$gl;_$collection;constructor(t,e){this._$context=t,this._$gl=e,this._$collection=Y()}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(e?13:5)+(t?1:0)+1,h=a-1;let o;o=t?oe.TEMPLATE(a,h,!0,e):le.TEMPLATE(a,!0,!1,e);const l=new ae(this._$gl,this._$context,o,ue.TEMPLATE(a,h,i,s,r));return this._$collection.set(n,l),l}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",h=i?"y":"n",o=i&&s?"y":"n";let l=0;switch(r){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${h}${o}${l}`}setGradientShapeUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=h[0],d[13]=h[1],d[14]=h[2],d[16]=h[3],d[17]=h[4],d[18]=h[5],d[11]=h[6],d[15]=h[7],d[19]=h[8],d[3]=o,d[7]=l;let g=20;n&&(d[g]=_.parentMatrixA,d[g+1]=_.parentMatrixB,d[g+2]=_.parentMatrixC,d[g+4]=_.parentMatrixD,d[g+5]=_.parentMatrixE,d[g+6]=_.parentMatrixF,d[g+8]=_.parentMatrixG,d[g+9]=_.parentMatrixH,d[g+10]=_.parentMatrixI,d[g+12]=_.ancestorMatrixA,d[g+13]=_.ancestorMatrixB,d[g+14]=_.ancestorMatrixC,d[g+16]=_.ancestorMatrixD,d[g+17]=_.ancestorMatrixE,d[g+18]=_.ancestorMatrixF,d[g+20]=_.ancestorMatrixG,d[g+21]=_.ancestorMatrixH,d[g+22]=_.ancestorMatrixI,d[g+11]=_.parentViewportX,d[g+15]=_.parentViewportY,d[g+19]=_.parentViewportW,d[g+23]=_.parentViewportH,d[g+24]=_.minXST,d[g+25]=_.minYST,d[g+26]=_.minXPQ,d[g+27]=_.minYPQ,d[g+28]=_.maxXST,d[g+29]=_.maxYST,d[g+30]=_.maxXPQ,d[g+31]=_.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=s,d[g+2]=r,g+=4),$?(d[g]=c[5],d[g+1]=u):(d[g]=c[0],d[g+1]=c[1],d[g+2]=c[2],d[g+3]=c[3])}}class ge{static TEXTURE(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 position = a_vertex * 2.0 - 1.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n\n"}static BLEND(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset   = u_highp[0].xy;\n    vec2 size     = u_highp[0].zw;\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position = position * size + offset;\n    position = (matrix * vec3(position, 1.0)).xy;\n    position /= viewport;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}static BLEND_CLIP(){return"#version 300 es\n\nlayout (location = 0) in vec2 a_vertex;\n\nuniform vec4 u_highp[4];\n\nout vec2 v_coord;\n\nvoid main() {\n    v_coord = a_vertex;\n\n    vec2 offset     = u_highp[0].xy;\n    vec2 size       = u_highp[0].zw;\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\n\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\n    position *= viewport;\n    position = (inv_matrix * vec3(position, 1.0)).xy;\n    position = (position - offset) / size;\n\n    position = position * 2.0 - 1.0;\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n}\n\n"}}class fe{static TEMPLATE(t,e,s){let r="";for(let t=1;t<e;t++){const s=t-1,n=t,a=`u_mediump[${e+i.floor(s/4)}][${s%4}]`,h=`u_mediump[${e+i.floor(n/4)}][${n%4}]`;r+=`\n    if (t <= ${h}) {\n        return mix(u_mediump[${s}], u_mediump[${n}], (t - ${a}) / (${h} - ${a}));\n    }\n`}return`#version 300 es\nprecision mediump float;\n\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvec4 getGradientColor(in float t) {\n    if (t <= u_mediump[${e}][0]) {\n        return u_mediump[0];\n    }\n    ${r}\n    return u_mediump[${e-1}];\n}\n\nvoid main() {\n    vec4 color = getGradientColor(v_coord.x);\n    ${s?"color = pow(color, vec4(0.45454545));":""}\n    color.rgb *= color.a;\n\n    o_color = color;\n}\n\n`}}class pe{_$context;_$gl;_$collection;constructor(t,e){this._$context=t,this._$gl=e,this._$collection=Y()}getGradientLUTShader(t,e){const s=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r=i.ceil(5*t/4),n=new ae(this._$gl,this._$context,ge.TEXTURE(),fe.TEMPLATE(r,t,e));return this._$collection.set(s,n),n}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n++]=r[i[0]],a[n++]=r[i[1]],a[n++]=r[i[2]],a[n++]=r[i[3]]}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const h=t.mediump;for(let t=r;t<n;t++){const e=i[t];h[a++]=(e>>16)/255,h[a++]=(e>>8&255)/255,h[a++]=(255&e)/255,h[a++]=s[t]}for(let t=r;t<n;t++)h[a++]=e[t]}}class me{static TEMPLATE(t,e,i,s,r,n,a,h,o){let l=0;const _=i?this.STATEMENT_BASE_TEXTURE_TRANSFORM(l++):"",$=s?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(l++):this.STATEMENT_BLUR_TEXTURE(),c="inner"===n,u=l;let d,g,f=4*l;switch(o?d=r?this.STATEMENT_GLOW(!1,i,h,o,u,f):this.STATEMENT_BEVEL(i,s,h,o,u,f):r?(f+=4,d=this.STATEMENT_GLOW(c,i,h,o,u,f)):(f+=8,d=this.STATEMENT_BEVEL(i,s,h,o,u,f)),n){case"outer":g=a?"blur - blur * base.a":"base + blur - blur * base.a";break;case"full":g=a?"blur":"base - base * blur.a + blur";break;default:g="blur"}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[${t}];\nuniform vec4 u_mediump[${e}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${_e.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    ${_}\n    ${$}\n    ${d}\n    o_color = ${g};\n}\n\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t){return`\n    vec2 base_scale  = u_mediump[${t}].xy;\n    vec2 base_offset = u_mediump[${t}].zw;\n\n    vec2 uv = v_coord * base_scale - base_offset;\n    vec4 base = mix(vec4(0.0), texture(u_textures[1], uv), isInside(uv));\n`}static STATEMENT_BLUR_TEXTURE(){return"\n    vec4 blur = texture(u_textures[0], v_coord);\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t){return`\n    vec2 blur_scale  = u_mediump[${t}].xy;\n    vec2 blur_offset = u_mediump[${t}].zw;\n\n    vec2 st = v_coord * blur_scale - blur_offset;\n    vec4 blur = mix(vec4(0.0), texture(u_textures[0], st), isInside(st));\n`}static STATEMENT_GLOW(t,e,i,s,r,n){return`\n    ${t?"blur.a = 1.0 - blur.a;":""}\n    ${i?this.STATEMENT_GLOW_STRENGTH(n):""}\n    ${s?this.STATEMENT_GLOW_GRADIENT_COLOR(e):this.STATEMENT_GLOW_SOLID_COLOR(r)}\n`}static STATEMENT_GLOW_STRENGTH(t){return`\n    float strength = u_mediump[${i.floor(t/4)}][${t%4}];\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\n    vec4 color = u_mediump[${t}];\n    blur = color * blur.a;\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t){return`\n    blur = texture(u_textures[${t?2:1}], vec2(blur.a, 0.5));\n`}static STATEMENT_BEVEL(t,e,i,s,r,n){return`\n    ${e?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2():this.STATEMENT_BLUR_TEXTURE_2()}\n    float highlight_alpha = blur.a - blur2.a;\n    float shadow_alpha    = blur2.a - blur.a;\n    ${i?this.STATEMENT_BEVEL_STRENGTH(n):""}\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\n    ${s?this.STATEMENT_BEVEL_GRADIENT_COLOR(t):this.STATEMENT_BEVEL_SOLID_COLOR(r)}\n`}static STATEMENT_BLUR_TEXTURE_2(){return"\n    vec4 blur2 = texture(u_textures[0], 1.0 - v_coord);\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(){return"\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\n    vec4 blur2 = mix(vec4(0.0), texture(u_textures[0], pq), isInside(pq));\n"}static STATEMENT_BEVEL_STRENGTH(t){return`\n    float strength = u_mediump[${i.floor(t/4)}][${t%4}];\n    highlight_alpha *= strength;\n    shadow_alpha    *= strength;\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\n    vec4 highlight_color = u_mediump[${t}];\n    vec4 shadow_color    = u_mediump[${t+1}];\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t){return`\n    blur = texture(u_textures[${t?2:1}], vec2(\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\n        0.5\n    ));\n`}}class xe{static TEMPLATE(t){const e=t.toFixed(1);return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump;\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec2  offset   = u_mediump.xy;\n    float fraction = u_mediump.z;\n    float samples  = u_mediump.w;\n    \n    vec4 color = texture(u_texture, v_coord);\n\n    for (float i = 1.0; i < ${e}; i += 1.0) {\n        color += texture(u_texture, v_coord + offset * i);\n        color += texture(u_texture, v_coord - offset * i);\n    }\n    color += texture(u_texture, v_coord + offset * ${e}) * fraction;\n    color += texture(u_texture, v_coord - offset * ${e}) * fraction;\n    color /= samples;\n\n    o_color = color;\n}\n\n`}}class be{static TEMPLATE(){return"#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[5];\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\n    vec4 add = u_mediump[4];\n    \n    vec4 color = texture(u_texture, v_coord);\n\n    color.rgb /= max(0.0001, color.a);\n    color = clamp(color * mul + add, 0.0, 1.0);\n    color.rgb *= color.a;\n\n    o_color = color;\n}\n\n"}}class ve{static TEMPLATE(t,e,s,r,n){const a=i.floor(.5*e),h=i.floor(.5*s),o=e*s;let l="";const _=n?1:2;for(let t=0;t<o;++t)l+=`\n    result += getWeightedColor(${t}, u_mediump[${_+i.floor(t/4)}][${t%4}]);\n`;const $=r?"result.a = texture(u_texture, v_coord).a;":"",c=n?"":"\n    vec4 substitute_color = u_mediump[1];\n    color = mix(substitute_color, color, isInside(uv));\n";return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${_e.FUNCTION_IS_INSIDE()}\n\nvec4 getWeightedColor (in int i, in float weight) {\n    vec2 rcp_size = u_mediump[0].xy;\n\n    int i_div_x = i / ${e};\n    int i_mod_x = i - ${e} * i_div_x;\n    vec2 offset = vec2(i_mod_x - ${a}, ${h} - i_div_x);\n    vec2 uv = v_coord + offset * rcp_size;\n\n    vec4 color = texture(u_texture, uv);\n    color.rgb /= max(0.0001, color.a);\n    ${c}\n\n    return color * weight;\n}\n\nvoid main() {\n    float rcp_divisor = u_mediump[0].z;\n    float bias        = u_mediump[0].w;\n\n    vec4 result = vec4(0.0);\n    ${l}\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\n    ${$}\n\n    result.rgb *= result.a;\n    o_color = result;\n}\n\n`}}class Te{static TEMPLATE(t,e,i,s){let r,n,a;switch(e){case 1:r="map_color.r";break;case 2:r="map_color.g";break;case 4:r="map_color.b";break;case 8:r="map_color.a";break;default:r="0.5"}switch(i){case 1:n="map_color.r";break;case 2:n="map_color.g";break;case 4:n="map_color.b";break;case 8:n="map_color.a";break;default:n="0.5"}switch(s){case"clamp":a="\n    vec4 source_color = texture(u_textures[0], uv);\n";break;case"ignore":a="\n    vec4 source_color =texture(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\n";break;case"color":a="\n    vec4 substitute_color = u_mediump[2];\n    vec4 source_color = mix(substitute_color, texture(u_textures[0], uv), isInside(uv));\n";break;default:a="\n    vec4 source_color = texture(u_textures[0], fract(uv));\n"}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\nuniform vec4 u_mediump[${t}];\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${_e.FUNCTION_IS_INSIDE()}\n\nvoid main() {\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\n    vec2 uv_to_st_offset = u_mediump[0].zw;\n    vec2 scale           = u_mediump[1].xy;\n\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\n    vec4 map_color = texture(u_textures[1], st);\n\n    vec2 offset = vec2(${r}, ${n}) - 0.5;\n    vec2 uv = v_coord + offset * scale;\n    ${a}\n\n    o_color = mix(texture(u_textures[0], v_coord), source_color, isInside(st));\n}\n\n`}}class ye{_$context;_$gl;_$collection;constructor(t,e){this._$context=t,this._$gl=e,this._$collection=Y()}getBlurFilterShader(t){const e=`b${t}`;if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new ae(this._$gl,this._$context,ge.TEXTURE(),xe.TEMPLATE(t));return this._$collection.set(e,i),i}getBitmapFilterShader(t,e,s,r,n,a,h){const o=`f${t?"y":"n"}${e?"y":"n"}${s?"y":"n"}${r}${n?"y":"n"}${a?"y":"n"}`;if(this._$collection.has(o)){const t=this._$collection.get(o);if(t)return t}let l=1;t&&l++,h&&l++;let _=(t?4:0)+(e?4:0)+(a?1:0);h||(_+=s?4:8),_=i.ceil(_/4);const $=new ae(this._$gl,this._$context,ge.TEXTURE(),me.TEMPLATE(l,_,t,e,s,r,n,a,h));return this._$collection.set(o,$),$}getColorMatrixFilterShader(){if(this._$collection.has("m")){const t=this._$collection.get("m");if(t)return t}const t=new ae(this._$gl,this._$context,ge.TEXTURE(),be.TEMPLATE());return this._$collection.set("m",t),t}getConvolutionFilterShader(t,e,s,r){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${s?"y":"n"}${r?"y":"n"}`;if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(r?1:2)+i.ceil(t*e/4),h=new ae(this._$gl,this._$context,ge.TEXTURE(),ve.TEMPLATE(a,t,e,s,r));return this._$collection.set(n,h),h}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r="color"===i?3:2,n=new ae(this._$gl,this._$context,ge.TEXTURE(),Te.TEMPLATE(r,t,e,i));return this._$collection.set(s,n),n}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u,d,g,f,p,m,x,b,v,T,y,E){let M;v?(M=t.textures,M[0]=0,M[1]=1,E&&(M[2]=2)):E&&(M=t.textures,M[0]=0,M[1]=2);const A=t.mediump;let w=0;v&&(A[w]=e/s,A[w+1]=i/r,A[w+2]=n/s,A[w+3]=(i-r-a)/r,w+=4),T&&(A[w]=e/h,A[w+1]=i/o,A[w+2]=l/h,A[w+3]=(i-o-_)/o,w+=4),E||($?(A[w]=u,A[w+1]=d,A[w+2]=g,A[w+3]=f,w+=4):(A[w]=u,A[w+1]=d,A[w+2]=g,A[w+3]=f,A[w+4]=p,A[w+5]=m,A[w+6]=x,A[w+7]=b,w+=8)),y&&(A[w]=c)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,h,o,l,_){const $=t.mediump;$[0]=1/e,$[1]=1/i,$[2]=1/r,$[3]=n/255;let c=4;a||($[c]=h,$[c+1]=o,$[c+2]=l,$[c+3]=_,c+=4);const u=s.length;for(let t=0;t<u;t++)$[c++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=h/s,g[5]=-o/r,"color"===l&&(g[8]=_,g[9]=$,g[10]=c,g[11]=u)}}class Ee{static TEMPLATE(t){return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_texture;\n${t?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_coord;\nout vec4 o_color;\n\nvoid main() {\n    vec4 src = texture(u_texture, v_coord);\n    ${t?_e.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = src;\n}\n\n`}}class Me{static TEMPLATE(t,e){let i;switch(t){case"subtract":i=this.FUNCTION_SUBTRACT();break;case"multiply":i=this.FUNCTION_MULTIPLY();break;case"lighten":i=this.FUNCTION_LIGHTEN();break;case"darken":i=this.FUNCTION_DARKEN();break;case"overlay":i=this.FUNCTION_OVERLAY();break;case"hardlight":i=this.FUNCTION_HARDLIGHT();break;case"difference":i=this.FUNCTION_DIFFERENCE();break;case"invert":i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_textures[2];\n${e?"uniform vec4 u_mediump[2];":""}\n\nin vec2 v_coord;\nout vec4 o_color;\n\n${i}\n\nvoid main() {\n    vec4 dst = texture(u_textures[0], v_coord);\n    vec4 src = texture(u_textures[1], v_coord);\n    ${e?_e.STATEMENT_COLOR_TRANSFORM_ON(0):""}\n    o_color = blend(src, dst);\n}\n\n`}static FUNCTION_NORMAL(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    return src + dst - dst * src.a;\n}\n\n"}static FUNCTION_SUBTRACT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_MULTIPLY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n    vec4 c = src * dst;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_LIGHTEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DARKEN(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_OVERLAY(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_HARDLIGHT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 mul = src * dst;\n    vec3 c1 = 2.0 * mul.rgb;\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_DIFFERENCE(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 a = src - src * dst.a;\n    vec4 b = dst - dst * src.a;\n\n    src.rgb /= src.a;\n    dst.rgb /= dst.a;\n\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\n    c.rgb *= c.a;\n\n    return a + b + c;\n}\n\n"}static FUNCTION_INVERT(){return"\n\nvec4 blend (in vec4 src, in vec4 dst) {\n    if (src.a == 0.0) { return dst; }\n    if (dst.a == 0.0) { return src; }\n\n    vec4 b = dst - dst * src.a;\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\n\n    return b + c;\n}\n\n"}}class Ae{_$context;_$gl;_$collection;constructor(t,e){this._$context=t,this._$gl=e,this._$collection=Y()}getNormalBlendShader(t){const e="n"+(t?"y":"n");if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new ae(this._$gl,this._$context,ge.BLEND(),Ee.TEMPLATE(t));return this._$collection.set(e,i),i}getClipShader(){if(this._$collection.has("c")){const t=this._$collection.get("c");if(t)return t}const t=new ae(this._$gl,this._$context,ge.BLEND_CLIP(),Ee.TEMPLATE(!1));return this._$collection.set("c",t),t}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=new ae(this._$gl,this._$context,ge.BLEND(),Me.TEMPLATE(t,e));return this._$collection.set(i,s),s}setNormalBlendUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u,d,g,f){const p=t.highp;if(p[0]=e,p[1]=i,p[2]=s,p[3]=r,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=h,o){const e=t.mediump;e[0]=l,e[1]=_,e[2]=$,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}setClipUniform(t,e,i,s,r,n,a,h){const o=t.highp;o[0]=e,o[1]=i,o[2]=s,o[3]=r,o[4]=n[0],o[5]=n[1],o[6]=n[2],o[8]=n[3],o[9]=n[4],o[10]=n[5],o[12]=n[6],o[13]=n[7],o[14]=n[8],o[7]=a,o[11]=h}setBlendUniform(t,e,i,s,r,n,a,h,o,l,_,$,c,u,d,g,f){const p=t.textures;p[0]=0,p[1]=1;const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=h,o){const e=t.mediump;e[0]=l,e[1]=_,e[2]=$,e[3]=c,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class we{_$currentProgramId;_$shapeShaderVariants;_$gradientShapeShaderVariants;_$gradientLUTShaderVariants;_$filterShaderVariants;_$blendShaderVariants;constructor(t,e){this._$currentProgramId=-1,this._$shapeShaderVariants=new ce(t,e),this._$gradientShapeShaderVariants=new de(t,e),this._$gradientLUTShaderVariants=new pe(t,e),this._$filterShaderVariants=new ye(t,e),this._$blendShaderVariants=new Ae(t,e)}get currentProgramId(){return this._$currentProgramId}set currentProgramId(t){this._$currentProgramId=t}get shapeShaderVariants(){return this._$shapeShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Ce{_$context;_$gl;_$attachment;_$maxLength;_$rgbToLinearTable;_$rgbIdentityTable;constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=i.floor(.75*e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new Float32Array(256),this._$rgbIdentityTable=new Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=i.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const s=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,n=this._$context.shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let s=0;s<r;s+=this._$maxLength-1){const h=i.min(s+this._$maxLength,r),o=n.getGradientLUTShader(h-s,e),l=o.uniform;n.setGradientLUTUniformForShape(l,t,s,h,a),o._$drawGradient(0===s?0:t[s][0],h===r?1:t[h-1][0])}if(this._$context._$bind(s),!this._$attachment.texture)throw new Error("the texture is null.");return this._$attachment.texture}generateForFilter(t,e,s){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context.shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<n;r+=this._$maxLength-1){const h=i.min(r+this._$maxLength,n),o=a.getGradientLUTShader(h-r,!1),l=o.uniform;a.setGradientLUTUniformForFilter(l,t,e,s,r,h),o._$drawGradient(0===r?0:t[r],h===n?1:t[h-1])}if(this._$context._$bind(r),!this._$attachment.texture)throw new Error("the texture is null.");return this._$attachment.texture}}class Se{static _$vertexBufferData;static _$indexRanges;static _$indexRangePool=U();static _$currentIndex;static get indexRangePool(){return this._$indexRangePool}static generate(t){let e=0;for(let i=0;i<t.length;++i)e+=12*(t[i].length/3-2);this._$vertexBufferData=new a(e),this._$indexRanges=U(),this._$currentIndex=0;for(let e=0;e<t.length;++e){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i,r=this._$indexRangePool.pop()||{first:0,count:0};r.first=i,r.count=s,this._$indexRanges.push(r)}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}class Fe{static _$vertexBufferData;static _$vertexBufferPos;static _$indexBufferData;static _$indexBufferPos;static _$lineCap;static _$lineJoin;static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new a(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new a(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new o(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){let a=t,h=e;for(let o=1;o<11;o++){const l=o/11,_=1-l,$=(t*_+i*l)*_+(i*_+r*l)*l,c=(e*_+s*l)*_+(s*_+n*l)*l;this._$addLineSegmentMesh(a,h,$,c,2),a=$,h=c}this._$addLineSegmentMesh(a,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,h=n+2,o=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let _=this._$indexBufferPos;l[_++]=n,l[_++]=a,l[_++]=o,l[_++]=o,l[_++]=h,l[_++]=n,this._$indexBufferPos=_,this._$expandVertexBufferIfNeeded(28);const $=this._$vertexBufferData;let c=this._$vertexBufferPos;$[c++]=t,$[c++]=e,$[c++]=i,$[c++]=s,$[c++]=1,$[c++]=1,$[c++]=1,$[c++]=t,$[c++]=e,$[c++]=i,$[c++]=s,$[c++]=-1,$[c++]=-1,$[c++]=1,$[c++]=i,$[c++]=s,$[c++]=t,$[c++]=e,$[c++]=-1,$[c++]=-1,$[c++]=r,$[c++]=i,$[c++]=s,$[c++]=t,$[c++]=e,$[c++]=1,$[c++]=1,$[c++]=r,this._$vertexBufferPos=c}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$cross=(t,e,i,s)=>t*s-i*e;static _$addLineJoinMesh(t,e,s,r,n,a,h,o,l,_=0,$=0){const c=s-t,u=r-e,d=a-s,g=h-r,f=this._$cross(c,u,d,g);if(!(i.abs(f)<1e-4))if(2!==n)switch(this._$lineJoin){case"round":this._$addRoundJoinMesh(s,r);break;case"miter":this._$addMiterJoinMesh(s,r,t,e,a,h,_,o,l,$);break;default:this._$addBevelJoinMesh(s,r,_,o,l,$)}else this._$addBevelJoinMesh(s,r,_,o,l,$)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,h,o,l){const _=this._$vertexBufferPos/7,$=_+1,c=_+2,u=_+3,d=_+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=_,g[f++]=a,g[f++]=$,g[f++]=_,g[f++]=$,g[f++]=c,g[f++]=_,g[f++]=c,g[f++]=h,g[f++]=_,g[f++]=o,g[f++]=u,g[f++]=_,g[f++]=u,g[f++]=d,g[f++]=_,g[f++]=d,g[f++]=l,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const p=this._$vertexBufferData;let m=this._$vertexBufferPos;p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=0,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=21,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=22,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=23,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=24,this._$vertexBufferPos=m}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let o=this._$indexBufferPos;h[o++]=a,h[o++]=i,h[o++]=s,h[o++]=a,h[o++]=r,h[o++]=n,this._$indexBufferPos=o,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let _=this._$vertexBufferPos;l[_++]=t,l[_++]=e,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,this._$vertexBufferPos=_}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],h=i[e-7],o=i[e-6],l=i[e-5],_=i[e-4],$=t/7,c=e/7;s!==h||r!==o?(this._$addLineCapMesh(s,r,n,a,$,$+1),this._$addLineCapMesh(h,o,l,_,c-1,c-2)):this._$addLineJoinMesh(l,_,s,r,n,a,c-2,c-1,$,$+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case"round":this._$addRoundJoinMesh(t,e);break;case"square":this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,h=a+1;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let l=this._$indexBufferPos;o[l++]=r,o[l++]=a,o[l++]=h,o[l++]=h,o[l++]=n,o[l++]=r,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const _=this._$vertexBufferData;let $=this._$vertexBufferPos;_[$++]=t,_[$++]=e,_[$++]=i,_[$++]=s,_[$++]=-1,_[$++]=-1,_[$++]=10,_[$++]=t,_[$++]=e,_[$++]=i,_[$++]=s,_[$++]=1,_[$++]=1,_[$++]=10,this._$vertexBufferPos=$}}class Be{_$gl;_$fillVertexArrayPool;_$strokeVertexArrayPool;_$boundVertexArray;_$fillAttrib_vertex;_$fillAttrib_bezier;_$strokeAttrib_vertex;_$strokeAttrib_option1;_$strokeAttrib_option2;_$strokeAttrib_type;_$vertexBufferData;_$commonVertexArray;constructor(t){this._$gl=t,this._$fillVertexArrayPool=U(),this._$strokeVertexArrayPool=U(),this._$boundVertexArray=null,this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new a([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$getVertexArray(t,e){const i=this._$gl.createVertexArray();if(!i)throw new Error("the WebGLVertexArrayObject is null.");this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length){const t=this._$fillVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();if(!t)throw new Error("the WebGLVertexArrayObject is null.");this.bind(t);const e=this._$gl.createBuffer();if(!e)throw new Error("the WebGLBuffer is null.");return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length){const t=this._$strokeVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();if(!t)throw new Error("the WebGLVertexArrayObject is null.");this.bind(t);const e=this._$gl.createBuffer();if(!e)throw new Error("the WebGLBuffer is null.");t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();if(!i)throw new Error("the WebGLBuffer is null.");return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=Se.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=X(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const s=Fe.generate(t,e,i),r=s.vertexBufferData,n=s.indexBufferData,a=this._$getStrokeVertexArray();return a.indexCount=n.length,this.bind(a),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,a.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,a.indexBuffer),a.vertexLength<r.length&&(a.vertexLength=X(r.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*a.vertexLength,this._$gl.DYNAMIC_DRAW)),a.indexLength<n.length&&(a.indexLength=X(n.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*a.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,r),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,n),a}releaseFill(t){this._$fillVertexArrayPool.push(t)}releaseStroke(t){this._$strokeVertexArrayPool.push(t)}bind(t=null){t!==this._$boundVertexArray&&(this._$boundVertexArray=t,this._$gl.bindVertexArray(t))}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class Re{_$context;_$gl;_$clips;_$poolClip;_$clipStatus;_$containerClip;_$currentClip;constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$poolClip=[],this._$clipStatus=!1,this._$containerClip=!1,this._$currentClip=!1}get containerClip(){return this._$containerClip}set containerClip(t){this._$containerClip=t}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context.frameBuffer,e=t.currentAttachment,i=t.getTextureFromCurrentAttachment();this._$context._$bind(this._$context.cacheAttachment),this._$context.cacheAttachment=null,this._$context.blend.disable();const s=this._$context.cacheBounds;this._$context.reset(),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(i,s.xMin,s.yMin,i.width,i.height),this._$context.blend.enable(),t.releaseAttachment(e,!0)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel;let i=0;for(let t=0;t<e;++t)i|=(1<<e-t)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&i,i),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");if(--t.clipLevel,t.mask=!!t.clipLevel,!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context.cacheAttachment&&this._$endClip());const e=t.width,i=t.height,s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);G(s.pop()),G(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(r,o.first,o.count);const l=r.indexRanges;for(let t=0;t<l.length;++t)Se.indexRangePool.push(l[t]);G(r.indexRanges),this._$context.vao.releaseFill(r),this._$endClipDef()}_$drawContainerClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel,i=this._$context.shaderList.shapeShaderVariants,s=i.getMaskShapeShader(!1,!1),r=s.uniform;let n=e;const a=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);const o=this._$poolClip.length;for(let t=0;t<o;++t){const t=this._$poolClip.shift();if(!t)continue;i.setMaskShapeUniform(r,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const o=t.vertexArrayObject.indexRanges;for(let e=0;e<o.length;++e){const i=o[e];this._$gl.stencilMask(1<<n-1),s._$containerClip(t.vertexArrayObject,i.first,i.count),Se.indexRangePool.push(i)}G(o),this._$context.vao.releaseFill(t.vertexArrayObject),++n,n>7&&(this._$unionStencilMask(e,a,h),n=e)}n>e+1&&this._$unionStencilMask(e,a,h)}_$unionStencilMask(t,e,i){const s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);G(s.pop()),G(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(r,o.first,o.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT));const l=r.indexRanges;for(let t=0;t<l.length;++t)Se.indexRangePool.push(l[t]);G(r.indexRanges),this._$context.vao.releaseFill(r)}_$onClip(t,e,i,s){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip.push({vertexArrayObject:t,matrixA:e[0],matrixB:e[1],matrixC:e[2],matrixD:e[3],matrixE:e[4],matrixF:e[5],matrixG:e[6],matrixH:e[7],matrixI:e[8],viewportWidth:i,viewportHeight:s}),!0)}_$onSave(){this._$clips.push(this._$clipStatus)}_$onRestore(){this._$clips.length&&(this._$clipStatus=!!this._$clips.pop())}}class Ie{_$context;_$gl;_$enabled;_$funcCode;constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case"add":this.toAdd();break;case"screen":this.toScreen();break;case"alpha":this.toAlpha();break;case"erase":this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,s,r,a,h,o,l,_,$,c,u,d,g,f,p,m,x){const b=this._$context.frameBuffer,v=b.currentAttachment,T=1!==h||1!==o||1!==l||1!==_||0!==$||0!==c||0!==u||0!==d,y=this._$context.shaderList.blendShaderVariants;switch(g){case"normal":case"layer":case"add":case"screen":case"alpha":case"erase":case"copy":{b.textureManager.bind0(t,x);const v=y.getNormalBlendShader(T);y.setNormalBlendUniform(v.uniform,e,s,r,a,m,f,p,T,h,o,l,_,$,c,u,d);const E=m[0],M=m[1],A=m[3],w=m[4],C=m[6],S=m[7];if(1!==E||0!==M||0!==A||1!==w){const t=e+r,h=s+a,o=+(t*E+h*A+C),l=+(t*E+s*A+C),_=+(e*E+h*A+C),$=+(e*E+s*A+C),c=+(t*M+h*w+S),u=+(t*M+s*w+S),d=+(e*M+h*w+S),g=+(e*M+s*w+S),m=n.MAX_VALUE,x=+i.min(i.min(i.min(i.min(m,o),l),_),$),b=+i.max(i.max(i.max(i.max(-m,o),l),_),$),v=+i.min(i.min(i.min(i.min(m,c),u),d),g),T=+i.max(i.max(i.max(i.max(-m,c),u),d),g),y=i.max(0,x),F=i.max(0,v),B=i.min(i.max(0,f-y),i.ceil(i.abs(b-x))),R=i.min(i.max(0,p-F),i.ceil(i.abs(T-v)));if(!B||!R)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(y,i.max(0,p-(F+R)),B+1,R+1)}else{const t=i.max(0,e+C),n=i.max(0,s+S),h=i.min(i.max(0,f-t),r),o=i.min(i.max(0,p-n),a);if(!h||!o)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,Math.max(0,p-(n+o)),h+1,o+1)}this.toOperation(g),v._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const i=Math.max(0,e+m[6]),n=Math.max(0,s+m[7]),E=Math.min(Math.max(0,f-i),r),M=Math.min(Math.max(0,p-n),a);if(!E||!M)return;const A=b.getTextureFromCurrentAttachment(),w=this._$context.frameBuffer.createTextureAttachment(r,a);this._$context._$bind(w),b.textureManager.bind0(A);const C=y.getClipShader(),S=C.uniform;y.setClipUniform(S,e,s,r,a,H(m),f,p),this.reset(),C._$drawImage();const F=b.getTextureFromCurrentAttachment();this._$context._$bind(v),b.textureManager.bind01(F,t,x);const B=y.getBlendShader(g,T);y.setBlendUniform(B.uniform,e,s,r,a,m,f,p,T,h,o,l,_,$,c,u,d),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(i,Math.max(0,p-(n+M)),E,M),this.toOneZero(),B._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),b.releaseAttachment(w,!0)}}}}class Le{_$gl;_$maxTextureSize;_$contextStyle;_$cacheBounds;_$matrix;_$cacheAttachment;_$stack;_$globalAlpha;_$imageSmoothingEnabled;_$globalCompositeOperation;_$clearColorR;_$clearColorG;_$clearColorB;_$clearColorA;_$viewportWidth;_$viewportHeight;_$frameBufferManager;_$path;_$grid;_$offsetX;_$offsetY;_$blends;_$positions;_$isLayer;_$shaderList;_$gradientLUT;_$vao;_$mask;_$blend;_$maskBufferArray;_$maskBoundsArray;_$attachmentArray;constructor(t,e){this._$gl=t;const s=i.min(e,t.getParameter(t.MAX_SAMPLES));this._$maxTextureSize=i.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new Qt,this._$cacheBounds=B(),this._$matrix=D(1,0,0,0,1,0,0,0,1),this._$cacheAttachment=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation="normal",this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new ee(t,s),this._$path=new se,this._$grid=new re,this._$offsetX=0,this._$offsetY=0,this._$blends=U(),this._$positions=U(),this._$isLayer=!1,this._$shaderList=new we(this,t),this._$gradientLUT=new Ce(this,t),this._$vao=new Be(t),this._$mask=new Re(this,t),this._$blend=new Ie(this,t),this._$maskBufferArray=[],this._$maskBoundsArray=[],this._$attachmentArray=[]}reset(){this._$globalAlpha=1,this._$globalCompositeOperation="normal",this._$imageSmoothingEnabled=!1,this._$contextStyle.clear()}get isLayer(){return this._$isLayer}get canvas(){return this._$gl.canvas}get cacheAttachment(){return this._$cacheAttachment}set cacheAttachment(t){this._$cacheAttachment=t}get cacheBounds(){return this._$cacheBounds}get fillStyle(){return this._$contextStyle.fillStyle}set fillStyle(t){this._$contextStyle.fillStyle=t}get strokeStyle(){return this._$contextStyle.strokeStyle}set strokeStyle(t){this._$contextStyle.strokeStyle=t}get lineWidth(){return this._$contextStyle.lineWidth}set lineWidth(t){this._$contextStyle.lineWidth=t}get lineCap(){return this._$contextStyle.lineCap}set lineCap(t){this._$contextStyle.lineCap=t}get lineJoin(){return this._$contextStyle.lineJoin}set lineJoin(t){this._$contextStyle.lineJoin=t}get miterLimit(){return this._$contextStyle.miterLimit}set miterLimit(t){this._$contextStyle.miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=W(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=t}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get shaderList(){return this._$shaderList}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get blend(){return this._$blend}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$getTextureScale(t,e){const s=i.max(t,e);return s>this._$maxTextureSize?this._$maxTextureSize/s:1}_$bind(t=null){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e&&e.dirty||i&&i.dirty)&&(e&&(e.dirty=!1),i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}setMaxSize(t,e){this._$frameBufferManager.setMaxSize(t,e)}transform(t,e,i,s,r,n){const a=this._$matrix[0],h=this._$matrix[1],o=this._$matrix[3],l=this._$matrix[4],_=this._$matrix[6],$=this._$matrix[7];this._$matrix[0]=t*a+e*o,this._$matrix[1]=t*h+e*l,this._$matrix[3]=i*a+s*o,this._$matrix[4]=i*h+s*l,this._$matrix[6]=r*a+n*o+_,this._$matrix[7]=r*h+n*l+$}drawImage(t,e,i,s,r,n=null){let a=1,h=1,o=1,l=0,_=0,$=0;const c=this._$globalAlpha;n&&(a=n[0],h=n[1],o=n[2],l=n[4]/255,_=n[5]/255,$=n[6]/255),this.blend.drawImage(t,e,i,s,r,a,h,o,c,l,_,$,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin()}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}fill(){const t=this._$path.vertices;if(!t.length)return;const e=U();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void G(e);const i=this._$vao.createFill(e),s=this.fillStyle;let r,n,a,h=this._$matrix;const o=this._$grid.enabled;if(s instanceof qt){const t=s.stops,e="linearRGB"===s.rgb;if(r=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(r,!0),n=this._$shaderList.gradientShapeShaderVariants,"linear"===s.type)a=n.getGradientShapeShader(!1,o,!1,!1,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,s.points,0);else{h=this._$stack[this._$stack.length-1];const t=0!==s.focalPointRatio;a=n.getGradientShapeShader(!1,o,!0,t,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,s.points,s.focalPointRatio)}}else if(s instanceof Kt){h=this._$stack[this._$stack.length-1];const t=s.colorTransform;r=s.texture,this._$frameBufferManager.textureManager.bind0(r,this._$imageSmoothingEnabled),n=this._$shaderList.shapeShaderVariants,a=n.getBitmapShapeShader(!1,s.repeat,o),t?n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,1,1,1,this._$globalAlpha,0,0,0,0)}else n=this._$shaderList.shapeShaderVariants,a=n.getSolidColorShapeShader(!1,this._$grid.enabled),n.setSolidColorShapeUniform(a.uniform,!1,0,0,0,o,h,this._$viewportWidth,this._$viewportHeight,this._$grid,s,this._$globalAlpha);const l=this._$shaderList.shapeShaderVariants,_=l.getMaskShapeShader(!1,o);l.setMaskShapeUniform(_.uniform,o,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],this._$viewportWidth,this._$viewportHeight,this._$grid),this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),_._$fill(i),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),a._$fill(i),this._$gl.disable(this._$gl.STENCIL_TEST),this.releaseFillVertexArray(i)}releaseFillVertexArray(t){this._$vao.releaseFill(t);const e=t.indexRanges;for(let t=0;t<e.length;++t)Se.indexRangePool.push(e[t]);G(e)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$updateContainerClipFlag(t){this._$mask.containerClip=t}_$startClip(t,e){let s=e.xMin,r=e.yMin,n=Math.abs(e.xMax-e.xMin),a=Math.abs(e.yMax-e.yMin);const h=this._$frameBufferManager,o=h.currentAttachment;if(!o||!o.texture)throw new Error("the current Attachment is null.");if(s>o.width||r>o.height)return null;if(n+s>o.width&&(n=o.width-s),a+r>o.height&&(a=o.height-r),0>s&&(n+=s,s=0),0>r&&(a+=r,r=0),0>=n||0>=a)return null;n=i.ceil(n),a=i.ceil(a),this._$cacheBounds.xMin=s,this._$cacheBounds.yMin=r,this._$cacheBounds.xMax=n,this._$cacheBounds.yMax=a,this._$cacheAttachment=o,this._$bind(h.createCacheAttachment(n,a,!0));const l=o.texture;return this.reset(),this.setTransform(1,0,0,1,0,0),this.drawImage(l,-s,-r,l.width,l.height),P(t[0],t[1],t[2],t[3],t[4]-e.xMin,t[5]-e.yMin)}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}closePath(){this._$path.close()}stroke(){const t=this._$path.vertices;if(!t.length)return;const e=U();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return void G(e);const s=this._$vao.createStroke(t,this.lineCap,this.lineJoin);let r=this._$matrix;const n=this.strokeStyle;let a=i.sign(r[0]*r[4]);a>0&&0!==r[1]&&0!==r[3]&&(a=-i.sign(r[1]*r[3]));let h,o,l=.5*this.lineWidth;this._$grid.enabled?(h=i.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),o=i.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(h=i.abs(r[0]+r[3]),o=i.abs(r[1]+r[4]));const _=i.min(h,o),$=i.max(h,o);l*=$*(1-.3*i.cos(.5*i.PI*(_/$))),l=i.max(1,l);const c=this._$grid.enabled;let u,d,g;if(n instanceof qt){"radial"===n.type&&(r=this._$stack[this._$stack.length-1]);const t=n.stops,e="linearRGB"===n.rgb;if(u=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(u,!0),d=this._$shaderList.gradientShapeShaderVariants,"linear"===n.type)g=d.getGradientShapeShader(!0,c,!1,!1,n.mode),d.setGradientShapeUniform(g.uniform,!0,l,a,this.miterLimit,c,r,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,n.points,0);else{r=this._$stack[this._$stack.length-1];const t=0!==n.focalPointRatio;g=d.getGradientShapeShader(!0,c,!0,t,n.mode),d.setGradientShapeUniform(g.uniform,!0,l,a,this.miterLimit,c,r,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,n.points,n.focalPointRatio)}}else if(n instanceof Kt){r=this._$stack[this._$stack.length-1];const t=n.colorTransform;u=n.texture,this._$frameBufferManager.textureManager.bind0(u),d=this._$shaderList.shapeShaderVariants,g=d.getBitmapShapeShader(!0,n.repeat,this._$grid.enabled),t?d.setBitmapShapeUniform(g.uniform,!0,l,a,this.miterLimit,c,r,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,u.width,u.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):d.setBitmapShapeUniform(g.uniform,!0,l,a,this.miterLimit,c,r,H(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,u.width,u.height,1,1,1,this._$globalAlpha,0,0,0,0)}else d=this._$shaderList.shapeShaderVariants,g=d.getSolidColorShapeShader(!0,this._$grid.enabled),d.setSolidColorShapeUniform(g.uniform,!0,l,a,this.miterLimit,c,r,this._$viewportWidth,this._$viewportHeight,this._$grid,n,this._$globalAlpha);g._$stroke(s),this._$vao.releaseStroke(s)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(){const t=this._$path.vertices;if(!t.length)return;const e=U();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void G(e);const i=this._$vao.createFill(e),s=this._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;s.setMaskShapeUniform(n,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),this._$mask._$onClip(i,this._$matrix,this._$viewportWidth,this._$viewportHeight)||(r._$fill(i),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(D(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){var t;this._$stack.length&&(t=this._$matrix,A.push(t),this._$matrix=this._$stack.pop()||D()),this._$mask._$onRestore()}createPattern(t,e,i){return new Kt(this,t,e,i)}createLinearGradient(t,e,i,s,r="rgb",n="pad"){return(new qt).linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a="rgb",h="pad",o=0){return(new qt).radial(t,e,i,s,r,n,a,h,o)}_$applyBlurFilter(t,e,s){const r=this._$frameBufferManager,n=r.currentAttachment;if(!n)throw new Error("the current attachment is null.");const a=n.width,h=n.height;r.textureManager.bind0(t,!0);const o=i.ceil(.5*s),l=1-(o-.5*s),_=1+s,$=this._$shaderList.filterShaderVariants,c=$.getBlurFilterShader(o);$.setBlurFilterUniform(c.uniform,a,h,e,l,_),c._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,h,o,l,_,$,c,u,d,g=null,f=null,p=null,m=0,x=0,b=0,v=0,T=0,y=0,E=0,M=0){const A=this._$frameBufferManager,w="inner"===c,C=A.currentAttachment,S=A.getTextureFromCurrentAttachment();let F=null;const B=null!==g&&null!==f&&null!==p;let R;null!==g&&null!==f&&null!==p&&(F=this._$gradientLUT.generateForFilter(g,f,p)),w?B&&F?A.textureManager.bind02(t,F,!0):A.textureManager.bind0(t):(R=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(R),B&&F?A.textureManager.bind012(t,S,F,!0):A.textureManager.bind01(t,S));const I=!(w||"full"===c&&u),L=!(e===h&&i===o&&0===l&&0===_),P=!(1===d),O=this._$shaderList.filterShaderVariants,k=O.getBitmapFilterShader(I,L,$,c,u,P,B);O.setBitmapFilterUniform(k.uniform,e,i,s,r,n,a,h,o,l,_,$,d,m,x,b,v,T,y,E,M,I,L,P,B),w?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),k._$drawImage(),w||A.releaseAttachment(C,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager.textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,h,o,l,_,$){const c=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment(c,u);this._$bind(d),this._$frameBufferManager.textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,h);g.setConvolutionFilterUniform(f.uniform,c,u,s,r,n,h,o,l,_,$),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,h,o,l,_,$,c,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),r||(r={x:0,y:0}),this._$frameBufferManager.textureManager.bind01(t,e);const p=this._$shaderList.filterShaderVariants,m=p.getDisplacementMapFilterShader(n,a,l);p.setDisplacementMapFilterUniform(m.uniform,e.width,e.height,i,s,r.x,r.y,h,o,l,_,$,c,u),this.blend.reset(),m._$drawImage()}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){const t=this._$positions.pop();t&&R(t),this._$isLayer=!!this._$blends.pop()}_$saveCurrentMask(){this._$maskBufferArray.push(this._$cacheAttachment),this._$cacheAttachment=null;const t=this._$cacheBounds;this._$maskBoundsArray.push(B(t.xMin,t.xMax,t.yMin,t.yMax))}_$saveAttachment(t,e,i=!1){const s=this._$frameBufferManager;this._$attachmentArray.push(s.currentAttachment),this._$bind(s.createCacheAttachment(t,e,i))}_$restoreAttachment(t=!1){const e=this._$frameBufferManager;e.releaseAttachment(e.currentAttachment,t),this._$bind(this._$attachmentArray.pop())}_$restoreCurrentMask(){this._$cacheAttachment=this._$maskBufferArray.pop()||null,this._$cacheBounds=this._$maskBoundsArray.pop()||B()}getCurrentPosition(){return this._$positions[this._$positions.length-1]}textureScale(t,e){const s=i.max(t,e);return s>this._$maxTextureSize?this._$maxTextureSize/s:1}}class Pe{static toString(){return"[class SoundMixer]"}static get namespace(){return"next2d.media.SoundMixer"}toString(){return"[object SoundMixer]"}get namespace(){return"next2d.media.SoundMixer"}static get volume(){return Mt()}static set volume(t){(t=>{Et=t})(W(t,0,1,1));const e=Mt(),s=Ui(),r=s._$sources;for(let t=0;t<r.length;++t){const s=r[t];for(let t=0;t<s._$sources.length;++t){const r=s._$sources[t];r._$gainNode&&(r._$gainNode.gain.value=i.min(e,r._$volume))}}const n=s._$videos;for(let t=0;t<n.length;++t){const s=n[t];s._$video&&(s._$video.volume=i.min(e,s.volume))}}static stopAll(){const t=Ui(),e=t._$sources;for(let t=0;t<e.length;++t)e[t].stop();const i=t._$videos;for(let t=0;t<i.length;++t)i[t].pause();t._$sources.length=0,t._$videos.length=0}}class Oe{_$stage;_$cacheStore;_$mode;_$actionOffset;_$actions;_$loaders;_$sounds;_$context;_$hitObject;_$rollOverObject;_$mouseOverTarget;_$ratio;_$stopFlag;_$startTime;_$fps;_$isLoad;_$loadStatus;_$width;_$height;_$baseWidth;_$baseHeight;_$scale;_$matrix;_$tx;_$ty;_$state;_$hitTestStart;_$stageX;_$stageY;_$broadcastEvents;_$optionWidth;_$optionHeight;_$tagId;_$bgColor;_$base;_$videos;_$sources;_$fullScreen;_$quality;_$textField;_$touchY;_$timerId;_$loadId;_$attachment;_$canvas;_$deltaX;_$deltaY;_$clickTarget;_$actionProcess;constructor(){this._$stage=new Ht,this._$stage._$player=this,this._$cacheStore=new Wt,this._$mode="loader",this._$actionOffset=0,this._$actions=U(),this._$loaders=U(),this._$sounds=Y(),this._$hitObject={x:0,y:0,pointer:"",hit:null},this._$rollOverObject=null,this._$mouseOverTarget=null,this._$ratio=Yt,this._$stopFlag=!0,this._$startTime=0,this._$fps=16,this._$isLoad=!1,this._$loadStatus=0,this._$width=0,this._$height=0,this._$baseWidth=0,this._$baseHeight=0,this._$scale=1,this._$matrix=P(1,0,0,1,0,0),this._$tx=0,this._$ty=0,this._$state="up",this._$hitTestStart=!1,this._$stageX=-1,this._$stageY=-1,this._$deltaX=0,this._$deltaY=0,this._$broadcastEvents=Y(),this._$optionWidth=0,this._$optionHeight=0,this._$tagId="",this._$bgColor="transparent",this._$base="",this._$fullScreen=!1,this._$quality="high",this._$sources=U(),this._$videos=U(),this._$textField=null,this._$touchY=0,this._$timerId=-1,this._$loadId=-1,this._$context=null,this._$attachment=null,this._$clickTarget=null,this._$actionProcess=!1,this._$canvas=Xt.createElement("canvas")}static get LOAD_START(){return 1}static get LOAD_END(){return 2}get canvas(){return this._$canvas}get broadcastEvents(){return this._$broadcastEvents}get cacheStore(){return this._$cacheStore}get context(){return this._$context}set context(t){this._$context=t}get base(){return this._$base}set base(t){if(-1===t.indexOf("//")){const e=t.split("/");""!==e[0]&&"."!==e[0]||e.shift(),e.pop(),this._$base=`${location.origin}/`,e.length&&(this._$base+=`${e.join("/")}/`)}else if(-1===t.indexOf("?"))this._$base="/"===t.slice(-1)?t:`${t}/`;else{const e=t.split("?")[0];this._$base="/"===e.slice(-1)?e:`${e}/`}}get stage(){return this._$stage}get x(){return this._$tx}get y(){return this._$ty}get scaleX(){return this._$matrix[0]}get scaleY(){return this._$matrix[3]}get mode(){return this._$mode}set mode(t){this._$mode=t}get contentElementId(){return ri}get width(){return this._$baseWidth}set width(t){this._$baseWidth=0|t}get height(){return this._$baseHeight}set height(t){this._$baseHeight=0|t}get bgColor(){return this._$bgColor}set bgColor(t){this._$bgColor=`${t}`}play(){if(this._$stopFlag){this._$stopFlag=!1,this._$timerId>-1&&c(this._$timerId),this._$startTime=u.now();const t=this._$stage._$frameRate;this._$fps=1e3/t|0,this._$timerId=$((t=>{this._$run(t)}))}}stop(){this._$timerId>-1&&c(this._$timerId),this._$stopFlag=!0,this._$timerId=-1,Pe.stopAll(),this._$cacheStore.reset(),Zi&&Zi.postMessage({command:"stop"})}removeCache(t){this._$cacheStore.removeCache(t),Zi&&Zi.postMessage({command:"removeCache",id:t})}setOptions(t=null){t&&(this._$optionWidth=t.width||this._$optionWidth,this._$optionHeight=t.height||this._$optionHeight,this._$tagId=t.tagId||this._$tagId,this.base=t.base||this._$base,this._$bgColor=t.bgColor||this._$bgColor,this._$fullScreen=!!t.fullScreen)}_$loadWebAudio(t=null){t&&this._$canvas.removeEventListener(_i,this._$loadWebAudio),mi||ji()}_$updateLoadStatus(){if(this._$loadStatus===Oe.LOAD_END)return this._$loadId>-1&&c(this._$loadId),this._$loadId=-1,void this._$loaded();this._$loadId=$((()=>{this._$updateLoadStatus()}))}_$loaded(){const t=Xt.getElementById(this.contentElementId);if(t){this._$setBackgroundColor(this._$bgColor),this._$deleteNode(),t.appendChild(this._$canvas),this._$stage._$prepareActions(),this._$broadcastEvents.has($t.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new $t($t.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has($t.EXIT_FRAME)&&this._$dispatchEvent(new $t($t.EXIT_FRAME));const e=this._$loaders.length;for(let t=0;t<e;++t){const t=this._$loaders.shift();t.hasEventListener($t.INIT)&&t.dispatchEvent(new $t($t.INIT)),t.hasEventListener($t.COMPLETE)&&t.dispatchEvent(new $t($t.COMPLETE))}this._$broadcastEvents.has($t.ACTIVATE)&&this._$dispatchEvent(new $t($t.ACTIVATE)),this._$doAction(),this._$draw(),this.play()}}_$initialize(){if("loading"===Xt.readyState)return void Vt.addEventListener("DOMContentLoaded",(()=>{this._$initialize()}));const t=this.contentElementId;if(this._$tagId){const e=Xt.getElementById(this._$tagId);if(!e)return void alert("Not Found Tag ID:"+this._$tagId);if(Xt.getElementById(t))this._$deleteNode();else{const i=Xt.createElement("div");i.id=t,i.tabIndex=-1,e.appendChild(i)}}else Xt.body.insertAdjacentHTML("beforeend",`<div id="${t}" tabindex="-1"></div>`);const e=Xt.getElementById(t);if(!e)throw new Error("the content element is null.");const i=e.parentElement;if(i){this._$initStyle(e),this._$buildWait();const t=this._$optionWidth?this._$optionWidth:"BODY"===i.tagName?Vt.innerWidth:i.offsetWidth,s=this._$optionHeight?this._$optionHeight:"BODY"===i.tagName?Vt.innerHeight:i.offsetHeight;"loader"===this._$mode&&t&&s&&(this._$baseWidth=t,this._$baseHeight=s,this._$resize())}"loader"===this._$mode?(this._$loadStatus=Oe.LOAD_START,this._$updateLoadStatus()):(this._$resize(),this._$loaded())}_$initStyle(t){const e=t.style;e.position="relative",e.top="0",e.left="0",e.backgroundColor="transparent",e.overflow="hidden",e.padding="0",e.margin="0",e.userSelect="none",e.outline="none";const i=this._$optionWidth,s=this._$optionHeight,r=t.parentElement;if(!r)throw new Error("the parentElement is null.");if("BODY"===r.tagName)return e.width=i?`${i}px`:`${window.innerWidth}px`,void(e.height=s?`${s}px`:`${window.innerHeight}px`);e.width=i?`${i}px`:`${r.offsetWidth}px`,e.height=s?`${s}px`:`${r.offsetHeight}px`}_$buildWait(){const t=Xt.getElementById(this.contentElementId);if(t){const e=`${this.contentElementId}_loading`;t.innerHTML=`<style>\n#${e} {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin: -24px 0 0 -24px;\n    width: 50px;\n    height: 50px;\n    border-radius: 50px;\n    border: 8px solid #dcdcdc;\n    border-right-color: transparent;\n    box-sizing: border-box;\n    animation: ${e} 0.8s infinite linear;\n}\n@keyframes ${e} {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>`;const i=Xt.createElement("div");i.id=e,t.appendChild(i)}}_$deleteNode(){const t=Xt.getElementById(this.contentElementId);if(t)for(;t.childNodes.length;)t.removeChild(t.childNodes[0])}_$initializeCanvas(){if(this._$canvas.width=1,this._$canvas.height=1,Zi){Zi.postMessage({command:"setStage",instanceId:this._$stage._$instanceId});const t=this._$canvas.transferControlToOffscreen();Zi.postMessage({command:"initialize",canvas:t,samples:this._$getSamples(),devicePixelRatio:Yt,isSafari:Fi},[t])}else{const t=this._$canvas.getContext("webgl2",{stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0});t?(this._$context=new Le(t,this._$getSamples()),this._$cacheStore.context=this._$context):alert("WebGL setting is off. Please turn the setting on.")}const t=()=>{if(this._$canvas.removeEventListener(_i,t),this._$canvas.removeEventListener(hi,t),!mi){ji();for(let t=0;t<this._$videos.length;++t){const e=this._$videos[t];e._$video&&(e._$video.muted=!1)}}};this._$canvas.addEventListener(hi,t),this._$canvas.addEventListener(_i,t),this._$canvas.addEventListener(ni,(t=>{vt(t),mt(ni),this._$touchY=t.changedTouches[0].pageY,this._$hitTest()})),this._$canvas.addEventListener(ai,(t=>{vt(t),mt(ai),this._$hitTest()})),this._$canvas.addEventListener(hi,(t=>{vt(t),mt(hi),this._$hitTest()})),this._$canvas.addEventListener(ai,(t=>{const e=t.changedTouches[0].pageY;this._$deltaY=this._$touchY-e,this._$touchY=e,vt(t),mt(ai),this._$hitTest()}),{passive:!1}),this._$canvas.addEventListener(oi,(t=>{vt(t),mt(oi),t.button||this._$hitTest()})),this._$canvas.addEventListener(ci,(t=>{vt(t),mt(ci),t.button||this._$hitTest()})),this._$canvas.addEventListener(ui,(t=>{vt(t),mt(ui),this._$hitTest(),vt(null),this._$stageX=-1,this._$stageY=-1})),this._$canvas.addEventListener(_i,(t=>{vt(t),mt(_i),t.button||this._$hitTest()})),this._$canvas.addEventListener(li,(t=>{vt(t),mt(li),this._$hitTest()})),this._$canvas.addEventListener($i,(t=>{t.defaultPrevented||(vt(t),mt($i),this._$hitTest())}),{passive:!1});let e="";e+="position: absolute;",e+="top: 0;",e+="left: 0;",e+="-webkit-tap-highlight-color: rgba(0,0,0,0);",e+="backface-visibility: hidden;",e+="transform-origin: 0 0;",1!==Yt&&(e+=`transform: scale(${1/Yt});`),this._$canvas.setAttribute("style",e)}_$resize(){const t=Xt.getElementById(this.contentElementId);if(t){this._$stage._$doChanged(),this._$cacheStore.reset();const e=t.parentElement;if(!e)throw new Error("the parentElement is null.");const s=this._$optionWidth?this._$optionWidth:"BODY"===e.tagName?Vt.innerWidth:e.offsetWidth?e.offsetWidth:parseFloat(e.style.width),r=this._$optionHeight?this._$optionHeight:"BODY"===e.tagName?Vt.innerHeight:e.offsetHeight?e.offsetHeight:parseFloat(e.style.height),n="BODY"===e.tagName?Vt.innerWidth:e.offsetWidth,a=i.min(s/this._$baseWidth,r/this._$baseHeight);let h=this._$fullScreen?s:this._$baseWidth*a|0,o=this._$fullScreen?r:this._$baseHeight*a|0;const l=t.style;l.width=`${h}px`,l.height=`${o}px`,l.top="0",l.left=this._$fullScreen?"0":n/2-h/2+"px",h*=Yt,o*=Yt,this._$scale=a,this._$width=h,this._$height=o;const _=this._$scale*this._$ratio;this._$matrix[0]=_,this._$matrix[3]=_,this._$fullScreen&&(this._$tx=(h-this._$baseWidth*a*Yt)/2,this._$ty=(o-this._$baseHeight*a*Yt)/2,this._$matrix[4]=this._$tx,this._$matrix[5]=this._$ty),this._$resizeCanvas(h,o,_,this._$tx,this._$ty),this._$ratio>1&&Yt>1&&(this._$canvas.style.transform=`scale(${1/this._$ratio})`),t.children.length>1&&t.children[1].dispatchEvent(new Event(`${ri}_blur`))}}_$setBackgroundColor(t="transparent"){if(Zi)Zi.postMessage({command:"setBackgroundColor",backgroundColor:t});else{const e=this._$context;if(!e)return;if("transparent"===t)e._$setColor(0,0,0,0);else{const i=Z(J(t));e._$setColor(i.R/255,i.G/255,i.B/255,1)}}}_$resizeCanvas(t,e,i,s=0,r=0){if(Zi)Zi.postMessage({command:"resize",width:t,height:e,scale:i,tx:s,ty:r});else{const i=this._$context;if(!i)return;this._$canvas.width=t,this._$canvas.height=e,i._$gl.viewport(0,0,t,e);const s=i.frameBuffer;this._$attachment&&(s.unbind(),s.releaseAttachment(this._$attachment,!0)),this._$attachment=s.createCacheAttachment(t,e,!1),i.setMaxSize(t,e)}}_$getSamples(){switch(this._$quality){case"high":return 4;case"medium":return 2;default:return 0}}_$dispatchEvent(t){if(this._$broadcastEvents.size&&this._$broadcastEvents.has(t.type)){const e=this._$broadcastEvents.get(t.type).slice(0);t.eventPhase=_t.AT_TARGET;for(let i=0;i<e.length;++i){const s=e[i];if(t.currentTarget=s.target,t.listener=s.listener,s.listener.call(null,t),t._$stopImmediatePropagation)break}return G(e),!0}return!1}_$run(t=0){if(this._$stopFlag)return;this._$doAction();const e=t-this._$startTime;if(e>this._$fps){if(this._$startTime=t-e%this._$fps,this._$action(),this._$sounds.size){for(const t of this._$sounds.values())t._$soundPlay();this._$sounds.clear()}this._$draw(),!Li&&!this._$hitTestStart&&"up"===this._$state&&this._$stageX>-1&&this._$stageY>-1&&bt()&&this._$pointerCheck()}else this._$videos.length&&!Zi&&this._$draw();this._$timerId=$((t=>{this._$run(t)}))}_$pointerCheck(){const t=this._$stageX,e=this._$stageY;this._$hitObject.x=t,this._$hitObject.y=e,this._$hitObject.pointer="",this._$hitObject.hit=null,Di.setTransform(1,0,0,1,0,0),Di.beginPath(),Ei[4]=this._$tx/this._$scale/Yt,Ei[5]=this._$ty/this._$scale/Yt,this._$stage._$mouseHit(Di,Ei,this._$hitObject,!0);let i=null,s=null,r=!1,n=!1;if(this._$hitObject.hit){if(i=this._$hitObject.hit,this._$mouseOverTarget&&this._$mouseOverTarget!==i){const t=this._$mouseOverTarget;t.willTrigger(jt.MOUSE_OUT)&&t.dispatchEvent(new jt(jt.MOUSE_OUT,!0,!1))}if(this._$rollOverObject!==i){let r=null;if(this._$rollOverObject)for(s=this._$rollOverObject,s.willTrigger(jt.ROLL_OUT)&&s.dispatchEvent(new jt(jt.ROLL_OUT,!1,!1)),r=s._$parent;r&&r._$root!==r&&r!==i;){if(r._$mouseEnabled&&r._$outCheck(t,e)){let t=!1,e=i;for(;e&&e._$root!==e;){if(e===r){t=!0;break}e=e._$parent}if(!t&&r._$parent===i._$parent&&r._$index>i._$index&&(t=!0),t)break}r.willTrigger(jt.ROLL_OUT)&&r.dispatchEvent(new jt(jt.ROLL_OUT,!1,!1)),r=r._$parent}for(s=i;s.willTrigger(jt.ROLL_OVER)&&s.dispatchEvent(new jt(jt.ROLL_OVER,!1,!1)),s=s._$parent,s&&s!==r&&s.stage!==s;);}switch(this._$rollOverObject=i,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==i:i&&i.willTrigger(jt.MOUSE_OVER)&&i.dispatchEvent(new jt(jt.MOUSE_OVER,!0,!1)),this._$mouseOverTarget=i}if("up"===this._$state&&(this._$clickTarget=null),!Li&&"up"===this._$state)for(s=i;s&&s.root!==s;){if("_$text"in s&&"input"===s.type){r=!0;break}if("buttonMode"in s&&s.buttonMode){n=!0;break}s=s._$parent}}else{if(this._$mouseOverTarget&&(i=this._$mouseOverTarget,i.willTrigger(jt.MOUSE_OUT)&&i.dispatchEvent(new jt(jt.MOUSE_OUT,!0,!1))),this._$rollOverObject)for(s=this._$rollOverObject;s&&s.root!==s;)s.willTrigger(jt.ROLL_OUT)&&s.dispatchEvent(new jt(jt.ROLL_OUT,!1,!1)),s=s._$parent;this._$rollOverObject=null,this._$mouseOverTarget=null}switch(!0){case r:this._$canvas.style.cursor="text";break;case n:this._$canvas.style.cursor="pointer";break;case!Li&&"up"===this._$state:this._$canvas.style.cursor="auto"}this._$actions.length>1&&this._$doAction()}_$action(){if(this._$stopFlag)return;let t=null;const e=this._$loaders.length;if(e){t=this._$loaders.slice(0),this._$loaders.length=0;for(let i=0;i<e;++i){const e=t[i];"content"in e&&e.content._$prepareActions()}}if(this._$stage._$nextFrame(),this._$broadcastEvents.has($t.ENTER_FRAME)&&this._$dispatchEvent(new $t($t.ENTER_FRAME)),this._$broadcastEvents.has($t.FRAME_CONSTRUCTED)&&this._$dispatchEvent(new $t($t.FRAME_CONSTRUCTED)),this._$doAction(),this._$broadcastEvents.has($t.EXIT_FRAME)&&this._$dispatchEvent(new $t($t.EXIT_FRAME)),this._$stage._$invalidate&&(this._$stage._$invalidate=!1,this._$dispatchEvent(new $t($t.RENDER))),t){for(let e=0;e<t.length;++e){const i=t[e];i.hasEventListener($t.INIT)&&i.dispatchEvent(new $t($t.INIT)),i.hasEventListener($t.COMPLETE)&&i.dispatchEvent(new $t($t.COMPLETE))}G(t)}this._$doAction()}_$draw(){if(!this._$width||!this._$height)return;if(Zi&&Zi.postMessage({command:"draw"}),!this._$stage._$isUpdated())return;const t=this._$context;if(!t)return;t._$bind(this._$attachment),t.reset(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.beginPath(),this._$stage._$draw(t,this._$matrix,p),this._$stage._$updated=!1;const e=t.frameBuffer,i=e.getTextureFromCurrentAttachment();e.unbind(),t.reset(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.drawImage(i,0,0,this._$width,this._$height),t._$bind(this._$attachment)}_$doAction(){for(;this._$actions.length;){this._$actionProcess=!0;const t=this._$actions.pop();if(!t)continue;t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0;const e=t._$currentFrame;if(!t._$actions.has(e))continue;const i=t._$actions.get(e);if(i){t._$actionProcess=!0;for(let e=0;e<i.length;++e)ft(t._$loaderInfo),i[e].apply(t);t._$actionProcess=!1,t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear())}}this._$actionProcess=!1,ft(null)}_$hitTest(){if(this._$stopFlag)return;const t=bt();if(!t)return;this._$hitTestStart=!0,yt(!1);let e=null,i=null,s=Vt.scrollX,r=Vt.scrollY;const n=Xt.getElementById(this.contentElementId);if(n){const t=n.getBoundingClientRect();s+=t.left,r+=t.top}let a=0,h=0;if("changedTouches"in t){const e=t.changedTouches[0];a=e.pageX,h=e.pageY}else"pageX"in t&&(a=t.pageX,h=t.pageY);a=(a-s)/this._$scale,h=(h-r)/this._$scale,this._$stageX=a,this._$stageY=h,this._$hitObject.x=a,this._$hitObject.y=h,this._$hitObject.pointer="",this._$hitObject.hit=null,Di.setTransform(1,0,0,1,0,0),Di.beginPath(),Ei[4]=this._$tx/this._$scale/Yt,Ei[5]=this._$ty/this._$scale/Yt,this._$stage._$mouseHit(Di,Ei,this._$hitObject,!0),this._$hitObject.hit&&t.preventDefault();let o=!1,l=!1,_=!1;const $=pt;switch($){case ai:case li:if(bi){const t=bi._$dragMousePoint();let e=t.x,i=t.y;Ti.lock||(e+=Ti.position.x,i+=Ti.position.y);const s=Ti.bounds;s&&(e=W(e,s.left,s.right),i=W(i,s.top,s.bottom)),bi.x=e,bi.y=i}break;case ni:case oi:this._$state="down",_="pointer"===this._$canvas.style.cursor,l=!0;break;case hi:case _i:case ci:this._$state="up"}switch(!0){case null===this._$hitObject.hit:case $===ui:if(this._$mouseOverTarget&&(e=this._$mouseOverTarget,e.willTrigger(jt.MOUSE_OUT)&&e.dispatchEvent(new jt(jt.MOUSE_OUT,!0,!1))),this._$rollOverObject)for(i=this._$rollOverObject;i&&i.root!==i;)i.willTrigger(jt.ROLL_OUT)&&i.dispatchEvent(new jt(jt.ROLL_OUT,!1,!1)),i=i._$parent;switch(this._$rollOverObject=null,this._$mouseOverTarget=null,$){case $i:this._$stage.hasEventListener(jt.MOUSE_WHEEL)&&this._$stage.dispatchEvent(new jt(jt.MOUSE_WHEEL,!0,!1));break;case ni:case oi:this._$stage.hasEventListener(jt.MOUSE_DOWN)&&this._$stage.dispatchEvent(new jt(jt.MOUSE_DOWN,!0,!1)),this._$textField&&(this._$textField.focus=!1,this._$textField=null);break;case hi:case _i:this._$textField&&(this._$textField.focus=!1,this._$textField=null),this._$stage.hasEventListener(jt.CLICK)&&this._$stage.dispatchEvent(new jt(jt.CLICK,!0,!1)),this._$stage.hasEventListener(jt.MOUSE_UP)&&this._$stage.dispatchEvent(new jt(jt.MOUSE_UP,!0,!1));break;case ai:case li:this._$stage.hasEventListener(jt.MOUSE_MOVE)&&this._$stage.dispatchEvent(new jt(jt.MOUSE_MOVE,!0,!1));break;case ci:this._$stage.hasEventListener(jt.DOUBLE_CLICK)&&this._$stage.dispatchEvent(new jt(jt.DOUBLE_CLICK,!0,!1))}break;default:switch(e=this._$hitObject.hit,$){case ai:case li:if(e.willTrigger(jt.MOUSE_MOVE)&&e.dispatchEvent(new jt(jt.MOUSE_MOVE,!0,!1)),this._$mouseOverTarget&&this._$mouseOverTarget!==e){const t=this._$mouseOverTarget;t.willTrigger(jt.MOUSE_OUT)&&t.dispatchEvent(new jt(jt.MOUSE_OUT,!0,!1))}if(this._$rollOverObject!==e){let t=null;if(this._$rollOverObject)for(i=this._$rollOverObject,i.willTrigger(jt.ROLL_OUT)&&i.dispatchEvent(new jt(jt.ROLL_OUT,!1,!1)),t=i._$parent;t&&t._$root!==t&&t!==e;){if(t._$mouseEnabled&&t._$outCheck(a,h)){let i=!1,s=e;for(;s&&s._$root!==s;){if(s===t){i=!0;break}s=s._$parent}if(!i&&t._$parent===e._$parent&&t._$index>e._$index&&(i=!0),i)break}t.willTrigger(jt.ROLL_OUT)&&t.dispatchEvent(new jt(jt.ROLL_OUT,!1,!1)),t=t._$parent}for(i=e;i.willTrigger(jt.ROLL_OVER)&&i.dispatchEvent(new jt(jt.ROLL_OVER,!1,!1)),i=i._$parent,i&&i!==t&&i.stage!==i;);}switch(this._$rollOverObject=e,!0){case null===this._$mouseOverTarget:case this._$mouseOverTarget!==e:e.willTrigger(jt.MOUSE_OVER)&&e.dispatchEvent(new jt(jt.MOUSE_OVER,!0,!1)),this._$mouseOverTarget=e}"up"===this._$state&&(this._$clickTarget=null);break;case ni:case oi:this._$textField&&e!==this._$textField&&"_$text"in this._$textField&&(this._$textField.focus=!1,this._$textField=null),"_$text"in e&&(e.focus=!0,this._$textField=e),e.willTrigger(jt.MOUSE_DOWN)&&e.dispatchEvent(new jt(jt.MOUSE_DOWN,!0,!1)),this._$clickTarget=e;break;case hi:case _i:this._$textField&&e!==this._$textField&&"_$text"in this._$textField&&(this._$textField.focus=!1,this._$textField=null),e.willTrigger(jt.MOUSE_UP)&&e.dispatchEvent(new jt(jt.MOUSE_UP,!0,!1)),this._$clickTarget===e&&e.willTrigger(jt.CLICK)&&e.dispatchEvent(new jt(jt.CLICK,!0,!1)),this._$clickTarget=null;break;case $i:e.willTrigger(jt.MOUSE_WHEEL)&&e.dispatchEvent(new jt(jt.MOUSE_WHEEL)),"deltaY"in t&&e.scrollEnabled&&(e.scrollV+=W(t.deltaY,-1,1,0));break;case ci:e.willTrigger(jt.DOUBLE_CLICK)&&e.dispatchEvent(new jt(jt.DOUBLE_CLICK))}if(!l&&!Li&&"up"===this._$state)for(i=e;i&&i.root!==i;){if("_$text"in i){if("input"===i.type){o=!0;break}}else if(i._$buttonMode){_=!0;break}i=i._$parent}}switch(!0){case o:this._$canvas.style.cursor="text";break;case _:this._$canvas.style.cursor="pointer";break;case!Li&&"up"===this._$state:this._$canvas.style.cursor="auto"}!this._$actionProcess&&this._$actions.length>1&&this._$doAction(),Tt&&(this._$stage._$prepareActions(),this._$actionProcess||this._$doAction()),this._$hitTestStart=!1}}class ke{_$bitmapData;_$matrix;_$repeat;_$smooth;constructor(t,e=null,i=!0,s=!1){this._$bitmapData=t,this._$matrix=e,this._$repeat=i,this._$smooth=s}clone(){return new ke(this._$bitmapData.clone(),this._$matrix?this._$matrix.clone():null,this._$repeat,this._$smooth)}toArray(){return U(this._$bitmapData,this._$matrix,this._$repeat,this._$smooth)}}class Ne{_$type;_$colors;_$alphas;_$ratios;_$matrix;_$spreadMethod;_$interpolationMethod;_$focalPointRatio;_$colorStops;constructor(t,e,i,s,r=null,n="pad",a="rgb",h=0){this._$type=t,this._$colors=e,this._$alphas=i,this._$ratios=s,this._$matrix=r,this._$spreadMethod=n,this._$interpolationMethod=a,this._$focalPointRatio=h,this._$colorStops=U()}get colorStops(){if(!this._$colorStops.length){const t=i.min(i.min(this._$alphas.length,this._$colors.length),this._$ratios.length);for(let e=0;e<t;++e){const t=this._$colors[e],i="string"==typeof t?Q(t):t,s=st(i,this._$alphas[e]);this._$colorStops[e]={ratio:this._$ratios[e]/255,R:s.R,G:s.G,B:s.B,A:s.A}}}return this._$colorStops}toArray(){return U(this._$type,this.colorStops,this._$matrix?this._$matrix._$matrix:f,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}clone(){return new Ne(this._$type,this._$colors.slice(),this._$alphas.slice(),this._$ratios.slice(),this._$matrix?this._$matrix.clone():null,this._$spreadMethod,this._$interpolationMethod,this._$focalPointRatio)}}class De{_$displayObject;_$maxAlpha;_$pointerX;_$pointerY;_$canDraw;_$fillType;_$fillGradient;_$fillBitmap;_$fillStyleR;_$fillStyleG;_$fillStyleB;_$fillStyleA;_$doFill;_$lineType;_$lineGradient;_$caps;_$joints;_$miterLimit;_$lineWidth;_$lineStyleR;_$lineStyleG;_$lineStyleB;_$lineStyleA;_$doLine;_$xMin;_$xMax;_$yMin;_$yMax;_$buffer;_$recode;_$fills;_$lines;constructor(t=null){this._$displayObject=t,this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=null,this._$caps="none",this._$joints="round",this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=n.MAX_VALUE,this._$xMax=-n.MAX_VALUE,this._$yMin=n.MAX_VALUE,this._$yMax=-n.MAX_VALUE,this._$buffer=null,this._$recode=null,this._$fills=null,this._$lines=null}static toString(){return"[class Graphics]"}static get namespace(){return"next2d.display.Graphics"}toString(){return"[object Graphics]"}get namespace(){return"next2d.display.Graphics"}static get MOVE_TO(){return 0}static get CURVE_TO(){return 1}static get LINE_TO(){return 2}static get CUBIC(){return 3}static get ARC(){return 4}static get FILL_STYLE(){return 5}static get STROKE_STYLE(){return 6}static get END_FILL(){return 7}static get END_STROKE(){return 8}static get BEGIN_PATH(){return 9}static get GRADIENT_FILL(){return 10}static get GRADIENT_STROKE(){return 11}static get CLOSE_PATH(){return 12}static get BITMAP_FILL(){return 13}static get BITMAP_STROKE(){return 14}beginBitmapFill(t,e=null,i=!0,s=!1){return this._$doFill&&this.endFill(),this._$fills||(this._$fills=U()),this._$maxAlpha=1,this._$doFill=!0,this._$canDraw=!0,this._$fills.push(De.BEGIN_PATH),this._$fillType=De.BITMAP_FILL,this._$fillBitmap=new ke(t,e,i,s),this}beginFill(t=0,e=1){this._$doFill&&this.endFill(),this._$fills||(this._$fills=U()),t=W(J(t),0,16777215,0),e=W(e,0,1,1),this._$maxAlpha=i.max(this._$maxAlpha,e),this._$doFill=!0,this._$canDraw=!0,this._$fills.push(De.BEGIN_PATH);const s=st(t,e);return this._$fillType=De.FILL_STYLE,this._$fillStyleR=s.R,this._$fillStyleG=s.G,this._$fillStyleB=s.B,this._$fillStyleA=s.A,this}beginGradientFill(t,e,s,r,n=null,a="pad",h="rgb",o=0){this._$doFill&&this.endFill(),this._$fills||(this._$fills=U());for(let t=0;t<s.length;++t)this._$maxAlpha=i.max(this._$maxAlpha,s[t]);return this._$doFill=!0,this._$canDraw=!0,this._$fills.push(De.BEGIN_PATH),this._$fillType=De.GRADIENT_FILL,this._$fillGradient=new Ne(t,e,s,r,n,a,h,o),this}clear(){return this._$maxAlpha=0,this._$pointerX=0,this._$pointerY=0,this._$canDraw=!1,this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$lineType=0,this._$lineGradient=null,this._$caps="none",this._$joints="round",this._$miterLimit=0,this._$lineWidth=1,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$doLine=!1,this._$xMin=n.MAX_VALUE,this._$xMax=-n.MAX_VALUE,this._$yMin=n.MAX_VALUE,this._$yMax=-n.MAX_VALUE,this._$recode&&G(this._$recode),this._$fills&&G(this._$fills),this._$lines&&G(this._$lines),this._$buffer=null,this._$recode=null,this._$fills=null,this._$lines=null,this._$restart(),this}clone(){const t=new De;return t.copyFrom(this),t}copyFrom(t){t._$fillGradient&&(this._$fillGradient=t._$fillGradient.clone()),t._$fillBitmap&&(this._$fillBitmap=t._$fillBitmap.clone()),this._$doFill=t._$doFill,this._$fillType=t._$fillType,this._$fillStyleR=t._$fillStyleR,this._$fillStyleG=t._$fillStyleG,this._$fillStyleB=t._$fillStyleB,this._$fillStyleA=t._$fillStyleA,t._$lineGradient&&(this._$lineGradient=t._$lineGradient.clone()),this._$doLine=t._$doLine,this._$lineType=t._$lineType,this._$caps=t._$caps,this._$joints=t._$joints,this._$miterLimit=t._$miterLimit,this._$lineWidth=t._$lineWidth,this._$lineStyleR=t._$lineStyleR,this._$lineStyleG=t._$lineStyleG,this._$lineStyleB=t._$lineStyleB,this._$lineStyleA=t._$lineStyleA,this._$xMin=t._$xMin,this._$xMax=t._$xMax,this._$yMin=t._$yMin,this._$yMax=t._$yMax,this._$maxAlpha=t._$maxAlpha,this._$pointerX=t._$pointerX,this._$pointerY=t._$pointerY,this._$canDraw=t._$canDraw,t._$fills&&(this._$fills=t._$fills.slice(0)),t._$lines&&(this._$lines=t._$lines.slice(0)),t._$recode&&(this._$recode=t._$recode.slice(0))}cubicCurveTo(t,e,i,s,r,n){return r=+r||0,n=+n||0,this._$pointerX===r&&this._$pointerY===n||(t=+t||0,e=+e||0,i=+i||0,s=+s||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$setBounds(r,n),this._$margePath(U(De.CUBIC,t,e,i,s,r,n)),this._$pointerX=r,this._$pointerY=n,this._$restart()),this}curveTo(t,e,i,s){return i=+i||0,s=+s||0,this._$pointerX===i&&this._$pointerY===s||(t=+t||0,e=+e||0,this._$setBounds(t,e),this._$setBounds(i,s),this._$margePath(U(De.CURVE_TO,t,e,i,s)),this._$pointerX=i,this._$pointerY=s,this._$restart()),this}drawCircle(t,e,i){return t=+t||0,e=+e||0,i=+i||0,this._$setBounds(t-i,e-i),this._$setBounds(t+i,e+i),this._$margePath(U(De.MOVE_TO,t+i,e,De.ARC,t,e,i)),this._$pointerX=t,this._$pointerY=e,this._$restart(),this}drawEllipse(t,e,s,r){const n=(s=+s||0)/2,a=(r=+r||0)/2,h=(t=+t||0)+n,o=(e=+e||0)+a,l=t+s,_=e+r,$=4/3*(i.SQRT2-1),c=$*n,u=$*a;return this.moveTo(h,e).cubicCurveTo(h+c,e,l,o-u,l,o).cubicCurveTo(l,o+u,h+c,_,h,_).cubicCurveTo(h-c,_,t,o+u,t,o).cubicCurveTo(t,o-u,h-c,e,h,e)}drawRect(t,e,i,s){const r=(t=+t||0)+(i=+i||0),n=(e=+e||0)+(s=+s||0);return this.moveTo(t,e).lineTo(t,n).lineTo(r,n).lineTo(r,e).lineTo(t,e)}drawRoundRect(t,e,s,r,n,a=NaN){t=+t||0,e=+e||0,s=+s||0,r=+r||0;const h=(n=+n||0)/2,o=(a=+a||n)/2,l=4/3*(i.SQRT2-1),_=l*h,$=l*o,c=t+h,u=t+s,d=u-h,g=e+o,f=e+r,p=f-o;return this.moveTo(c,e).lineTo(d,e).cubicCurveTo(d+_,e,u,g-$,u,g).lineTo(u,p).cubicCurveTo(u,p+$,d+_,f,d,f).lineTo(c,f).cubicCurveTo(c-_,f,t,p+$,t,p).lineTo(t,g).cubicCurveTo(t,g-$,c-_,e,c,e)}endFill(){if(this._$doFill&&this._$fills&&this._$fills.length>7)switch(this._$recode||(this._$recode=U()),this._$fills[2]===this._$fills[this._$fills.length-2]&&this._$fills[3]===this._$fills[this._$fills.length-1]||this._$fills.push(De.LINE_TO,this._$fills[2],this._$fills[3]),this._$recode.push(...this._$fills),this._$fillType){case De.FILL_STYLE:this._$recode.push(this._$fillType,this._$fillStyleR,this._$fillStyleG,this._$fillStyleB,this._$fillStyleA,De.END_FILL);break;case De.GRADIENT_FILL:this._$fillGradient&&this._$recode.push(this._$fillType,...this._$fillGradient.toArray());break;case De.BITMAP_FILL:this._$fillBitmap&&this._$recode.push(this._$fillType,...this._$fillBitmap.toArray())}return this._$fills&&(G(this._$fills),this._$fills=null),this._$fillType=0,this._$fillGradient=null,this._$fillBitmap=null,this._$fillStyleR=0,this._$fillStyleG=0,this._$fillStyleB=0,this._$fillStyleA=0,this._$doFill=!1,this._$restart(),this}endLine(){if(this._$doLine&&this._$lines)switch(this._$recode||(this._$recode=U()),this._$recode.push(...this._$lines),G(this._$lines),this._$lines=null,this._$lineType){case De.STROKE_STYLE:this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,this._$lineStyleR,this._$lineStyleG,this._$lineStyleB,this._$lineStyleA,De.END_STROKE);break;case De.GRADIENT_STROKE:this._$lineGradient&&this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,...this._$lineGradient.toArray());break;case De.BITMAP_STROKE:this._$fillBitmap&&this._$recode.push(this._$lineType,this._$lineWidth,this._$caps,this._$joints,this._$miterLimit,...this._$fillBitmap.toArray())}return this._$lineType=0,this._$lineWidth=0,this._$lineGradient=null,this._$lineStyleR=0,this._$lineStyleG=0,this._$lineStyleB=0,this._$lineStyleA=0,this._$caps="none",this._$joints="round",this._$miterLimit=0,this._$doLine=!1,this._$restart(),this}lineBitmapStyle(t,e=null,i=!0,s=!1){return this._$doLine&&this.endLine(),this._$lines||(this._$lines=U()),this._$maxAlpha=1,this._$doLine=!0,this._$canDraw=!0,this._$lines.push(De.BEGIN_PATH),this._$lineType=De.BITMAP_STROKE,this._$fillBitmap=new ke(t,e,i,s),this}lineGradientStyle(t,e,s,r,n=null,a="pad",h="rgb",o=0){if(!this._$doLine)return this;this._$lines||(this._$lines=U());for(let t=0;t<s.length;++t)this._$maxAlpha=i.max(this._$maxAlpha,s[t]);return this._$lines.push(De.BEGIN_PATH),this._$lineType=De.GRADIENT_STROKE,this._$lineGradient=new Ne(t,e,s,r,n,a,h,o),this}lineStyle(t=1,e=0,s=1,r="round",n="round",a=3){this._$doLine&&this.endLine(),this._$lines||(this._$lines=U()),e=W(J(e),0,16777215,0),s=W(+s,0,1,1),this._$maxAlpha=i.max(this._$maxAlpha,s),this._$doLine=!0,this._$canDraw=!0,this._$pointerX||this._$pointerY?this._$lines.push(De.BEGIN_PATH,De.MOVE_TO,this._$pointerX,this._$pointerY):this._$lines.push(De.BEGIN_PATH);const h=st(e,s);return this._$lineType=De.STROKE_STYLE,this._$lineStyleR=h.R,this._$lineStyleG=h.G,this._$lineStyleB=h.B,this._$lineStyleA=h.A,this._$lineWidth=t,this._$caps=`${r}`,this._$joints=`${n}`,"miter"===this._$joints&&(this._$miterLimit=a),this}lineTo(t,e){return t=+t||0,e=+e||0,this._$pointerX===t&&this._$pointerY===e||(this._$setBounds(t,e),this._$margePath(U(De.LINE_TO,t,e)),this._$pointerX=t,this._$pointerY=e,this._$restart()),this}moveTo(t,e){t=+t||0,e=+e||0,this._$pointerX=t,this._$pointerY=e,this._$setBounds(t,e);let i=!1;return this._$doFill&&this._$fills&&this._$fills[this._$fills.length-3]===De.MOVE_TO&&(i=!0,this._$fills[this._$fills.length-2]=t,this._$fills[this._$fills.length-1]=e),this._$doLine&&this._$lines&&this._$lines[this._$lines.length-3]===De.MOVE_TO&&(i=!0,this._$lines[this._$lines.length-2]=t,this._$lines[this._$lines.length-1]=e),i||this._$margePath(U(De.MOVE_TO,t,e)),this._$restart(),this}_$clip(t,s){const r=this._$getBounds(),n=K(r,s);R(r);const a=i.ceil(i.abs(n.xMax-n.xMin)),h=i.ceil(i.abs(n.yMax-n.yMin));switch(R(n),!0){case 0===a:case 0===h:case a===-1/0:case h===-1/0:case a===e:case h===e:return}t.reset(),t.setTransform(s[0],s[1],s[2],s[3],s[4],s[5]),this._$doDraw(t,null,!0),t.clip()}_$draw(t,s,r,a="normal",h=null){if(!this._$maxAlpha)return;const o=W(r[3]+r[7]/255,0,1),l=this._$displayObject;let _=null!==l._$scale9Grid;const $=l._$transform._$rawMatrix();_&&(_=_&&i.abs($[1])<.001&&i.abs($[2])<1e-4);const c=this._$getBounds(),u=K(c,s),d=u.xMax,g=u.xMin,f=u.yMax,p=u.yMin;R(u);const m=i.ceil(i.abs(d-g)),x=i.ceil(i.abs(f-p));switch(!0){case 0===m:case 0===x:case m===-1/0:case x===-1/0:case m===e:case x===e:return}const b=t.frameBuffer,v=b.currentAttachment;if(!v||g>v.width||p>v.height)return;let T=+i.sqrt(s[0]*s[0]+s[1]*s[1]);if(!n.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}let y=+i.sqrt(s[2]*s[2]+s[3]*s[3]);if(!n.isInteger(y)){const t=y.toString(),e=t.indexOf("e");-1!==e&&(y=+t.slice(0,e)),y=+y.toFixed(4)}if(0>g+m||0>p+x){if(!(h&&h.length&&l._$canApply(h)))return;{let t=new wt(0,0,m,x);for(let e=0;e<h.length;++e)t=h[e]._$generateFilterRect(t,T,y);if(0>t.x+t.width||0>t.y+t.height)return}}const E=U(T,y);let M=`${l._$instanceId}`;!_&&l._$loaderInfo&&l._$characterId&&(M=`${l._$loaderInfo._$id}@${l._$characterId}`);const A=Ui(),w=A.cacheStore,C=w.generateKeys(M,E,r);G(E);let S=w.get(C);if(!S){const e=b.currentAttachment;let n=i.ceil(i.abs(c.xMax-c.xMin)*T),a=i.ceil(i.abs(c.yMax-c.yMin)*y);const h=t._$getTextureScale(n,a);h<1&&(n*=h,a*=h);const o=b.createCacheAttachment(n,a,!0);if(t._$bind(o),t.reset(),t.setTransform(T,0,0,y,-c.xMin*T,-c.yMin*y),_){const e=A.scaleX,r=P(e,0,0,e,0,0),n=j(r,$);O(r);const a=l._$parent._$transform.concatenatedMatrix._$matrix;O(a);const h=P(a[0],a[1],a[2],a[3],a[4]*e-g,a[5]*e-p),o=j(h,n),_=o[4]-(s[4]-g),u=o[5]-(s[5]-p);O(o);const d=K(c,n),f=+d.xMax,m=+d.xMin,x=+d.yMax,b=+d.yMin,v=i.ceil(i.abs(f-m)),T=i.ceil(i.abs(x-b));R(d),t.grid.enable(m,b,v,T,c,l._$scale9Grid,e,n[0],n[1],n[2],n[3],n[4],n[5],h[0],h[1],h[2],h[3],h[4]-_,h[5]-u),O(n),O(h)}r[3]=1,this._$doDraw(t,r,!1),_&&t.grid.disable(),S=b.getTextureFromCurrentAttachment(),w.set(C,S),b.releaseAttachment(o,!1),t._$bind(e)}let F=!1,B=0,I=0;h&&h.length&&l._$canApply(h)&&(F=!0,S=l._$drawFilter(t,S,s,h,m,x),S&&(B=S._$offsetX,I=S._$offsetY));const L=i.atan2(s[1],s[0]),k=i.atan2(-s[2],s[3]);if(F||!L&&!k)t.setTransform(1,0,0,1,g-B,p-I);else{const e=c.xMin*T,r=c.yMin*y,n=i.cos(L),a=i.sin(L),h=i.cos(k),o=i.sin(k);t.setTransform(n,a,-o,h,e*n-r*o+s[4],e*a+r*h+s[5])}S&&(t.reset(),t.globalAlpha=o,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=a,t.drawImage(S,0,0,S.width,S.height,r)),G(C),R(c)}_$doDraw(t,e=null,i=!1){t.reset(),t.beginPath(),this._$runCommand(t,e,i)}_$hit(t,e,i,s=!1){return t.beginPath(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,null,s,i)}_$getBounds(){const t=this._$displayObject;return t&&t._$bounds?B(t._$bounds.xMin,t._$bounds.xMax,t._$bounds.yMin,t._$bounds.yMax):B(this._$xMin,this._$xMax,this._$yMin,this._$yMax)}_$restart(){if(this._$displayObject&&(this._$displayObject._$posted=!1,this._$buffer=null,!this._$displayObject._$isUpdated())){this._$displayObject._$doChanged(),yt();const t=Ui().cacheStore;t.removeCache(this._$displayObject._$instanceId),this._$displayObject._$characterId&&t.removeCache(this._$displayObject._$characterId)}}_$setBounds(t=0,e=0){this._$setFillBounds(t,e),this._$doLine&&this._$setLineBounds(t,e)}_$setFillBounds(t=0,e=0){this._$xMin=i.min(this._$xMin,t),this._$xMax=i.max(this._$xMax,t),this._$yMin=i.min(this._$yMin,e),this._$yMax=i.max(this._$yMax,e)}_$setLineBounds(t=0,e=0){this._$xMin=i.min(this._$xMin,i.min(t,this._$pointerX)),this._$xMax=i.max(this._$xMax,i.max(t,this._$pointerX)),this._$yMin=i.min(this._$yMin,i.min(e,this._$pointerY)),this._$yMax=i.max(this._$yMax,i.max(e,this._$pointerY));const s=this._$lineWidth/2,r=.5*i.PI,n=i.atan2(e-this._$pointerY,t-this._$pointerX),a=i.atan2(this._$pointerY-e,this._$pointerX-t),h=n+r,o=n-r,l=a+r,_=a-r;let $=t+s,c=-s+t,u=this._$pointerX+s,d=-s+this._$pointerX,g=e+s,f=-s+e,p=this._$pointerY+s,m=-s+this._$pointerY;switch(this._$xMin=i.min(this._$xMin,i.min($,i.min(c,i.min(u,d)))),this._$xMax=i.max(this._$xMax,i.max($,i.max(c,i.max(u,d)))),this._$yMin=i.min(this._$yMin,i.min(g,i.min(f,i.min(p,m)))),this._$yMax=i.max(this._$yMax,i.max(g,i.max(f,i.max(p,m)))),i.abs(h)%r!=0&&($=t+i.cos(h)*s),i.abs(o)%r!=0&&(c=t+i.cos(o)*s),i.abs(l)%r!=0&&(u=this._$pointerX+i.cos(l)*s),i.abs(_)%r!=0&&(d=this._$pointerX+i.cos(_)*s),h&&i.abs(h)%i.PI!=0&&(g=e+i.sin(h)*s),o&&i.abs(o)%i.PI!=0&&(f=e+i.sin(o)*s),l&&i.abs(l)%i.PI!=0&&(p=this._$pointerY+i.sin(l)*s),_&&i.abs(_)%i.PI!=0&&(m=this._$pointerY+i.sin(_)*s),this._$xMin=i.min(this._$xMin,i.min($,i.min(c,i.min(u,d)))),this._$xMax=i.max(this._$xMax,i.max($,i.max(c,i.max(u,d)))),this._$yMin=i.min(this._$yMin,i.min(g,i.min(f,i.min(p,m)))),this._$yMax=i.max(this._$yMax,i.max(g,i.max(f,i.max(p,m)))),this._$caps){case"round":if(i.abs(n)%r!=0){const e=t+i.cos(n)*s;this._$xMin=i.min(this._$xMin,e),this._$xMax=i.max(this._$xMax,e)}if(n&&i.abs(n)%i.PI!=0){const t=e+i.sin(n)*s;this._$yMin=i.min(this._$yMin,t),this._$yMax=i.max(this._$yMax,t)}if(i.abs(a)%r!=0){const t=this._$pointerX+i.cos(a)*s;this._$xMin=i.min(this._$xMin,t),this._$xMax=i.max(this._$xMax,t)}if(a&&i.abs(a)%i.PI!=0){const t=this._$pointerY+i.sin(a)*s;this._$yMin=i.min(this._$yMin,t),this._$yMax=i.max(this._$yMax,t)}break;case"square":if(i.abs(n)%r!=0){const t=i.cos(n)*s,e=$+t,r=c+t;this._$xMin=i.min(this._$xMin,i.min(e,r)),this._$xMax=i.max(this._$xMax,i.max(e,r))}if(i.abs(a)%r!=0){const t=i.cos(a)*s,e=u+t,r=d+t;this._$xMin=i.min(this._$xMin,i.min(e,r)),this._$xMax=i.max(this._$xMax,i.max(e,r))}if(n&&i.abs(n)%i.PI!=0){const t=i.sin(n)*s,e=g+t,r=f+t;this._$yMin=i.min(this._$yMin,i.min(e,r)),this._$yMax=i.max(this._$yMax,i.max(e,r))}if(a&&i.abs(a)%i.PI!=0){const t=i.sin(a)*s,e=p+t,r=m+t;this._$yMin=i.min(this._$yMin,i.min(e,r)),this._$yMax=i.max(this._$yMax,i.max(e,r))}}}_$margePath(t){this._$doFill&&this._$fills&&this._$fills.push(...t),this._$doLine&&this._$lines&&this._$lines.push(...t),G(t)}_$getRecodes(){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),this._$recode||(this._$recode=U()),!this._$buffer){const t=U(),e=this._$recode;for(let i=0;i<e.length;){const s=e[i++];switch(t.push(s),s){case De.BEGIN_PATH:case De.END_FILL:case De.END_STROKE:case De.CLOSE_PATH:break;case De.MOVE_TO:case De.LINE_TO:t.push(e[i++],e[i++]);break;case De.CURVE_TO:case De.FILL_STYLE:t.push(e[i++],e[i++],e[i++],e[i++]);break;case De.CUBIC:t.push(e[i++],e[i++],e[i++],e[i++],e[i++],e[i++]);break;case De.STROKE_STYLE:switch(t.push(e[i++]),e[i++]){case"none":t.push(0);break;case"round":t.push(1);break;case"square":t.push(2)}switch(e[i++]){case"bevel":t.push(0);break;case"miter":t.push(1);break;case"round":t.push(2)}t.push(e[i++],e[i++],e[i++],e[i++],e[i++]);break;case De.ARC:t.push(e[i++],e[i++],e[i++]);break;case De.GRADIENT_FILL:{const s=e[i++],r=e[i++],n=e[i++],a=e[i++],h=e[i++],o=e[i++];t.push("linear"===s?0:1),t.push(r.length);for(let e=0;e<r.length;++e){const i=r[e];t.push(i.ratio,i.R,i.G,i.B,i.A)}switch(t.push(n[0],n[1],n[2],n[3],n[4],n[5]),a){case"reflect":t.push(0);break;case"repeat":t.push(1);break;default:t.push(2)}t.push("linearRGB"===h?0:1),t.push(o)}break;case De.GRADIENT_STROKE:{switch(t.push(e[i++]),e[i++]){case"none":t.push(0);break;case"round":t.push(1);break;case"square":t.push(2)}switch(e[i++]){case"bevel":t.push(0);break;case"miter":t.push(1);break;case"round":t.push(2)}t.push(e[i++]);const s=e[i++],r=e[i++],n=e[i++],a=e[i++],h=e[i++],o=e[i++];t.push("linear"===s?0:1),t.push(r.length);for(let e=0;e<r.length;++e){const i=r[e];t.push(i.ratio,i.R,i.G,i.B,i.A)}switch(t.push(n[0],n[1],n[2],n[3],n[4],n[5]),a){case"reflect":t.push(0);break;case"repeat":t.push(1);break;default:t.push(2)}t.push("linearRGB"===h?0:1),t.push(o)}break;case De.BITMAP_FILL:{const s=e[i++];let r;if(null!==s.image||null!==s.canvas){const t=Ui().cacheStore,e=t.getCanvas(),i=s.width,n=s.height;e.width=i,e.height=n;const a=e.getContext("2d");if(!a)throw new Error("the context is null.");a.drawImage(s.image||s.canvas,0,0),r=new Uint8Array(a.getImageData(0,0,i,n).data),t.destroy(a)}else{if(null===s._$buffer)break;r=s._$buffer}t.push(s.width,s.height,this._$xMax-this._$xMin,this._$yMax-this._$yMin,r.length);for(let e=0;e<r.length;++e)t.push(r[e]);const n=e[i++];n?t.push(n[0],n[1],n[2],n[3],n[4],n[5]):t.push(1,0,0,1,0,0);const a=e[i++];t.push(a?1:0);const h=e[i++];t.push(h?1:0)}break;case De.BITMAP_STROKE:{switch(t.push(e[i++]),e[i++]){case"none":t.push(0);break;case"round":t.push(1);break;case"square":t.push(2)}switch(e[i++]){case"bevel":t.push(0);break;case"miter":t.push(1);break;case"round":t.push(2)}t.push(e[i++]);const s=e[i++];let r;if(null!==s.image||null!==s.canvas){const t=Ui().cacheStore,e=t.getCanvas(),i=s.width,n=s.height;e.width=i,e.height=n;const a=e.getContext("2d");if(!a)throw new Error("the context is null.");a.drawImage(s.image||s.canvas,0,0),r=new Uint8Array(a.getImageData(0,0,i,n).data),t.destroy(a)}else{if(null===s._$buffer)break;r=s._$buffer}t.push(s.width,s.height,this._$xMax-this._$xMin,this._$yMax-this._$yMin,r.length);for(let e=0;e<r.length;++e)t.push(r[e]);const n=e[i++];n?t.push(n[0],n[1],n[2],n[3],n[4],n[5]):t.push(1,0,0,1,0,0);const a=e[i++];t.push(a?1:0);const h=e[i++];t.push(h?1:0)}}}this._$buffer=new a(t)}return this._$buffer.slice()}_$runCommand(t,e=null,s=!1,r=null){if(this._$doLine&&this.endLine(),this._$doFill&&this.endFill(),!this._$recode)return!1;const n=this._$recode,a=n.length;for(let h=0;h<a;)switch(n[h++]){case De.BEGIN_PATH:t.beginPath();break;case De.MOVE_TO:t.moveTo(n[h++],n[h++]);break;case De.LINE_TO:t.lineTo(n[h++],n[h++]);break;case De.CURVE_TO:t.quadraticCurveTo(n[h++],n[h++],n[h++],n[h++]);break;case De.FILL_STYLE:{if(s||r){h+=4;continue}const a=I();a[0]=n[h++]/255,a[1]=n[h++]/255,a[2]=n[h++]/255,a[3]=n[h++]/255,null!==e&&(1===e[3]&&0===e[7]||(a[3]=i.max(0,i.min(a[3]*e[3]+e[7],255))/255)),t.fillStyle=a}break;case De.END_FILL:if(r&&"isPointInPath"in t&&t.isPointInPath(r.x,r.y))return!0;s||r||t.fill();break;case De.STROKE_STYLE:{if(s||r){h+=8;continue}t.lineWidth=n[h++],t.lineCap=n[h++],t.lineJoin=n[h++],t.miterLimit=n[h++];const a=I();a[0]=n[h++]/255,a[1]=n[h++]/255,a[2]=n[h++]/255,a[3]=n[h++]/255,null!==e&&(1===e[3]&&0===e[7]||(a[3]=i.max(0,i.min(a[3]*e[3]+e[7],255))/255)),t.strokeStyle=a}break;case De.END_STROKE:if(r&&"isPointInStroke"in t&&t.isPointInStroke(r.x,r.y))return!0;s||r||t.stroke();break;case De.CLOSE_PATH:t.closePath();break;case De.CUBIC:t.bezierCurveTo(n[h++],n[h++],n[h++],n[h++],n[h++],n[h++]);break;case De.ARC:t.arc(n[h++],n[h++],n[h++],0,2*i.PI);break;case De.GRADIENT_FILL:{if(r&&"isPointInPath"in t&&t.isPointInPath(r.x,r.y))return!0;if(s||r||t instanceof CanvasRenderingContext2D){h+=6;continue}const a=n[h++],o=n[h++],l=n[h++],_=n[h++],$=n[h++],c=n[h++];let u;if("linear"===a){const e=z(l);u=t.createLinearGradient(e[0],e[1],e[2],e[3],$,_)}else t.save(),t.transform(l[0],l[1],l[2],l[3],l[4],l[5]),u=t.createRadialGradient(0,0,0,0,0,819.2,$,_,c);for(let t=0;t<o.length;++t){const s=o[t];let r=s.A;e&&(1===e[3]&&0===e[7]||(r=0|i.max(0,i.min(s.A*e[3]+e[7],255)))),u.addColorStop(s.ratio,I(s.R,s.G,s.B,r))}t.fillStyle=u,t.fill(),"radial"===a&&t.restore()}break;case De.GRADIENT_STROKE:{if(r&&"isPointInStroke"in t&&t.isPointInStroke(r.x,r.y))return!0;if(s||r||t instanceof CanvasRenderingContext2D){h+=12;continue}t.lineWidth=n[h++],t.lineCap=n[h++],t.lineJoin=n[h++],t.miterLimit=n[h++];const a=n[h++],o=n[h++],l=n[h++],_=n[h++],$=n[h++],c=n[h++];let u;if("linear"===a){const e=z(l);u=t.createLinearGradient(e[0],e[1],e[2],e[3],$,_)}else t.save(),t.transform(l[0],l[1],l[2],l[3],l[4],l[5]),u=t.createRadialGradient(0,0,0,0,0,819.2,$,_,c);for(let t=0;t<o.length;++t){const s=o[t];let r=s.A;e&&(1===e[3]&&0===e[7]||(r=0|i.max(0,i.min(s.A*e[3]+e[7],255)))),u.addColorStop(s.ratio,I(s.R,s.G,s.B,r))}t.strokeStyle=u,t.stroke(),"radial"===a&&t.restore()}break;case De.BITMAP_FILL:{if(r&&"isPointInPath"in t&&t.isPointInPath(r.x,r.y))return!0;if(s||r||t instanceof CanvasRenderingContext2D){h+=6;continue}t.save();const i=n[h++],a=n[h++],o=n[h++],l=n[h++];a&&t.transform(a[0],a[1],a[2],a[3],a[4],a[5]);const _=i.getTexture();if(!_||!e)break;o||i.width!==this._$xMax-this._$xMin||i.height!==this._$yMax-this._$yMin?(t.fillStyle=t.createPattern(_,o,e),t.imageSmoothingEnabled=l,t.fill()):t.drawImage(_,0,0,i.width,i.height),t.restore(),t.imageSmoothingEnabled=!1}break;case De.BITMAP_STROKE:{if(r&&"isPointInStroke"in t&&t.isPointInStroke(r.x,r.y))return!0;if(s||r||t instanceof CanvasRenderingContext2D){h+=9;continue}t.save(),t.lineWidth=n[h++],t.lineCap=n[h++],t.lineJoin=n[h++],t.miterLimit=n[h++];const i=n[h++],a=n[h++],o=n[h++],l=n[h++];a&&t.transform(a[0],a[1],a[2],a[3],a[4],a[5]);const _=i.getTexture();if(!_||!e)break;t.strokeStyle=t.createPattern(_,o,e),t.imageSmoothingEnabled=l,t.stroke(),t.restore(),t.imageSmoothingEnabled=!1}}return!1}}class Ue{_$volume;_$loop;constructor(t=1,e=!1){this._$volume=1,this._$loop=!1,this.volume=t,this.loop=e}static toString(){return"[class SoundTransform]"}static get namespace(){return"next2d.media.SoundTransform"}toString(){return"[object SoundTransform]"}get namespace(){return"next2d.media.SoundTransform"}get loop(){return this._$loop}set loop(t){this._$loop=t}get volume(){return this._$volume}set volume(t){this._$volume=W(+t,0,1,0)}}class Ge extends Gt{_$buttonMode;_$hitArea;_$soundTransform;_$graphics;_$useHandCursor;constructor(){super(),this._$buttonMode=!1,this._$hitArea=null,this._$soundTransform=null,this._$useHandCursor=!0,this._$graphics=null}static toString(){return"[class Sprite]"}static get namespace(){return"next2d.display.Sprite"}toString(){return"[object Sprite]"}get namespace(){return"next2d.display.Sprite"}get buttonMode(){return this._$buttonMode}set buttonMode(t){this._$buttonMode=!!t}get dropTarget(){return bi}get graphics(){return this._$graphics||(this._$graphics=new De(this)),this._$graphics}get hitArea(){return this._$hitArea}set hitArea(t){this._$hitArea&&(this._$hitArea._$hitObject=null),this._$hitArea=t,t&&(t._$hitObject=this)}get soundTransform(){return this._$soundTransform||(this._$soundTransform=new Ue),this._$soundTransform}set soundTransform(t){this._$soundTransform=t}get useHandCursor(){return this._$useHandCursor}set useHandCursor(t){this._$useHandCursor=t}startDrag(t=!1,e=null){let i=0,s=0;if(!t){const t=this._$dragMousePoint();i=this.x-t.x,s=this.y-t.y}vi(this),Ti.lock=t,Ti.position.x=i,Ti.position.y=s,Ti.bounds=e}stopDrag(){vi(null),Ti.lock=!1,Ti.position.x=0,Ti.position.y=0,Ti.bounds=null}_$sync(t){Zi&&this._$stage&&this._$createWorkerInstance(),this._$controller=t.controller,this._$dictionary=t.dictionary,this._$placeMap=t.placeMap,this._$placeObjects=t.placeObjects}_$build(t,e){const i=this._$baseBuild(t,e);return Zi&&this._$stage&&this._$createWorkerInstance(),this._$controller=i.controller,this._$dictionary=i.dictionary,this._$placeMap=i.placeMap,this._$placeObjects=i.placeObjects,i}_$dragMousePoint(){return this._$parent?this._$parent.globalToLocal(Gi()):this.globalToLocal(Gi())}}class Ve extends At{_$name;_$frame;constructor(t,e){super(),this._$name=`${t}`,this._$frame=0|e}static toString(){return"[class FrameLabel]"}static get namespace(){return"next2d.display.FrameLabel"}toString(){return"[object FrameLabel]"}get namespace(){return"next2d.display.FrameLabel"}get frame(){return this._$frame}get name(){return this._$name}}class Ye{_$url;_$contentType;_$data;_$method;_$requestHeaders;_$responseDataFormat;_$withCredentials;constructor(t=""){this._$url=`${t}`,this._$contentType="application/json",this._$data="",this._$method="GET",this._$requestHeaders=U(),this._$responseDataFormat="json",this._$withCredentials=!1}static toString(){return"[class URLRequest]"}static get namespace(){return"next2d.net.URLRequest"}toString(){return"[object URLRequest]"}get namespace(){return"next2d.net.URLRequest"}get contentType(){return this._$contentType}set contentType(t){this._$contentType=`${t}`}get data(){return this._$data}set data(t){this._$data=t}get method(){return this._$method}set method(t){this._$method=`${t}`}get requestHeaders(){return this._$requestHeaders}set requestHeaders(t){this._$requestHeaders.length=0,this._$requestHeaders.push(...t)}get url(){if(this._$url&&-1===this._$url.indexOf("//")){const t=this._$url.split("/");""!==t[0]&&"."!==t[0]||t.shift();const e=Ui();if(e)return`${e.base}${t.join("/")}`}return this._$url}set url(t){this._$url=`${t}`}get responseDataFormat(){return this._$responseDataFormat}set responseDataFormat(t){this._$responseDataFormat=`${t}`}get withCredentials(){return this._$withCredentials}set withCredentials(t){this._$withCredentials=t}get headers(){const t=U();return t.push(new lt("Content-Type",`${this._$contentType}`)),this._$requestHeaders.length&&t.push(...this._$requestHeaders),t}}class Xe extends $t{_$text;constructor(t,e=!1,i=!1,s=""){super(t,e,i),this._$text=`${s}`}static toString(){return"[class IOErrorEvent]"}static get namespace(){return"next2d.events.IOErrorEvent"}toString(){return this.formatToString("IOErrorEvent","type","bubbles","cancelable","eventPhase","text")}get namespace(){return"next2d.events.IOErrorEvent"}static get IO_ERROR(){return"ioError"}get text(){return this._$text}}class ze extends $t{_$bytesLoaded;_$bytesTotal;constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class ProgressEvent]"}static get namespace(){return"next2d.events.ProgressEvent"}toString(){return this.formatToString("ProgressEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.ProgressEvent"}static get PROGRESS(){return"progress"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class He extends At{_$sources;_$bytesLoaded;_$bytesTotal;_$volume;_$currentCount;_$src;_$loopCount;_$stopFlag;_$character;_$audioBuffer;_$arrayBuffer;constructor(){super(),this._$bytesLoaded=0,this._$bytesTotal=0,this._$arrayBuffer=null,this._$audioBuffer=null,this._$character=null,this._$sources=U(),this._$volume=1,this._$currentCount=0,this._$loopCount=0,this._$stopFlag=!0,this._$src=""}static toString(){return"[class Sound]"}static get namespace(){return"next2d.media.Sound"}toString(){return"[object Sound]"}get namespace(){return"next2d.media.Sound"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get loopCount(){return this._$loopCount}set loopCount(t){this._$loopCount=t}get src(){return this._$src}set src(t){this.load(new Ye(t))}get volume(){return this._$volume}set volume(t){this._$volume=i.min(Pe.volume,W(t,0,1,1));const e=this._$sources.length;if(e&&mi)for(let t=0;t<e;++t){const e=this._$sources[t];e._$gainNode&&(e._$gainNode.gain.value=this._$volume,e._$volume=this._$volume)}}clone(){const t=new He;return t.volume=this.volume,t._$loopCount=this._$loopCount,this._$character?t._$character=this._$character:t._$audioBuffer=this._$audioBuffer,t}load(t){this._$src=t.url,Qi({format:"arraybuffer",url:t.url,method:t.method,data:t.data,headers:t.headers,withCredentials:t.withCredentials,event:{loadstart:t=>{this._$loadStart(t)},progress:t=>{this._$progress(t)},loadend:t=>{this._$loadEnd(t)}}})}_$loadStart(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger($t.OPEN)&&this.dispatchEvent(new $t($t.OPEN)),this.willTrigger(ze.PROGRESS)&&this.dispatchEvent(new ze(ze.PROGRESS,!1,!1,t.loaded,t.total))}_$progress(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(ze.PROGRESS)&&this.dispatchEvent(new ze(ze.PROGRESS,!1,!1,t.loaded,t.total))}_$loadEnd(t){this._$bytesLoaded=t.loaded,this._$bytesTotal=t.total,this.willTrigger(ze.PROGRESS)&&this.dispatchEvent(new ze(ze.PROGRESS,!1,!1,t.loaded,t.total));const e=t.target;if(!e)throw new Error("the Sound target is null.");199<e.status&&400>e.status?(this._$arrayBuffer=e.response,mi?Wi(this).then((t=>{(t.hasEventListener($t.INIT)||t.hasEventListener($t.COMPLETE))&&Ui()._$loaders.push(t)})):Mi.push(this)):this.willTrigger(Xe.IO_ERROR)&&this.dispatchEvent(new Xe(Xe.IO_ERROR,!1,!1,e.statusText))}play(t=0){const e=this._$character?this._$character.audioBuffer:this._$audioBuffer;if(mi&&e)this._$createBufferSource(t);else{const e=u.now(),i=()=>{if(null===(this._$character?this._$character.audioBuffer:this._$audioBuffer)||null===mi)$(i);else{const i=(u.now()-e)/1e3;this._$createBufferSource(t,i)}};$(i)}}stop(){this._$stopFlag=!0;const t=this._$sources.length;if(t){const e=Ui();if(mi)for(let e=0;e<t;++e){const t=this._$sources[e];t._$gainNode&&(t._$gainNode.gain.value=0,t._$gainNode.disconnect(),t._$gainNode=null),t.onended=null,t.disconnect()}e._$sources.splice(e._$sources.indexOf(this),1),this._$currentCount=0,this._$sources.length=0}}_$build(t,e){const s=e.loaderInfo;if(!s||!s._$data)throw new Error("the loaderInfo or data is null.");if(this._$character=s._$data.characters[t.characterId],!this._$character)throw new Error("character is null.");this._$character.audioBuffer||(mi?Wi(this).then((t=>{(t.hasEventListener($t.INIT)||t.hasEventListener($t.COMPLETE))&&Ui()._$loaders.push(t)})):Mi.push(this)),this._$loopCount=0|t.loopCount,this._$volume=i.min(Pe.volume,t.volume)}_$createBufferSource(t=0,e=0){if(!mi)throw new Error("the Audio Context is null.");const s=mi.createBufferSource();s.onended=t=>this._$endEventHandler(t),s.buffer=this._$character?this._$character.audioBuffer:this._$audioBuffer,s._$gainNode=mi.createGain(),s._$gainNode.connect(mi.destination);const r=i.min(Pe.volume,this._$volume);s._$gainNode.gain.value=r,s._$volume=r,s.connect(s._$gainNode),s.start(0|t,e);const n=Ui();-1===n._$sources.indexOf(this)&&n._$sources.push(this),this._$sources.push(s),this._$stopFlag=!1}_$endEventHandler(t){const e=t.target;if(this._$sources.splice(this._$sources.indexOf(e),1),!this._$stopFlag&&this._$loopCount>this._$currentCount)this._$createBufferSource(),this._$currentCount++;else{if(this._$currentCount=0,mi&&(e._$gainNode&&(e._$gainNode.gain.value=0,e._$gainNode.disconnect(),e._$gainNode=null),e.onended=null,e.disconnect()),!this._$sources.length){const t=Ui();t._$sources.splice(t._$sources.indexOf(this),1)}this.willTrigger($t.SOUND_COMPLETE)&&this.dispatchEvent(new $t($t.SOUND_COMPLETE))}}}class We extends Ge{_$labels;_$currentFrame;_$stopFlag;_$canAction;_$childRemove;_$canSound;_$actionProcess;_$actions;_$frameCache;_$sounds;_$actionOffset;_$actionLimit;_$totalFrames;_$isPlaying;_$loopConfig;_$tweenFrame;constructor(){super(),this._$stopFlag=!1,this._$canAction=!0,this._$childRemove=!1,this._$canSound=!0,this._$actionProcess=!1,this._$actions=Y(),this._$frameCache=Y(),this._$labels=null,this._$sounds=Y(),this._$actionOffset=0,this._$actionLimit=0,this._$currentFrame=1,this._$totalFrames=1,this._$isPlaying=!1,this._$loopConfig=null,this._$tweenFrame=0}static toString(){return"[class MovieClip]"}static get namespace(){return"next2d.display.MovieClip"}toString(){return"[object MovieClip]"}get namespace(){return"next2d.display.MovieClip"}get currentFrame(){return this._$currentFrame}get currentFrameLabel(){if(!this._$labels)return null;const t=this._$currentFrame;return this._$labels.has(t)&&this._$labels.get(t)||null}get currentLabels(){return this._$labels&&this._$labels.size?s.from(this._$labels.values()):null}get isPlaying(){return this._$isPlaying}get totalFrames(){return this._$totalFrames}get loopConfig(){if(this._$loopConfig)return this._$loopConfig;const t=this._$getPlaceObject();return t&&t.loop?(this._$tweenFrame&&(this._$changePlace=this._$tweenFrame!==this._$parent._$currentFrame,this._$tweenFrame=0),t.loop.tweenFrame&&(this._$tweenFrame=t.loop.tweenFrame),t.loop):null}set loopConfig(t){this._$loopConfig=t,t&&(t.frame=this._$startFrame,this._$loopConfig=t,this._$currentFrame=this._$getLoopFrame(t))}gotoAndPlay(t){this.play(),this._$goToFrame(t)}gotoAndStop(t){this.stop(),this._$goToFrame(t)}nextFrame(){this.stop(),this._$totalFrames>this._$currentFrame&&this._$goToFrame(this._$currentFrame+1)}play(){this._$stopFlag=!1,this._$isPlaying=!0,this._$updateState()}prevFrame(){const t=this._$currentFrame-1;t&&(this.stop(),this._$goToFrame(t))}stop(){this._$stopFlag=!0,this._$isPlaying=!1}addFrameLabel(t){this._$labels||(this._$labels=Y()),this._$labels.set(t.frame,t)}addFrameScript(...t){for(let e=0;e<t.length;e+=2){const i=t[e];let s=+i;_(s)&&(s=this._$getFrameForLabel(`${i}`));const r=t[e+1];if(r&&s&&this._$totalFrames>=s&&this._$addAction(s,r),s===this._$currentFrame){const t=Ui();if(t._$actionOffset=t._$actions.length,this._$canAction=!0,this._$setAction(),t._$actionOffset!==t._$actions.length){const e=t._$actions.splice(0,t._$actionOffset);t._$actions.push(...t._$actions,...e),t._$actionOffset=0}}}}_$getFrameForLabel(t){if(!this._$labels)return 0;for(const[e,i]of this._$labels)if(i.name===t)return e;return 0}_$addAction(t,e){if(t){this._$actions.has(t)||this._$actions.set(t,U());const i=this._$actions.get(t);i&&i.push(e)}}_$setAction(){if(this._$executeAddedEvent(),this._$canAction){const t=this._$currentFrame;if(this._$labels&&this._$labels.has(t)){const e=this._$labels.get(t);e&&e.willTrigger($t.FRAME_LABEL)&&e.dispatchEvent(new $t($t.FRAME_LABEL))}if(this._$actions.size&&this._$actions.has(t)){const t=Ui();-1===t._$actions.indexOf(this)&&t._$actions.push(this)}}}_$goToFrame(t){let e=+t;if(_(e)&&(e=this._$getFrameForLabel(`${t}`)),e<1&&(e=1),e>this._$totalFrames)return this._$currentFrame=this._$totalFrames,this._$clearChildren(),this._$canAction=!1,void(this._$wait=!1);const i=Ui();switch(!0){case e!==this._$currentFrame:{this._$wait=!1;const t=this._$currentFrame;this._$actionProcess&&(this._$frameCache.set("nextFrame",e),this._$frameCache.set("stopFlag",this._$stopFlag),this._$frameCache.set("isPlaying",this._$isPlaying)),this._$currentFrame=e,this._$clearChildren(),i._$actionOffset=i._$actions.length;const s=i._$actionOffset?i._$actions.indexOf(this):-1;if(this._$canAction=!0,this._$prepareActions(),i._$actionOffset&&i._$actionOffset!==i._$actions.length){const t=i._$actions.splice(0,i._$actionOffset);i._$actions.push(...i._$actions,...t),i._$actionOffset=0}if(!this._$actionProcess&&(s>-1||!i._$actionOffset))for(;i._$actions.length&&i._$actions.length!==s;){const t=i._$actions.pop();if(!t)continue;t._$canAction=!1,t._$actionOffset=0,t._$actionLimit=0,t._$actionProcess&&t._$frameCache.size&&(t._$currentFrame=t._$frameCache.get("nextFrame"),t._$clearChildren(),t._$stopFlag=t._$frameCache.get("stopFlag"),t._$isPlaying=t._$frameCache.get("isPlaying"),t._$frameCache.clear());const e=t._$currentFrame;if(!t._$actions.has(e))continue;const s=t._$actions.get(e);if(s)for(let e=0;e<s.length;++e)try{ft(t._$loaderInfo),s[e].apply(t)}catch(e){t.stop()}}this._$actionProcess&&(this._$currentFrame=t,this._$clearChildren())}break;case!this._$actionProcess&&i._$actions.indexOf(this)>-1:{if(!this._$actionLimit)break;this._$wait=!1;const t=i._$actions.splice(this._$actionOffset,this._$actionLimit);for(;t.length;){const e=t.pop();if(!e)continue;e._$canAction=!1,e._$actionOffset=0,e._$actionLimit=0;const i=e._$currentFrame;if(!e._$actions.has(i))continue;const s=e._$actions.get(i);if(s)for(let t=0;t<s.length;++t)try{ft(e._$loaderInfo),s[t].apply(e)}catch(t){e.stop()}}}}ft(null),this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)&&!i._$sounds.has(this._$instanceId)&&i._$sounds.set(this._$instanceId,this)}_$prepareActions(){this._$wait=!1;const t=this._$needsChildren?this._$getChildren():this._$children;for(let e=t.length-1;e>-1;--e)t[e]._$prepareActions();this._$setAction()}_$nextFrame(){let t=this._$needsChildren;switch(!0){case this._$wait:t=!0,this._$wait=!1;break;case this._$stopFlag:case 1===this._$totalFrames:break;default:{t=!0,this._$canAction=!0,this._$canSound=!0;const e=this.loopConfig;if(e){const i=e.end?e.end:this._$totalFrames;switch(e.type){case 0:this._$changePlace?this._$currentFrame=e.start:(++this._$currentFrame,this._$currentFrame>i&&(this._$currentFrame=e.start));break;case 1:this._$changePlace?this._$currentFrame=e.start:(++this._$currentFrame,this._$currentFrame>i&&(this._$currentFrame=i,t=!1,this._$canAction=!1,this._$canSound=!1));break;case 2:this._$changePlace?this._$currentFrame=e.start:(t=!1,this._$canAction=!1,this._$canSound=!1);break;case 3:this._$changePlace?this._$currentFrame=i:(--this._$currentFrame,e.start>this._$currentFrame&&(this._$currentFrame=e.start,t=!1,this._$canAction=!1,this._$canSound=!1));break;case 4:this._$changePlace?this._$currentFrame=i:(--this._$currentFrame,e.start>this._$currentFrame&&(this._$currentFrame=i))}}else++this._$currentFrame,this._$currentFrame>this._$totalFrames&&(this._$currentFrame=1);if(t&&this._$clearChildren(),this._$canSound&&this._$sounds.size&&this._$sounds.has(this._$currentFrame)){const t=Ui();t._$sounds.has(this._$instanceId)||t._$sounds.set(this._$instanceId,this)}}}const e=this._$needsChildren?this._$getChildren():this._$children;for(let i=e.length-1;i>-1;--i){const s=e[i];s._$isNext&&(t?s._$nextFrame():t=s._$nextFrame())}return this._$setAction(),this._$isNext=t,!this._$posted&&Zi&&this._$postProperty(),this._$isNext}_$getLoopFrame(t){const e=this._$parent._$currentFrame-t.frame;let s=1;switch(t.type){case 0:{const i=t.end?t.end:this._$totalFrames;s=t.start;for(let r=0;r<e;++r)++s,s>i&&(s=t.start)}break;case 1:{const r=t.end?t.end:this._$totalFrames;s=i.min(r,t.start+e)}break;case 2:s=t.start;break;case 3:s=t.end?t.end:this._$totalFrames,s=i.max(t.start,s-e);break;case 4:{const i=t.end?t.end:this._$totalFrames;s=i;for(let r=0;r<e;++r)--s,t.start>s&&(s=i)}}return s}_$buildCharacter(t){if(t.sounds)for(let e=0;e<t.sounds.length;++e){const i=t.sounds[e],s=U();for(let t=0;t<i.sound.length;++t){const e=new He;e._$build(i.sound[t],this),s.push(e)}this._$sounds.set(i.frame,s)}if(t.actions)for(let e=0;e<t.actions.length;++e){const i=t.actions[e];i.script||(i.script=Function(i.action)),this._$addAction(i.frame,i.script)}if(t.labels)for(let e=0;e<t.labels.length;++e){const i=t.labels[e];this.addFrameLabel(new Ve(i.name,i.frame))}this._$totalFrames=t.totalFrame||1}_$sync(t){super._$sync(t),this._$buildCharacter(t)}_$build(t,e){const i=super._$build(t,e);return this._$buildCharacter(i),i}_$soundPlay(){if(!this._$sounds.has(this._$currentFrame))return;const t=this._$sounds.get(this._$currentFrame);if(t.length){let e=this._$soundTransform,i=this._$parent;for(;i;)i._$soundTransform&&(e=i._$soundTransform),i=i._$parent;for(let i=0;i<t.length;++i){const s=t[i];e&&(s.loopCount=e.loop?16777215:0,s.volume=e.volume),s.play()}}this._$canSound=!1}}class je{_$font;_$size;_$color;_$bold;_$italic;_$underline;_$align;_$leftMargin;_$rightMargin;_$indent;_$leading;_$blockIndent;_$letterSpacing;constructor(t=null,e=null,i=null,s=null,r=null,n=null,a=null,h=null,o=null,l=null,_=null,$=null){this._$font=t,this._$size=e,this._$color=null===i?null:W(J(i),0,16777215,0),this._$bold=s,this._$italic=r,this._$underline=n,this._$align=a,this._$leftMargin=h,this._$rightMargin=o,this._$indent=l,this._$leading=_,this._$blockIndent=$,this._$letterSpacing=0}static toString(){return"[class TextFormat]"}static get namespace(){return"next2d.text.TextFormat"}toString(){return"[object TextFormat]"}get namespace(){return"next2d.text.TextFormat"}get align(){return this._$align}set align(t){this._$align=t}get blockIndent(){return this._$blockIndent}set blockIndent(t){this._$blockIndent=t}get bold(){return this._$bold}set bold(t){this._$bold=null!==t?!!t:null}get color(){return this._$color}set color(t){this._$color=t,t&&(this._$color=W(J(t),0,16777215,0))}get font(){return this._$font}set font(t){this._$font=null!==t?`${t}`:null}get indent(){return this._$indent}set indent(t){this._$indent=t}get italic(){return this._$italic}set italic(t){this._$italic=null!==t?!!t:null}get leading(){return this._$leading}set leading(t){this._$leading=t}get leftMargin(){return this._$leftMargin}set leftMargin(t){this._$leftMargin=t}get letterSpacing(){return this._$letterSpacing}set letterSpacing(t){this._$letterSpacing=t}get rightMargin(){return this._$rightMargin}set rightMargin(t){this._$rightMargin=t}get size(){return this._$size}set size(t){this._$size=t?0|t:null}get underline(){return this._$underline}set underline(t){this._$underline=null!==t?!!t:null}_$clone(){const t=new je(this._$font,this._$size,this._$color,this._$bold,this._$italic,this._$underline,this._$align,this._$leftMargin,this._$rightMargin,this._$indent,this._$leading,this._$blockIndent);return t._$letterSpacing=this._$letterSpacing,t}_$setDefault(){this._$align="left",this._$blockIndent=0,this._$bold=!1,this._$color=0,this._$font="Times New Roman",this._$indent=0,this._$italic=!1,this._$leading=0,this._$leftMargin=0,this._$letterSpacing=0,this._$rightMargin=0,this._$size=12,this._$underline=!1}_$merge(t){null===this._$align&&(this._$align=t._$align),null===this._$blockIndent&&(this._$blockIndent=t._$blockIndent),null===this._$bold&&(this._$bold=t._$bold),null===this._$color&&(this._$color=t._$color),null===this._$font&&(this._$font=t._$font),null===this._$indent&&(this._$indent=t._$indent),null===this._$italic&&(this._$italic=t._$italic),null===this._$leading&&(this._$leading=t._$leading),null===this._$leftMargin&&(this._$leftMargin=t._$leftMargin),null===this._$letterSpacing&&(this._$letterSpacing=t._$letterSpacing),null===this._$rightMargin&&(this._$rightMargin=t._$rightMargin),null===this._$size&&(this._$size=t._$size),null===this._$underline&&(this._$underline=t._$underline)}_$widthMargin(){let t=0;return this._$indent&&(t+=this._$indent),this._$leftMargin&&(t+=this._$leftMargin),this._$rightMargin&&(t+=this._$rightMargin),t}_$generateFontStyle(){let t="";return this._$italic&&(t="italic "),this._$bold&&(t+="bold "),`${t}${this._$size}px '${this._$font}','sans-serif'`}}class qe extends $t{constructor(t,e=!0,i=!1){super(t,e,i)}static toString(){return"[class FocusEvent]"}static get namespace(){return"next2d.events.FocusEvent"}toString(){return this.formatToString("FocusEvent","type","bubbles","cancelable","eventPhase")}get namespace(){return"next2d.events.FocusEvent"}static get FOCUS_IN(){return"focusIn"}static get FOCUS_OUT(){return"focusOut"}}class Ke{static toString(){return"[class Easing]"}static get namespace(){return"next2d.ui.Easing"}toString(){return"[object Easing]"}get namespace(){return"next2d.ui.Easing"}static linear(t,e,i,s){return t/s*i+e}static inQuad(t,e,i,s){return(t/=s)*t*i+e}static outQuad(t,e,i,s){return-(t/=s)*(t-2)*i+e}static inOutQuad(t,e,i,s){return(t/=s/2)<1?t*t*i/2+e:-((t-=1)*(t-2)-1)*i/2+e}static inCubic(t,e,i,s){return(t/=s)*t*t*i+e}static outCubic(t,e,i,s){return t/=s,(--t*t*t+1)*i+e}static inOutCubic(t,e,i,s){return(t/=s/2)<1?t*t*t*i/2+e:((t-=2)*t*t+2)*i/2+e}static inQuart(t,e,i,s){return(t/=s)*t*t*t*i+e}static outQuart(t,e,i,s){return t/=s,(--t*t*t*t-1)*-i+e}static inOutQuart(t,e,i,s){return(t/=s/2)<1?t*t*t*t*i/2+e:((t-=2)*t*t*t-2)*-i/2+e}static inQuint(t,e,i,s){return(t/=s)*t*t*t*t*i+e}static outQuint(t,e,i,s){return t/=s,(--t*t*t*t*t+1)*i+e}static inOutQuint(t,e,i,s){return(t/=s/2)<1?t*t*t*t*t*i/2+e:((t-=2)*t*t*t*t+2)*i/2+e}static inSine(t,e,s,r){return-s*i.cos(t/r*(i.PI/2))+s+e}static outSine(t,e,s,r){return s*i.sin(t/r*(i.PI/2))+e}static inOutSine(t,e,s,r){return-s/2*(i.cos(i.PI*t/r)-1)+e}static inExpo(t,e,s,r){return s*i.pow(2,10*(t/r-1))+e}static outExpo(t,e,s,r){return s*(1-i.pow(2,-10*t/r))+e}static inOutExpo(t,e,s,r){return(t/=r/2)<1?s/2*i.pow(2,10*(t-1))+e:s/2*(2-i.pow(2,-10*(t-1)))+e}static inCirc(t,e,s,r){return(1-i.sqrt(1-(t/=r)*t))*s+e}static outCirc(t,e,s,r){return t/=r,i.sqrt(1- --t*t)*s+e}static inOutCirc(t,e,s,r){return(t/=2*r)<1?(i.sqrt(1-t*t)-1)/-2*s+e:(i.sqrt(1-(t-=2)*t)+1)/2*s+e}static inBack(t,e,i,s){return(2.70158*(t/=s)*t*t-1.70158*t*t)*i+e}static outBack(t,e,s,r){return(1+2.70158*i.pow((t/=r)-1,3)+1.70158*i.pow(t-1,2))*s+e}static inOutBack(t,e,i,s){let r=1.70158;return(t/=s/2)<1?t*t*((1+(r*=1.525))*t-r)*i/2+e:((t-=2)*t*((1+(r*=1.525))*t+r)+2)*i/2+e}static inElastic(t,e,s,r){return 0==(t/=r)?e:1===t?s+e:-i.pow(2,(t*=10)-10)*i.sin((t-10.75)*(2*i.PI/3))*s+e}static outElastic(t,e,s,r){return 0==(t/=r)?e:1===t?s+e:(i.pow(2,-10*t)*i.sin((10*t-.75)*(2*i.PI/3))+1)*s+e}static inOutElastic(t,e,s,r){return 0==(t/=r)?e:1===t?s+e:t<.5?-i.pow(2,20*t-10)*i.sin((20*t-11.125)*(2*i.PI/4.5))/2*s+e:(i.pow(2,-20*t+10)*i.sin((20*t-11.125)*(2*i.PI/4.5))/2+1)*s+e}static outBounce(t,e,i,s){return(t/=s)<1/2.75?7.5625*t*t*i+e:t<2/2.75?(7.5625*(t-=1.5/2.75)*t+.75)*i+e:t<2.5/2.75?(7.5625*(t-=2.25/2.75)*t+.9375)*i+e:(7.5625*(t-=2.625/2.75)*t+.984375)*i+e}static inBounce(t,e,i,s){return i-Ke.outBounce(s-t,0,i,s)+e}static inOutBounce(t,e,i,s){return t<s/2?Ke.inBounce(2*t,e,i/2,s):Ke.outBounce(2*t-s,e+i/2,i/2,s)}}class Qe extends At{_$target;_$delay;_$duration;_$ease;_$from;_$names;_$startTime;_$stopFlag;_$forceStop;_$to;_$currentTime;constructor(t,e=null,i=null,s=0,r=1,n=null){super(),this._$target=t,this._$delay=s,this._$duration=r,this._$ease=n||Ke.linear,this._$from=e,this._$names=null,this._$startTime=0,this._$stopFlag=!1,this._$forceStop=!1,this._$to=i,this._$currentTime=0}static toString(){return"[class Job]"}static get namespace(){return"next2d.ui.Job"}toString(){return"[object Job]"}get namespace(){return"next2d.ui.Job"}get ease(){return this._$ease}set ease(t){"function"==typeof t&&(this._$ease=t)}get delay(){return this._$delay}set delay(t){this._$delay=t}get duration(){return this._$duration}set duration(t){this._$duration=t}get from(){return this._$from}set from(t){this._$from=t}get to(){return this._$to}set to(t){this._$to=t}get target(){return this._$target}initialize(){this._$forceStop||(this._$stopFlag=!1,this._$startTime=u.now(),this._$names=this.entries(this._$from),this.addEventListener($t.ENTER_FRAME,(t=>{this._$update(t)})))}entries(t){const e=Object.entries(t);for(let t=0;t<e.length;++t){const i=e[t],s=i[1];s&&"object"==typeof s&&(i[1]=this.entries(s))}return e}start(){return new Promise((t=>{this.hasEventListener($t.COMPLETE)||this.addEventListener($t.COMPLETE,(e=>{this.removeEventListener($t.COMPLETE,e.listener),t()})),this._$delay?d((()=>{this.initialize()}),1e3*this._$delay):this.initialize()}))}stop(){this.hasEventListener($t.STOP)&&this.dispatchEvent(new $t($t.STOP)),this.hasEventListener($t.ENTER_FRAME)&&this.removeAllEventListener($t.ENTER_FRAME),this.hasEventListener($t.UPDATE)&&this.removeAllEventListener($t.UPDATE),this.hasEventListener($t.COMPLETE)&&this.removeAllEventListener($t.COMPLETE),this._$forceStop=!0,this._$stopFlag=!0}_$update(t){this._$stopFlag||(this._$currentTime=.001*(u.now()-this._$startTime),this._$names&&this._$updateProperty(this._$target,this._$from,this._$to,this._$names),this.hasEventListener($t.UPDATE)&&this.dispatchEvent(new $t($t.UPDATE)),this._$currentTime>=this._$duration&&(this.removeEventListener($t.ENTER_FRAME,t.listener),this.hasEventListener($t.COMPLETE)&&this.dispatchEvent(new $t($t.COMPLETE))))}_$updateProperty(t,e,i,s){for(let r=0;r<s.length;++r){const n=s[r],a=n[0],h=n[1];if(h&&"object"==typeof h){this._$updateProperty(t[a],e[a],i[a],h);continue}const o=e[a];this._$duration>this._$currentTime?t[a]=this._$ease(this._$currentTime,o,i[a]-o,this._$duration):t[a]=i[a]}}}class Je{static toString(){return"[class Tween]"}static get namespace(){return"next2d.ui.Tween"}toString(){return"[object Tween]"}get namespace(){return"next2d.ui.Tween"}static add(t,e,i,s=0,r=1,n=null){return new Qe(t,e,i,s,r,n)}}class Ze extends Ut{_$bounds;_$originBounds;_$textData;_$widthTable;_$heightTable;_$textFormatTable;_$objectTable;_$imageData;_$textHeightTable;_$heightCache;_$background;_$backgroundColor;_$border;_$borderColor;_$htmlText;_$multiline;_$text;_$wordWrap;_$scrollH;_$scrollV;_$maxScrollV;_$maxScrollH;_$maxChars;_$defaultTextFormat;_$rawHtmlText;_$restrict;_$isHTML;_$textHeight;_$textWidth;_$textarea;_$autoSize;_$autoFontSize;_$textAreaActive;_$totalWidth;_$scrollEnabled;_$scrollSprite;_$type;_$focus;_$isComposing;_$thickness;_$thicknessColor;_$verticalAlign;_$createdTextData;constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$htmlText="",this._$multiline=!1,this._$text="",this._$wordWrap=!1,this._$scrollH=0,this._$scrollV=1,this._$maxScrollV=null,this._$maxScrollH=null,this._$maxChars=0;const t=new je;t._$setDefault(),this._$defaultTextFormat=t,this._$rawHtmlText="",this._$bounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$originBounds={xMin:0,xMax:100,yMin:0,yMax:100},this._$restrict="",this._$isHTML=!1,this._$createdTextData=!1,this._$textData=U(),this._$textHeight=null,this._$textWidth=null,this._$widthTable=U(),this._$textarea=null,this._$autoSize="none",this._$autoFontSize=!1,this._$heightTable=U(),this._$textFormatTable=U(),this._$textAreaActive=!1,this._$totalWidth=0,this._$objectTable=U(),this._$imageData=U(),this._$scrollEnabled=!0,this._$scrollSprite=null,this._$type="static",this._$textHeightTable=U(),this._$focus=!1,this._$isComposing=!1,this._$thickness=0,this._$thicknessColor=0,this._$verticalAlign="top",this._$heightCache=Y()}static toString(){return"[class TextField]"}static get namespace(){return"next2d.text.TextField"}toString(){return"[object TextField]"}get namespace(){return"next2d.text.TextField"}get autoFontSize(){return this._$autoFontSize}set autoFontSize(t){t!==this._$autoFontSize&&(this._$autoFontSize=t,this._$reload())}get autoSize(){return this._$autoSize}set autoSize(t){t!==this._$autoSize&&(this._$autoSize=t,this._$reload())}get background(){return this._$background}set background(t){t!==this._$background&&(this._$background=!!t,this._$reset())}get backgroundColor(){return this._$backgroundColor}set backgroundColor(t){(t=W(J(t),0,16777215,16777215))!==this._$backgroundColor&&(this._$backgroundColor=t,this._$reset())}get border(){return this._$border}set border(t){t!==this._$border&&(this._$border=!!t,this._$reset())}get borderColor(){return this._$borderColor}set borderColor(t){(t=W(J(t),0,16777215,0))!==this._$borderColor&&(this._$borderColor=t,this._$reset())}get defaultTextFormat(){return this._$defaultTextFormat._$clone()}set defaultTextFormat(t){t._$merge(this._$defaultTextFormat),this._$defaultTextFormat=t,this._$reset()}get focus(){return this._$focus}set focus(t){if(this._$focus!==t)if(this._$focus=t,this._$focus){if("input"===this._$type){const t=Ui(),e=Xt.getElementById(t.contentElementId);if(!e)return;this._$createTextAreaElement(t._$scale);const s=this._$textarea;if(!s)return;const r=this._$transform.concatenatedMatrix,n=this._$getBounds(null),a=st(J(this._$defaultTextFormat.color),100);s.style.color=`rgb(${a.R},${a.G},${a.B})`,s.style.left=(r.tx+n.xMin+t.x/t._$scale/Yt)*t._$scale+"px",s.style.top=(r.ty+n.yMin+t.y/t._$scale/Yt)*t._$scale+"px",s.style.width=`${i.ceil((this.width-1)*t._$scale)}px`,s.style.height=`${i.ceil((this.height-1)*t._$scale)}px`,s.value=this.text,e.appendChild(s),$((()=>{s.focus()})),this._$doChanged(),yt(),this._$textAreaActive=!0,this.willTrigger(qe.FOCUS_IN)&&this.dispatchEvent(new qe(qe.FOCUS_IN))}}else this._$textarea&&(this._$textarea.dispatchEvent(new Event(`${ri}_blur`)),this.willTrigger(qe.FOCUS_OUT)&&this.dispatchEvent(new qe(qe.FOCUS_OUT)),this._$textarea.remove())}get htmlText(){return this._$htmlText}set htmlText(t){this._$htmlText!==t&&(this._$htmlText=`${t}`,this._$rawHtmlText="",this._$text="",this._$isHTML=!0,this._$textFormatTable.length=0,this._$reload())}get length(){return this.text.length}get maxChars(){return this._$maxChars}set maxChars(t){this._$maxChars=0|t}get maxScrollH(){return null===this._$maxScrollH&&(this._$maxScrollH=0),this._$maxScrollH}get maxScrollV(){if(null===this._$maxScrollV){if(this._$maxScrollV=1,this._$getTextData(),!this._$textHeightTable.length)return this._$maxScrollV;const t=this._$textHeightTable.length,e=this.height;if(e>this.textHeight)return this._$maxScrollV;let i=0,s=0;for(;t>s&&(i+=this._$textHeightTable[s++],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}get multiline(){return this._$multiline}set multiline(t){t!==this._$multiline&&(this._$multiline=!!t,this._$reset())}get numLines(){return this._$createdTextData||this._$getTextData(),this._$objectTable.length}get restrict(){return this._$restrict}set restrict(t){this._$restrict=`${t}`}get scrollEnabled(){return this._$scrollEnabled}set scrollEnabled(t){this._$scrollEnabled=t}get scrollH(){return this._$scrollH}set scrollH(t){t=W(0|t,0,this.maxScrollH),this._$scrollH!==t&&(this._$scrollH=t,this._$reset(),this.willTrigger($t.SCROLL)&&this.dispatchEvent(new $t($t.SCROLL,!0)))}get scrollV(){return this._$scrollV}set scrollV(t){if(t=W(0|t,1,this.maxScrollV),this._$scrollV!==t){if(this._$scrollV=i.max(1,t),this._$reset(),this._$scrollSprite&&this.textHeight>this.height){this._$scrollSprite.height=this.height*this.height/this.textHeight-1;const t=this._$parent;if(t){this._$scrollSprite.alpha=1,this._$scrollSprite.x=this.x+this.width-this._$scrollSprite.width-.5,this._$scrollSprite.y=this.y+.5+(this.height-1-this._$scrollSprite.height)/(this.maxScrollV-1)*(this._$scrollV-1),t.addChildAt(this._$scrollSprite,t.getChildIndex(this)+1),this._$scrollSprite.hasLocalVariable("job")&&this._$scrollSprite.getLocalVariable("job").stop();const e=Je.add(this._$scrollSprite,{alpha:1},{alpha:0},1);e.addEventListener($t.COMPLETE,(t=>{const e=t.target.target;e.deleteLocalVariable("job"),e.parent&&e.parent.removeChild(e)})),e.start(),this._$scrollSprite.setLocalVariable("job",e)}}this.willTrigger($t.SCROLL)&&this.dispatchEvent(new $t($t.SCROLL,!0))}}get text(){if(!this._$isHTML)return this._$text;if(this._$rawHtmlText)return this._$rawHtmlText;let t="";const e=this._$getTextData();for(let i=1;i<e.length;++i){const s=e[i];switch(s.mode){case"text":t+=s.text;break;case"break":t+="\r"}}return this._$rawHtmlText=t,t}set text(t){null===t&&(t=""),(t=`${t}`)!==this._$text&&(this._$text=t,this._$htmlText="",this._$isHTML=!1,this._$textFormatTable.length=0,this._$reload())}get textColor(){return this._$defaultTextFormat.color||0}set textColor(t){this._$defaultTextFormat.color=t,this._$reload()}get textHeight(){if(""===this.text)return 0;if(null===this._$textHeight){this._$textHeight=2,this._$getTextData();const t=this._$textHeightTable.length;1===t&&(this._$textHeight+=this._$defaultTextFormat.leading||0);for(let e=0;e<t;++e)this._$textHeight+=this._$textHeightTable[e]}return this._$textHeight}get textWidth(){if(null===this._$textWidth){this._$textWidth=0,this._$getTextData();for(let t=0;t<this._$widthTable.length;++t)this._$textWidth=i.max(this._$textWidth,this._$widthTable[t])}return this._$textWidth}get thickness(){return this._$thickness}set thickness(t){(t|=0)!==this._$thickness&&(this._$thickness=t,this._$reset())}get thicknessColor(){return this._$thicknessColor}set thicknessColor(t){(t=W(J(t),0,16777215,0))!==this._$thicknessColor&&(this._$thicknessColor=t,this._$reset())}get type(){return this._$type}set type(t){this._$type=t,"static"===t&&(this._$textarea=null)}get verticalAlign(){return this._$verticalAlign}set verticalAlign(t){t!==this._$verticalAlign&&(this._$verticalAlign=t,this._$reset())}get wordWrap(){return this._$wordWrap}set wordWrap(t){this._$wordWrap!==t&&(this._$wordWrap=!!t,this._$reset())}get width(){return super.width}set width(t){if(!_(t=+t)&&t>-1){const e=this._$getBounds(null),s=i.abs(e.xMin);this._$originBounds.xMax=t+s,this._$originBounds.xMin=s,this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin,super.width=t,this._$reload()}}get height(){return super.height}set height(t){if(!_(t=+t)&&t>-1){const e=this._$getBounds(null),s=i.abs(e.yMin);this._$originBounds.yMax=t+s,this._$bounds.yMax=this._$originBounds.yMax,this._$bounds.yMin=this._$originBounds.yMin,super.height=t,this._$reload()}}get x(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[4]+e.xMin}set x(t){const e=this._$getBounds(null);super.x=t-e.xMin}get y(){const t=this._$transform.matrix,e=this._$getBounds(null);return t._$matrix[5]+e.yMin}set y(t){const e=this._$getBounds(null);super.y=t-e.yMin}appendText(t){const e=this.text;this.text=e+`${t}`}getTextFormat(t=-1,e=-1){t|=0,e|=0;const i=this._$getTextData(),s=e>-1?e:i.length;let r=!1,n=new je,a=t>-1?t:0;for(;a<s;++a){if("break"===i[a].mode)continue;const t=i[a].textFormat;r?(n.align=n.align!==t.align?null:t.align,n.blockIndent=n.blockIndent!==t.blockIndent?null:t.blockIndent,n.bold=n.bold!==t.bold?null:t.bold,n.color=n.color!==t.color?null:t.color,n.font=n.font!==t.font?null:t.font,n.indent=n.indent!==t.indent?null:t.indent,n.italic=n.italic!==t.italic?null:t.italic,n.leading=n.leading!==t.leading?null:t.leading,n.leftMargin=n.leftMargin!==t.leftMargin?null:t.leftMargin,n.letterSpacing=n.letterSpacing!==t.letterSpacing?null:t.letterSpacing,n.rightMargin=n.rightMargin!==t.rightMargin?null:t.rightMargin,n.size=n.size!==t.size?null:t.size,n.underline=n.underline!==t.underline?null:t.underline):(r=!0,n=t._$clone())}return n}getLineText(t){if(!this._$text&&!this._$htmlText)return"";t|=0;let e="";const i=this._$getTextData();for(let s=0;s<i.length;s++){const r=i[s];if(r.yIndex>t)break;r.yIndex===t&&"text"===r.mode&&(e+=r.text)}return e}replaceText(t,e,i){if(e|=0,(t|=0)>-1&&e>-1&&e>=t){const s=this.text;t>=s.length?e>=s.length&&e>=t&&(this.text=s+`${i}`):this.text=s.slice(0,t)+`${i}`+s.slice(e,s.length)}}setTextFormat(t,e=-1,i=-1){e|=0,i|=0;const s=this._$getTextData();switch(this._$reset(),!0){case-1===e&&-1===i:for(let e=0;e<s.length;++e)this._$textFormatTable[e]=t._$clone();break;case e>-1&&-1===i:{let i=e+1,r=s[i];"wrap"===r.mode&&(r=s[++i]),this._$textFormatTable[i]=t._$clone()}break;case e>-1&&i>-1&&i>e:{let r=0;for(let n=e;n<i;++n){const e=s[n];e&&("wrap"!==e.mode&&"break"!==e.mode?this._$textFormatTable[n+r]=t._$clone():(++i,--r))}}}this._$getTextData(),this._$resize()}_$getTextData(){if(!this._$createdTextData){this._$createdTextData=!0,this._$textData.length=0,this._$imageData.length=0,this._$heightTable.length=0,this._$textHeightTable.length=0,this._$objectTable.length=0,this._$widthTable.length=0,this._$heightCache.clear();let t=-1;if(this._$isHTML){let e=this._$htmlText;const i=e.search(/(< .*>|<>)/g);i>-1&&(e=e.slice(0,i)),e=e.replace(/\r\n/g,"\r\r"),gi.innerHTML!==e&&(gi.textContent="",gi.insertAdjacentHTML("afterbegin",e));let s=this._$defaultTextFormat;if(this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}this._$totalWidth=0,this._$heightTable[0]=0,this._$textHeightTable[0]=this._$getTextHeight(s),this._$widthTable[0]=0;const r={mode:"break",x:0,yIndex:0,textFormat:s._$clone()};this._$objectTable[0]=r,this._$textData[0]=r,this._$parseTag(gi,s._$clone(),t)}else{const e=this._$multiline?this._$text.split("\n"):[this._$text.replace("\n","")];for(let i=0;i<e.length;++i){this._$totalWidth=0;let s=this.defaultTextFormat;const r=this._$wordWrap||this._$multiline?this._$heightTable.length:0;if(this._$heightTable[r]=0,this._$textHeightTable[r]=this._$getTextHeight(s),this._$widthTable[r]=0,r&&(this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(s),s=t}const n={mode:"break",x:0,yIndex:r,textFormat:s._$clone()};s=this.defaultTextFormat,this._$objectTable[r]=n,this._$textData[this._$textData.length]=n;const a=e[i];a&&(t=this._$parseText(a,s,t))}}this._$heightCache.clear()}return this._$textData}_$parseTag(t,e,s){const r=t.childNodes,n=r.length;for(let t=0;t<n;++t){let n=e._$clone();const a=r[t];if(3!==a.nodeType)switch(a.nodeName){case"P":{if(a.hasAttribute("align")){const t=a.getAttribute("align");"center"!==t&&"left"!==t&&"right"!==t||(n.align=t,1===this._$textData.length&&(this._$textData[0].textFormat.align=n.align))}if(this._$parseTag(a,n,s),!this._$multiline)break;this._$totalWidth=this._$getImageOffsetX();const t=this._$heightTable.length;if(this._$heightTable[t]=0,this._$textHeightTable[t]=0,this._$widthTable[t]=0,t&&(this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1]),this._$textData.length in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length]._$clone();t._$merge(n),n=t}const e={mode:"break",x:0,yIndex:t,textFormat:n};this._$objectTable[t]=e,this._$textData.push(e)}break;case"B":n.bold=!0,this._$parseTag(a,n,s);break;case"I":n.italic=!0,this._$parseTag(a,n,s);break;case"U":n.underline=!0,this._$parseTag(a,n,s);break;case"FONT":if(a.hasAttribute("face")&&(n.font=a.getAttribute("face")),a.hasAttribute("size")){const t=a.getAttribute("size");t&&(n.size=+t)}if(a.hasAttribute("color")&&(n.color=J(a.getAttribute("color"))),a.hasAttribute("letterSpacing")){const t=a.getAttribute("size");t&&(n.letterSpacing=+t)}this._$parseTag(a,n,s);break;case"BR":{if(!this._$multiline)break;const t=this._$heightTable.length;this._$heightTable[t]=this._$heightTable[t-1],this._$textHeightTable[t]=this._$textHeightTable[t-1],this._$widthTable[t]=0,this._$totalWidth=this._$getImageOffsetX(),n.indent=0;const e={mode:"break",x:0,yIndex:t,textFormat:n};this._$objectTable[t]=e,this._$textData[this._$textData.length]=e}break;case"IMG":{if(!a.hasAttribute("src"))break;const t=a.getAttribute("src");if(!t)break;let e=0;if(a.hasAttribute("width")){const t=a.getAttribute("width");t&&(e=+t)}let s=0;if(a.hasAttribute("height")){const t=a.getAttribute("height");t&&(s=+t)}let r=8;if(a.hasAttribute("vspace")){const t=a.getAttribute("vspace");t&&(r=+t)}let h=8;if(a.hasAttribute("hspace")){const t=a.getAttribute("hspace");t&&(h=+t)}let o=0;for(let t=0;t<this._$textHeightTable.length;t++)o+=this._$textHeightTable[t];const l=new Image,_={mode:"image",image:l,src:t,loaded:!1,x:0,y:o,width:e,height:s,hspace:h,vspace:r,textFormat:n._$clone()};if(l.crossOrigin="anonymous",l.addEventListener("load",(()=>{_.width||(_.width=l.width),_.height||(_.height=l.height),_.loaded=!0,this._$reload()})),l.src=t,this._$imageData.length>0){const t=this._$imageData[this._$imageData.length-1],e=t.y+t.height+2*t.vspace;_.y=i.max(o,e)}this._$textData[this._$textData.length]=_,this._$imageData[this._$imageData.length]=_}break;default:this._$parseTag(a,n,s)}else s=this._$parseText(a.nodeValue||"",n,s)}}_$parseText(t,e,s){let r=this._$heightTable.length-1,n=e._$clone();const a=this._$transform.concatenatedMatrix._$matrix,h=(this._$originBounds.xMax-this._$originBounds.xMin)*(a[0]/a[3]);O(a);const o=h-n._$widthMargin()-4;for(let a=0;a<t.length;++a){if(n=e._$clone(),this._$textData.length+s in this._$textFormatTable){const t=this._$textFormatTable[this._$textData.length+s]._$clone();t._$merge(n),n=t}const h={mode:"text",text:t[a],x:0,width:0,height:0,yIndex:r,textFormat:n};let l=!1;this._$multiline&&(l="\n"===h.text||"\r"===h.text||"\n\r"===h.text);const _=r&&n.leading||0;let $,c=0,u=0,d=0;if(Oi){if(Oi.font=n._$generateFontStyle(),c=Oi.measureText(h.text||"").width,c+=n.letterSpacing||0,u=this._$getTextHeight(n),d=u+_,h.height=u,l||this._$wordWrap&&this._$totalWidth+c>o){this._$widthTable[++r]=0,h.yIndex=r,this._$heightTable[r]=this._$heightTable[r-1],this._$textHeightTable[r]=this._$textHeightTable[r-1],this._$totalWidth=this._$getImageOffsetX(),n=n._$clone(),n.indent=0,$={mode:l?"break":"wrap",x:0,yIndex:r,textFormat:n},this._$objectTable[r]=$,l||--s;let t=h.text||"",e=0,a=!0;const o=/[0-9a-zA-Z?!;:.,]/g;for(;t.match(o);){++e;const i=this._$textData[this._$textData.length-e];if("text"!==i.mode){a=!1;break}t=i.text||""}if(e>1&&this._$textData&&(this._$textData[this._$textData.length-e+1].text||"").match(/[0-9a-zA-Z]/g)&&--e,e>0&&a){const t=this._$textData.length-e;this._$textData.splice(t,0,$);let s=1,n=this._$textData[t-s];for(this._$widthTable[r-1]=0,this._$heightTable[r-1]=0,this._$textHeightTable[r-1]=0;"text"===n.mode;)u=this._$getTextHeight(n.textFormat),d=u+_,this._$widthTable[r-1]+=n.width||0,this._$heightTable[r-1]=i.max(this._$heightTable[r-1],u),this._$textHeightTable[r-1]=i.max(this._$textHeightTable[r-1],d),++s,n=this._$textData[t-s];for(s=1;this._$textData.length>t+s;)n=this._$textData[t+s],++s,u=this._$getTextHeight(n.textFormat),d=u+_,this._$heightTable[r]=i.max(this._$heightTable[r],u),this._$textHeightTable[r]=i.max(this._$textHeightTable[r],d),n.x=this._$totalWidth,n.yIndex=r,this._$totalWidth+=n.width||0}else this._$textData[this._$textData.length]=$}l||(h.width=c,h.x=this._$totalWidth,this._$totalWidth+=c,this._$widthTable&&(this._$widthTable[r]=i.max(this._$widthTable[r],this._$totalWidth)),this._$heightTable[r]=i.max(this._$heightTable[r],u),this._$textHeightTable[r]=i.max(this._$textHeightTable[r],d),this._$textData[this._$textData.length]=h)}}return s}_$getTextHeight(t){const e=t.size||0,i=t.font||"",s=t.bold?"bold":"normal",r=`${e}_${i}_${s}`;if(this._$heightCache.has(r))return this._$heightCache.get(r)||0;const n=pi.style,a=`${e}px`;n.fontSize!==a&&(n.fontSize=a),n.fontFamily!==i&&(n.fontFamily=i),n.fontWeight!==s&&(n.fontWeight=s);const h=10>e?pi.clientHeight*e*.1:pi.clientHeight;return this._$heightCache.set(r,h),h}_$getImageOffsetX(){if(!this._$imageData.length)return 0;let t=0;for(let e=0;e<this._$textHeightTable.length;++e)t+=this._$textHeightTable[e];if(this._$imageData)for(let e=0;e<this._$imageData.length;++e){const i=this._$imageData[e],s=i.height+2*i.vspace;if(i.y<=t&&t<i.y+s)return i.width+2*i.hspace}return 0}_$reset(){this._$createdTextData=!1,this._$textData.length=0,this._$imageData.length=0,this._$heightTable.length=0,this._$textHeightTable.length=0,this._$widthTable.length=0,this._$objectTable.length=0,this._$textHeight=null,this._$textWidth=null,this._$totalWidth=0,this._$maxScrollH=null,this._$maxScrollV=null,this._$doChanged(),yt(),Ui().cacheStore.removeCache(this._$instanceId)}_$reload(){if(this._$reset(),this._$getTextData(),"none"===this._$autoSize&&this._$autoFontSize){let t=this._$defaultTextFormat.size||0;const e=t;if(this.width&&this.textWidth&&this.textWidth>this.width)for(;this.textWidth>this.width;){if(this._$defaultTextFormat.size=t--,1>t){this._$defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}if(this.height&&this.textHeight&&this.textHeight>this.height)for(;this.textHeight>this.height;){if(this._$defaultTextFormat.size=t--,1>t){this._$defaultTextFormat.size=1;break}this._$reset(),this._$getTextData()}this._$defaultTextFormat.size=e}this._$resize()}_$resize(){if("none"!==this._$autoSize){const t=this._$defaultTextFormat,e=this.textWidth+4+t._$widthMargin();if(this._$wordWrap)this._$bounds.xMax=this._$originBounds.xMax,this._$bounds.xMin=this._$originBounds.xMin;else switch(this._$autoSize){case"left":case"center":this._$bounds.xMax=e+this._$bounds.xMin;break;case"right":this._$bounds.xMax=this._$originBounds.xMax-(this._$originBounds.xMax-this._$originBounds.xMin-(e-this._$originBounds.xMin))}this._$bounds.yMax=this.textHeight+4+this._$originBounds.yMin}else this._$scrollEnabled&&!this._$scrollSprite&&(this._$scrollSprite=new Ge,this._$scrollSprite.graphics.beginFill("#000",.3).drawRoundRect(0,0,3,3,3),this._$scrollSprite.scale9Grid=new wt(1.5,1.5,.1,.1))}_$getAlignOffset(t,e){const s=this._$widthTable[t.yIndex],r=t.textFormat;let n=0;n+=r.blockIndent||0,n+=r.leftMargin||0;const a=r.rightMargin||0;switch(!0){case!this._$wordWrap&&s>e:return i.max(0,n);case"center"===r.align:case"center"===this._$autoSize:return i.max(0,e/2-n-a-s/2);case"right"===r.align:case"right"===this._$autoSize:return i.max(0,e-n-s-a-2);default:return i.max(0,n+2)}}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();return 1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=j(t,i)),K(this._$bounds,e)}return B(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}_$buildCharacter(t){const e=this._$defaultTextFormat;switch(e.font=t.font,e.size=0|t.size,e.align=t.align,e.color=0|t.color,e.leading=t.leading,e.letterSpacing=t.letterSpacing,e.leftMargin=t.leftMargin,e.rightMargin=t.rightMargin,t.fontType){case 1:e.bold=!0;break;case 2:e.italic=!0;break;case 3:e.bold=!0,e.italic=!0}switch(this._$type=t.inputType,this._$multiline=!!t.multiline,this._$wordWrap=!!t.wordWrap,this._$border=!!t.border,this._$scrollEnabled=!!t.scroll,this._$thickness=0|t.thickness,this._$thicknessColor=0|t.thicknessColor,this._$bounds.xMin=t.originBounds.xMin,this._$bounds.xMax=t.originBounds.xMax,this._$bounds.yMin=t.originBounds.yMin,this._$bounds.yMax=t.originBounds.yMax,this._$originBounds.xMin=t.originBounds.xMin,this._$originBounds.xMax=t.originBounds.xMax,this._$originBounds.yMin=t.originBounds.yMin,this._$originBounds.yMax=t.originBounds.yMax,t.autoSize){case 1:this.autoSize=t.align;break;case 2:this.autoFontSize=!0}this.text=t.text,Zi&&this._$stage&&this._$createWorkerInstance()}_$sync(t){this._$buildCharacter(t)}_$build(t,e){const i=this._$baseBuild(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const s=this._$getBounds(),r=s.xMax,n=s.xMin,a=s.yMax,h=s.yMin;R(s);const o=i.ceil(i.abs(r-n)),l=i.ceil(i.abs(a-h));if(!o||!l)return;let _=e;const $=this._$transform._$rawMatrix();1===$[0]&&0===$[1]&&0===$[2]&&1===$[3]&&0===$[4]&&0===$[5]||(_=j(e,$)),t.reset(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(o,0),t.lineTo(o,l),t.lineTo(0,l),t.lineTo(0,0),t.clip(),_!==e&&O(_)}_$draw(t,s,r){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&!this.text)return;let a=r;const h=this._$transform._$rawColorTransform();1===h[0]&&1===h[1]&&1===h[2]&&1===h[3]&&0===h[4]&&0===h[5]&&0===h[6]&&0===h[7]||(a=q(r,h));const o=W(a[3]+a[7]/255,0,1);if(!o)return;let l=s;const _=this._$transform._$rawMatrix();1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||(l=j(s,_));const $=this._$getBounds(null);$.xMin-=this._$thickness,$.xMax+=this._$thickness,$.yMin-=this._$thickness,$.yMax+=this._$thickness;const c=K($,l),u=+c.xMax,d=+c.xMin,g=+c.yMax,f=+c.yMin;R(c);const p=i.ceil(i.abs(u-d)),m=i.ceil(i.abs(g-f));switch(!0){case 0===p:case 0===m:case p===-1/0:case m===-1/0:case p===e:case m===e:return}if(0>d+p||0>f+m)return;const x=t.frameBuffer,b=x.currentAttachment;if(!b||d>b.width||f>b.height)return;let v=+i.sqrt(l[0]*l[0]+l[1]*l[1]);if(!n.isInteger(v)){const t=v.toString(),e=t.indexOf("e");-1!==e&&(v=+t.slice(0,e)),v=+v.toFixed(4)}let T=+i.sqrt(l[2]*l[2]+l[3]*l[3]);if(!n.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}const y=this._$filters||this.filters;if(0>d+p||0>f+m){if(!y.length||!this._$canApply(y))return;{let t=new wt(0,0,p,m);for(let e=0;e<y.length;++e)t=y[e]._$generateFilterRect(t,v,T);if(0>t.x+t.width||0>t.y+t.height)return}}const E=this._$blendMode||this.blendMode,M=U(v,T),A=this._$instanceId,w=Ui().cacheStore,C=w.generateKeys(A,M);let S=w.get(C);if(this._$isUpdated()&&(w.removeCache(A),S=null),!S){const t=i.min(1,i.max(v,T)),e=i.ceil(i.abs($.xMax-$.xMin)*v),r=i.ceil(i.abs($.yMax-$.yMin)*T);a[3]=1;const n=w.getCanvas();n.width=e+2*t,n.height=r+2*t;const h=n.getContext("2d");if(!h)throw new Error("the context is null.");if(this._$background||this._$border){if(h.beginPath(),h.moveTo(0,0),h.lineTo(e,0),h.lineTo(e,r),h.lineTo(0,r),h.lineTo(0,0),this._$background){const t=st(this._$backgroundColor),e=i.max(0,i.min(255*t.A*a[3]+a[7],255))/255;h.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,h.fill()}if(this._$border){const e=st(this._$borderColor),s=i.max(0,i.min(255*e.A*a[3]+a[7],255))/255;h.lineWidth=t,h.strokeStyle=`rgba(${e.R},${e.G},${e.B},${s})`,h.stroke()}}h.save(),h.beginPath(),h.moveTo(2,2),h.lineTo(e-2,2),h.lineTo(e-2,r-2),h.lineTo(2,r-2),h.lineTo(2,2),h.clip(),h.beginPath(),h.setTransform(v,0,0,T,0,0),this._$doDraw(h,s,a,e/v),h.restore(),S=x.createTextureFromCanvas(h.canvas),w.set(C,S),w.destroy(h)}let F=!1,B=0,I=0;y&&y.length&&this._$canApply(y)&&(F=!0,S=this._$drawFilter(t,S,l,y,p,m),B=S._$offsetX,I=S._$offsetY);const L=i.atan2(l[1],l[0]),P=i.atan2(-l[2],l[3]);if(F||!L&&!P)t.setTransform(1,0,0,1,d-B,f-I);else{const e=$.xMin*v,s=$.yMin*T,r=i.cos(L),n=i.sin(L),a=i.cos(P),h=i.sin(P);t.setTransform(r,n,-h,a,e*r-s*h+l[4],e*n+s*a+l[5])}t.reset(),t.globalAlpha=o,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=E,t.drawImage(S,0,0,S.width,S.height,a),G(C),R($),l!==s&&O(l),a!==r&&N(a)}_$doDraw(t,e,s,r){const n=this._$getTextData(),a=this.width,h=this.height;let o=0,l=0,_=0,$=0;if("top"!==this._$verticalAlign&&this.height>this.textHeight)switch(this._$verticalAlign){case"middle":$=(this.height-this.textHeight+2)/2;break;case"bottom":$=this.height-this.textHeight+2}for(let c=0;c<n.length;++c){const u=n[c];if(0===u.width)continue;const d=o+u.x;if("none"===this._$autoSize&&(l>h||d>a))continue;const g=u.textFormat,f=st(g.color||0),p=i.max(0,i.min(255*f.A*s[3]+s[7],255))/255;if(t.fillStyle=`rgba(${f.R},${f.G},${f.B},${p})`,this._$thickness){const e=st(this._$thicknessColor),r=i.max(0,i.min(255*e.A*s[3]+s[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${r})`}const m=0|u.yIndex;switch(u.mode){case"break":case"wrap":if(_++,this.scrollV>_)continue;if(l+=this._$textHeightTable[m],o=this._$getAlignOffset(this._$objectTable[m],r),g.underline){const r=g.size?g.size/12:0,n=st(g.color||0),a=i.max(0,i.min(255*n.A*s[3]+s[7],255))/255;t.lineWidth=i.max(1,1/i.min(e[0],e[3])),t.strokeStyle=`rgba(${n.R},${n.G},${n.B},${a})`,t.beginPath(),t.moveTo(o,$+l-r),t.lineTo(o+this._$widthTable[m],$+l-r),t.stroke()}break;case"text":{if(this.scrollV>_)continue;let e=l-this._$heightTable[0];!Fi&&g.size&&(e+=Yt*(g.size/12)),t.beginPath(),t.textBaseline="top",t.font=rt(g.font||"",g.size||0,!!g.italic,!!g.bold),this._$thickness&&t.strokeText(u.text,d,$+e),t.fillText(u.text,d,$+e)}break;case"image":if(!u.loaded)continue;t.beginPath(),t.drawImage(u.image,u.hspace,$+u.y,u.width,u.height)}}}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,s){let r=e;const n=this._$transform._$rawMatrix();1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(r=j(e,n));const a=this._$getBounds(null),h=K(a,r),o=+h.xMax,l=+h.xMin,_=+h.yMax,$=+h.yMin;R(h),R(a);const c=i.ceil(i.abs(o-l)),u=i.ceil(i.abs(_-$));return t.setTransform(1,0,0,1,l,$),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,u),t.lineTo(0,u),t.lineTo(0,0),r!==e&&O(r),t.isPointInPath(s.x,s.y)}_$createTextAreaElement(t){if(!this._$textarea){this._$textarea=Xt.createElement("textarea"),this._$textarea.value=this.text,this._$textarea.id=`${ri}_TextField_${this._$instanceId}`,this._$wordWrap||(this._$textarea.wrap="off");const t=this._$defaultTextFormat;let e="";e+="position: absolute;",e+="outline: 0;",e+=`padding: 2px 2px 2px ${i.max(3,t.leftMargin||0)}px;`,e+="margin: 0;",e+="appearance: none;",e+="resize: none;",e+="overflow: hidden;",e+="z-index: 2147483647;",e+="vertical-align: top;",this._$textarea.setAttribute("style",e),this._$textarea.addEventListener(`${ri}_blur`,(t=>{let e=t.target.value;if(e&&this._$restrict){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const i=e.match(new zt(t,"gm"));e=i?i.join(""):""}const i=Ui();if(Xt.getElementById(i.contentElementId)){const t=Xt.getElementById(`${ri}_TextField_${this._$instanceId}`);t&&t.remove()}this.text=e,this._$focus=!1,this._$textAreaActive=!1,this._$doChanged(),yt()})),this._$textarea.addEventListener("input",(t=>{const e=t.target,s=Ui();let r=e.value;if(this._$restrict&&!this._$isComposing&&r){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const e=r.match(new zt(t,"gm"));r=e?e.join(""):""}if(!this._$isComposing&&this.text!==r){this.text=r,e.value=r,this.willTrigger($t.CHANGE)&&this.dispatchEvent(new $t($t.CHANGE,!0));const t=this._$transform.concatenatedMatrix,n=this._$getBounds(null);e.style.left=`${i.floor((t.tx+n.xMin+s.x/s._$scale/Yt)*s._$scale)}px`,e.style.top=`${i.floor((t.ty+n.yMin+s.y/s._$scale/Yt)*s._$scale)}px`,e.style.width=`${i.ceil((this.width-1)*s._$scale)}px`,e.style.height=`${i.ceil((this.height-1)*s._$scale)}px`}})),this._$textarea.addEventListener("compositionstart",(()=>{this._$isComposing=!0})),this._$textarea.addEventListener("compositionend",(t=>{this._$isComposing=!1;const e=t.target;let i=e.value;if(!this._$restrict||!i)return;let s=this._$restrict;"["!==s[0]&&(s="["+s),"]"!==s[s.length-1]&&(s+="]");const r=i.match(new zt(s,"gm"));i=r?r.join(""):"",this.text=i,e.value=i})),this._$textarea.addEventListener("click",(()=>{this.willTrigger(jt.CLICK)&&this.dispatchEvent(new jt(jt.CLICK))})),this._$textarea.addEventListener($i,(t=>{this.scrollV+=t.deltaY})),this._$textarea.addEventListener(di,(t=>{const e=t.target;this.scrollV=e.scrollTop/(e.scrollHeight-e.clientHeight)*this.maxScrollV+1})),this._$textarea.addEventListener(ni,(()=>{Ui()._$state="down"})),this._$textarea.addEventListener(hi,(()=>{Ui()._$state="up"})),this._$textarea.addEventListener(oi,(()=>{Ui()._$state="down"})),this._$textarea.addEventListener(_i,(()=>{Ui()._$state="up"}))}const e=this._$defaultTextFormat,s=e.size?i.ceil(e.size*t*this._$transform.concatenatedMatrix.d):0;this._$textarea.style.fontSize=`${s}px`,this._$textarea.style.fontFamily=e.font||"Times New Roman",this._$textarea.style.lineHeight=(s+i.max(0,e.leading||0))/s+"em","none"!==this._$autoSize?this._$textarea.style.textAlign="center":this._$textarea.style.textAlign=e.align||"none",this._$textarea.addEventListener("keydown",(t=>{const e=t.target;let i=e.value;if(this._$restrict&&!this._$isComposing&&i){let t=this._$restrict;"["!==t[0]&&(t="["+t),"]"!==t[t.length-1]&&(t+="]");const e=i.match(new zt(t,"gm"));i=e?e.join(""):""}if(this._$isComposing||(this.text=i,e.value=i),"Enter"===t.code&&!this._$multiline)return!1}));const r=this._$textarea.style;this._$border?r.border=`solid 1px #${this.borderColor.toString(16)}`:r.border="none",this._$border||this._$background?r.backgroundColor=`#${this.backgroundColor.toString(16)}`:r.backgroundColor="transparent",this._$textarea.maxLength=this._$maxChars?this._$maxChars:2147483647}_$createWorkerInstance(){if(this._$created||!Zi)return;this._$created=!0;const t=this._$getBounds(),e={command:"createTextField",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,xMin:t.xMin,yMin:t.yMin,xMax:t.xMax,yMax:t.yMax,textData:this._$getTextData(),scrollV:this.scrollV,widthTable:this._$widthTable,heightTable:this._$heightTable,textHeightTable:this._$textHeightTable,objectTable:this._$objectTable,limitWidth:this.width,limitHeight:this.height,textHeight:this.textHeight,verticalAlign:this._$verticalAlign,autoSize:this._$autoSize,wordWrap:this._$wordWrap,border:this._$border,background:this._$background,thickness:this._$thickness};this._$border&&(e.borderColor=this._$borderColor),this._$background&&(e.backgroundColor=this._$backgroundColor),this._$thickness&&(e.thicknessColor=this._$backgroundColor),this._$characterId>-1&&(e.characterId=this._$characterId),this._$loaderInfo&&(e.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(e.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),Zi.postMessage(e)}_$postProperty(){if(!Zi)return;const t=this._$createMessage();t.textAreaActive=this._$textAreaActive;const e=this._$getBounds(null);t.xMin=e.xMin,t.yMin=e.yMin,t.xMax=e.xMax,t.yMax=e.yMax,R(e),this._$isUpdated()&&(t.textData=this._$getTextData(),t.scrollV=this.scrollV,t.widthTable=this._$widthTable,t.heightTable=this._$heightTable,t.textHeightTable=this._$textHeightTable,t.objectTable=this._$objectTable,t.limitWidth=this.width,t.limitHeight=this.height,t.textHeight=this.textHeight,t.verticalAlign=this._$verticalAlign,t.autoSize=this._$autoSize,t.wordWrap=this._$wordWrap,t.border=this._$border,this._$border&&(t.borderColor=this._$borderColor),t.background=this._$background,this._$background&&(t.backgroundColor=this._$backgroundColor),t.thickness=this._$thickness,this._$thickness&&(t.thicknessColor=this._$backgroundColor)),Zi.postMessage(t),this._$posted=!0,this._$updated=!1}}class ti extends $t{_$bytesLoaded;_$bytesTotal;constructor(t,e=!1,i=!1,s=0,r=0){super(t,e,i),this._$bytesLoaded=0|s,this._$bytesTotal=0|r}static toString(){return"[class VideoEvent]"}static get namespace(){return"next2d.events.VideoEvent"}toString(){return this.formatToString("VideoEvent","type","bubbles","cancelable","eventPhase","bytesLoaded","bytesTotal")}get namespace(){return"next2d.events.VideoEvent"}static get PROGRESS(){return"progress"}static get PLAY(){return"play"}static get PLAY_START(){return"playStart"}static get PLAY_END(){return"playEnd"}static get PAUSE(){return"pause"}static get SEEK(){return"seek"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}}class ei extends Dt{_$smoothing;_$loop;_$autoPlay;_$bounds;_$bytesLoaded;_$bytesTotal;_$timerId;_$video;_$stop;_$volume;_$ready;_$context;constructor(t=0,e=0){super(),this._$smoothing=!0,this._$loop=!1,this._$autoPlay=!0,this._$bounds=B(0,t,0,e),this._$bytesLoaded=0,this._$bytesTotal=0,this._$timerId=-1,this._$video=null,this._$stop=!0,this._$ready=!1,this._$volume=1,this._$context=null}static toString(){return"[class Video]"}static get namespace(){return"next2d.media.Video"}toString(){return"[object Video]"}get namespace(){return"next2d.media.Video"}get bytesLoaded(){return this._$bytesLoaded}get bytesTotal(){return this._$bytesTotal}get currentTime(){return this._$video?this._$video.currentTime:0}get duration(){return this._$video?this._$video.duration:0}get loop(){return this._$loop}set loop(t){this._$loop=!!t}get autoPlay(){return this._$autoPlay}set autoPlay(t){this._$autoPlay=!!t}get smoothing(){return this._$smoothing}set smoothing(t){this._$smoothing=!!t}get src(){return this._$video?this._$video.src:""}set src(t){this._$video||(this._$video=this._$initializeVideo()),this._$video.src=t,this._$video.load()}get videoHeight(){return this._$video?this._$video.videoHeight:this._$bounds.yMax}get videoWidth(){return this._$video?this._$video.videoWidth:this._$bounds.xMax}get volume(){return this._$volume}set volume(t){this._$volume=W(i.min(Pe.volume,t),0,1,1),this._$video&&(this._$video.volume=this._$volume)}clear(){this._$video&&this._$video.pause(),this._$video=null,this._$bounds.xMax=0,this._$bounds.yMax=0,this._$doChanged()}pause(){if(this._$video&&!this._$stop){this._$stop=!0,this._$video.pause(),c(this._$timerId),this._$timerId=-1,this.hasEventListener(ti.PAUSE)&&this.dispatchEvent(new ti(ti.PAUSE,!1,!1,this._$bytesLoaded,this._$bytesTotal));const t=Ui();t._$videos.splice(t._$videos.indexOf(this),1)}}play(){this._$video&&this._$stop&&(this._$stop=!1,this._$video.volume=i.min(this._$volume,Pe.volume),this._$video.play().then((()=>{this._$timerId=$((()=>{this._$update()})),this.hasEventListener(ti.PLAY)&&this.dispatchEvent(new ti(ti.PLAY,!1,!1,this._$bytesLoaded,this._$bytesTotal));const t=Ui();-1===t._$videos.indexOf(this)&&t._$videos.push(this),this._$ready=!0})))}seek(t){this._$video&&(this._$video.currentTime=t,this.hasEventListener(ti.SEEK)&&this.dispatchEvent(new ti(ti.SEEK,!1,!1,this._$bytesLoaded,this._$bytesTotal)))}_$update(){const t=Ui();if(!this.stage||!this._$video)return this._$video&&this._$video.pause(),c(this._$timerId),this._$timerId=-1,void t._$videos.splice(t._$videos.indexOf(this),1);Zi&&this._$postProperty(),this._$bytesLoaded=this._$video.currentTime,this._$video.currentTime&&(this.hasEventListener(ti.PROGRESS)&&this.dispatchEvent(new ti(ti.PROGRESS,!1,!1,this._$bytesLoaded,this._$bytesTotal)),this._$doChanged()),this._$timerId=$((()=>{this._$update()}))}_$start(){if(!this._$video)return;this._$bounds.xMax=this._$video.videoWidth,this._$bounds.yMax=this._$video.videoHeight,this._$bytesTotal=this._$video.duration;const t=Ui();this._$autoPlay&&(this._$stop=!1,this._$video.play().then((()=>{-1===t._$videos.indexOf(this)&&t._$videos.push(this),this.hasEventListener(ti.PLAY_START)&&this.dispatchEvent(new ti(ti.PLAY_START,!1,!1,this._$bytesLoaded,this._$bytesTotal)),this._$timerId=$((()=>{this._$update()})),this._$ready=!0,this._$doChanged()}))),this._$createContext()}_$initializeVideo(){const t=Xt.createElement("video");return t.autoplay=!1,t.crossOrigin="anonymous",mi||(t.muted=!0),Li&&t.setAttribute("playsinline",""),t.addEventListener("canplaythrough",(()=>{this._$start()})),t.addEventListener("ended",(()=>{this._$loop?t.currentTime=0:(this.hasEventListener(ti.PLAY_END)&&this.dispatchEvent(new ti(ti.PLAY_END,!1,!1,this._$bytesLoaded,this._$bytesTotal)),c(this._$timerId),this._$timerId=-1)})),t}_$createContext(){if(Zi){const t=new l(this._$bounds.xMax,this._$bounds.yMax);this._$context=t.getContext("2d")}}_$buildCharacter(t){t.buffer&&!t._$buffer&&(t._$buffer=new Uint8Array(t.buffer),t.buffer=null),this._$loop=t.loop,this._$autoPlay=t.autoPlay,this._$bounds.xMin=t.bounds.xMin,this._$bounds.yMin=t.bounds.yMin,this._$bounds.xMax=t.bounds.xMax,this._$bounds.yMax=t.bounds.yMax,this._$video||(this._$video=this._$initializeVideo()),this._$video.src=URL.createObjectURL(new Blob([t._$buffer],{type:"video/mp4"})),this._$video.volume=i.min(t.volume,Pe.volume),this._$video.load(),Zi&&this._$stage&&this._$createWorkerInstance()}_$sync(t){this._$buildCharacter(t)}_$build(t,e){const i=this._$baseBuild(t,e);return this._$buildCharacter(i),i}_$clip(t,e){const i=this._$bounds.xMax,s=this._$bounds.yMax;if(!i||!s)return;let r=e;const n=this._$transform._$rawMatrix();1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(r=j(e,n)),t.reset(),t.setTransform(r[0],r[1],r[2],r[3],r[4],r[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(),r!==e&&O(r)}_$draw(t,s,r){if(!this._$visible||!this._$video||!this._$ready)return;let n=r;const a=this._$transform._$rawColorTransform();1===a[0]&&1===a[1]&&1===a[2]&&1===a[3]&&0===a[4]&&0===a[5]&&0===a[6]&&0===a[7]||(n=q(r,a));const h=W(n[3]+n[7]/255,0,1,0);if(!h)return void(n!==r&&N(n));let o=s;const l=this._$transform._$rawMatrix();1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(o=j(s,l));const _=K(this._$bounds,o),$=+_.xMax,c=+_.xMin,u=+_.yMax,d=+_.yMin;R(_);const g=i.ceil(i.abs($-c)),f=i.ceil(i.abs(u-d));switch(!0){case 0===g:case 0===f:case g===-1/0:case f===-1/0:case g===e:case f===e:return}const p=t.frameBuffer,m=p.currentAttachment;if(!m||c>m.width||d>m.height)return;const x=this._$filters||this.filters;if(0>c+g||0>d+f){if(!(x&&x.length&&this._$canApply(x)))return;{const t=+i.sqrt(o[0]*o[0]+o[1]*o[1]),e=+i.sqrt(o[2]*o[2]+o[3]*o[3]);let s=new wt(0,0,g,f);for(let i=0;i<x.length;++i)s=x[i]._$generateFilterRect(s,t,e);if(0>s.x+s.width||0>s.y+s.height)return}}const b=this._$blendMode||this.blendMode;let v=p.createTextureFromVideo(this._$video,this._$smoothing);if(x&&x.length&&this._$canApply(x)){const e=+i.sqrt(o[0]*o[0]+o[1]*o[1]),s=+i.sqrt(o[2]*o[2]+o[3]*o[3]);if(1!==e||1!==s){const i=p.currentAttachment,r=p.createCacheAttachment(g,f,!1);t._$bind(r);const n=P(e,0,0,s,g/2,f/2),a=P(1,0,0,1,-v.width/2,-v.height/2),h=j(n,a);O(n),O(a),t.reset(),t.setTransform(h[0],h[1],h[2],h[3],h[4],h[5]),t.drawImage(v,0,0,v.width,v.height),p.releaseTexture(v),O(h),v=p.getTextureFromCurrentAttachment(),p.releaseAttachment(r,!1),t._$bind(i)}v=this._$drawFilter(t,v,o,x,g,f),t.reset(),t.globalAlpha=h,t.imageSmoothingEnabled=this._$smoothing,t.globalCompositeOperation=b;const r=K(this._$bounds,o);t.setTransform(1,0,0,1,r.xMin-v._$offsetX,r.yMin-v._$offsetY),t.drawImage(v,0,0,v.width,v.height,n),R(r)}else t.reset(),t.setTransform(o[0],o[1],o[2],o[3],o[4],o[5]),t.globalAlpha=h,t.imageSmoothingEnabled=this._$smoothing,t.globalCompositeOperation=b,t.drawImage(v,0,0,v.width,v.height,n),p.releaseTexture(v);o!==s&&O(o),n!==r&&N(n)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,s){let r=e;const n=this._$transform._$rawMatrix();n!==f&&(r=j(e,n));const a=this._$getBounds(null),h=K(a,r),o=+h.xMax,l=+h.xMin,_=+h.yMax,$=+h.yMin;R(h),R(a);const c=i.ceil(i.abs(o-l)),u=i.ceil(i.abs(_-$));return t.setTransform(1,0,0,1,l,$),t.beginPath(),t.moveTo(0,0),t.lineTo(c,0),t.lineTo(c,u),t.lineTo(0,u),t.lineTo(0,0),r!==e&&O(r),t.isPointInPath(s.x,s.y)}_$getBounds(t=null){if(t){let e=t;const i=this._$transform._$rawMatrix();i!==f&&(e=j(t,i));const s=K(this._$bounds,e);return e!==t&&O(e),s}return B(this._$bounds.xMin,this._$bounds.xMax,this._$bounds.yMin,this._$bounds.yMax)}_$createWorkerInstance(){if(!Zi||this._$created)return;this._$created=!0;const t={command:"createVideo",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,smoothing:this._$smoothing,xMin:this._$bounds.xMin,yMin:this._$bounds.yMin,xMax:this._$bounds.xMax,yMax:this._$bounds.yMax};this._$characterId>-1&&(t.characterId=this._$characterId),this._$loaderInfo&&(t.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(t.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),Zi.postMessage(t)}_$postProperty(){if(!Zi)return;const t=this._$createMessage();t.smoothing=this._$smoothing;const e=U(),i=this._$context;if(i&&this._$video){t.xMin=this._$bounds.xMin,t.yMin=this._$bounds.yMin,t.xMax=this._$bounds.xMax,t.yMax=this._$bounds.yMax,i.drawImage(this._$video,0,0);const s=i.canvas.transferToImageBitmap();t.imageBitmap=s,e.push(s)}Zi.postMessage(t,e),G(e),this._$posted=!0,this._$updated=!1}}class ii{_$instanceId;_$width;_$height;_$buffer;_$image;_$canvas;_$pixelBuffer;constructor(t=0,e=0){this._$instanceId=ut(),this._$width=0|t,this._$height=0|e,this._$buffer=null,this._$image=null,this._$canvas=null,this._$pixelBuffer=null}static toString(){return"[class BitmapData]"}static get namespace(){return"next2d.display.BitmapData"}toString(){return"[object BitmapData]"}get namespace(){return"next2d.display.BitmapData"}get height(){return this._$height}get buffer(){return this._$buffer}set buffer(t){this._$buffer=t}get image(){return this._$image}set image(t){this._$canvas=null,this._$image=t,t&&(this._$width=t.width,this._$height=t.height)}get canvas(){return this._$canvas}set canvas(t){this._$image=null,this._$canvas=t,t&&(this._$width=t.width,this._$height=t.height)}get width(){return this._$width}clone(){const t=new ii(this.width,this.height);if(null!==this._$image||null!==this._$canvas){const e=Ui().cacheStore.getCanvas();e.width=this.width,e.height=this.height;const i=e.getContext("2d");if(!i)throw new Error("the context is null.");this._$image&&i.drawImage(this._$image,0,0),this._$canvas&&i.drawImage(this._$canvas,0,0),t.canvas=e}else null!==this._$buffer&&(t._$buffer=this._$buffer.slice());return t}getTexture(){const{width:t,height:e}=this;if(!t||!e)return null;const i=Ui().context;if(!i)throw new Error("the context is null.");return null!==this._$image?i.frameBuffer.createTextureFromImage(this._$image):null!==this._$canvas?i.frameBuffer.createTextureFromCanvas(this._$canvas):null!==this._$buffer?i.frameBuffer.createTextureFromPixels(t,e,this._$buffer,!0):null}draw(t,e=null,i=null,s=null,r=null){const{width:n,height:a}=this;if(!n||!a)return;const h=Ui(),o=h._$width,l=h._$height;(n>o||a>l)&&(h._$width=n,h._$height=a,h._$resizeCanvas(n,a,h.scaleX));const _=i?i._$colorTransform:p;let $=e?e._$matrix:f;if(e){const e=t._$transform.matrix;e.invert(),$=j($,e._$matrix),Yi(e)}if(s||(s=h.cacheStore.getCanvas()),Zi){t._$stage||(t instanceof Gt?es&&es(t):(t._$createWorkerInstance(),t._$postProperty())),s.width=n,s.height=a;const e=s.getContext("2d");if(!e)throw new Error("the context is null.");e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,n,a);const i=t._$instanceId;Ci.set(i,{source:t,context:e,callback:r});const h=U(),o={command:"bitmapDraw",sourceId:i,width:n,height:a};1===$[0]&&0===$[1]&&0===$[2]&&1===$[3]&&0===$[4]&&0===$[5]||(o.matrix=$.slice(),h.push(o.matrix.buffer)),1===_[0]&&1===_[1]&&1===_[2]&&1===_[3]&&0===_[4]&&0===_[5]&&0===_[6]&&0===_[7]||(o.colorTransform=_.slice(),h.push(o.colorTransform.buffer)),Zi.postMessage(o,h),G(h)}else{const e=h.context;if(!e)throw new Error("the context is null.");const i=e.frameBuffer,o=i.currentAttachment;e._$bind(h._$attachment),e.reset(),e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,h._$width,h._$height),e.beginPath(),t._$draw(e,$,_);const l=i.getTextureFromCurrentAttachment();i.unbind(),e.reset(),e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,l.width+1,l.height+1),e.drawImage(l,0,0,l.width,l.height),s.width=n,s.height=a;const c=s.getContext("2d");if(!c)return;c.setTransform(1,0,0,1,0,0),c.clearRect(0,0,n,a),c.drawImage(h.canvas,0,0),o&&e._$bind(o),r&&r(s)}e&&Yi(e),i&&zi(i)}}class si extends Dt{_$graphics;_$bounds;_$bitmapId;_$src;constructor(){super(),this._$graphics=null,this._$bounds=null,this._$bitmapId=0,this._$src=""}static toString(){return"[class Shape]"}static get namespace(){return"next2d.display.Shape"}toString(){return"[object Shape]"}get namespace(){return"next2d.display.Shape"}get graphics(){return this._$graphics||(this._$graphics=new De(this)),this._$graphics}get src(){return this._$src}set src(t){const e=new Image;e.addEventListener("load",(()=>{const t=e.width,i=e.height,s=new ii(t,i);s.image=e,this.graphics.beginBitmapFill(s).drawRect(0,0,t,i),this.hasEventListener($t.LOAD)&&this.dispatchEvent(new $t($t.LOAD))})),this._$src=e.src=t}_$buildCharacter(t,e){const s=this.graphics;if(!e._$data)throw new Error("the loaderInfo data is null.");if(t.recodes)switch(!0){case t.bitmapId>0:{this._$bitmapId=t.bitmapId;const r=e._$data.characters[t.bitmapId];if(!r.buffer)throw new Error("the bitmap buffer is null.");const n=i.abs(r.bounds.xMax-r.bounds.xMin),a=i.abs(r.bounds.yMax-r.bounds.yMin),h=new ii(n,a);r._$buffer||(r._$buffer=new Uint8Array(r.buffer),G(r.buffer),r.buffer=null),h.buffer=r._$buffer.slice(),s._$recode=U();const o=t.recodes;if(o[o.length-1]===De.END_FILL){const t=o.length-6;for(let e=0;e<t;++e)s._$recode.push(o[e]);s._$recode.push(De.BITMAP_FILL,h,null,"repeat",!1)}else{const e=o[o.length-9],i=o[o.length-8],r=o[o.length-7],n=o[o.length-6],a=o.length-10;for(let t=0;t<a;++t)s._$recode.push(o[t]);s._$recode.push(De.BITMAP_STROKE,e,i,r,n,h,P(1,0,0,1,t.bounds.xMin,t.bounds.yMin),"repeat",!1)}}break;case t.inBitmap:{s._$recode=U();const e=t.recodes;for(let t=0;t<e.length;++t){const i=e[t];if(s._$recode[t]=i,"object"!=typeof i)continue;if(!i.buffer)continue;const r=new ii(i.width,i.height);r.buffer=new Uint8Array(i.buffer),s._$recode[t++]=r;const n=e[t];s._$recode[t]=P(n[0],n[1],n[2],n[3],n[4],n[5])}}break;default:s._$recode=t.recodes.slice(0)}else{const e=i.abs(t.bounds.xMax-t.bounds.xMin),r=i.abs(t.bounds.yMax-t.bounds.yMin),n=new ii(e,r);if(!t._$buffer){if(!t.buffer)throw new Error("the bitmap buffer is null.");t._$buffer=new Uint8Array(t.buffer),G(t.buffer),t.buffer=null}n.buffer=t._$buffer.slice(0),s.beginBitmapFill(n,null,!1).drawRect(0,0,e,r)}s._$maxAlpha=1,s._$canDraw=!0,s._$xMin=t.bounds.xMin,s._$xMax=t.bounds.xMax,s._$yMin=t.bounds.yMin,s._$yMax=t.bounds.yMax,t.grid&&(this._$scale9Grid=new wt(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),Zi&&this._$stage&&this._$createWorkerInstance()}_$createWorkerInstance(){if(this._$created||!Zi)return;this._$created=!0;const t=U(),e=this._$getBounds(),i={command:"createShape",instanceId:this._$instanceId,parentId:this._$parent?this._$parent._$instanceId:-1,maxAlpha:0,canDraw:!1,xMin:e.xMin,yMin:e.yMin,xMax:e.xMax,yMax:e.yMax},s=this._$graphics;if(s){const e=s._$getRecodes();e.length&&s._$maxAlpha>0&&s._$canDraw&&(i.maxAlpha=s._$maxAlpha,i.canDraw=s._$canDraw,i.recodes=e,t.push(e.buffer))}this._$characterId>-1&&(i.characterId=this._$characterId),this._$loaderInfo&&(i.loaderInfoId=this._$loaderInfo._$id),this._$scale9Grid&&(i.grid={x:this._$scale9Grid.x,y:this._$scale9Grid.y,w:this._$scale9Grid.width,h:this._$scale9Grid.height}),Zi.postMessage(i,t)}_$sync(t){this._$loaderInfo&&this._$buildCharacter(t,this._$loaderInfo)}_$build(t,e){const i=this._$baseBuild(t,e);return this._$buildCharacter(i,e._$loaderInfo),i}_$getBounds(t=null){if(!this._$graphics)return B(0,0,0,0);const e=this._$graphics._$getBounds();if(!t)return e;let i=t;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=j(t,s));const r=K(e,i);return R(e),i!==t&&O(i),r}_$draw(t,e,i){if(!this._$visible)return;if(!this._$graphics||!this._$graphics._$canDraw)return;let s=i;const r=this._$transform._$rawColorTransform();if((r!==p&&1!==r[0]||1!==r[1]||1!==r[2]||1!==r[3]||0!==r[4]||0!==r[5]||0!==r[6]||0!==r[7])&&(s=q(i,r)),!W(s[3]+s[7]/255,0,1,0))return void(s!==i&&N(s));const n=this._$filters||this.filters,a=this._$blendMode||this.blendMode;let h=e;const o=this._$transform._$rawMatrix();(o!==Ei&&1!==o[0]||0!==o[1]||0!==o[2]||1!==o[3]||0!==o[4]||0!==o[5])&&(h=j(e,o)),this._$graphics._$draw(t,h,s,a,n),h!==e&&O(h),s!==i&&N(s)}_$clip(t,e){if(!this._$graphics)return;let i=e;const s=this._$transform._$rawMatrix();1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=j(e,s)),this._$graphics._$clip(t,i),i!==e&&O(i)}_$mouseHit(t,e,i){return!!this._$visible&&this._$hit(t,e,i)}_$hit(t,e,i,s=!1){let r=!1;const n=this._$graphics;if(n&&n._$canDraw&&n._$getBounds()){let a=e;const h=this._$transform._$rawMatrix();1===h[0]&&0===h[1]&&0===h[2]&&1===h[3]&&0===h[4]&&0===h[5]||(a=j(e,h)),r=n._$hit(t,a,i,s),a!==e&&O(a)}return r}_$postProperty(){if(!Zi)return;const t=this._$createMessage(),e=this._$graphics;if(e&&!e._$buffer){t.maxAlpha=e._$maxAlpha,t.canDraw=e._$canDraw;const i=e._$getRecodes();t.recodes=i;const s=U(i.buffer),r=this._$getBounds();t.xMin=r.xMin,t.yMin=r.yMin,t.xMax=r.xMax,t.yMax=r.yMax,Zi.postMessage(t,s),G(s)}else Zi.postMessage(t);this._$posted=!0,this._$updated=!1}}const ri="__next2d__",ni="touchstart",ai="touchmove",hi="touchend",oi="mousedown",li="mousemove",_i="mouseup",$i="wheel",ci="dblclick",ui="mouseleave",di="scroll",gi=Xt.createElement("p"),fi=Xt.createElement("div");fi.innerHTML="a",fi.style.display="block",fi.style.position="absolute",fi.style.top="-9999px",fi.style.left="-9999px",fi.style.padding="0",fi.style.margin="0",fi.style.padding="0",fi.style.border="0",fi.style.outline="0",fi.style.verticalAlign="bottom",fi.style.lineHeight="100%";const pi=fi;let mi=null;const xi=new Map;let bi=null;const vi=t=>{bi=t},Ti={lock:!1,position:{x:0,y:0},bounds:null},yi=new Float32Array(256);new Float32Array(256);for(let t=0;t<256;++t)yi[t]=i.pow(t/255,2.23333333),yi[t]=t/255;const Ei=new Float32Array([1,0,0,1,0,0]),Mi=[],Ai=[],wi=[],Ci=new Map;let Si=!1,Fi=!1,Bi=!1,Ri=!1,Ii=!1,Li=!1;const Pi=Xt.createElement("canvas");Pi.width=1,Pi.height=1;const Oi=Pi.getContext("2d");Oi&&(Oi.globalAlpha=0,Oi.imageSmoothingEnabled=!1);const ki=Xt.createElement("canvas");ki.width=1,ki.height=1;const Ni=ki.getContext("2d");if(!Ni)throw new Error("the CanvasRenderingContext2D is null.");Ni.globalAlpha=0,Ni.imageSmoothingEnabled=!1;const Di=Ni,Ui=()=>Vt.next2d.player,Gi=()=>{const t=bt();if(!t)return new at;const e=Ui();let i=Vt.scrollX,s=Vt.scrollY;const r=Xt.getElementById(e.contentElementId);if(r){const t=r.getBoundingClientRect();i+=t.left,s+=t.top}let n=0,a=0;if("changedTouches"in t){const e=t.changedTouches[0];n=e.pageX,a=e.pageY}else"pageX"in t&&(n=t.pageX,a=t.pageY);const h=(n-i)/e._$scale-e.x/e._$scale/Yt,o=(a-s)/e._$scale-e.y/e._$scale/Yt;return new at(h,o)},Vi=(t=1,e=0,i=0,s=1,r=0,n=0)=>{const a=Ai.pop();return a?(a.setTo(t,e,i,s,r,n),a):new ht(t,e,i,s,r,n)},Yi=t=>{Ai.push(t)},Xi=(t=1,e=1,i=1,s=1,r=0,n=0,a=0,h=0)=>{const o=wi.length?wi.pop():null;return o?(o.redMultiplier=t,o.greenMultiplier=e,o.blueMultiplier=i,o.alphaMultiplier=s,o.redOffset=r,o.greenOffset=n,o.blueOffset=a,o.alphaOffset=h,o):new ot(t,e,i,s,r,n,a,h)},zi=t=>{wi.push(t)},Hi=(t,e)=>{t._$character?t._$character.audioBuffer=e:t._$audioBuffer=e},Wi=t=>{if(!mi)throw new Error("the AudioContext is null.");let e=null;if(t._$character){const i=t._$character.buffer;i&&(e=new Uint8Array(i).buffer,G(i),t._$character.buffer=null)}else e=t._$arrayBuffer;return e?mi.decodeAudioData(e).then((e=>(Hi(t,e),Promise.resolve(t)))).catch((()=>{if(!e)throw new Error;return((t,e)=>{if(!mi)throw new Error("the Audio Context is null.");const i=new Uint8Array(e);let s=0;for(;s=i.indexOf(255,s),-1!==s&&224!=(224&i[s+1]);)++s;if(s>-1)return mi.decodeAudioData(i.subarray(s).buffer).then((e=>(Hi(t,e),Promise.resolve(t)))).catch((()=>{throw new Error("This voice data is not available.")}));throw new Error("This voice data is not available.")})(t,e)})):Promise.resolve(t)},ji=()=>{if(mi||(mi=new AudioContext,mi.resume()),mi){const t=U();for(let e=0;e<Mi.length;++e){const i=Mi[e];i._$character&&i._$character.audioBuffer&&t.push(Promise.resolve(i)),i._$audioBuffer&&t.push(Promise.resolve(i)),t.push(Wi(i))}Promise.all(t).then((t=>{Mi.length=0,Ui()._$loaders.push(...t)}))}};let qi=-1;const Ki=()=>{const t=Ui();if(t._$loadStatus===Oe.LOAD_END){t._$resize();const e=t.stage;e.willTrigger($t.RESIZE)&&e.dispatchEvent(new $t($t.RESIZE))}};Vt.addEventListener("resize",(()=>{g(qi),qi=d(Ki,300)}));const Qi=t=>{let e=null;switch(t.method.toUpperCase()){case"GET":if(t.data){const e=t.url.split("?");e[1]=1===e.length?t.data.toString():`${e[1]}&${t.data.toString()}`,t.url=e.join("?")}break;case"PUT":case"POST":t.data&&(e=t.data.toString())}const i=new XMLHttpRequest;if(i.open(t.method,t.url,!0),i.responseType=t.format,i.withCredentials=t.withCredentials,t.event){const e=Object.keys(t.event);for(let s=0;s<e.length;++s){const r=e[s];i.addEventListener(r,t.event[r])}G(e)}for(let e=0;e<t.headers.length;++e){const s=t.headers[e];i.setRequestHeader(s.name,s.value)}i.send(e)},Ji=t=>{switch(t){case We.namespace:return new We;case si.namespace:return new si;case Ze.namespace:return new Ze;case Ge.namespace:return new Ge;case ei.namespace:return new ei}};let Zi=null,ts=null,es=null;const is=URL.createObjectURL(new Blob(['(()=>{"use strict";var r=Uint8Array,n=Uint16Array,e=Int32Array,a=new r([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),t=new r([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),i=new r([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=function(r,a){for(var t=new n(31),i=0;i<31;++i)t[i]=a+=1<<r[i-1];var o=new e(t[30]);for(i=1;i<30;++i)for(var f=t[i];f<t[i+1];++f)o[f]=f-t[i]<<5|i;return{b:t,r:o}},f=o(a,2),u=f.b,v=f.r;u[28]=258,v[258]=28;for(var c=o(t,0),l=c.b,d=(c.r,new n(32768)),s=0;s<32768;++s){var w=(43690&s)>>1|(21845&s)<<1;w=(61680&(w=(52428&w)>>2|(13107&w)<<2))>>4|(3855&w)<<4,d[s]=((65280&w)>>8|(255&w)<<8)>>1}var h=function(r,e,a){for(var t=r.length,i=0,o=new n(e);i<t;++i)r[i]&&++o[r[i]-1];var f,u=new n(e);for(i=1;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(a){f=new n(1<<e);var v=15-e;for(i=0;i<t;++i)if(r[i])for(var c=i<<4|r[i],l=e-r[i],s=u[r[i]-1]++<<l,w=s|(1<<l)-1;s<=w;++s)f[d[s]>>v]=c}else for(f=new n(t),i=0;i<t;++i)r[i]&&(f[i]=d[u[r[i]-1]++]>>15-r[i]);return f},y=new r(288);for(s=0;s<144;++s)y[s]=8;for(s=144;s<256;++s)y[s]=9;for(s=256;s<280;++s)y[s]=7;for(s=280;s<288;++s)y[s]=8;var b=new r(32);for(s=0;s<32;++s)b[s]=5;var g=h(y,9,1),p=h(b,5,1),m=function(r){for(var n=r[0],e=1;e<r.length;++e)r[e]>n&&(n=r[e]);return n},k=function(r,n,e){var a=n/8|0;return(r[a]|r[a+1]<<8)>>(7&n)&e},x=function(r,n){var e=n/8|0;return(r[e]|r[e+1]<<8|r[e+2]<<16)>>(7&n)},T=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],z=function(r,n,e){var a=new Error(n||T[r]);if(a.code=r,Error.captureStackTrace&&Error.captureStackTrace(a,z),!e)throw a;return a},E=function(n,e,o,f){var v=n.length,c=f?f.length:0;if(!v||e.f&&!e.l)return o||new r(0);var d=!o||2!=e.i,s=e.i;o||(o=new r(3*v));var w,y=function(n){var e=o.length;if(n>e){var a=new r(Math.max(2*e,n));a.set(o),o=a}},b=e.f||0,T=e.p||0,E=e.b||0,M=e.l,S=e.d,U=e.m,A=e.n,C=8*v;do{if(!M){b=k(n,T,1);var q=k(n,T+1,3);if(T+=3,!q){var D=n[(w=T,(G=4+((w+7)/8|0))-4)]|n[G-3]<<8,F=G+D;if(F>v){s&&z(0);break}d&&y(E+D),o.set(n.subarray(G,F),E),e.b=E+=D,e.p=T=8*F,e.f=b;continue}if(1==q)M=g,S=p,U=9,A=5;else if(2==q){var I=k(n,T,31)+257,O=k(n,T+10,15)+4,J=I+k(n,T+5,31)+1;T+=14;for(var L=new r(J),N=new r(19),P=0;P<O;++P)N[i[P]]=k(n,T+3*P,7);T+=3*O;var R=m(N),j=(1<<R)-1,B=h(N,R,1);for(P=0;P<J;){var G,H=B[k(n,T,j)];if(T+=15&H,(G=H>>4)<16)L[P++]=G;else{var K=0,Q=0;for(16==G?(Q=3+k(n,T,3),T+=2,K=L[P-1]):17==G?(Q=3+k(n,T,7),T+=3):18==G&&(Q=11+k(n,T,127),T+=7);Q--;)L[P++]=K}}var V=L.subarray(0,I),W=L.subarray(I);U=m(V),A=m(W),M=h(V,U,1),S=h(W,A,1)}else z(1);if(T>C){s&&z(0);break}}d&&y(E+131072);for(var X=(1<<U)-1,Y=(1<<A)-1,Z=T;;Z=T){var $=(K=M[x(n,T)&X])>>4;if((T+=15&K)>C){s&&z(0);break}if(K||z(2),$<256)o[E++]=$;else{if(256==$){Z=T,M=null;break}var _=$-254;if($>264){var rr=a[P=$-257];_=k(n,T,(1<<rr)-1)+u[P],T+=rr}var nr=S[x(n,T)&Y],er=nr>>4;if(nr||z(3),T+=15&nr,W=l[er],er>3&&(rr=t[er],W+=x(n,T)&(1<<rr)-1,T+=rr),T>C){s&&z(0);break}d&&y(E+131072);var ar=E+_;if(E<W){var tr=c-W,ir=Math.min(W,ar);for(tr+E<0&&z(3);E<ir;++E)o[E]=f[tr+E]}for(;E<ar;E+=4)o[E]=o[E-W],o[E+1]=o[E+1-W],o[E+2]=o[E+2-W],o[E+3]=o[E+3-W];E=ar}}e.l=M,e.p=Z,e.b=E,e.f=b,M&&(b=1,e.m=U,e.d=S,e.n=A)}while(!b);return E==o.length?o:function(n,e,a){(null==e||e<0)&&(e=0),(null==a||a>n.length)&&(a=n.length);var t=new r(a-e);return t.set(n.subarray(e,a)),t}(o,0,E)},M=new r(0);function S(n,e){var a,t,i=function(r){31==r[0]&&139==r[1]&&8==r[2]||z(6,"invalid gzip data");var n=r[3],e=10;4&n&&(e+=2+(r[10]|r[11]<<8));for(var a=(n>>3&1)+(n>>4&1);a>0;a-=!r[e++]);return e+(2&n)}(n);return i+8>n.length&&z(6,"invalid gzip data"),E(n.subarray(i,-8),{i:2},e&&e.out||new r((t=(a=n).length,(a[t-4]|a[t-3]<<8|a[t-2]<<16|a[t-1]<<24)>>>0)),e&&e.dictionary)}function U(r,n){return E(r.subarray((e=r,a=n&&n.dictionary,(8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31)&&z(6,"invalid zlib data"),(e[1]>>5&1)==+!a&&z(6,"invalid zlib data: "+(32&e[1]?"need":"unexpected")+" dictionary"),2+(e[1]>>3&4)),-4),{i:2},n&&n.out,n&&n.dictionary);var e,a}var A="undefined"!=typeof TextDecoder&&new TextDecoder;try{A.decode(M,{stream:!0})}catch(r){}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;self.addEventListener("message",(r=>{return n=void 0,e=void 0,t=function*(){const n=31==(e=r.data)[0]&&139==e[1]&&8==e[2]?S(e,a):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?function(r,n){return E(r,{i:2},n&&n.out,n&&n.dictionary)}(e,a):U(e,a);var e,a;let t="";for(let r=0;r<n.length;r+=4096)t+=String.fromCharCode(...n.slice(r,r+4096));self.postMessage(JSON.parse(decodeURIComponent(t)))},new((a=void 0)||(a=Promise))((function(r,i){function o(r){try{u(t.next(r))}catch(r){i(r)}}function f(r){try{u(t.throw(r))}catch(r){i(r)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof a?e:new a((function(r){r(e)}))).then(o,f)}u((t=t.apply(n,e||[])).next())}));var n,e,a,t}))})();'],{type:"text/javascript"})),ss=[];let rs=null;const ns=()=>(rs||(rs=new Worker(is)),rs);let as=!1;const hs=t=>{as=t},os=()=>{if(Xt.body.appendChild(pi),"OffscreenCanvas"in window){const t=new OffscreenCanvas(0,0).getContext("webgl2");Zi=null!==t?new Worker(URL.createObjectURL(new Blob(['(()=>{"use strict";let t=0;const e=1/0,i=Math,s=Array,r=Map,n=Number,a=Float32Array,h=Int32Array,o=Int16Array,l=OffscreenCanvas,_=isNaN,c=requestAnimationFrame,$=setTimeout,u=clearTimeout,d=new a([1,0,0,1,0,0]),g=new a([1,1,1,1,0,0,0,0]),f=-32768,p=32767,m=i.PI/180,x=(i.PI,[]),b=[],v=[],T=[],A=[],y=[],M=[],E=[],w=new l(1,1).getContext("2d"),C=(t=0,e=0,i=0,s=0)=>{const r=E.pop()||{xMin:0,xMax:0,yMin:0,yMax:0};return r.xMin=t,r.xMax=e,r.yMin=i,r.yMax=s,r},S=t=>{E.push(t)},B=(t=0,e=0,i=0,s=0)=>{const r=b.pop()||new a(4);return r[0]=t,r[1]=e,r[2]=i,r[3]=s,r},F=t=>{b.push(t)},R=(t=0,e=0,i=0,s=0,r=0,n=0)=>{const h=v.pop()||new a(6);return h[0]=t,h[1]=e,h[2]=i,h[3]=s,h[4]=r,h[5]=n,h},I=t=>{v.push(t)},P=(t=1,e=1,i=1,s=1,r=0,n=0,h=0,o=0)=>{const l=T.pop()||new a(8);return l[0]=t,l[1]=e,l[2]=i,l[3]=s,l[4]=r,l[5]=n,l[6]=h,l[7]=o,l},k=t=>{T.push(t)},L=(t=0,e=0,i=0,s=0,r=0,n=0,h=0,o=0,l=0)=>{const _=A.pop()||new a(9);return _[0]=t,_[1]=e,_[2]=i,_[3]=s,_[4]=r,_[5]=n,_[6]=h,_[7]=o,_[8]=l,_},N=(...t)=>{const e=y.pop()||[];return t.length&&e.push(...t),e},U=(t=null)=>{t&&(t.length&&(t.length=0),y.push(t))},O=t=>{t.size&&t.clear(),M.push(t)},D=()=>M.pop()||new r,X=t=>(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t),V=t=>{const e=1/(t[0]*t[4]-t[3]*t[1]),i=t[3]*t[7]-t[4]*t[6],s=t[1]*t[6]-t[0]*t[7];return L(t[4]*e,0-t[1]*e,0,0-t[3]*e,t[0]*e,0,i*e,s*e,1)},Y=(t,e,s,r=null)=>{const n=+t;return _(n)&&null!==r?r:i.min(i.max(e,_(n)?0:n),s)},G=(t,e)=>R(t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]),z=(t,e)=>P(t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[0]*e[4]+t[4],t[1]*e[5]+t[5],t[2]*e[6]+t[6],t[3]*e[7]+t[7]),W=(t,e)=>{const s=t.xMax*e[0]+t.yMax*e[2]+e[4],r=t.xMax*e[0]+t.yMin*e[2]+e[4],a=t.xMin*e[0]+t.yMax*e[2]+e[4],h=t.xMin*e[0]+t.yMin*e[2]+e[4],o=t.xMax*e[1]+t.yMax*e[3]+e[5],l=t.xMax*e[1]+t.yMin*e[3]+e[5],_=t.xMin*e[1]+t.yMax*e[3]+e[5],c=t.xMin*e[1]+t.yMin*e[3]+e[5],$=i.min(n.MAX_VALUE,s,r,a,h),u=i.max(0-n.MAX_VALUE,s,r,a,h),d=i.min(n.MAX_VALUE,o,l,_,c),g=i.max(0-n.MAX_VALUE,o,l,_,c);return C($,u,d,g)},H=t=>_(+t)?(t=>{if(!w)return 0;w.fillStyle=t;const e=+`0x${w.fillStyle.slice(1)}`;return w.fillStyle="rgba(0, 0, 0, 1)",e})(`${t}`):+t,q=(t,e,i)=>(t>>16)*(i?e:1)/255,j=(t,e,i)=>(t>>8&255)*(i?e:1)/255,Q=(t,e,i)=>(255&t)*(i?e:1)/255,J=(t,e=1)=>({R:(16711680&t)>>16,G:(65280&t)>>8,B:255&t,A:255*e}),K=(t,e,i=!1,s=!1)=>{let r="";return i&&(r="italic "),s&&(r+="bold "),`${r}${e}px \'${t}\',\'sans-serif\'`},Z=t=>{t.color&&k(t.color),t.isFilter=!1,t.isUpdated=null,t.canApply=null,t.matrix=null,t.color=null,t.baseMatrix=null,t.baseColor=null,t.filters=null,t.blendMode="normal",x.push(t)};class tt{constructor(){this._$pool=[],this._$store=new Map,this._$timerMap=new Map,this._$context=null}set context(t){this._$context=t}reset(){for(const t of this._$store.values()){for(const e of t.values())this.destroy(e);O(t)}this._$store.clear()}destroy(t=null){if(t)if(t instanceof WebGLTexture)c((()=>{this._$context&&this._$context.frameBuffer.releaseTexture(t)}));else if(t instanceof CanvasRenderingContext2D){const e=t.canvas,i=e.width,s=e.height;t.clearRect(0,0,i+1,s+1),e.width=e.height=1,this._$pool.push(e)}}getCanvas(){return this._$pool.pop()||document.createElement("canvas")}remove(t,e){if(!this._$store.has(t))return;const i=this._$store.get(t);i.has(e)&&(i.delete(e),i.size||(O(i),this._$store.delete(t)))}stopTimer(t){t=`${t}`,this._$timerMap.has(t)&&(u(this._$timerMap.get(t)),this._$timerMap.delete(t))}removeCache(t){if(t=`${t}`,this._$store.has(t)){const e=this._$store.get(t);for(const t of e.values())this.destroy(t);e.clear(),O(e),this._$store.delete(t)}this._$timerMap.delete(t)}setRemoveTimer(t){if(t=`${t}`,this.stopTimer(t),this._$store.has(t)){const e=$((()=>{this.removeCache(t)}),5e3);this._$timerMap.set(t,e)}}get(t){const e=`${t[0]}`,i=`${t[1]}`;if(this._$store.has(e)){this.stopTimer(e);const t=this._$store.get(e);if(t.has(i))return t.get(i)}return null}set(t,e=null){const i=`${t[0]}`,s=`${t[1]}`;this._$store.has(i)||this._$store.set(i,D());const r=this._$store.get(i);if(!e)return r.delete(s),void(r.size||(O(r),this._$store.delete(i)));const n=r.get(s);n&&n!==e&&this.destroy(n),r.set(s,e)}has(t){const e=`${t[0]}`;return!!this._$store.has(e)&&this._$store.get(e).has(`${t[1]}`)}generateKeys(t,e=null,i=null){let s="";e&&(s+=`${e.join("_")}`),i&&(s+=this.colorToString(i));const r=N();return r[1]=s?this.generateHash(s):"_0",r[0]=`${t}`,r}colorToString(t){return 0===t[7]?"":`_${t[7]}`}generateHash(t){let e=0;const i=t.length;for(let s=0;s<i;s++)e=(e<<5)-e+t.charCodeAt(s),e|=0;return`_${e}`}}class et{constructor(t=0,e=0){this._$x=0,this._$y=0,this.x=t,this.y=e}static toString(){return"[class Point]"}static get namespace(){return"next2d.geom.Point"}toString(){return`(x=${this.x}, y=${this.y})`}get namespace(){return"next2d.geom.Point"}get length(){return i.sqrt(i.pow(this.x,2)+i.pow(this.y,2))}get x(){return this._$x}set x(t){this._$x=Y(+t,f,p,0)}get y(){return this._$y}set y(t){this._$y=Y(+t,f,p,0)}add(t){return new et(this.x+t.x,this.y+t.y)}clone(){return new et(this.x,this.y)}copyFrom(t){this._$x=t._$x,this._$y=t._$y}static distance(t,e){return i.sqrt(i.pow(t._$x-e._$x,2)+i.pow(t._$y-e._$y,2))}equals(t){return this._$x===t._$x&&this._$y===t._$y}static interpolate(t,e,i){return new et(t.x+(e.x-t.x)*(1-i),t.y+(e.y-t.y)*(1-i))}normalize(t){const e=this.length;this.x=this.x*t/e,this.y=this.y*t/e}offset(t,e){this.x+=t,this.y+=e}static polar(t,e){return new et(t*i.cos(e),t*i.sin(e))}setTo(t,e){this.x=t,this.y=e}subtract(t){return new et(this.x-t.x,this.y-t.y)}}class it{constructor(t=0,e=0,i=0,s=0){this._$x=0,this._$y=0,this._$width=0,this._$height=0,this.setTo(t,e,i,s)}static toString(){return"[class Rectangle]"}static get namespace(){return"next2d.geom.Rectangle"}toString(){return`(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`}get namespace(){return"next2d.geom.Rectangle"}get bottom(){return this.y+this.height}set bottom(t){this.height=+t-this.y}get bottomRight(){return new et(this.right,this.bottom)}set bottomRight(t){this.right=t.x,this.bottom=t.y}get height(){return this._$height}set height(t){this._$height=Y(+t,f,p,0)}get left(){return this.x}set left(t){this.width=this.right-+t,this.x=t}get right(){return this.x+this.width}set right(t){this.width=+t-this.x}get size(){return new et(this.width,this.height)}set size(t){this.width=t.x,this.height=t.y}get top(){return this.y}set top(t){this.height=+(this.bottom-+t),this.y=t}get topLeft(){return new et(this.x,this.y)}set topLeft(t){this.left=t.x,this.top=t.y}get width(){return this._$width}set width(t){this._$width=Y(+t,f,p,0)}get x(){return this._$x}set x(t){this._$x=Y(+t,f,p,0)}get y(){return this._$y}set y(t){this._$y=Y(+t,f,p,0)}clone(){return new it(this.x,this.y,this.width,this.height)}contains(t,e){return this.x<=t&&this.y<=e&&this.right>t&&this.bottom>e}containsPoint(t){return this.x<=t.x&&this.y<=t.y&&this.right>t.x&&this.bottom>t.y}containsRect(t){return this.x<=t.x&&this.y<=t.y&&this.right>=t.right&&this.bottom>=t.bottom}copyFrom(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height}equals(t){return this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height}inflate(t,e){this.x=this.x-+t,this.width=this.width+2*+t,this.y=this.y-+e,this.height=this.height+2*+e}inflatePoint(t){this.x=this.x-t.x,this.width=this.width+2*t.x,this.y=this.y-t.y,this.height=this.height+2*t.y}intersection(t){const e=i.max(this.x,t.x),s=i.max(this.y,t.y),r=i.min(this.right,t.right)-e,n=i.min(this.bottom,t.bottom)-s;return r>0&&n>0?new it(e,s,r,n):new it(0,0,0,0)}intersects(t){const e=i.max(this.x,t.x),s=i.max(this.y,t.y),r=i.min(this.right,t.right),n=i.min(this.bottom,t.bottom);return r-e>0&&n-s>0}isEmpty(){return this.width<=0||this.height<=0}offset(t,e){this.x+=t,this.y+=e}offsetPoint(t){this.x+=t.x,this.y+=t.y}setEmpty(){this._$x=0,this._$y=0,this._$width=0,this._$height=0}setTo(t,e,i,s){this.x=t,this.y=e,this.width=i,this.height=s}union(t){return this.isEmpty()?t.clone():t.isEmpty()?this.clone():new it(i.min(this.x,t.x),i.min(this.y,t.y),i.max(this.right-t.left,t.right-this.left),i.max(this.bottom-t.top,t.bottom-this.top))}}let st=!1;class rt{constructor(){this._$updated=!0}static toString(){return"[class BitmapFilter]"}static get namespace(){return"next2d.filters.BitmapFilter"}toString(){return"[object BitmapFilter]"}get namespace(){return"next2d.filters.BitmapFilter"}_$isUpdated(){return this._$updated}_$doChanged(){this._$updated=!0,((t=!0)=>{st=t})()}}class nt extends rt{constructor(t=4,e=4,i=1){super(),this._$blurX=4,this._$blurY=4,this._$quality=1,this.blurX=t,this.blurY=e,this.quality=i}static toString(){return"[class BlurFilter]"}static get namespace(){return"next2d.filters.BlurFilter"}toString(){return"[object BlurFilter]"}get namespace(){return"next2d.filters.BlurFilter"}static get STEP(){return[.5,1.05,1.4,1.55,1.75,1.9,2,2.15,2.2,2.3,2.5,3,3,3.5,3.5]}get blurX(){return this._$blurX}set blurX(t){(t=Y(+t,0,255,0))!==this._$blurX&&(this._$blurX=t,this._$doChanged())}get blurY(){return this._$blurY}set blurY(t){(t=Y(+t,0,255,0))!==this._$blurY&&(this._$blurY=t,this._$doChanged())}get quality(){return this._$quality}set quality(t){(t=Y(0|t,0,15,1))!==this._$quality&&(this._$quality=t,this._$doChanged())}clone(){return new nt(this._$blurX,this._$blurY,this._$quality)}_$toArray(){return N(1,this._$blurX,this._$blurY,this._$quality)}_$generateFilterRect(t,e=0,s=0){const r=t.clone();if(!this._$quality)return r;const n=nt.STEP[this._$quality-1];let a=0>=this._$blurX?1:this._$blurX*n,h=0>=this._$blurY?1:this._$blurY*n;return e?a*=e:a=i.round(a),s?h*=s:h=i.round(h),r.x-=a,r.width+=2*a,r.y-=h,r.height+=2*h,r}_$canApply(){return 0!==this._$blurX&&0!==this._$blurY}_$applyFilter(t,e,s=!0){this._$updated=!1;const r=t.frameBuffer,n=r.currentAttachment,a=r.getTextureFromCurrentAttachment();if(!this._$canApply())return s?a:r.createTextureFromCurrentAttachment();const h=i.sqrt(e[0]*e[0]+e[1]*e[1]),o=i.sqrt(e[2]*e[2]+e[3]*e[3]),l=new it(0,0,a.width,a.height),_=this._$generateFilterRect(l,h,o),c=0|i.ceil(_.width),$=0|i.ceil(_.height),u=i.ceil(i.abs(_.x)+.5*i.abs(c-_.width)),d=i.ceil(i.abs(_.y)+.5*i.abs($-_.height));t._$offsetX=u+t._$offsetX,t._$offsetY=d+t._$offsetY;const g=this._$blurX*h,f=this._$blurY*o;let p=1,m=1;g>128?p=.0625:g>64?p=.125:g>32?p=.25:g>16&&(p=.5),f>128?m=.0625:f>64?m=.125:f>32?m=.25:f>16&&(m=.5);const x=g*p,b=f*m,v=i.ceil(c*p),T=i.ceil($*m),A=r.createTextureAttachment(v,T),y=[A,r.createTextureAttachment(v,T)];let M=0;t._$bind(A),t.reset(),t.setTransform(p,0,0,m,0,0),t.drawImage(a,u,d,a.width,a.height),t.blend.toOneZero();let E=r.getTextureFromCurrentAttachment();for(let e=0;e<this._$quality;++e){if(this._$blurX>0){M=(M+1)%2;const e=y[M];t._$bind(e),t._$applyBlurFilter(E,!0,x),E=r.getTextureFromCurrentAttachment()}if(this._$blurY>0){M=(M+1)%2;const e=y[M];t._$bind(e),t._$applyBlurFilter(E,!1,b),E=r.getTextureFromCurrentAttachment()}}if(t.blend.reset(),1!==p||1!==m){const e=r.createTextureAttachment(c,$);t._$bind(e),t.reset(),t.imageSmoothingEnabled=!0,t.setTransform(1/p,0,0,1/m,0,0),t.drawImage(E,0,0,v,T),E=r.getTextureFromCurrentAttachment(),t.reset(),t.setTransform(1,0,0,1,0,0),r.releaseAttachment(y[0],!0),r.releaseAttachment(y[1],!0),s?r.releaseAttachment(n,!0):r.releaseAttachment(e,!1)}else r.releaseAttachment(y[(M+1)%2],!0),s?r.releaseAttachment(n,!0):r.releaseAttachment(y[M],!1);return E}}class at extends rt{constructor(t=4,e=45,i=16777215,s=1,r=0,n=1,a=4,h=4,o=1,l=1,_="inner",c=!1){super(),this._$blurFilter=new nt(a,h,l),this._$distance=4,this._$angle=45,this._$highlightColor=16777215,this._$highlightAlpha=1,this._$shadowColor=0,this._$shadowAlpha=1,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.highlightColor=i,this.highlightAlpha=s,this.shadowColor=r,this.shadowAlpha=n,this.strength=o,this.type=_,this.knockout=c}static toString(){return"[class BevelFilter]"}static get namespace(){return"next2d.filters.BevelFilter"}toString(){return"[object BevelFilter]"}get namespace(){return"next2d.filters.BevelFilter"}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=Y(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get highlightAlpha(){return this._$highlightAlpha}set highlightAlpha(t){(t=Y(+t,0,1,0))!==this._$highlightAlpha&&(this._$highlightAlpha=t,this._$doChanged())}get highlightColor(){return this._$highlightColor}set highlightColor(t){(t=Y(H(t),0,16777215,16777215))!==this._$highlightColor&&(this._$highlightColor=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get shadowAlpha(){return this._$shadowAlpha}set shadowAlpha(t){(t=Y(+t,0,1,0))!==this._$shadowAlpha&&(this._$shadowAlpha=t,this._$doChanged())}get shadowColor(){return this._$shadowColor}set shadowColor(t){(t=Y(H(t),0,16777215,0))!==this._$shadowColor&&(this._$shadowColor=t,this._$doChanged())}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){(t=`${t}`)!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new at(this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return N(0,this._$distance,this._$angle,this._$highlightColor,this._$highlightAlpha,this._$shadowColor,this._$shadowAlpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*m,a=i.abs(i.cos(n)*this._$distance),h=i.abs(i.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-h,r.height+=2*h,r}_$canApply(){return this._$strength>0&&0!==this._$distance&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;if(!r)throw new Error("the current attachment is null.");t.setTransform(1,0,0,1,0,0);const n=s.getTextureFromCurrentAttachment();if(!this._$canApply())return n;const a=r.width,h=r.height,o=t._$offsetX,l=t._$offsetY,_=i.sqrt(e[0]*e[0]+e[1]*e[1]),c=i.sqrt(e[2]*e[2]+e[3]*e[3]),$=this._$angle*m,u=i.cos($)*this._$distance*_,d=i.sin($)*this._$distance*c,g=s.createTextureAttachment(a,h);t._$bind(g),t.reset(),t.drawImage(n,0,0,a,h),t.globalCompositeOperation="erase",t.drawImage(n,2*u,2*d,a,h);const f=this._$blurFilter._$applyFilter(t,e,!1),p=f.width,x=f.height,b=i.ceil(p+2*i.abs(u)),v=i.ceil(x+2*i.abs(d)),T="inner"===this._$type,A=T?a:b,y=T?h:v,M=i.abs(u),E=i.abs(d),w=(p-a)/2,C=(x-h)/2,S=T?0:M+w,B=T?0:E+C,F=T?-w-u:M-u,R=T?-C-d:E-d;return t._$bind(r),s.releaseAttachment(g,!0),t._$applyBitmapFilter(f,A,y,a,h,S,B,p,x,F,R,!1,this._$type,this._$knockout,this._$strength,null,null,null,q(this._$highlightColor,this._$highlightAlpha,!0),j(this._$highlightColor,this._$highlightAlpha,!0),Q(this._$highlightColor,this._$highlightAlpha,!0),this._$highlightAlpha,q(this._$shadowColor,this._$shadowAlpha,!0),j(this._$shadowColor,this._$shadowAlpha,!0),Q(this._$shadowColor,this._$shadowAlpha,!0),this._$shadowAlpha),t._$offsetX=o+S,t._$offsetY=l+B,s.releaseTexture(f),s.getTextureFromCurrentAttachment()}}class ht extends rt{constructor(t=null){super(),this._$matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this.matrix=t}static toString(){return"[class ColorMatrixFilter]"}static get namespace(){return"next2d.filters.ColorMatrixFilter"}toString(){return"[object ColorMatrixFilter]"}get namespace(){return"next2d.filters.ColorMatrixFilter"}get matrix(){return this._$matrix}set matrix(t){if(t&&s.isArray(t)&&20===t.length){for(let e=0;e<20;++e)if(t[e]!==this._$matrix[e]){this._$doChanged();break}this._$matrix=t}}clone(){return new ht(this._$matrix)}_$toArray(){return N(2,this._$matrix)}_$generateFilterRect(t){return t}_$canApply(){return!0}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment(),r=s.width,n=s.height,a=e.createTextureAttachment(r,n);return t._$bind(a),t.reset(),t._$applyColorMatrixFilter(s,this._$matrix),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()}}class ot extends rt{constructor(t=0,e=0,i=null,s=1,r=0,n=!0,a=!0,h=0,o=0){super(),this._$matrixX=0,this._$matrixY=0,this._$matrix=null,this._$divisor=1,this._$bias=0,this._$preserveAlpha=!0,this._$clamp=!0,this._$color=0,this._$alpha=0,this.matrixX=t,this.matrixY=e,this.matrix=i,this.divisor=s,this.bias=r,this.preserveAlpha=n,this.clamp=a,this.color=h,this.alpha=o}static toString(){return"[class ConvolutionFilter]"}static get namespace(){return"next2d.filters.ConvolutionFilter"}toString(){return"[object ConvolutionFilter]"}get namespace(){return"next2d.filters.ConvolutionFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get bias(){return this._$bias}set bias(t){t!==this._$bias&&(this._$bias=0|t,this._$doChanged())}get clamp(){return this._$clamp}set clamp(t){t!==this._$clamp&&(this._$clamp=!!t,this._$doChanged())}get color(){return this._$color}set color(t){(t=Y(H(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get divisor(){return this._$divisor}set divisor(t){t!==this._$divisor&&(this._$divisor=0|t,this._$doChanged())}get matrix(){return this._$matrix}set matrix(t){s.isArray(this._$matrix)&&U(this._$matrix),this._$matrix=s.isArray(t)?t:null,this._$doChanged()}get matrixX(){return this._$matrixX}set matrixX(t){(t=0|Y(0|t,0,15,0))!==this._$matrixX&&(this._$matrixX=t,this._$doChanged())}get matrixY(){return this._$matrixY}set matrixY(t){(t=0|Y(0|t,0,15,0))!==this._$matrixY&&(this._$matrixY=t,this._$doChanged())}get preserveAlpha(){return this._$preserveAlpha}set preserveAlpha(t){t!==this._$preserveAlpha&&(this._$preserveAlpha=!!t,this._$doChanged())}clone(){return new ot(this._$matrixX,this._$matrixY,this._$matrix?this._$matrix.slice():null,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$toArray(){return N(3,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$matrix&&this._$matrixX*this._$matrixY===this._$matrix.length}_$applyFilter(t){this._$updated=!1;const e=t.frameBuffer,i=e.currentAttachment;t.setTransform(1,0,0,1,0,0);const s=e.getTextureFromCurrentAttachment();return this._$canApply()&&this._$matrix?(t._$applyConvolutionFilter(s,this._$matrixX,this._$matrixY,this._$matrix,this._$divisor,this._$bias,this._$preserveAlpha,this._$clamp,q(this._$color,this._$alpha,!1),j(this._$color,this._$alpha,!1),Q(this._$color,this._$alpha,!1),this._$alpha),e.releaseAttachment(i,!0),e.getTextureFromCurrentAttachment()):s}}class lt extends rt{constructor(t=null,e=null,i=0,s=0,r=0,n=0,a="wrap",h=0,o=0){super(),this._$mapBitmap=null,this._$mapPoint=null,this._$componentX=0,this._$componentY=0,this._$scaleX=0,this._$scaleY=0,this._$mode="wrap",this._$color=0,this._$alpha=0,this.mapBitmap=t,this.mapPoint=e,this.componentX=i,this.componentY=s,this.scaleX=r,this.scaleY=n,this.mode=a,this.color=h,this.alpha=o}static toString(){return"[class DisplacementMapFilter]"}static get namespace(){return"next2d.filters.DisplacementMapFilter"}toString(){return"[object DisplacementMapFilter]"}get namespace(){return"next2d.filters.DisplacementMapFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get color(){return this._$color}set color(t){(t=Y(H(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get componentX(){return this._$componentX}set componentX(t){t!==this._$componentX&&(this._$componentX=t,this._$doChanged())}get componentY(){return this._$componentY}set componentY(t){t!==this._$componentY&&(this._$componentY=t,this._$doChanged())}get mapBitmap(){return this._$mapBitmap}set mapBitmap(t){t!==this._$mapBitmap&&(this._$mapBitmap=t,this._$doChanged())}get mapPoint(){return this._$mapPoint}set mapPoint(t){t!==this._$mapPoint&&(this._$mapPoint=t,this._$doChanged())}get mode(){return this._$mode}set mode(t){t!==this._$mode&&(this._$mode=t,this._$doChanged())}get scaleX(){return this._$scaleX}set scaleX(t){(t=Y(+t,-65535,65535,0))!==this._$scaleX&&(this._$scaleX=t,this._$doChanged())}get scaleY(){return this._$scaleY}set scaleY(t){(t=Y(+t,-65535,65535,0))!==this._$scaleY&&(this._$scaleY=t,this._$doChanged())}clone(){return new lt(this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$toArray(){return N(4,this._$mapBitmap,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,this._$color,this._$alpha)}_$generateFilterRect(t){return t}_$canApply(){return null!==this._$mapBitmap&&this._$componentX>0&&this._$componentY>0&&0!==this._$scaleX&&0!==this._$scaleY}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=s.getTextureFromCurrentAttachment();if(!this._$canApply()||!r||!this._$mapBitmap)return n;const a=this._$mapBitmap.getTexture();if(!a)return n;const h=i.sqrt(e[0]*e[0]+e[1]*e[1]),o=i.sqrt(e[2]*e[2]+e[3]*e[3]);return t._$applyDisplacementMapFilter(n,a,n.width/h,n.height/o,this._$mapPoint,this._$componentX,this._$componentY,this._$scaleX,this._$scaleY,this._$mode,q(this._$color,this._$alpha,!0),j(this._$color,this._$alpha,!0),Q(this._$color,this._$alpha,!0),this._$alpha),s.releaseAttachment(r,!0),s.getTextureFromCurrentAttachment()}}class _t extends rt{constructor(t=4,e=45,i=0,s=1,r=4,n=4,a=1,h=1,o=!1,l=!1,_=!1){super(),this._$blurFilter=new nt(r,n,h),this._$distance=4,this._$angle=45,this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this._$hideObject=!1,this.distance=t,this.angle=e,this.color=i,this.alpha=s,this.strength=a,this.inner=o,this.knockout=l,this.hideObject=_}static toString(){return"[class DropShadowFilter]"}static get namespace(){return"next2d.filters.DropShadowFilter"}toString(){return"[object DropShadowFilter]"}get namespace(){return"next2d.filters.DropShadowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get angle(){return this._$angle}set angle(t){(t%=360)!==this._$angle&&(this._$angle=Y(t,-360,360,45),this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=Y(H(t),0,16777215,0))!==this._$color&&(this._$color=t,this._$doChanged())}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get hideObject(){return this._$hideObject}set hideObject(t){t!==this._$hideObject&&(this._$hideObject=!!t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new _t(this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$toArray(){return N(5,this._$distance,this._$angle,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout,this._$hideObject)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*m,a=i.cos(n)*this._$distance*2,h=i.sin(n)*this._$distance*2;return r.x=i.min(r.x,a),r.width+=i.abs(a),r.y=i.min(r.y,h),r.height+=i.abs(h),r}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const s=t.frameBuffer,r=s.currentAttachment;if(!r)throw new Error("the current attachment is null.");if(t.setTransform(1,0,0,1,0,0),!this._$canApply())return s.getTextureFromCurrentAttachment();const n=r.width,a=r.height,h=t._$offsetX,o=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,c=l.height,$=t._$offsetX,u=t._$offsetY,d=$-h,g=u-o,f=i.sqrt(e[0]*e[0]+e[1]*e[1]),p=i.sqrt(e[2]*e[2]+e[3]*e[3]),x=this._$angle*m,b=i.cos(x)*this._$distance*f,v=i.sin(x)*this._$distance*p,T=this._$inner?n:_+i.max(0,i.abs(b)-d),A=this._$inner?a:c+i.max(0,i.abs(v)-g),y=i.ceil(T),M=i.ceil(A),E=(y-T)/2,w=(M-A)/2,C=this._$inner?0:i.max(0,d-b)+E,S=this._$inner?0:i.max(0,g-v)+w,B=this._$inner?b-$:(b>0?i.max(0,b-d):0)+E,F=this._$inner?v-u:(v>0?i.max(0,v-g):0)+w;let R,I;return this._$inner?(R="inner",I=this._$knockout||this._$hideObject):!this._$knockout&&this._$hideObject?(R="full",I=!0):(R="outer",I=this._$knockout),t._$bind(r),t._$applyBitmapFilter(l,y,M,n,a,C,S,_,c,B,F,!0,R,I,this._$strength,null,null,null,q(this._$color,this._$alpha,!0),j(this._$color,this._$alpha,!0),Q(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=h+C,t._$offsetY=o+S,s.releaseTexture(l),s.getTextureFromCurrentAttachment()}}class ct extends rt{constructor(t=0,e=1,i=4,s=4,r=1,n=1,a=!1,h=!1){super(),this._$blurFilter=new nt(i,s,n),this._$color=0,this._$alpha=1,this._$strength=1,this._$inner=!1,this._$knockout=!1,this.color=t,this.alpha=e,this.strength=r,this.inner=a,this.knockout=h}static toString(){return"[class GlowFilter]"}static get namespace(){return"next2d.filters.GlowFilter"}toString(){return"[object GlowFilter]"}get namespace(){return"next2d.filters.GlowFilter"}get alpha(){return this._$alpha}set alpha(t){(t=Y(+t,0,1,0))!==this._$alpha&&(this._$alpha=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get color(){return this._$color}set color(t){(t=Y(H(t),0,16777215,4))!==this._$color&&(this._$color=t,this._$doChanged())}get inner(){return this._$inner}set inner(t){t!==this._$inner&&(this._$inner=!!t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}clone(){return new ct(this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$toArray(){return N(6,this._$color,this._$alpha,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$inner,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,i=0){const s=t.clone();return this._$canApply()?this._$blurFilter._$generateFilterRect(s,e,i):s}_$canApply(){return this._$alpha>0&&this._$strength>0&&this._$blurFilter._$canApply()}_$applyFilter(t,e){const i=t.frameBuffer,s=i.currentAttachment;if(!s)throw new Error("the current attachment is null.");if(this._$updated=!1,t.setTransform(1,0,0,1,0,0),!this._$canApply())return i.getTextureFromCurrentAttachment();const r=s.width,n=s.height,a=t._$offsetX,h=t._$offsetY,o=this._$blurFilter._$applyFilter(t,e,!1),l=o.width,_=o.height,c=t._$offsetX,$=t._$offsetY,u=this._$inner?r:l,d=this._$inner?n:_,g=this._$inner?0:c-a,f=this._$inner?0:$-h,p=this._$inner?-c:0,m=this._$inner?-$:0,x=this._$inner?"inner":"outer";return t._$bind(s),t._$applyBitmapFilter(o,u,d,r,n,g,f,l,_,p,m,!0,x,this._$knockout,this._$strength,null,null,null,q(this._$color,this._$alpha,!0),j(this._$color,this._$alpha,!0),Q(this._$color,this._$alpha,!0),this._$alpha,0,0,0,0),t._$offsetX=a+g,t._$offsetY=h+f,i.releaseTexture(o),i.getTextureFromCurrentAttachment()}}class $t extends rt{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,l="inner",_=!1){super(),this._$blurFilter=new nt(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=l,this.knockout=_}static toString(){return"[class GradientBevelFilter]"}static get namespace(){return"next2d.filters.GradientBevelFilter"}toString(){return"[object GradientBevelFilter]"}get namespace(){return"next2d.filters.GradientBevelFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,s.isArray(t)){for(let e=0;e<t.length;++e){const i=t[e];t[e]=Y(+i,0,1,0)}this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=Y(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(H(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new $t(this._$distance,this._$angle,this._$colors?this._$colors.slice():null,this._$alphas?this._$alphas.slice():null,this._$ratios?this._$ratios.slice():null,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return N(7,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*m,a=i.abs(i.cos(n)*this._$distance),h=i.abs(i.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-h,r.height+=2*h,r}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;t.setTransform(1,0,0,1,0,0);const n=s.getTextureFromCurrentAttachment();if(!this._$canApply()||!r)return n;const a=r.width,h=r.height,o=t._$offsetX,l=t._$offsetY,_=i.sqrt(e[0]*e[0]+e[1]*e[1]),c=i.sqrt(e[2]*e[2]+e[3]*e[3]),$=+this._$angle*m,u=+i.cos($)*this._$distance*_,d=+i.sin($)*this._$distance*c,g=s.createTextureAttachment(a,h);t._$bind(g),t.reset(),t.drawImage(n,0,0,a,h),t.globalCompositeOperation="erase",t.drawImage(n,2*u,2*d,a,h);const f=this._$blurFilter._$applyFilter(t,e,!1),p=f.width,x=f.height,b=i.ceil(p+2*i.abs(u)),v=i.ceil(x+2*i.abs(d)),T="inner"===this._$type,A=T?a:b,y=T?h:v,M=i.abs(u),E=i.abs(d),w=(p-a)/2,C=(x-h)/2,S=T?0:M+w,B=T?0:E+C,F=T?-w-u:M-u,R=T?-C-d:E-d;return t._$bind(r),t._$applyBitmapFilter(f,A,y,a,h,S,B,p,x,F,R,!1,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=o+S,t._$offsetY=l+B,s.releaseAttachment(g,!0),s.getTextureFromCurrentAttachment()}}class ut extends rt{constructor(t=4,e=45,i=null,s=null,r=null,n=4,a=4,h=1,o=1,l="inner",_=!1){super(),this._$blurFilter=new nt(n,a,o),this._$distance=4,this._$angle=45,this._$colors=null,this._$alphas=null,this._$ratios=null,this._$strength=1,this._$type="inner",this._$knockout=!1,this.distance=t,this.angle=e,this.colors=i,this.alphas=s,this.ratios=r,this.strength=h,this.type=l,this.knockout=_}static toString(){return"[class GradientGlowFilter]"}static get namespace(){return"next2d.filters.GradientGlowFilter"}toString(){return"[object GradientGlowFilter]"}get namespace(){return"next2d.filters.GradientGlowFilter"}get alphas(){return this._$alphas}set alphas(t){if(t!==this._$alphas){if(this._$alphas=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(+t[e],0,1,0);this._$alphas=t}this._$doChanged()}}get angle(){return this._$angle}set angle(t){(t=Y(t%360,-360,360,45))!==this._$angle&&(this._$angle=t,this._$doChanged())}get blurX(){return this._$blurFilter.blurX}set blurX(t){this._$blurFilter.blurX=t}get blurY(){return this._$blurFilter.blurY}set blurY(t){this._$blurFilter.blurY=t}get colors(){return this._$colors}set colors(t){if(this._$colors!==t){if(this._$colors=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(H(t[e]),0,16777215,0);this._$colors=t}this._$doChanged()}}get distance(){return this._$distance}set distance(t){(t=Y(+t,-255,255,4))!==this._$distance&&(this._$distance=t,this._$doChanged())}get knockout(){return this._$knockout}set knockout(t){t!==this._$knockout&&(this._$knockout=!!t,this._$doChanged())}get quality(){return this._$blurFilter.quality}set quality(t){this._$blurFilter.quality=t}get ratios(){return this._$ratios}set ratios(t){if(this._$ratios!==t){if(this._$ratios=t,s.isArray(t)){for(let e=0;e<t.length;++e)t[e]=Y(+t[e],0,255,0);this._$ratios=t}this._$doChanged()}}get strength(){return this._$strength}set strength(t){(t=Y(0|t,0,255,0))!==this._$strength&&(this._$strength=t,this._$doChanged())}get type(){return this._$type}set type(t){t!==this._$type&&(this._$type=t,this._$doChanged())}clone(){return new ut(this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$toArray(){return N(8,this._$distance,this._$angle,this._$colors,this._$alphas,this._$ratios,this._$blurFilter.blurX,this._$blurFilter.blurY,this._$strength,this._$blurFilter.quality,this._$type,this._$knockout)}_$isUpdated(){return this._$updated||this._$blurFilter._$isUpdated()}_$generateFilterRect(t,e=0,s=0){let r=t.clone();if(!this._$canApply())return r;r=this._$blurFilter._$generateFilterRect(r,e,s);const n=this._$angle*m,a=i.abs(i.cos(n)*this._$distance),h=i.abs(i.sin(n)*this._$distance);return r.x+=-a,r.width+=a,r.y+=-h,r.height+=2*h,r}_$canApply(){return this._$strength>0&&this._$distance>0&&null!==this._$alphas&&null!==this._$ratios&&null!==this._$colors&&this._$blurFilter._$canApply()}_$applyFilter(t,e){this._$updated=!1;const s=t.frameBuffer,r=s.currentAttachment;if(t.setTransform(1,0,0,1,0,0),!this._$canApply()||!r)return s.getTextureFromCurrentAttachment();const n=r.width,a=r.height,h=t._$offsetX,o=t._$offsetY,l=this._$blurFilter._$applyFilter(t,e,!1),_=l.width,c=l.height,$=t._$offsetX,u=t._$offsetY,d=$-h,g=u-o,f=i.sqrt(e[0]*e[0]+e[1]*e[1]),p=i.sqrt(e[2]*e[2]+e[3]*e[3]),x=+this._$angle*m,b=+i.cos(x)*this._$distance*f,v=+i.sin(x)*this._$distance*p,T="inner"===this.type,A=T?n:_+i.max(0,i.abs(b)-d),y=T?a:c+i.max(0,i.abs(v)-g),M=i.ceil(A),E=i.ceil(y),w=(M-A)/2,C=(E-y)/2,S=T?0:i.max(0,d-b)+w,B=T?0:i.max(0,g-v)+C,F=T?b-$:(b>0?i.max(0,b-d):0)+w,R=T?v-u:(v>0?i.max(0,v-g):0)+C;return t._$bind(r),t._$applyBitmapFilter(l,M,E,n,a,S,B,_,c,F,R,!0,this._$type,this._$knockout,this._$strength,this._$ratios,this._$colors,this._$alphas,0,0,0,0,0,0,0,0),t._$offsetX=h+S,t._$offsetY=o+B,s.releaseTexture(l),s.getTextureFromCurrentAttachment()}}class dt{constructor(){this._$instanceId=-1,this._$parentId=-1,this._$loaderInfoId=-1,this._$characterId=-1,this._$clipDepth=0,this._$depth=0,this._$isMask=!1,this._$updated=!0,this._$matrix=R(1,0,0,1,0,0),this._$colorTransform=P(1,1,1,1,0,0,0,0),this._$blendMode="normal",this._$filters=null,this._$visible=!0,this._$maskId=-1,this._$maskMatrix=null,this._$isMask=!1,this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$scale9Grid=null,this._$matrixBase=null}_$shouldClip(t){const e=this._$getBounds(t),s=i.abs(e.xMax-e.xMin),r=i.abs(e.yMax-e.yMin);return S(e),!(!s||!r)}_$getLayerBounds(t=null){const e=this._$getBounds(t),i=this._$filters;if(!i||!i.length)return e;let s=new it(e.xMin,e.yMin,e.xMax-e.xMin,e.yMax-e.yMin);S(e);for(let t=0;t<i.length;++t)s=i[t]._$generateFilterRect(s,0,0);const r=s.x,n=s.x+s.width,a=s.y,h=s.y+s.height;return C(r,n,a,h)}_$getBounds(t=null){const e=C(this._$xMin,this._$xMax,this._$yMin,this._$yMax);if(!t)return e;let i=t;const s=this._$matrix;1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=G(t,s));const r=W(e,i);return S(e),i!==t&&I(i),r}_$startClip(t,e){let i=null;if(!t.cacheAttachment){let s=e;const r=this._$matrix;1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(s=G(e,r));const n=this._$getBounds(null),a=W(n,s);if(S(n),i=t._$startClip(e,a),S(a),s!==e&&I(s),!i)return!1}t._$enterClip(),t._$beginClipDef();let s=!1;return"_$children"in this&&(s=!0,t._$updateContainerClipFlag(!0)),this._$clip(t,i||e),this._$updated=!1,s&&(t._$updateContainerClipFlag(!1),t._$drawContainerClip()),t._$endClipDef(),i}_$update(t){if(this._$updated=!0,this._$visible=t.visible,this._$isMask=t.isMask,this._$depth=t.depth,this._$clipDepth=t.clipDepth,this._$maskId=t.maskId,this._$maskId>-1&&t.maskMatrix&&(this._$maskMatrix=t.maskMatrix),this._$matrix[0]="a"in t?t.a:1,this._$matrix[1]="b"in t?t.b:0,this._$matrix[2]="c"in t?t.c:0,this._$matrix[3]="d"in t?t.d:1,this._$matrix[4]="tx"in t?t.tx:0,this._$matrix[5]="ty"in t?t.ty:0,this._$colorTransform[0]="f0"in t?t.f0:1,this._$colorTransform[1]="f1"in t?t.f1:1,this._$colorTransform[2]="f2"in t?t.f2:1,this._$colorTransform[3]="f3"in t?t.f3:1,this._$colorTransform[4]="f4"in t?t.f4:0,this._$colorTransform[5]="f5"in t?t.f5:0,this._$colorTransform[6]="f6"in t?t.f6:0,this._$colorTransform[7]="f7"in t?t.f7:0,this._$blendMode=t.blendMode||"normal",this._$filters=null,t.filters&&t.filters.length){this._$filters=N();for(let e=0;e<t.filters.length;++e){const i=t.filters[e];switch(i.shift()){case 0:this._$filters.push(new at(...i));break;case 1:this._$filters.push(new nt(...i));break;case 2:this._$filters.push(new ht(...i));break;case 3:this._$filters.push(new ot(...i));break;case 4:this._$filters.push(new lt(...i));break;case 5:this._$filters.push(new _t(...i));break;case 6:this._$filters.push(new ct(...i));break;case 7:this._$filters.push(new $t(...i));break;case 8:this._$filters.push(new ut(...i))}}}t.grid&&(this._$scale9Grid=new it(t.grid.x,t.grid.y,t.grid.w,t.grid.h),t.matrixBase&&(this._$matrixBase=t.matrixBase))}_$canApply(t=null){if(t)for(let e=0;e<t.length;++e)if(t[e]._$canApply())return!0;return!1}_$remove(){const t=oe,e=t.cacheStore;e.setRemoveTimer(this._$instanceId),this._$loaderInfoId>-1&&this._$characterId&&e.setRemoveTimer(`${this._$loaderInfoId}@${this._$characterId}`),t.instances.delete(this._$instanceId),this._$instanceId=-1,this._$parentId=-1,this._$loaderInfoId=-1,this._$characterId=-1,this._$updated=!0,this._$blendMode="normal",this._$filters=null,this._$visible=!0,this._$maskId=-1,this._$isMask=!1,this._$depth=0,this._$clipDepth=0,this._$scale9Grid=null}_$isUpdated(){return this._$updated}_$isFilterUpdated(t,e,s,r=null,n=!1,a=0,h=0){if(this._$isUpdated())return!0;if(r&&n)for(let t=0;t<r.length;++t)if(r[t]._$isUpdated())return!0;const o=oe.cacheStore.get([this._$instanceId,"f"]);if(!o)return!0;switch(!0){case o.filterState!==n:case o.layerWidth!==i.ceil(t):case o.layerHeight!==i.ceil(e):case o.matrix!==s[0]+"_"+s[1]+"_"+s[2]+"_"+s[3]+"_"+a+"_"+h:return!0;default:return!1}}_$applyFilter(t,e,s,r,n,a){const h=+i.sqrt(r[0]*r[0]+r[1]*r[1]),o=+i.sqrt(r[2]*r[2]+r[3]*r[3]),l=i.atan2(r[1],r[0]),_=i.atan2(0-r[2],r[3]),c=R(i.cos(l),i.sin(l),0-i.sin(_),i.cos(_),n/2,a/2),$=R(1,0,0,1,0-s.width/2,0-s.height/2),u=G(c,$);I(c),I($);const d=t.frameBuffer,g=d.currentAttachment,f=d.createCacheAttachment(n,a);t._$bind(f),t.reset(),t.setTransform(u[0],u[1],u[2],u[3],u[4],u[5]),I(u),t.drawImage(s,0,0,s.width,s.height),t._$offsetX=0,t._$offsetY=0;const p=R(h,0,0,o,0,0);let m=null;for(let i=0;i<e.length;++i)m=e[i]._$applyFilter(t,p);if(I(p),!m)return s;const x=t._$offsetX,b=t._$offsetY;return t._$offsetX=0,t._$offsetY=0,m._$offsetX=x,m._$offsetY=b,m.matrix=r[0]+"_"+r[1]+"_"+r[2]+"_"+r[3],m.filterState=!0,m.layerWidth=n,m.layerHeight=a,t._$bind(g),d.releaseAttachment(f,!1),m}_$drawFilter(t,e,i,s,r,n){const a=oe.cacheStore,h=[this._$instanceId,"f"],o=a.get(h),l=this._$isFilterUpdated(r,n,i,s,!0);if(o&&!l)return o;if(o&&(a.set(h,null),o.layerWidth=0,o.layerHeight=0,o._$offsetX=0,o._$offsetY=0,o.matrix=null,o.colorTransform=null,t.frameBuffer.releaseTexture(o)),!o||l){const o=this._$applyFilter(t,s,e,i,r,n);return a.set(h,o),o}return o}}class gt extends dt{constructor(){super(),this._$recodes=null,this._$maxAlpha=0,this._$canDraw=!1}_$clip(t,e){this._$recodes&&(t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),this._$runCommand(t,this._$recodes,null,!0),t.clip())}_$draw(t,s,r,a="normal",h=null){if(!(this._$visible&&this._$recodes&&this._$maxAlpha&&this._$canDraw))return;const o=Y(r[3]+r[7]/255,0,1,0);if(!o)return;const l=this._$matrix;let _=null!==this._$scale9Grid;_&&(_=_&&i.abs(l[1])<.001&&i.abs(l[2])<1e-4);const c=C(this._$xMin,this._$xMax,this._$yMin,this._$yMax),$=W(c,s),u=$.xMax,d=$.xMin,g=$.yMax,f=$.yMin;S($);const p=i.ceil(i.abs(u-d)),m=i.ceil(i.abs(g-f));switch(!0){case 0===p:case 0===m:case p===-1/0:case m===-1/0:case p===e:case m===e:return}const x=t.frameBuffer,b=x.currentAttachment;if(!b||d>b.width||f>b.height)return;let v=+i.sqrt(s[0]*s[0]+s[1]*s[1]);if(!n.isInteger(v)){const t=v.toString(),e=t.indexOf("e");-1!==e&&(v=+t.slice(0,e)),v=+v.toFixed(4)}let T=+i.sqrt(s[2]*s[2]+s[3]*s[3]);if(!n.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}if(0>d+p||0>f+m){if(!(h&&h.length&&this._$canApply(h)))return;{let t=new it(0,0,p,m);for(let e=0;e<h.length;++e)t=h[e]._$generateFilterRect(t,v,T);if(0>t.x+t.width||0>t.y+t.height)return}}const A=N(v,T);let y=`${this._$instanceId}`;!_&&this._$loaderInfoId>-1&&this._$characterId>-1&&(y=`${this._$loaderInfoId}@${this._$characterId}`);const M=oe.cacheStore,E=M.generateKeys(y,A,r);U(A);let w=M.get(E);if(!w){let e=i.ceil(i.abs(c.xMax-c.xMin)*v),n=i.ceil(i.abs(c.yMax-c.yMin)*T);const a=t._$getTextureScale(e,n);a<1&&(e*=a,n*=a);const h=x.createCacheAttachment(e,n,!0);if(t._$bind(h),t.reset(),t.setTransform(v,0,0,T,0-c.xMin*v,0-c.yMin*T),_){const e=oe.scaleX,r=R(e,0,0,e,0,0),n=G(r,l);I(r);const a=this._$matrixBase,h=R(a[0],a[1],a[2],a[3],a[4]*e-d,a[5]*e-f),o=G(h,n),_=o[4]-(s[4]-d),$=o[5]-(s[5]-f);I(o);const u=W(c,n),g=+u.xMax,p=+u.xMin,m=+u.yMax,x=+u.yMin,b=i.ceil(i.abs(g-p)),v=i.ceil(i.abs(m-x));S(u),t.grid.enable(p,x,b,v,c,this._$scale9Grid,e,n[0],n[1],n[2],n[3],n[4],n[5],h[0],h[1],h[2],h[3],h[4]-_,h[5]-$),I(n),I(h)}r[3]=1,this._$runCommand(t,this._$recodes,r,!1),_&&t.grid.disable(),w=x.getTextureFromCurrentAttachment(),M.set(E,w),x.releaseAttachment(h,!1),t._$bind(b)}let B=!1,F=0,P=0;h&&h.length&&this._$canApply(h)&&(B=!0,w=this._$drawFilter(t,w,s,h,p,m),F=w._$offsetX,P=w._$offsetY);const k=i.atan2(s[1],s[0]),L=i.atan2(0-s[2],s[3]);if(B||!k&&!L)t.setTransform(1,0,0,1,d-F,f-P);else{const e=c.xMin*v,r=c.yMin*T,n=i.cos(k),a=i.sin(k),h=i.cos(L),o=i.sin(L);t.setTransform(n,a,0-o,h,e*n-r*o+s[4],e*a+r*h+s[5])}t.reset(),t.globalAlpha=o,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=a,t.drawImage(w,0,0,w.width,w.height,r),U(E),S(c)}setupStroke(t,e,i,s,r){switch(t.lineWidth=e,i){case 0:t.lineCap="none";break;case 1:t.lineCap="round";break;case 2:t.lineCap="square"}switch(s){case 0:t.lineJoin="bevel";break;case 1:t.lineJoin="miter";break;case 2:t.lineJoin="round"}t.miterLimit=r}createGradientStyle(t,e,s,r,n,a,h,o=null){let l,_="pad";switch(n){case 0:_="reflect";break;case 1:_="repeat"}if(0===e){const e=(t=>{const e=-819.2*t[0]-819.2*t[2]+t[4],s=819.2*t[0]-819.2*t[2]+t[4],r=-819.2*t[0]+819.2*t[2]+t[4],n=-819.2*t[1]-819.2*t[3]+t[5],a=819.2*t[1]-819.2*t[3]+t[5];let h=r-e,o=-819.2*t[1]+819.2*t[3]+t[5]-n;const l=i.sqrt(h*h+o*o);l?(h/=l,o/=l):(h=0,o=0);const _=(s-e)*h+(a-n)*o;return B(e+_*h,n+_*o,s,a)})(r);l=t.createLinearGradient(e[0],e[1],e[2],e[3],a?"rgb":"linearRGB",_)}else t.save(),t.transform(r[0],r[1],r[2],r[3],r[4],r[5]),l=t.createRadialGradient(0,0,0,0,0,819.2,a?"rgb":"linearRGB",_,h);for(let t=0;t<s.length;++t){const e=s[t];let r=e.A;o&&(1===o[3]&&0===o[7]||(r=0|i.max(0,i.min(e.A*o[3]+o[7],255)))),l.addColorStop(e.ratio,B(e.R,e.G,e.B,r))}return l}_$runCommand(t,e,s=null,r=!1){t.reset(),t.beginPath();const n=e.length;for(let a=0;a<n;)switch(e[a++]){case 9:t.beginPath();break;case 0:t.moveTo(e[a++],e[a++]);break;case 2:t.lineTo(e[a++],e[a++]);break;case 1:t.quadraticCurveTo(e[a++],e[a++],e[a++],e[a++]);break;case 5:{if(r){a+=4;continue}const n=B();n[0]=e[a++]/255,n[1]=e[a++]/255,n[2]=e[a++]/255,n[3]=e[a++]/255,null!==s&&(1===s[3]&&0===s[7]||(n[3]=i.max(0,i.min(n[3]*s[3]+s[7],255))/255)),t.fillStyle=n}break;case 7:r||t.fill();break;case 6:{if(r){a+=8;continue}this.setupStroke(t,e[a++],e[a++],e[a++],e[a++]);const n=B();n[0]=e[a++]/255,n[1]=e[a++]/255,n[2]=e[a++]/255,n[3]=e[a++]/255,null!==s&&(1===s[3]&&0===s[7]||(n[3]=i.max(0,i.min(n[3]*s[3]+s[7],255))/255)),t.strokeStyle=n}break;case 8:r||t.stroke();break;case 12:t.closePath();break;case 3:t.bezierCurveTo(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);break;case 4:t.arc(e[a++],e[a++],e[a++]);break;case 10:{if(r){a+=1;const t=e[a++];a+=5*t,a+=9;continue}const i=e[a++];let n=e[a++];const h=N();for(;n;)h.push({ratio:e[a++],R:e[a++],G:e[a++],B:e[a++],A:e[a++]}),n--;const o=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);t.fillStyle=this.createGradientStyle(t,i,h,o,e[a++],e[a++],e[a++],s),t.fill(),1===i&&t.restore(),I(o),U(h)}break;case 11:{if(r){a+=5;const t=e[a++];a+=5*t,a+=9;continue}this.setupStroke(t,e[a++],e[a++],e[a++],e[a++]);const i=e[a++];let n=e[a++];const h=N();for(;n;)h.push({ratio:e[a++],R:e[a++],G:e[a++],B:e[a++],A:e[a++]}),n--;const o=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);t.strokeStyle=this.createGradientStyle(t,i,h,o,e[a++],e[a++],e[a++],s),t.stroke(),1===i&&t.restore(),I(o),U(h)}break;case 13:{const i=e[a++],n=e[a++],h=e[a++],o=e[a++],l=e[a++];if(r){a+=l,a+=8;continue}const _=new Uint8Array(e.subarray(a,l+a));a+=l;const c=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]),$=!!e[a++],u=!!e[a++];t.save(),1===c[0]&&0===c[1]&&0===c[2]&&1===c[3]&&0===c[4]&&0===c[5]||t.transform(c[0],c[1],c[2],c[3],c[4],c[5]),I(c);const d=t.frameBuffer,g=d.createTextureFromPixels(i,n,_,!0);$||i!==h||n!==o?(t.fillStyle=t.createPattern(g,$,s||P()),t.imageSmoothingEnabled=u,t.fill()):(t.drawImage(g,0,0,i,n),d.releaseTexture(g)),t.restore(),t.imageSmoothingEnabled=!1}break;case 14:{if(r){a+=4;const t=e[a++];a+=t,a+=8;continue}t.save(),this.setupStroke(t,e[a++],e[a++],e[a++],e[a++]);const i=e[a++],n=e[a++],h=e[a++],o=new Uint8Array(e.subarray(a,h+a));a+=h;const l=R(e[a++],e[a++],e[a++],e[a++],e[a++],e[a++]);1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||t.transform(l[0],l[1],l[2],l[3],l[4],l[5]),I(l);const _=!!e[a++],c=!!e[a++],$=t.frameBuffer.createTextureFromPixels(i,n,o,!0);t.strokeStyle=t.createPattern($,_,s||P()),t.imageSmoothingEnabled=c,t.stroke(),t.restore(),t.imageSmoothingEnabled=!1}}}_$update(t){if(super._$update(t),t.recodes){this._$recodes=t.recodes,this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,this._$maxAlpha=t.maxAlpha,this._$canDraw=t.canDraw;const e=oe.cacheStore;e.removeCache(this._$instanceId),this._$loaderInfoId>-1&&this._$characterId>-1&&e.removeCache(`${this._$loaderInfoId}@${this._$characterId}`)}}}class ft extends gt{constructor(){super(),this._$children=N()}_$clip(t,e){let i=e;const s=this._$matrix;1===s[0]&&0===s[1]&&0===s[2]&&1===s[3]&&0===s[4]&&0===s[5]||(i=G(e,s)),this._$recodes&&this._$canDraw&&super._$clip(t,i);const r=oe.instances,n=this._$children;for(let e=0;e<this._$children.length;++e){const s=n[e];if(!r.has(s))continue;const a=r.get(s);a&&!a._$isMask&&(a._$clip(t,i),a._$updated=!1)}i!==e&&I(i)}_$draw(t,e,s){if(!this._$visible)return;let r=s;const n=this._$colorTransform;if(1===n[0]&&1===n[1]&&1===n[2]&&1===n[3]&&0===n[4]&&0===n[5]&&0===n[6]&&0===n[7]||(r=z(s,n)),!Y(r[3]+r[7]/255,0,1,0))return;const a=this._$children,h=a.length;if(!(h||this._$recodes&&this._$canDraw))return;const o=this._$preDraw(t,e);if(!o)return;if(o.isFilter&&!o.isUpdated)return void this._$postDraw(t,e,r,o);let l=o.matrix;const _=o.isFilter&&o.color?o.color:r;this._$recodes&&this._$canDraw&&this._$maxAlpha>0&&super._$draw(t,l,_);let c=!0,$=0;const u=N(),g=N(),f=N(),p=N(),m=oe.instances,x=t.isLayer;for(let e=0;e<h;++e){const s=a[e];if(!m.has(s))continue;const r=m.get(s);if(r._$isMask)continue;const n=r._$blendMode;if(("alpha"===n||"erase"===n)&&!x)continue;if($&&(r._$placeId>$||r._$clipDepth>0)){if(t.restore(),c&&(t._$leaveClip(),u.length)){const t=u.pop();t&&(I(l),l=t)}$=f.length&&f.pop()||0,c=!!p.pop()}if(!c)continue;if(r._$clipDepth>0){if(t.save(),$&&f.push($),p.push(c),$=r._$clipDepth,c=r._$shouldClip(l),c){const e=r._$startClip(t,l);if(!1===e){c=!1;continue}e instanceof Float32Array&&(u.push(l),l=e)}continue}const h=r._$maskId>-1&&m.has(r._$maskId)?m.get(r._$maskId):null;if(h){let e;if(h._$updated=!1,this._$instanceId===h._$parentId)e=l;else{e=d;let i=m.get(h._$parentId);for(;i||i._$instanceId!==i._$parentId;)e=G(i._$matrix,e),i=m.get(i._$parentId);const s=oe.scaleX,r=R(s,0,0,s,0,0);if(e=G(r,e),I(r),t.isLayer){const i=t.getCurrentPosition();e[4]-=i.xMin,e[5]-=i.yMin}t.cacheBounds&&(e[4]-=t.cacheBounds.xMin,e[5]-=t.cacheBounds.yMin)}if(!h._$shouldClip(e))continue;const s=h._$startClip(t,e);if(t.save(),!1===s){t.restore();continue}if(s instanceof Float32Array){if(g.push(l),this!==h._$parent){const e=this._$matrix;s[0]=i.abs(l[0])*i.sign(e[0]),s[1]=i.abs(l[1])*i.sign(e[1]),s[2]=i.abs(l[2])*i.sign(e[2]),s[3]=i.abs(l[3])*i.sign(e[3]),s[4]=l[4]-t.cacheBounds.xMin,s[5]=l[5]-t.cacheBounds.yMin}l=s}}if(r._$draw(t,l,_),r._$updated=!1,h&&(t.restore(),t._$leaveClip(),g.length)){const t=g.pop();t&&(I(l),l=t)}}if($&&(t.restore(),p.pop()&&t._$leaveClip()),U(u),U(g),U(f),U(p),o.isFilter)return this._$postDraw(t,e,r,o);o.matrix!==e&&I(o.matrix),r!==s&&k(r),Z(o)}_$getLayerBounds(t=null){let e=d;if(t){e=t;const i=this._$matrix;i!==d&&(e=G(t,i))}const s=!!this._$recodes,r=this._$children;if(!r.length&&!s){const i=C(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&I(e),i}const a=n.MAX_VALUE;let h=a,o=-a,l=a,_=-a;if(s){const t=C(this._$xMin,this._$xMax,this._$yMin,this._$yMax),i=W(t,e);S(t),h=+i.xMin,o=+i.xMax,l=+i.yMin,_=+i.yMax,S(i)}const c=oe.instances;for(let t=0;t<r.length;++t){const s=r[t];if(!c.has(s))continue;const n=c.get(s)._$getLayerBounds(e);h=i.min(h,n.xMin),o=i.max(o,n.xMax),l=i.min(l,n.yMin),_=i.max(_,n.yMax),S(n)}if(t&&e!==t&&I(e),!t)return C(h,o,l,_);if(!this._$filters)return C(h,o,l,_);let $=new it(h,l,o-h,_-l);for(let t=0;t<this._$filters.length;++t)$=this._$filters[t]._$generateFilterRect($,0,0);return h=$.x,o=$.x+$.width,l=$.y,_=$.y+$.height,C(h,o,l,_)}_$getBounds(t=null){let e=d;if(t){e=t;const i=this._$matrix;1===i[0]&&0===i[1]&&0===i[2]&&1===i[3]&&0===i[4]&&0===i[5]||(e=G(t,i))}const s=!!this._$recodes,r=this._$children;if(!r.length&&!s){const i=C(e[4],-e[4],e[5],-e[5]);return t&&e!==t&&I(e),i}const a=n.MAX_VALUE;let h=a,o=-a,l=a,_=-a;if(s){const t=C(this._$xMin,this._$xMax,this._$yMin,this._$yMax);S(t);const i=W(t,e);h=i.xMin,o=i.xMax,l=i.yMin,_=i.yMax,S(i)}const c=oe.instances;for(let t=0;t<r.length;++t){const s=r[t];if(!c.has(s))continue;const n=c.get(s)._$getBounds(e);h=i.min(h,n.xMin),o=i.max(o,n.xMax),l=i.min(l,n.yMin),_=i.max(_,n.yMax),S(n)}return t&&e!==t&&I(e),C(h,o,l,_)}_$preDraw(t,e){let s=e;const r=this._$matrix;if(1===r[0]&&0===r[1]&&0===r[2]&&1===r[3]&&0===r[4]&&0===r[5]||(s=G(e,r)),!s[0]&&!s[1]||!s[2]&&!s[3])return null;const n=x.pop()||{isFilter:!1,isUpdated:null,canApply:null,matrix:null,color:null,basePosition:{x:0,y:0},position:{dx:0,dy:0},baseMatrix:null,baseColor:null,blendMode:"normal",filters:null,layerWidth:0,layerHeight:0};n.matrix=s;const a=this._$blendMode;if("normal"!==a||this._$filters&&this._$filters.length>0){const e=this._$getBounds(null),h=W(e,s);S(e);const o=+h.xMax,l=+h.xMin,_=+h.yMax,c=+h.yMin;S(h);const $=i.abs(o-l),u=i.abs(_-c);if(0>=$||0>=u)return Z(n),null;if(0>l+$||0>c+u)return Z(n),null;const d=t.frameBuffer.currentAttachment;if(!d||!d.texture||l>d.width||c>d.height)return Z(n),null;n.basePosition.x=r[4],n.basePosition.y=r[5];const g=this._$getLayerBounds(null),f=W(g,s);let p=i.abs(f.xMax-f.xMin),m=i.abs(f.yMax-f.yMin);S(f);let x=s[4]-i.floor(l),b=s[5]-i.floor(c),v=i.floor(l),T=i.floor(c),A=l,y=c;if(p!==$||m!==u){const t=R(s[0],s[1],s[2],s[3],0,0),e=W(g,t);I(t),x+=-i.floor(e.xMin)-x,b+=-i.floor(e.yMin)-b,v-=-i.floor(e.xMin)-(s[4]-v),T-=-i.floor(e.yMin)-(s[5]-T),A-=-e.xMin-(s[4]-A),y-=-e.yMin-(s[5]-y),S(e)}if(S(g),n.position.dx=v>0?v:0,n.position.dy=T>0?T:0,p+A>d.texture.width&&(p-=p-d.texture.width+A),m+y>d.texture.height&&(m-=m-d.texture.height+y),0>v&&(x+=v,p+=A),0>T&&(b+=T,m+=y),0>=p||0>=m||!p||!m)return Z(n),null;t._$startLayer(C(A,0,y,0)),n.canApply=this._$canApply(this._$filters);const M=this._$isFilterUpdated(p,m,s,this._$filters,n.canApply,n.basePosition.x,n.basePosition.y);t._$saveCurrentMask(),M&&t._$saveAttachment(i.ceil(p),i.ceil(m),!1),n.isFilter=!0,n.isUpdated=M,n.color=P(),n.baseMatrix=s,n.filters=this._$filters,n.blendMode=a,n.layerWidth=p,n.layerHeight=m,n.matrix=R(s[0],s[1],s[2],s[3],x,b)}return n}_$postDraw(t,e,i,s){const r=N(this._$instanceId,"f"),n=oe.cacheStore,a=t.frameBuffer;let h;if(s.isUpdated){h=a.getTextureFromCurrentAttachment();const t=n.get(r);t&&(n.set(r,null),a.releaseTexture(t))}else if(h=n.get(r),!h)throw new Error("the texture is null.");s.canApply||(h._$offsetX=0,h._$offsetY=0);let o=h._$offsetX,l=h._$offsetY;if(s.isUpdated&&s.canApply){const i=n.get(r);i&&(n.set(r,null),i.layerWidth=0,i.layerHeight=0,i._$offsetX=0,i._$offsetY=0,i.matrix=null,i.colorTransform=null,a.releaseTexture(i));const _=s.filters;if(_&&_.length){t._$offsetX=0,t._$offsetY=0;for(let i=0;i<_.length;++i)h=_[i]._$applyFilter(t,e);o=t._$offsetX,l=t._$offsetY,t._$offsetX=0,t._$offsetY=0,h._$offsetX=o,h._$offsetY=l}}if(s.isUpdated){h.filterState=s.canApply;const t=s.baseMatrix;t&&(h.matrix=`${t[0]}_${t[1]}_${t[2]}_${t[3]}`),h.layerWidth=s.layerWidth,h.layerHeight=s.layerHeight}n.set(r,h),U(r),s.isUpdated&&t._$restoreAttachment(),t.reset(),t.globalAlpha=Y(i[3]+i[7]/255,0,1),t.globalCompositeOperation=s.blendMode,t.setTransform(1,0,0,1,0,0),t.drawImage(h,-o+s.position.dx,-l+s.position.dy,h.width,h.height,i),t._$endLayer(),t._$restoreCurrentMask(),s.baseMatrix!==e&&I(s.baseMatrix),I(s.matrix),Z(s)}_$remove(){this._$children.length=0,this._$recodes=null,super._$remove(),ce.push(this)}}class pt{constructor(){this._$rgb="rgb",this._$mode="pad",this._$type="linear",this._$focalPointRatio=0,this._$points=R(),this._$stops=N()}dispose(){const t=this._$stops;for(let e=0;e<t.length;++e)F(t[e][1]);I(this._$points)}get mode(){return this._$mode}get type(){return this._$type}get rgb(){return this._$rgb}get points(){return this._$points}get focalPointRatio(){return this._$focalPointRatio}get stops(){return this._$stops.sort(((t,e)=>{switch(!0){case t[0]>e[0]:return 1;case e[0]>t[0]:return-1;default:return 0}})),this._$stops}linear(t,e,i,s,r="rgb",n="pad"){return this._$type="linear",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$rgb=r,this._$mode=n,this._$stops.length&&(this._$stops.length=0),this}radial(t,e,i,s,r,n,a="rgb",h="pad",o=0){return this._$type="radial",this._$points[0]=t,this._$points[1]=e,this._$points[2]=i,this._$points[3]=s,this._$points[4]=r,this._$points[5]=n,this._$rgb=a,this._$mode=h,this._$focalPointRatio=Y(o,-.975,.975,0),this._$stops.length&&(this._$stops.length=0),this}addColorStop(t,e){this._$stops.push(N(t,e))}}class mt{constructor(t,e,i,s){this._$context=t,this._$texture=e,this._$repeat=i,this._$colorTransform=s}dispose(){this._$context.frameBuffer.releaseTexture(this._$texture)}get texture(){return this._$texture}get repeat(){return this._$repeat}get colorTransform(){return this._$colorTransform}}class xt{constructor(){this._$fillStyle=B(1,1,1,1),this._$strokeStyle=B(1,1,1,1),this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5}get miterLimit(){return this._$miterLimit}set miterLimit(t){this._$miterLimit=t}get lineWidth(){return this._$lineWidth}set lineWidth(t){this._$lineWidth=t}get lineCap(){return this._$lineCap}set lineCap(t){this._$lineCap=t}get lineJoin(){return this._$lineJoin}set lineJoin(t){this._$lineJoin=t}get fillStyle(){return this._$fillStyle}set fillStyle(t){this._$fillStyle instanceof a&&F(this._$fillStyle),this._$fillStyle=t}get strokeStyle(){return this._$strokeStyle}set strokeStyle(t){this._$strokeStyle instanceof a&&F(this._$strokeStyle),this._$strokeStyle=t}clear(){this._$lineWidth=1,this._$lineCap="round",this._$lineJoin="round",this._$miterLimit=5,this._$clearFill(),this._$clearStroke()}_$clearFill(){return this._$fillStyle instanceof pt||this._$fillStyle instanceof mt?(this._$fillStyle.dispose(),void(this._$fillStyle=B(1,1,1,1))):void this._$fillStyle.fill(1)}_$clearStroke(){return this._$strokeStyle instanceof pt||this._$strokeStyle instanceof mt?(this._$strokeStyle.dispose(),void(this._$strokeStyle=B(1,1,1,1))):void this._$strokeStyle.fill(1)}}class bt{constructor(t){this._$gl=t,this._$objectPool=[],this._$objectPoolArea=0,this._$activeTexture=-1,this._$boundTextures=[null,null,null],this._$maxWidth=0,this._$maxHeight=0,this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT,1),this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0)}_$createTexture(t,e){const i=this._$gl.createTexture();return i.width=0,i.height=0,i.area=0,i.dirty=!0,i.smoothing=!0,i._$offsetX=0,i._$offsetY=0,this.bind0(i,!1),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_S,this._$gl.CLAMP_TO_EDGE),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_WRAP_T,this._$gl.CLAMP_TO_EDGE),i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.texStorage2D(this._$gl.TEXTURE_2D,1,this._$gl.RGBA8,t,e),i}_$getTexture(t,e){for(let i=0;i<this._$objectPool.length;i++){const s=this._$objectPool[i];if(s.width===t&&s.height===e)return this._$objectPool.splice(i,1),this._$objectPoolArea-=s.area,this.bind0(s,!1),s}return this._$createTexture(t,e)}create(t,e,i=null,s=!1,r=!0){const n=this._$getTexture(t,e);return s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!1),n.width!==t||n.height!==e?(n.width=t,n.height=e,n.area=t*e,n.dirty=!1,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,t,e,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):i&&(n.dirty=!1,this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,t,e,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)),s&&this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r||this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL,!0),n}createFromImage(t,e=!1){return this._$createFromElement(t.width,t.height,t,e)}createFromCanvas(t){return this._$createFromElement(t.width,t.height,t,!1)}createFromVideo(t,e=!1){return this._$createFromElement(t.videoWidth,t.videoHeight,t,e)}_$createFromElement(t,e,i,s=!1){const r=this._$getTexture(t,e);return r.dirty=!1,this.bind0(r,s),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),r.width!==t||r.height!==e?(r.width=t,r.height=e,r.area=t*e,this._$gl.texImage2D(this._$gl.TEXTURE_2D,0,this._$gl.RGBA,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i)):this._$gl.texSubImage2D(this._$gl.TEXTURE_2D,0,0,0,this._$gl.RGBA,this._$gl.UNSIGNED_BYTE,i),this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteTexture(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPool.length&&this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();this._$objectPoolArea-=t.area,this._$gl.deleteTexture(t)}}bind0(t,e=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,e)}bind01(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,null,null),this._$bindTexture(1,this._$gl.TEXTURE1,e,i),this._$bindTexture(0,this._$gl.TEXTURE0,t,i)}bind012(t,e,i,s=null){this._$bindTexture(2,this._$gl.TEXTURE2,i,s),this._$bindTexture(1,this._$gl.TEXTURE1,e,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}bind02(t,e,i=null){this._$bindTexture(2,this._$gl.TEXTURE2,e,i),this._$bindTexture(1,this._$gl.TEXTURE1,null,null),this._$bindTexture(0,this._$gl.TEXTURE0,t,null)}_$bindTexture(t,e,i=null,s=null){const r=i!==this._$boundTextures[t],n=null!==s&&null!==i&&s!==i.smoothing;if((r||n||e===this._$gl.TEXTURE0)&&e!==this._$activeTexture&&(this._$activeTexture=e,this._$gl.activeTexture(e)),r&&(this._$boundTextures[t]=i,this._$gl.bindTexture(this._$gl.TEXTURE_2D,i)),n){i&&(i.smoothing=!!s);const t=s?this._$gl.LINEAR:this._$gl.NEAREST;this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MIN_FILTER,t),this._$gl.texParameteri(this._$gl.TEXTURE_2D,this._$gl.TEXTURE_MAG_FILTER,t)}}}class vt{constructor(t){this._$gl=t,this._$objectPool=N(),this._$objectPoolArea=0,this._$maxWidth=0,this._$maxHeight=0}set maxWidth(t){this._$maxWidth=t}set maxHeight(t){this._$maxHeight=t}_$createStencilBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the stencil buffer is null.");return t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getStencilBuffer(t,e){const i=this._$objectPool.length;for(let s=0;s<i;++s){const i=this._$objectPool[s];if(i.width===t&&i.height===e)return this._$objectPool.splice(s,1),this._$objectPoolArea-=i.area,i}if(i>100){const t=this._$objectPool.shift();if(t)return this._$objectPoolArea-=t.area,t}return this._$createStencilBuffer()}create(t,e){const i=this._$getStencilBuffer(t,e);return i.width===t&&i.height===e||(i.width=t,i.height=e,i.area=t*e,i.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,i),this._$gl.renderbufferStorage(this._$gl.RENDERBUFFER,this._$gl.STENCIL_INDEX8,t,e)),i}release(t){if(t.area>this._$maxWidth*this._$maxHeight*2)this._$gl.deleteRenderbuffer(t);else if(t.dirty=!0,this._$objectPool.push(t),this._$objectPoolArea+=t.area,this._$objectPoolArea>this._$maxWidth*this._$maxHeight*10){const t=this._$objectPool.shift();t&&(this._$objectPoolArea-=t.area,this._$gl.deleteRenderbuffer(t))}}}class Tt{constructor(t,e){this._$gl=t,this._$samples=e,this._$objectPool=N()}set samples(t){this._$samples=t}_$createColorBuffer(){const t=this._$gl.createRenderbuffer();if(!t)throw new Error("the color buffer is null.");const e=this._$gl.createRenderbuffer();if(!e)throw new Error("the stencil buffer is null.");return t.stencil=e,t.samples=0,t.width=0,t.height=0,t.area=0,t.dirty=!0,t}_$getColorBuffer(t){if(!this._$objectPool.length)return this._$createColorBuffer();const e=this._$bsearch(t);if(e<this._$objectPool.length){const t=this._$objectPool[e];return this._$objectPool.splice(e,1),t}const i=this._$objectPool.shift();if(!i)throw new Error("the color buffer is void.");return i}create(t,e,s=0){t=i.max(256,X(t)),e=i.max(256,X(e));const r=this._$getColorBuffer(t*e);return s||(s=this._$samples),(r.width<t||r.height<e||r.samples!==s)&&(t=i.max(t,r.width),e=i.max(e,r.height),r.samples=s,r.width=t,r.height=e,r.area=t*e,r.dirty=!1,this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,s,this._$gl.RGBA8,t,e),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,r.stencil),this._$gl.renderbufferStorageMultisample(this._$gl.RENDERBUFFER,s,this._$gl.STENCIL_INDEX8,t,e)),r}release(t){t.dirty=!0;const e=this._$bsearch(t.area);this._$objectPool.splice(e,0,t)}_$bsearch(t){let e=-1,s=this._$objectPool.length;for(;i.abs(s-e)>1;){const r=i.floor((s+e)/2);t<=this._$objectPool[r].area?s=r:e=r}return s}}class At{constructor(t,e){this._$gl=t,this._$objectPool=[],this._$frameBuffer=t.createFramebuffer(),t.bindFramebuffer(t.READ_FRAMEBUFFER,this._$frameBuffer),this._$frameBufferTexture=t.createFramebuffer(),this._$currentAttachment=null,this._$isBinding=!1,this._$textureManager=new bt(t),this._$stencilBufferPool=new vt(t),this._$colorBufferPool=new Tt(t,e)}get currentAttachment(){return this._$currentAttachment}get textureManager(){return this._$textureManager}createCacheAttachment(t,e,i=!1,s=0){const r=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},n=this._$textureManager.create(t,e);return r.width=t,r.height=e,i?(r.color=this._$colorBufferPool.create(t,e,s),r.texture=n,r.msaa=!0,r.stencil=r.color.stencil):(r.color=n,r.texture=n,r.msaa=!1,r.stencil=this._$stencilBufferPool.create(t,e)),r.mask=!1,r.clipLevel=0,r.isActive=!0,r}setMaxSize(t,e){this._$stencilBufferPool._$maxWidth=t,this._$stencilBufferPool._$maxHeight=e,this._$textureManager._$maxWidth=t,this._$textureManager._$maxHeight=e}createTextureAttachment(t,e){const i=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!1},s=this._$textureManager.create(t,e);return i.width=t,i.height=e,i.color=s,i.texture=s,i.msaa=!1,i.stencil=null,i.mask=!1,i.clipLevel=0,i.isActive=!0,i}createTextureAttachmentFrom(t){const e=this._$objectPool.pop()||{width:0,height:0,color:null,texture:null,msaa:!1,stencil:null,mask:!1,clipLevel:0,isActive:!0};return e.width=t.width,e.height=t.height,e.color=t,e.texture=t,e.msaa=!1,e.stencil=null,e.mask=!1,e.clipLevel=0,e.isActive=!0,e}releaseAttachment(t=null,e=!1){t&&t.isActive&&(t.msaa?t.color instanceof WebGLRenderbuffer&&this._$colorBufferPool.release(t.color):t.stencil&&this._$stencilBufferPool.release(t.stencil),e&&t.texture&&this._$textureManager.release(t.texture),t.color=null,t.texture=null,t.stencil=null,t.isActive=!1,this._$objectPool.push(t))}bind(t){this._$currentAttachment=t,this._$isBinding||(this._$isBinding=!0,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer)),t.msaa?t.color instanceof WebGLRenderbuffer&&(this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.color),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.RENDERBUFFER,t.color)):t.color instanceof WebGLTexture&&(t.color&&this._$textureManager.bind0(t.color),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,t.color,0)),this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER,t.stencil),this._$gl.framebufferRenderbuffer(this._$gl.FRAMEBUFFER,this._$gl.STENCIL_ATTACHMENT,this._$gl.RENDERBUFFER,t.stencil)}unbind(){this._$currentAttachment=null,this._$isBinding&&(this._$isBinding=!1,this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,null))}getTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");if(!this._$currentAttachment.msaa&&this._$currentAttachment.texture)return this._$currentAttachment.texture;const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$currentAttachment.texture;if(!i)throw new Error("the texture is null.");return i.dirty=!1,this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER,this._$frameBufferTexture),this._$textureManager.bind0(i),this._$gl.framebufferTexture2D(this._$gl.FRAMEBUFFER,this._$gl.COLOR_ATTACHMENT0,this._$gl.TEXTURE_2D,i,0),this._$gl.blitFramebuffer(0,0,t,e,0,0,t,e,this._$gl.COLOR_BUFFER_BIT,this._$gl.NEAREST),this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER,this._$frameBuffer),i}createTextureFromPixels(t,e,i=null,s=!1,r=!0){return this._$textureManager.create(t,e,i,s,r)}createTextureFromCanvas(t){return this._$textureManager.createFromCanvas(t)}createTextureFromImage(t,e=!1){return this._$textureManager.createFromImage(t,e)}createTextureFromVideo(t,e=!1){return this._$textureManager.createFromVideo(t,e)}createTextureFromCurrentAttachment(){if(!this._$currentAttachment)throw new Error("the current attachment is null.");const t=this._$currentAttachment.width,e=this._$currentAttachment.height,i=this._$textureManager.create(t,e);return this._$textureManager.bind0(i),this._$gl.copyTexSubImage2D(this._$gl.TEXTURE_2D,0,0,0,0,0,t,e),i}releaseTexture(t){this._$textureManager.release(t)}}class yt{constructor(){this._$bezierConverterBuffer=new a(32)}cubicToQuad(t,e,i,s,r,n,a,h){this._$split2Cubic(t,e,i,s,r,n,a,h,0,16),this._$split2Cubic(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0,8),this._$split2Cubic(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16,24),this._$split2Quad(this._$bezierConverterBuffer[0],this._$bezierConverterBuffer[1],this._$bezierConverterBuffer[2],this._$bezierConverterBuffer[3],this._$bezierConverterBuffer[4],this._$bezierConverterBuffer[5],this._$bezierConverterBuffer[6],this._$bezierConverterBuffer[7],0),this._$split2Quad(this._$bezierConverterBuffer[8],this._$bezierConverterBuffer[9],this._$bezierConverterBuffer[10],this._$bezierConverterBuffer[11],this._$bezierConverterBuffer[12],this._$bezierConverterBuffer[13],this._$bezierConverterBuffer[14],this._$bezierConverterBuffer[15],8),this._$split2Quad(this._$bezierConverterBuffer[16],this._$bezierConverterBuffer[17],this._$bezierConverterBuffer[18],this._$bezierConverterBuffer[19],this._$bezierConverterBuffer[20],this._$bezierConverterBuffer[21],this._$bezierConverterBuffer[22],this._$bezierConverterBuffer[23],16),this._$split2Quad(this._$bezierConverterBuffer[24],this._$bezierConverterBuffer[25],this._$bezierConverterBuffer[26],this._$bezierConverterBuffer[27],this._$bezierConverterBuffer[28],this._$bezierConverterBuffer[29],this._$bezierConverterBuffer[30],this._$bezierConverterBuffer[31],24)}_$split2Cubic(t,e,i,s,r,n,a,h,o,l){const _=.125*(t+3*(i+r)+a),c=.125*(e+3*(s+n)+h),$=.125*(a+r-i-t),u=.125*(h+n-s-e);this._$bezierConverterBuffer[o]=t,this._$bezierConverterBuffer[o+1]=e,this._$bezierConverterBuffer[o+2]=.5*(t+i),this._$bezierConverterBuffer[o+3]=.5*(e+s),this._$bezierConverterBuffer[o+4]=_-$,this._$bezierConverterBuffer[o+5]=c-u,this._$bezierConverterBuffer[o+6]=_,this._$bezierConverterBuffer[o+7]=c,this._$bezierConverterBuffer[l]=_,this._$bezierConverterBuffer[l+1]=c,this._$bezierConverterBuffer[l+2]=_+$,this._$bezierConverterBuffer[l+3]=c+u,this._$bezierConverterBuffer[l+4]=.5*(r+a),this._$bezierConverterBuffer[l+5]=.5*(n+h),this._$bezierConverterBuffer[l+6]=a,this._$bezierConverterBuffer[l+7]=h}_$split2Quad(t,e,i,s,r,n,a,h,o){const l=.125*(t+3*(i+r)+a),_=.125*(e+3*(s+n)+h);this._$bezierConverterBuffer[o]=.25*t+.75*i,this._$bezierConverterBuffer[o+1]=.25*e+.75*s,this._$bezierConverterBuffer[o+2]=l,this._$bezierConverterBuffer[o+3]=_,this._$bezierConverterBuffer[o+4]=.75*r+.25*a,this._$bezierConverterBuffer[o+5]=.75*n+.25*h,this._$bezierConverterBuffer[o+6]=a,this._$bezierConverterBuffer[o+7]=h}}class Mt{constructor(){this._$currentPath=N(),this._$vertices=N(),this._$bezierConverter=new yt}get vertices(){return this._$pushCurrentPathToVertices(),this._$vertices}begin(){for(this._$currentPath.length=0;this._$vertices.length;)U(this._$vertices.pop())}moveTo(t,e){this._$currentPath.length?this._$equalsToLastPoint(t,e)||(this._$pushCurrentPathToVertices(),this._$pushPointToCurrentPath(t,e,!1)):this._$pushPointToCurrentPath(t,e,!1)}lineTo(t,e){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}quadTo(t,e,i,s){this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(i,s)||(this._$pushPointToCurrentPath(t,e,!0),this._$pushPointToCurrentPath(i,s,!1))}cubicTo(t,e,i,s,r,n){if(this._$currentPath.length||this.moveTo(0,0),this._$equalsToLastPoint(r,n))return;const a=+this._$currentPath[this._$currentPath.length-3],h=+this._$currentPath[this._$currentPath.length-2];this._$bezierConverter.cubicToQuad(a,h,t,e,i,s,r,n);const o=this._$bezierConverter._$bezierConverterBuffer;for(let t=0;t<32;)this.quadTo(o[t++],o[t++],o[t++],o[t++])}drawCircle(t,e,i){const s=i,r=.5522847498307936*i;this.cubicTo(t+s,e+r,t+r,e+s,t,e+s),this.cubicTo(t-r,e+s,t-s,e+r,t-s,e),this.cubicTo(t-s,e-r,t-r,e-s,t,e-s),this.cubicTo(t+r,e-s,t+s,e-r,t+s,e)}close(){if(this._$currentPath.length<=6)return;const t=+this._$currentPath[0],e=+this._$currentPath[1];this._$equalsToLastPoint(t,e)||this._$pushPointToCurrentPath(t,e,!1)}_$equalsToLastPoint(t,e){const i=+this._$currentPath[this._$currentPath.length-3],s=+this._$currentPath[this._$currentPath.length-2];return t===i&&e===s}_$pushPointToCurrentPath(t,e,i){this._$currentPath.push(t,e,i)}_$pushCurrentPathToVertices(){this._$currentPath.length<4?this._$currentPath.length=0:(this._$vertices.push(this._$currentPath),this._$currentPath=N())}createRectVertices(t,e,i,s){return N(N(t,e,!1,t+i,e,!1,t+i,e+s,!1,t,e+s,!1))}}class Et{constructor(){this.enabled=!1,this.parentMatrixA=1,this.parentMatrixB=0,this.parentMatrixC=0,this.parentMatrixD=0,this.parentMatrixE=1,this.parentMatrixF=0,this.parentMatrixG=0,this.parentMatrixH=0,this.parentMatrixI=1,this.ancestorMatrixA=1,this.ancestorMatrixB=0,this.ancestorMatrixC=0,this.ancestorMatrixD=0,this.ancestorMatrixE=1,this.ancestorMatrixF=0,this.ancestorMatrixG=0,this.ancestorMatrixH=0,this.ancestorMatrixI=1,this.parentViewportX=0,this.parentViewportY=0,this.parentViewportW=0,this.parentViewportH=0,this.minXST=1e-5,this.minYST=1e-5,this.minXPQ=1e-5,this.minYPQ=1e-5,this.maxXST=.99999,this.maxYST=.99999,this.maxXPQ=.99999,this.maxYPQ=.99999}enable(t,e,s,r,n,a,h,o,l,_,c,$,u,d,g,f,p,m,x){const b=n.xMax-n.xMin,v=n.yMax-n.yMin,T=a.width,A=a.height,y=i.abs(i.ceil(b*h)),M=i.abs(i.ceil(v*h)),E=T>0?(a.x-n.xMin)/b:1e-5,w=A>0?(a.y-n.yMin)/v:1e-5,C=T>0?(a.x+a.width-n.xMin)/b:.99999,S=A>0?(a.y+a.height-n.yMin)/v:.99999;let B=y*E/s,F=M*w/r,R=(s-y*(1-C))/s,I=(r-M*(1-S))/r;if(B>=R){const t=E/(E+(1-C));B=i.max(t-1e-5,0),R=i.min(t+1e-5,1)}if(F>=I){const t=w/(w+(1-S));F=i.max(t-1e-5,0),I=i.min(t+1e-5,1)}this.enabled=!0,this.parentMatrixA=o,this.parentMatrixB=l,this.parentMatrixD=_,this.parentMatrixE=c,this.parentMatrixG=$,this.parentMatrixH=u,this.ancestorMatrixA=d,this.ancestorMatrixB=g,this.ancestorMatrixD=f,this.ancestorMatrixE=p,this.ancestorMatrixG=m,this.ancestorMatrixH=x,this.parentViewportX=t,this.parentViewportY=e,this.parentViewportW=s,this.parentViewportH=r,this.minXST=E,this.minYST=w,this.minXPQ=B,this.minYPQ=F,this.maxXST=C,this.maxYST=S,this.maxXPQ=R,this.maxYPQ=I}disable(){this.enabled=!1}}class wt{constructor(t,e){this._$gl=t,this._$array=[],this._$map=D();const i=this._$gl.getProgramParameter(e,this._$gl.ACTIVE_UNIFORMS);for(let t=0;t<i;t++){const i=this._$gl.getActiveUniform(e,t);if(!i)throw new Error("the WebGLActiveInfo is null.");const s=i.name.endsWith("[0]")?i.name.slice(0,-3):i.name,r=this._$gl.getUniformLocation(e,s);if(!r)throw new Error("the WebGLUniformLocation is null.");if(i.type===this._$gl.SAMPLER_2D&&1===i.size)continue;const n={};switch(i.type){case this._$gl.FLOAT_VEC4:n.method=this._$gl.uniform4fv.bind(this._$gl,r),n.array=new a(4*i.size),n.assign=-1;break;case this._$gl.INT_VEC4:n.method=this._$gl.uniform4iv.bind(this._$gl,r),n.array=new h(4*i.size),n.assign=-1;break;case this._$gl.SAMPLER_2D:n.method=this._$gl.uniform1iv.bind(this._$gl,r),n.array=new h(i.size),n.assign=1;break;case this._$gl.FLOAT:case this._$gl.FLOAT_VEC2:case this._$gl.FLOAT_VEC3:case this._$gl.FLOAT_MAT2:case this._$gl.FLOAT_MAT3:case this._$gl.FLOAT_MAT4:case this._$gl.INT:case this._$gl.INT_VEC2:case this._$gl.INT_VEC3:default:throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead")}this._$array.push(n),this._$map.set(s,n)}}getArray(t){const e=this._$map.get(t);if(!e||!e.array)throw new Error("the UniformData is null.");return e.array}get textures(){const t=this._$map.get("u_textures");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get highp(){const t=this._$map.get("u_highp");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get mediump(){const t=this._$map.get("u_mediump");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}get integer(){const t=this._$map.get("u_integer");if(!t||!t.array)throw new Error("the UniformData is null.");return t.array}bindUniforms(){const t=this._$array.length;for(let e=0;e<t;e++){const t=this._$array[e];void 0!==t.method&&void 0!==t.assign&&(t.assign<0?t.method(t.array):t.assign>0&&(t.assign--,t.method(t.array)))}}}class Ct{constructor(t,e,i,s){this._$gl=t,this._$context=e,this._$program=this._$createProgram(i,s),this._$uniform=new wt(t,this._$program)}get uniform(){return this._$uniform}_$createProgram(e,i){const s=this._$gl.createProgram();if(!s)throw new Error("WebGL program error");s.id=t++;const r=this._$gl.createShader(this._$gl.VERTEX_SHADER);if(!r)throw new Error("WebGL vertex shader error");this._$gl.shaderSource(r,e),this._$gl.compileShader(r);const n=this._$gl.createShader(this._$gl.FRAGMENT_SHADER);if(!n)throw new Error("WebGL fragment shader error");return this._$gl.shaderSource(n,i),this._$gl.compileShader(n),this._$gl.attachShader(s,r),this._$gl.attachShader(s,n),this._$gl.linkProgram(s),this._$gl.detachShader(s,r),this._$gl.detachShader(s,n),this._$gl.deleteShader(r),this._$gl.deleteShader(n),s}_$attachProgram(){const t=this._$context.shaderList;t.currentProgramId!==this._$program.id&&(t.currentProgramId=this._$program.id,this._$gl.useProgram(this._$program))}_$drawImage(){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindCommonVertexArray(),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$drawGradient(t,e){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bindGradientVertexArray(t,e),this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP,0,4)}_$stroke(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawElements(this._$gl.TRIANGLES,t.indexCount,this._$gl.UNSIGNED_SHORT,0)}_$fill(t){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t);const e=t.indexRanges,i=e[e.length-1],s=i.first+i.count;this._$gl.drawArrays(this._$gl.TRIANGLES,0,s)}_$containerClip(t,e,i){this._$attachProgram(),this._$context.blend.reset(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.TRIANGLES,e,i)}_$drawPoints(t,e,i){this._$attachProgram(),this._$uniform.bindUniforms(),this._$context.vao.bind(t),this._$gl.drawArrays(this._$gl.POINTS,e,i)}}class St{static FUNCTION_GRID_OFF(){return"\\n\\nvec2 applyMatrix(in vec2 vertex) {\\n    mat3 matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n\\n    vec2 position = (matrix * vec3(vertex, 1.0)).xy;\\n\\n    return position;\\n}\\n\\n"}static FUNCTION_GRID_ON(t){return`\\n\\nvec2 applyMatrix(in vec2 vertex) {\\n    mat3 parent_matrix = mat3(\\n        u_highp[${t}].xyz,\\n        u_highp[${t+1}].xyz,\\n        u_highp[${t+2}].xyz\\n    );\\n    mat3 ancestor_matrix = mat3(\\n        u_highp[${t+3}].xyz,\\n        u_highp[${t+4}].xyz,\\n        u_highp[${t+5}].xyz\\n    );\\n    vec2 parent_offset = vec2(u_highp[${t+2}].w, u_highp[${t+3}].w);\\n    vec2 parent_size   = vec2(u_highp[${t+4}].w, u_highp[${t+5}].w);\\n    vec4 grid_min = u_highp[${t+6}];\\n    vec4 grid_max = u_highp[${t+7}];\\n\\n    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;\\n    position = (position - parent_offset) / parent_size;\\n\\n    vec4 ga = grid_min;\\n    vec4 gb = grid_max  - grid_min;\\n    vec4 gc = vec4(1.0) - grid_max;\\n\\n    vec2 pa = position;\\n    vec2 pb = position - grid_min.st;\\n    vec2 pc = position - grid_max.st;\\n\\n    position = (ga.pq / ga.st) * min(pa, ga.st)\\n             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)\\n             + (gc.pq / gc.st) * max(vec2(0.0), pc);\\n\\n    position = position * parent_size + parent_offset;\\n    position = (ancestor_matrix * vec3(position, 1.0)).xy;\\n\\n    return position;\\n}\\n\\n`}}class Bt{static TEMPLATE(t,e,i,s){const r=e-1,n=i?this.VARYING_UV_ON():"",a=i?this.STATEMENT_UV_ON():"";return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\nlayout (location = 1) in vec2 a_option1;\\nlayout (location = 2) in vec2 a_option2;\\nlayout (location = 3) in float a_type;\\n\\nuniform vec4 u_highp[${t}];\\n\\n${n}\\n\\n${s?St.FUNCTION_GRID_ON(i?5:0):St.FUNCTION_GRID_OFF()}\\n\\nfloat crossVec2(in vec2 v1, in vec2 v2) {\\n    return v1.x * v2.y - v2.x * v1.y;\\n}\\n\\nvec2 perpendicularVec2(in vec2 v1) {\\n    float face = u_highp[${r}][1];\\n\\n    return face * vec2(v1.y, -v1.x);\\n}\\n\\nvec2 calculateNormal(in vec2 direction) {\\n    vec2 normalized = normalize(direction);\\n    return perpendicularVec2(normalized);\\n}\\n\\nvec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {\\n    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);\\n    return (o1 + t * v1);\\n}\\n\\nvec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {\\n    float miter_limit = u_highp[${r}][2];\\n\\n    vec2 a = applyMatrix(a_option1);\\n    vec2 b = applyMatrix(a_option2);\\n\\n    v1 = convex * (position - a);\\n    v2 = convex * (b - position);\\n    o1 = calculateNormal(v1) + a;\\n    o2 = calculateNormal(v2) + position;\\n\\n    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;\\n    return normalize(anchor) * min(length(anchor), miter_limit);\\n}\\n\\nvoid main() {\\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\\n    float half_width = u_highp[${r}][0];\\n\\n    vec2 position = applyMatrix(a_vertex);\\n    vec2 offset = vec2(0.0);\\n    vec2 v1, v2, o1, o2;\\n\\n    if (a_type == 1.0 || a_type == 2.0) { // \\n        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));\\n    } else if (a_type == 10.0) { // \\n        offset = normalize(position - applyMatrix(a_option1));\\n        offset += a_option2 * perpendicularVec2(offset);\\n    } else if (a_type == 21.0) { // B\\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\\n    } else if (a_type == 22.0) { // A\\n        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\\n    } else if (a_type == 23.0) { // A\\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;\\n    } else if (a_type == 24.0) { // B\\n        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);\\n        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;\\n    } else if (a_type >= 30.0) { // \\n        float face = u_highp[${r}][1];\\n        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */\\n        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);\\n    }\\n    \\n    offset *= half_width;\\n    position += offset;\\n    ${a}\\n\\n    position /= viewport;\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n`}static VARYING_UV_ON(){return"\\nout vec2 v_uv;\\n"}static STATEMENT_UV_ON(){return"\\n    mat3 uv_matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n    mat3 inverse_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\\n    );\\n\\n    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;\\n    v_uv += offset;\\n    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;\\n"}}class Ft{static TEMPLATE(t,e,i,s){const r=i?this.ATTRIBUTE_BEZIER_ON():"",n=i?this.VARYING_BEZIER_ON():e?this.VARYING_UV_ON():"",a=i?this.STATEMENT_BEZIER_ON():e?this.STATEMENT_UV_ON():"";return`#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n${r}\\n\\nuniform vec4 u_highp[${t}];\\n\\n${n}\\n\\n${s?St.FUNCTION_GRID_ON(e?5:0):St.FUNCTION_GRID_OFF()}\\n\\nvoid main() {\\n    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);\\n\\n    ${a}\\n\\n    vec2 pos = applyMatrix(a_vertex) / viewport;\\n    pos = pos * 2.0 - 1.0;\\n    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);\\n}\\n\\n`}static ATTRIBUTE_BEZIER_ON(){return"\\nlayout (location = 1) in vec2 a_bezier;\\n"}static VARYING_UV_ON(){return"\\nout vec2 v_uv;\\n"}static VARYING_BEZIER_ON(){return"\\nout vec2 v_bezier;\\n"}static STATEMENT_UV_ON(){return"\\n    mat3 uv_matrix = mat3(\\n        u_highp[0].xyz,\\n        u_highp[1].xyz,\\n        u_highp[2].xyz\\n    );\\n    mat3 inverse_matrix = mat3(\\n        u_highp[3].xyz,\\n        u_highp[4].xyz,\\n        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)\\n    );\\n\\n    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;\\n"}static STATEMENT_BEZIER_ON(){return"\\n    v_bezier = a_bezier;\\n"}}class Rt{static FUNCTION_IS_INSIDE(){return"\\n\\nfloat isInside(in vec2 uv) {\\n    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));\\n}\\n\\n"}static STATEMENT_COLOR_TRANSFORM_ON(t){return`\\n    vec4 mul = u_mediump[${t}];\\n    vec4 add = u_mediump[${t+1}];\\n\\n    src.rgb /= max(0.0001, src.a);\\n    src = clamp(src * mul + add, 0.0, 1.0);\\n    src.rgb *= src.a;\\n`}}class It{static SOLID_COLOR(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump;\\n\\nout vec4 o_color;\\n\\nvoid main() {\\n    o_color = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);\\n}\\n\\n"}static BITMAP_CLIPPED(){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[3];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;\\n\\n    vec4 src = texture(u_texture, uv);\\n    ${Rt.STATEMENT_COLOR_TRANSFORM_ON(1)}\\n    o_color = src;\\n}`}static BITMAP_PATTERN(){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[3];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);\\n    \\n    vec4 src = texture(u_texture, uv);\\n    ${Rt.STATEMENT_COLOR_TRANSFORM_ON(1)}\\n    o_color = src;\\n}`}static MASK(){return"#version 300 es\\nprecision mediump float;\\n\\nin vec2 v_bezier;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 px = dFdx(v_bezier);\\n    vec2 py = dFdy(v_bezier);\\n\\n    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);\\n    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);\\n\\n    if (alpha > 0.0) {\\n        o_color = vec4(min(alpha, 1.0));\\n    } else {\\n        discard;\\n    }    \\n}\\n\\n"}}class Pt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getSolidColorShapeShader(t,e){const i=`s${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Bt.TEMPLATE(s,r,!1,e):Ft.TEMPLATE(s,!1,!1,e);const a=new Ct(this._$gl,this._$context,n,It.SOLID_COLOR());return this._$collection.set(i,a),a}getBitmapShapeShader(t,e,i){const s=`b${t?"y":"n"}${e?"y":"n"}${i?"y":"n"}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r=(i?13:5)+(t?1:0),n=r;let a;a=t?Bt.TEMPLATE(r,n,!0,i):Ft.TEMPLATE(r,!0,!1,i);const h=e?It.BITMAP_PATTERN():It.BITMAP_CLIPPED(),o=new Ct(this._$gl,this._$context,a,h);return this._$collection.set(s,o),o}getMaskShapeShader(t,e){const i=`m${t?"y":"n"}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=(e?8:3)+(t?1:0),r=s;let n;n=t?Bt.TEMPLATE(s,r,!1,e):Ft.TEMPLATE(s,!1,!0,e);const a=new Ct(this._$gl,this._$context,n,It.MASK());return this._$collection.set(i,a),a}setSolidColorShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c){const $=t.highp;let u;n?($[0]=l.parentMatrixA,$[1]=l.parentMatrixB,$[2]=l.parentMatrixC,$[4]=l.parentMatrixD,$[5]=l.parentMatrixE,$[6]=l.parentMatrixF,$[8]=l.parentMatrixG,$[9]=l.parentMatrixH,$[10]=l.parentMatrixI,$[12]=l.ancestorMatrixA,$[13]=l.ancestorMatrixB,$[14]=l.ancestorMatrixC,$[16]=l.ancestorMatrixD,$[17]=l.ancestorMatrixE,$[18]=l.ancestorMatrixF,$[20]=l.ancestorMatrixG,$[21]=l.ancestorMatrixH,$[22]=l.ancestorMatrixI,$[3]=h,$[7]=o,$[11]=l.parentViewportX,$[15]=l.parentViewportY,$[19]=l.parentViewportW,$[23]=l.parentViewportH,$[24]=l.minXST,$[25]=l.minYST,$[26]=l.minXPQ,$[27]=l.minYPQ,$[28]=l.maxXST,$[29]=l.maxYST,$[30]=l.maxXPQ,$[31]=l.maxYPQ,u=32):($[0]=a[0],$[1]=a[1],$[2]=a[2],$[4]=a[3],$[5]=a[4],$[6]=a[5],$[8]=a[6],$[9]=a[7],$[10]=a[8],$[3]=h,$[7]=o,u=12),e&&($[u]=i,$[u+1]=s,$[u+2]=r);const d=t.mediump;d[0]=_[0],d[1]=_[1],d[2]=_[2],d[3]=_[3]*c}setBitmapShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,p,m,x,b){const v=t.highp;let T;v[0]=a[0],v[1]=a[1],v[2]=a[2],v[4]=a[3],v[5]=a[4],v[6]=a[5],v[8]=a[6],v[9]=a[7],v[10]=a[8],v[12]=h[0],v[13]=h[1],v[14]=h[2],v[16]=h[3],v[17]=h[4],v[18]=h[5],v[11]=h[6],v[15]=h[7],v[19]=h[8],v[3]=o,v[7]=l,T=20,n&&(v[T]=_.parentMatrixA,v[T+1]=_.parentMatrixB,v[T+2]=_.parentMatrixC,v[T+4]=_.parentMatrixD,v[T+5]=_.parentMatrixE,v[T+6]=_.parentMatrixF,v[T+8]=_.parentMatrixG,v[T+9]=_.parentMatrixH,v[T+10]=_.parentMatrixI,v[T+12]=_.ancestorMatrixA,v[T+13]=_.ancestorMatrixB,v[T+14]=_.ancestorMatrixC,v[T+16]=_.ancestorMatrixD,v[T+17]=_.ancestorMatrixE,v[T+18]=_.ancestorMatrixF,v[T+20]=_.ancestorMatrixG,v[T+21]=_.ancestorMatrixH,v[T+22]=_.ancestorMatrixI,v[T+11]=_.parentViewportX,v[T+15]=_.parentViewportY,v[T+19]=_.parentViewportW,v[T+23]=_.parentViewportH,v[T+24]=_.minXST,v[T+25]=_.minYST,v[T+26]=_.minXPQ,v[T+27]=_.minYPQ,v[T+28]=_.maxXST,v[T+29]=_.maxYST,v[T+30]=_.maxXPQ,v[T+31]=_.maxYPQ,T=52),e&&(v[T]=i,v[T+1]=s,v[T+2]=r);const A=t.mediump;A[0]=c,A[1]=$,A[4]=u,A[5]=d,A[6]=g,A[7]=f,A[8]=p,A[9]=m,A[10]=x,A[11]=b}setMaskShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u=null){const d=t.highp;e&&u?(d[0]=u.parentMatrixA,d[1]=u.parentMatrixB,d[2]=u.parentMatrixC,d[4]=u.parentMatrixD,d[5]=u.parentMatrixE,d[6]=u.parentMatrixF,d[8]=u.parentMatrixG,d[9]=u.parentMatrixH,d[10]=u.parentMatrixI,d[12]=u.ancestorMatrixA,d[13]=u.ancestorMatrixB,d[14]=u.ancestorMatrixC,d[16]=u.ancestorMatrixD,d[17]=u.ancestorMatrixE,d[18]=u.ancestorMatrixF,d[20]=u.ancestorMatrixG,d[21]=u.ancestorMatrixH,d[22]=u.ancestorMatrixI,d[3]=c,d[7]=$,d[11]=u.parentViewportX,d[15]=u.parentViewportY,d[19]=u.parentViewportW,d[23]=u.parentViewportH,d[24]=u.minXST,d[25]=u.minYST,d[26]=u.minXPQ,d[27]=u.minYPQ,d[28]=u.maxXST,d[29]=u.maxYST,d[30]=u.maxXPQ,d[31]=u.maxYPQ):(d[0]=i,d[1]=s,d[2]=r,d[4]=n,d[5]=a,d[6]=h,d[8]=o,d[9]=l,d[10]=_,d[3]=c,d[7]=$)}setMaskShapeUniformIdentity(t,e,i){const s=t.highp;s[0]=1,s[1]=0,s[2]=0,s[4]=0,s[5]=1,s[6]=0,s[8]=0,s[9]=0,s[10]=1,s[3]=e,s[7]=i}}class kt{static TEMPLATE(t,e,i,s,r){const n=i?this.STATEMENT_GRADIENT_TYPE_RADIAL(e,s):this.STATEMENT_GRADIENT_TYPE_LINEAR(e);let a;switch(r){case"reflect":a="1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";break;case"repeat":a="fract(t)";break;default:a="clamp(t, 0.0, 1.0)"}return`#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_highp[${t}];\\n\\nin vec2 v_uv;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2 p = v_uv;\\n    ${n}\\n    t = ${a};\\n    o_color = texture(u_texture, vec2(t, 0.5));\\n}\\n\\n`}static STATEMENT_GRADIENT_TYPE_LINEAR(t){return`\\n    vec2 a = u_highp[${t}].xy;\\n    vec2 b = u_highp[${t}].zw;\\n\\n    vec2 ab = b - a;\\n    vec2 ap = p - a;\\n\\n    float t = dot(ab, ap) / dot(ab, ab);\\n`}static STATEMENT_GRADIENT_TYPE_RADIAL(t,e){return`\\n    float radius = u_highp[${t}][0];\\n\\n    vec2 coord = p / radius;\\n    ${e?this.STATEMENT_FOCAL_POINT_ON(t):this.STATEMENT_FOCAL_POINT_OFF()}\\n`}static STATEMENT_FOCAL_POINT_OFF(){return"\\n    float t = length(coord);\\n"}static STATEMENT_FOCAL_POINT_ON(t){return`\\n    vec2 focal = vec2(u_highp[${t}][1], 0.0);\\n\\n    vec2 dir = normalize(coord - focal);\\n\\n    float a = dot(dir, dir);\\n    float b = 2.0 * dot(dir, focal);\\n    float c = dot(focal, focal) - 1.0;\\n    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\\n\\n    float t = distance(focal, coord) / distance(focal, focal + dir * x);\\n`}}class Lt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getGradientShapeShader(t,e,i,s,r){const n=this.createCollectionKey(t,e,i,s,r);if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(e?13:5)+(t?1:0)+1,h=a-1;let o;o=t?Bt.TEMPLATE(a,h,!0,e):Ft.TEMPLATE(a,!0,!1,e);const l=new Ct(this._$gl,this._$context,o,kt.TEMPLATE(a,h,i,s,r));return this._$collection.set(n,l),l}createCollectionKey(t,e,i,s,r){const n=t?"y":"n",a=e?"y":"n",h=i?"y":"n",o=i&&s?"y":"n";let l=0;switch(r){case"reflect":l=1;break;case"repeat":l=2}return`${n}${a}${h}${o}${l}`}setGradientShapeUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=t.highp;d[0]=a[0],d[1]=a[1],d[2]=a[2],d[4]=a[3],d[5]=a[4],d[6]=a[5],d[8]=a[6],d[9]=a[7],d[10]=a[8],d[12]=h[0],d[13]=h[1],d[14]=h[2],d[16]=h[3],d[17]=h[4],d[18]=h[5],d[11]=h[6],d[15]=h[7],d[19]=h[8],d[3]=o,d[7]=l;let g=20;n&&(d[g]=_.parentMatrixA,d[g+1]=_.parentMatrixB,d[g+2]=_.parentMatrixC,d[g+4]=_.parentMatrixD,d[g+5]=_.parentMatrixE,d[g+6]=_.parentMatrixF,d[g+8]=_.parentMatrixG,d[g+9]=_.parentMatrixH,d[g+10]=_.parentMatrixI,d[g+12]=_.ancestorMatrixA,d[g+13]=_.ancestorMatrixB,d[g+14]=_.ancestorMatrixC,d[g+16]=_.ancestorMatrixD,d[g+17]=_.ancestorMatrixE,d[g+18]=_.ancestorMatrixF,d[g+20]=_.ancestorMatrixG,d[g+21]=_.ancestorMatrixH,d[g+22]=_.ancestorMatrixI,d[g+11]=_.parentViewportX,d[g+15]=_.parentViewportY,d[g+19]=_.parentViewportW,d[g+23]=_.parentViewportH,d[g+24]=_.minXST,d[g+25]=_.minYST,d[g+26]=_.minXPQ,d[g+27]=_.minYPQ,d[g+28]=_.maxXST,d[g+29]=_.maxYST,d[g+30]=_.maxXPQ,d[g+31]=_.maxYPQ,g=52),e&&(d[g]=i,d[g+1]=s,d[g+2]=r,g+=4),c?(d[g]=$[5],d[g+1]=u):(d[g]=$[0],d[g+1]=$[1],d[g+2]=$[2],d[g+3]=$[3])}}class Nt{static TEXTURE(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 position = a_vertex * 2.0 - 1.0;\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\\n\\n"}static BLEND(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[4];\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 offset   = u_highp[0].xy;\\n    vec2 size     = u_highp[0].zw;\\n    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position = position * size + offset;\\n    position = (matrix * vec3(position, 1.0)).xy;\\n    position /= viewport;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}static BLEND_CLIP(){return"#version 300 es\\n\\nlayout (location = 0) in vec2 a_vertex;\\n\\nuniform vec4 u_highp[4];\\n\\nout vec2 v_coord;\\n\\nvoid main() {\\n    v_coord = a_vertex;\\n\\n    vec2 offset     = u_highp[0].xy;\\n    vec2 size       = u_highp[0].zw;\\n    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);\\n    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);\\n\\n    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);\\n    position *= viewport;\\n    position = (inv_matrix * vec3(position, 1.0)).xy;\\n    position = (position - offset) / size;\\n\\n    position = position * 2.0 - 1.0;\\n    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\\n}\\n\\n"}}class Ut{static TEMPLATE(t,e,s){let r="";for(let t=1;t<e;t++){const s=t-1,n=t,a=`u_mediump[${e+i.floor(s/4)}][${s%4}]`,h=`u_mediump[${e+i.floor(n/4)}][${n%4}]`;r+=`\\n    if (t <= ${h}) {\\n        return mix(u_mediump[${s}], u_mediump[${n}], (t - ${a}) / (${h} - ${a}));\\n    }\\n`}return`#version 300 es\\nprecision mediump float;\\n\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvec4 getGradientColor(in float t) {\\n    if (t <= u_mediump[${e}][0]) {\\n        return u_mediump[0];\\n    }\\n    ${r}\\n    return u_mediump[${e-1}];\\n}\\n\\nvoid main() {\\n    vec4 color = getGradientColor(v_coord.x);\\n    ${s?"color = pow(color, vec4(0.45454545));":""}\\n    color.rgb *= color.a;\\n\\n    o_color = color;\\n}\\n\\n`}}class Ot{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getGradientLUTShader(t,e){const s=`l${("00"+t).slice(-3)}${e?"y":"n"}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r=i.ceil(5*t/4),n=new Ct(this._$gl,this._$context,Nt.TEXTURE(),Ut.TEMPLATE(r,t,e));return this._$collection.set(s,n),n}setGradientLUTUniformForShape(t,e,i,s,r){let n=0;const a=t.mediump;for(let t=i;t<s;t++){const i=e[t][1];a[n++]=r[i[0]],a[n++]=r[i[1]],a[n++]=r[i[2]],a[n++]=r[i[3]]}for(let t=i;t<s;t++)a[n++]=e[t][0]}setGradientLUTUniformForFilter(t,e,i,s,r,n){let a=0;const h=t.mediump;for(let t=r;t<n;t++){const e=i[t];h[a++]=(e>>16)/255,h[a++]=(e>>8&255)/255,h[a++]=(255&e)/255,h[a++]=s[t]}for(let t=r;t<n;t++)h[a++]=e[t]}}class Dt{static TEMPLATE(t,e,i,s,r,n,a,h,o){let l=0;const _=i?this.STATEMENT_BASE_TEXTURE_TRANSFORM(l++):"",c=s?this.STATEMENT_BLUR_TEXTURE_TRANSFORM(l++):this.STATEMENT_BLUR_TEXTURE(),$="inner"===n,u=l;let d,g,f=4*l;switch(o?d=r?this.STATEMENT_GLOW(!1,i,h,o,u,f):this.STATEMENT_BEVEL(i,s,h,o,u,f):r?(f+=4,d=this.STATEMENT_GLOW($,i,h,o,u,f)):(f+=8,d=this.STATEMENT_BEVEL(i,s,h,o,u,f)),n){case"outer":g=a?"blur - blur * base.a":"base + blur - blur * base.a";break;case"full":g=a?"blur":"base - base * blur.a + blur";break;default:g="blur"}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[${t}];\\nuniform vec4 u_mediump[${e}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${Rt.FUNCTION_IS_INSIDE()}\\n\\nvoid main() {\\n    ${_}\\n    ${c}\\n    ${d}\\n    o_color = ${g};\\n}\\n\\n`}static STATEMENT_BASE_TEXTURE_TRANSFORM(t){return`\\n    vec2 base_scale  = u_mediump[${t}].xy;\\n    vec2 base_offset = u_mediump[${t}].zw;\\n\\n    vec2 uv = v_coord * base_scale - base_offset;\\n    vec4 base = mix(vec4(0.0), texture(u_textures[1], uv), isInside(uv));\\n`}static STATEMENT_BLUR_TEXTURE(){return"\\n    vec4 blur = texture(u_textures[0], v_coord);\\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM(t){return`\\n    vec2 blur_scale  = u_mediump[${t}].xy;\\n    vec2 blur_offset = u_mediump[${t}].zw;\\n\\n    vec2 st = v_coord * blur_scale - blur_offset;\\n    vec4 blur = mix(vec4(0.0), texture(u_textures[0], st), isInside(st));\\n`}static STATEMENT_GLOW(t,e,i,s,r,n){return`\\n    ${t?"blur.a = 1.0 - blur.a;":""}\\n    ${i?this.STATEMENT_GLOW_STRENGTH(n):""}\\n    ${s?this.STATEMENT_GLOW_GRADIENT_COLOR(e):this.STATEMENT_GLOW_SOLID_COLOR(r)}\\n`}static STATEMENT_GLOW_STRENGTH(t){return`\\n    float strength = u_mediump[${i.floor(t/4)}][${t%4}];\\n    blur.a = clamp(blur.a * strength, 0.0, 1.0);\\n`}static STATEMENT_GLOW_SOLID_COLOR(t){return`\\n    vec4 color = u_mediump[${t}];\\n    blur = color * blur.a;\\n`}static STATEMENT_GLOW_GRADIENT_COLOR(t){return`\\n    blur = texture(u_textures[${t?2:1}], vec2(blur.a, 0.5));\\n`}static STATEMENT_BEVEL(t,e,i,s,r,n){return`\\n    ${e?this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2():this.STATEMENT_BLUR_TEXTURE_2()}\\n    float highlight_alpha = blur.a - blur2.a;\\n    float shadow_alpha    = blur2.a - blur.a;\\n    ${i?this.STATEMENT_BEVEL_STRENGTH(n):""}\\n    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);\\n    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);\\n    ${s?this.STATEMENT_BEVEL_GRADIENT_COLOR(t):this.STATEMENT_BEVEL_SOLID_COLOR(r)}\\n`}static STATEMENT_BLUR_TEXTURE_2(){return"\\n    vec4 blur2 = texture(u_textures[0], 1.0 - v_coord);\\n"}static STATEMENT_BLUR_TEXTURE_TRANSFORM_2(){return"\\n    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;\\n    vec4 blur2 = mix(vec4(0.0), texture(u_textures[0], pq), isInside(pq));\\n"}static STATEMENT_BEVEL_STRENGTH(t){return`\\n    float strength = u_mediump[${i.floor(t/4)}][${t%4}];\\n    highlight_alpha *= strength;\\n    shadow_alpha    *= strength;\\n`}static STATEMENT_BEVEL_SOLID_COLOR(t){return`\\n    vec4 highlight_color = u_mediump[${t}];\\n    vec4 shadow_color    = u_mediump[${t+1}];\\n    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;\\n`}static STATEMENT_BEVEL_GRADIENT_COLOR(t){return`\\n    blur = texture(u_textures[${t?2:1}], vec2(\\n        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,\\n        0.5\\n    ));\\n`}}class Xt{static TEMPLATE(t){const e=t.toFixed(1);return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump;\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec2  offset   = u_mediump.xy;\\n    float fraction = u_mediump.z;\\n    float samples  = u_mediump.w;\\n    \\n    vec4 color = texture(u_texture, v_coord);\\n\\n    for (float i = 1.0; i < ${e}; i += 1.0) {\\n        color += texture(u_texture, v_coord + offset * i);\\n        color += texture(u_texture, v_coord - offset * i);\\n    }\\n    color += texture(u_texture, v_coord + offset * ${e}) * fraction;\\n    color += texture(u_texture, v_coord - offset * ${e}) * fraction;\\n    color /= samples;\\n\\n    o_color = color;\\n}\\n\\n`}}class Vt{static TEMPLATE(){return"#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[5];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);\\n    vec4 add = u_mediump[4];\\n    \\n    vec4 color = texture(u_texture, v_coord);\\n\\n    color.rgb /= max(0.0001, color.a);\\n    color = clamp(color * mul + add, 0.0, 1.0);\\n    color.rgb *= color.a;\\n\\n    o_color = color;\\n}\\n\\n"}}class Yt{static TEMPLATE(t,e,s,r,n){const a=i.floor(.5*e),h=i.floor(.5*s),o=e*s;let l="";const _=n?1:2;for(let t=0;t<o;++t)l+=`\\n    result += getWeightedColor(${t}, u_mediump[${_+i.floor(t/4)}][${t%4}]);\\n`;const c=r?"result.a = texture(u_texture, v_coord).a;":"",$=n?"":"\\n    vec4 substitute_color = u_mediump[1];\\n    color = mix(substitute_color, color, isInside(uv));\\n";return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${Rt.FUNCTION_IS_INSIDE()}\\n\\nvec4 getWeightedColor (in int i, in float weight) {\\n    vec2 rcp_size = u_mediump[0].xy;\\n\\n    int i_div_x = i / ${e};\\n    int i_mod_x = i - ${e} * i_div_x;\\n    vec2 offset = vec2(i_mod_x - ${a}, ${h} - i_div_x);\\n    vec2 uv = v_coord + offset * rcp_size;\\n\\n    vec4 color = texture(u_texture, uv);\\n    color.rgb /= max(0.0001, color.a);\\n    ${$}\\n\\n    return color * weight;\\n}\\n\\nvoid main() {\\n    float rcp_divisor = u_mediump[0].z;\\n    float bias        = u_mediump[0].w;\\n\\n    vec4 result = vec4(0.0);\\n    ${l}\\n    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);\\n    ${c}\\n\\n    result.rgb *= result.a;\\n    o_color = result;\\n}\\n\\n`}}class Gt{static TEMPLATE(t,e,i,s){let r,n,a;switch(e){case 1:r="map_color.r";break;case 2:r="map_color.g";break;case 4:r="map_color.b";break;case 8:r="map_color.a";break;default:r="0.5"}switch(i){case 1:n="map_color.r";break;case 2:n="map_color.g";break;case 4:n="map_color.b";break;case 8:n="map_color.a";break;default:n="0.5"}switch(s){case"clamp":a="\\n    vec4 source_color = texture(u_textures[0], uv);\\n";break;case"ignore":a="\\n    vec4 source_color =texture(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));\\n";break;case"color":a="\\n    vec4 substitute_color = u_mediump[2];\\n    vec4 source_color = mix(substitute_color, texture(u_textures[0], uv), isInside(uv));\\n";break;default:a="\\n    vec4 source_color = texture(u_textures[0], fract(uv));\\n"}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\nuniform vec4 u_mediump[${t}];\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${Rt.FUNCTION_IS_INSIDE()}\\n\\nvoid main() {\\n    vec2 uv_to_st_scale  = u_mediump[0].xy;\\n    vec2 uv_to_st_offset = u_mediump[0].zw;\\n    vec2 scale           = u_mediump[1].xy;\\n\\n    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;\\n    vec4 map_color = texture(u_textures[1], st);\\n\\n    vec2 offset = vec2(${r}, ${n}) - 0.5;\\n    vec2 uv = v_coord + offset * scale;\\n    ${a}\\n\\n    o_color = mix(texture(u_textures[0], v_coord), source_color, isInside(st));\\n}\\n\\n`}}class zt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getBlurFilterShader(t){const e=`b${t}`;if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new Ct(this._$gl,this._$context,Nt.TEXTURE(),Xt.TEMPLATE(t));return this._$collection.set(e,i),i}getBitmapFilterShader(t,e,s,r,n,a,h){const o=`f${t?"y":"n"}${e?"y":"n"}${s?"y":"n"}${r}${n?"y":"n"}${a?"y":"n"}`;if(this._$collection.has(o)){const t=this._$collection.get(o);if(t)return t}let l=1;t&&l++,h&&l++;let _=(t?4:0)+(e?4:0)+(a?1:0);h||(_+=s?4:8),_=i.ceil(_/4);const c=new Ct(this._$gl,this._$context,Nt.TEXTURE(),Dt.TEMPLATE(l,_,t,e,s,r,n,a,h));return this._$collection.set(o,c),c}getColorMatrixFilterShader(){if(this._$collection.has("m")){const t=this._$collection.get("m");if(t)return t}const t=new Ct(this._$gl,this._$context,Nt.TEXTURE(),Vt.TEMPLATE());return this._$collection.set("m",t),t}getConvolutionFilterShader(t,e,s,r){const n=`c${("0"+t).slice(-2)}${("0"+e).slice(-2)}${s?"y":"n"}${r?"y":"n"}`;if(this._$collection.has(n)){const t=this._$collection.get(n);if(t)return t}const a=(r?1:2)+i.ceil(t*e/4),h=new Ct(this._$gl,this._$context,Nt.TEXTURE(),Yt.TEMPLATE(a,t,e,s,r));return this._$collection.set(n,h),h}getDisplacementMapFilterShader(t,e,i){const s=`d${t}${e}${i}`;if(this._$collection.has(s)){const t=this._$collection.get(s);if(t)return t}const r="color"===i?3:2,n=new Ct(this._$gl,this._$context,Nt.TEXTURE(),Gt.TEMPLATE(r,t,e,i));return this._$collection.set(s,n),n}setBlurFilterUniform(t,e,i,s,r,n){const a=t.mediump;s?(a[0]=1/e,a[1]=0):(a[0]=0,a[1]=1/i),a[2]=r,a[3]=n}setBitmapFilterUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f,p,m,x,b,v,T,A,y){let M;v?(M=t.textures,M[0]=0,M[1]=1,y&&(M[2]=2)):y&&(M=t.textures,M[0]=0,M[1]=2);const E=t.mediump;let w=0;v&&(E[w]=e/s,E[w+1]=i/r,E[w+2]=n/s,E[w+3]=(i-r-a)/r,w+=4),T&&(E[w]=e/h,E[w+1]=i/o,E[w+2]=l/h,E[w+3]=(i-o-_)/o,w+=4),y||(c?(E[w]=u,E[w+1]=d,E[w+2]=g,E[w+3]=f,w+=4):(E[w]=u,E[w+1]=d,E[w+2]=g,E[w+3]=f,E[w+4]=p,E[w+5]=m,E[w+6]=x,E[w+7]=b,w+=8)),A&&(E[w]=$)}setColorMatrixFilterUniform(t,e){const i=t.mediump;i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[5],i[5]=e[6],i[6]=e[7],i[7]=e[8],i[8]=e[10],i[9]=e[11],i[10]=e[12],i[11]=e[13],i[12]=e[15],i[13]=e[16],i[14]=e[17],i[15]=e[18],i[16]=e[4]/255,i[17]=e[9]/255,i[18]=e[14]/255,i[19]=e[19]/255}setConvolutionFilterUniform(t,e,i,s,r,n,a,h,o,l,_){const c=t.mediump;c[0]=1/e,c[1]=1/i,c[2]=1/r,c[3]=n/255;let $=4;a||(c[$]=h,c[$+1]=o,c[$+2]=l,c[$+3]=_,$+=4);const u=s.length;for(let t=0;t<u;t++)c[$++]=s[t]}setDisplacementMapFilterUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=t.textures;d[0]=0,d[1]=1;const g=t.mediump;g[0]=s/e,g[1]=r/i,g[2]=n/e,g[3]=(r-i-a)/i,g[4]=h/s,g[5]=-o/r,"color"===l&&(g[8]=_,g[9]=c,g[10]=$,g[11]=u)}}class Wt{static TEMPLATE(t){return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_texture;\\n${t?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\nvoid main() {\\n    vec4 src = texture(u_texture, v_coord);\\n    ${t?Rt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = src;\\n}\\n\\n`}}class Ht{static TEMPLATE(t,e){let i;switch(t){case"subtract":i=this.FUNCTION_SUBTRACT();break;case"multiply":i=this.FUNCTION_MULTIPLY();break;case"lighten":i=this.FUNCTION_LIGHTEN();break;case"darken":i=this.FUNCTION_DARKEN();break;case"overlay":i=this.FUNCTION_OVERLAY();break;case"hardlight":i=this.FUNCTION_HARDLIGHT();break;case"difference":i=this.FUNCTION_DIFFERENCE();break;case"invert":i=this.FUNCTION_INVERT();break;default:i=this.FUNCTION_NORMAL()}return`#version 300 es\\nprecision mediump float;\\n\\nuniform sampler2D u_textures[2];\\n${e?"uniform vec4 u_mediump[2];":""}\\n\\nin vec2 v_coord;\\nout vec4 o_color;\\n\\n${i}\\n\\nvoid main() {\\n    vec4 dst = texture(u_textures[0], v_coord);\\n    vec4 src = texture(u_textures[1], v_coord);\\n    ${e?Rt.STATEMENT_COLOR_TRANSFORM_ON(0):""}\\n    o_color = blend(src, dst);\\n}\\n\\n`}static FUNCTION_NORMAL(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    return src + dst - dst * src.a;\\n}\\n\\n"}static FUNCTION_SUBTRACT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_MULTIPLY(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n    vec4 c = src * dst;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_LIGHTEN(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_DARKEN(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_OVERLAY(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 mul = src * dst;\\n    vec3 c1 = 2.0 * mul.rgb;\\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_HARDLIGHT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 mul = src * dst;\\n    vec3 c1 = 2.0 * mul.rgb;\\n    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;\\n    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_DIFFERENCE(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 a = src - src * dst.a;\\n    vec4 b = dst - dst * src.a;\\n\\n    src.rgb /= src.a;\\n    dst.rgb /= dst.a;\\n\\n    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);\\n    c.rgb *= c.a;\\n\\n    return a + b + c;\\n}\\n\\n"}static FUNCTION_INVERT(){return"\\n\\nvec4 blend (in vec4 src, in vec4 dst) {\\n    if (src.a == 0.0) { return dst; }\\n    if (dst.a == 0.0) { return src; }\\n\\n    vec4 b = dst - dst * src.a;\\n    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);\\n\\n    return b + c;\\n}\\n\\n"}}class qt{constructor(t,e){this._$context=t,this._$gl=e,this._$collection=D()}getNormalBlendShader(t){const e="n"+(t?"y":"n");if(this._$collection.has(e)){const t=this._$collection.get(e);if(t)return t}const i=new Ct(this._$gl,this._$context,Nt.BLEND(),Wt.TEMPLATE(t));return this._$collection.set(e,i),i}getClipShader(){if(this._$collection.has("c")){const t=this._$collection.get("c");if(t)return t}const t=new Ct(this._$gl,this._$context,Nt.BLEND_CLIP(),Wt.TEMPLATE(!1));return this._$collection.set("c",t),t}getBlendShader(t,e){const i=`${t}${e?"y":"n"}`;if(this._$collection.has(i)){const t=this._$collection.get(i);if(t)return t}const s=new Ct(this._$gl,this._$context,Nt.BLEND(),Ht.TEMPLATE(t,e));return this._$collection.set(i,s),s}setNormalBlendUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f){const p=t.highp;if(p[0]=e,p[1]=i,p[2]=s,p[3]=r,p[4]=n[0],p[5]=n[1],p[6]=n[2],p[8]=n[3],p[9]=n[4],p[10]=n[5],p[12]=n[6],p[13]=n[7],p[14]=n[8],p[7]=a,p[11]=h,o){const e=t.mediump;e[0]=l,e[1]=_,e[2]=c,e[3]=$,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}setClipUniform(t,e,i,s,r,n,a,h){const o=t.highp;o[0]=e,o[1]=i,o[2]=s,o[3]=r,o[4]=n[0],o[5]=n[1],o[6]=n[2],o[8]=n[3],o[9]=n[4],o[10]=n[5],o[12]=n[6],o[13]=n[7],o[14]=n[8],o[7]=a,o[11]=h}setBlendUniform(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g,f){const p=t.textures;p[0]=0,p[1]=1;const m=t.highp;if(m[0]=e,m[1]=i,m[2]=s,m[3]=r,m[4]=n[0],m[5]=n[1],m[6]=n[2],m[8]=n[3],m[9]=n[4],m[10]=n[5],m[12]=n[6],m[13]=n[7],m[14]=n[8],m[7]=a,m[11]=h,o){const e=t.mediump;e[0]=l,e[1]=_,e[2]=c,e[3]=$,e[4]=u,e[5]=d,e[6]=g,e[7]=f}}}class jt{constructor(t,e){this._$currentProgramId=-1,this._$shapeShaderVariants=new Pt(t,e),this._$gradientShapeShaderVariants=new Lt(t,e),this._$gradientLUTShaderVariants=new Ot(t,e),this._$filterShaderVariants=new zt(t,e),this._$blendShaderVariants=new qt(t,e)}get currentProgramId(){return this._$currentProgramId}set currentProgramId(t){this._$currentProgramId=t}get shapeShaderVariants(){return this._$shapeShaderVariants}get gradientShapeShaderVariants(){return this._$gradientShapeShaderVariants}get gradientLUTShaderVariants(){return this._$gradientLUTShaderVariants}get filterShaderVariants(){return this._$filterShaderVariants}get blendShaderVariants(){return this._$blendShaderVariants}}class Qt{constructor(t,e){this._$context=t,this._$gl=e,this._$attachment=t.frameBuffer.createTextureAttachment(512,1),this._$maxLength=i.floor(.75*e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),this._$rgbToLinearTable=new Float32Array(256),this._$rgbIdentityTable=new Float32Array(256);for(let t=0;t<256;t++){const e=t/255;this._$rgbToLinearTable[t]=i.pow(e,2.23333333),this._$rgbIdentityTable[t]=e}}generateForShape(t,e){const s=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const r=t.length,n=this._$context.shaderList.gradientLUTShaderVariants,a=e?this._$rgbToLinearTable:this._$rgbIdentityTable;this._$context.blend.toOneZero();for(let s=0;s<r;s+=this._$maxLength-1){const h=i.min(s+this._$maxLength,r),o=n.getGradientLUTShader(h-s,e),l=o.uniform;n.setGradientLUTUniformForShape(l,t,s,h,a),o._$drawGradient(0===s?0:t[s][0],h===r?1:t[h-1][0])}if(this._$context._$bind(s),!this._$attachment.texture)throw new Error("the texture is null.");return this._$attachment.texture}generateForFilter(t,e,s){const r=this._$context.frameBuffer.currentAttachment;this._$context._$bind(this._$attachment);const n=t.length,a=this._$context.shaderList.gradientLUTShaderVariants;this._$context.blend.toOneZero();for(let r=0;r<n;r+=this._$maxLength-1){const h=i.min(r+this._$maxLength,n),o=a.getGradientLUTShader(h-r,!1),l=o.uniform;a.setGradientLUTUniformForFilter(l,t,e,s,r,h),o._$drawGradient(0===r?0:t[r],h===n?1:t[h-1])}if(this._$context._$bind(r),!this._$attachment.texture)throw new Error("the texture is null.");return this._$attachment.texture}}class Jt{static get indexRangePool(){return this._$indexRangePool}static generate(t){let e=0;for(let i=0;i<t.length;++i)e+=12*(t[i].length/3-2);this._$vertexBufferData=new a(e),this._$indexRanges=N(),this._$currentIndex=0;for(let e=0;e<t.length;++e){const i=this._$currentIndex;this._$generateMesh(t[e]);const s=this._$currentIndex-i,r=this._$indexRangePool.pop()||{first:0,count:0};r.first=i,r.count=s,this._$indexRanges.push(r)}return{vertexBufferData:this._$vertexBufferData,indexRanges:this._$indexRanges}}static _$generateMesh(t){const e=this._$vertexBufferData;let i=this._$currentIndex;const s=t.length-5;for(let r=3;r<s;r+=3){let s=4*i;t[r+2]?(e[s++]=t[r-3],e[s++]=t[r-2],e[s++]=0,e[s++]=0,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=0,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=1,e[s++]=1):t[r+5]?(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+6],e[s++]=t[r+7],e[s++]=.5,e[s++]=.5):(e[s++]=t[0],e[s++]=t[1],e[s++]=.5,e[s++]=.5,e[s++]=t[r],e[s++]=t[r+1],e[s++]=.5,e[s++]=.5,e[s++]=t[r+3],e[s++]=t[r+4],e[s++]=.5,e[s++]=.5),i+=3}this._$currentIndex=i}}Jt._$indexRangePool=N();class Kt{static generate(t,e,i){this._$vertexBufferData=this._$vertexBufferData||new a(1024),this._$vertexBufferPos=0,this._$indexBufferData=this._$indexBufferData||new Int16Array(256),this._$indexBufferPos=0,this._$lineCap=e,this._$lineJoin=i;for(let e=0;e<t.length;e++){const i=this._$vertexBufferPos;this._$generateLineSegment(t[e]);const s=this._$vertexBufferPos;this._$generateLineJoin(i,s),this._$generateLineCap(i,s)}return{vertexBufferData:this._$vertexBufferData.slice(0,this._$vertexBufferPos),indexBufferData:this._$indexBufferData.slice(0,this._$indexBufferPos)}}static _$expandVertexBufferIfNeeded(t){if(this._$vertexBufferPos+t>this._$vertexBufferData.length){const t=new a(2*this._$vertexBufferData.length);t.set(this._$vertexBufferData),this._$vertexBufferData=t}}static _$expandIndexBufferIfNeeded(t){if(this._$indexBufferPos+t>this._$indexBufferData.length){const t=new o(2*this._$indexBufferData.length);t.set(this._$indexBufferData),this._$indexBufferData=t}}static _$generateLineSegment(t){const e=t.length-5;for(let i=0;i<e;i+=3)t[i+2]||(t[i+5]?this._$addQuadSegmentMesh(t[i],t[i+1],t[i+3],t[i+4],t[i+6],t[i+7]):this._$addLineSegmentMesh(t[i],t[i+1],t[i+3],t[i+4]))}static _$addQuadSegmentMesh(t,e,i,s,r,n){let a=t,h=e;for(let o=1;o<11;o++){const l=o/11,_=1-l,c=(t*_+i*l)*_+(i*_+r*l)*l,$=(e*_+s*l)*_+(s*_+n*l)*l;this._$addLineSegmentMesh(a,h,c,$,2),a=c,h=$}this._$addLineSegmentMesh(a,h,r,n)}static _$addLineSegmentMesh(t,e,i,s,r=1){const n=this._$vertexBufferPos/7,a=n+1,h=n+2,o=n+3;this._$expandIndexBufferIfNeeded(6);const l=this._$indexBufferData;let _=this._$indexBufferPos;l[_++]=n,l[_++]=a,l[_++]=o,l[_++]=o,l[_++]=h,l[_++]=n,this._$indexBufferPos=_,this._$expandVertexBufferIfNeeded(28);const c=this._$vertexBufferData;let $=this._$vertexBufferPos;c[$++]=t,c[$++]=e,c[$++]=i,c[$++]=s,c[$++]=1,c[$++]=1,c[$++]=1,c[$++]=t,c[$++]=e,c[$++]=i,c[$++]=s,c[$++]=-1,c[$++]=-1,c[$++]=1,c[$++]=i,c[$++]=s,c[$++]=t,c[$++]=e,c[$++]=-1,c[$++]=-1,c[$++]=r,c[$++]=i,c[$++]=s,c[$++]=t,c[$++]=e,c[$++]=1,c[$++]=1,c[$++]=r,this._$vertexBufferPos=$}static _$generateLineJoin(t,e){const i=this._$vertexBufferData,s=e-55;for(let e=t;e<s;e+=28){const t=e/7;this._$addLineJoinMesh(i[e],i[e+1],i[e+21],i[e+22],i[e+27],i[e+49],i[e+50],t+2,t+3,t+4,t+5)}}static _$addLineJoinMesh(t,e,s,r,n,a,h,o,l,_=0,c=0){const $=s-t,u=r-e,d=a-s,g=h-r,f=this._$cross($,u,d,g);if(!(i.abs(f)<1e-4))if(2!==n)switch(this._$lineJoin){case"round":this._$addRoundJoinMesh(s,r);break;case"miter":this._$addMiterJoinMesh(s,r,t,e,a,h,_,o,l,c);break;default:this._$addBevelJoinMesh(s,r,_,o,l,c)}else this._$addBevelJoinMesh(s,r,_,o,l,c)}static _$addRoundJoinMesh(t,e){const i=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(57);const s=this._$indexBufferData;let r=this._$indexBufferPos;for(let t=1;t<18;t++){const e=i+t;s[r++]=i,s[r++]=e,s[r++]=e+1}s[r++]=i,s[r++]=i+18,s[r++]=i+1,this._$indexBufferPos=r,this._$expandVertexBufferIfNeeded(133);const n=this._$vertexBufferData;let a=this._$vertexBufferPos;n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0;for(let i=0;i<18;i++)n[a++]=t,n[a++]=e,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=0,n[a++]=30+i;this._$vertexBufferPos=a}static _$addMiterJoinMesh(t,e,i,s,r,n,a,h,o,l){const _=this._$vertexBufferPos/7,c=_+1,$=_+2,u=_+3,d=_+4;this._$expandIndexBufferIfNeeded(18);const g=this._$indexBufferData;let f=this._$indexBufferPos;g[f++]=_,g[f++]=a,g[f++]=c,g[f++]=_,g[f++]=c,g[f++]=$,g[f++]=_,g[f++]=$,g[f++]=h,g[f++]=_,g[f++]=o,g[f++]=u,g[f++]=_,g[f++]=u,g[f++]=d,g[f++]=_,g[f++]=d,g[f++]=l,this._$indexBufferPos=f,this._$expandVertexBufferIfNeeded(35);const p=this._$vertexBufferData;let m=this._$vertexBufferPos;p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=0,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=21,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=22,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=23,p[m++]=t,p[m++]=e,p[m++]=i,p[m++]=s,p[m++]=r,p[m++]=n,p[m++]=24,this._$vertexBufferPos=m}static _$addBevelJoinMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7;this._$expandIndexBufferIfNeeded(6);const h=this._$indexBufferData;let o=this._$indexBufferPos;h[o++]=a,h[o++]=i,h[o++]=s,h[o++]=a,h[o++]=r,h[o++]=n,this._$indexBufferPos=o,this._$expandVertexBufferIfNeeded(7);const l=this._$vertexBufferData;let _=this._$vertexBufferPos;l[_++]=t,l[_++]=e,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,l[_++]=0,this._$vertexBufferPos=_}static _$generateLineCap(t,e){const i=this._$vertexBufferData,s=i[t],r=i[t+1],n=i[t+2],a=i[t+3],h=i[e-7],o=i[e-6],l=i[e-5],_=i[e-4],c=t/7,$=e/7;s!==h||r!==o?(this._$addLineCapMesh(s,r,n,a,c,c+1),this._$addLineCapMesh(h,o,l,_,$-1,$-2)):this._$addLineJoinMesh(l,_,s,r,n,a,$-2,$-1,c,c+1)}static _$addLineCapMesh(t,e,i,s,r,n){switch(this._$lineCap){case"round":this._$addRoundJoinMesh(t,e);break;case"square":this._$addSquareCapMesh(t,e,i,s,r,n)}}static _$addSquareCapMesh(t,e,i,s,r,n){const a=this._$vertexBufferPos/7,h=a+1;this._$expandIndexBufferIfNeeded(6);const o=this._$indexBufferData;let l=this._$indexBufferPos;o[l++]=r,o[l++]=a,o[l++]=h,o[l++]=h,o[l++]=n,o[l++]=r,this._$indexBufferPos=l,this._$expandVertexBufferIfNeeded(14);const _=this._$vertexBufferData;let c=this._$vertexBufferPos;_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=-1,_[c++]=-1,_[c++]=10,_[c++]=t,_[c++]=e,_[c++]=i,_[c++]=s,_[c++]=1,_[c++]=1,_[c++]=10,this._$vertexBufferPos=c}}Kt._$cross=(t,e,i,s)=>t*s-i*e;class Zt{constructor(t){this._$gl=t,this._$fillVertexArrayPool=N(),this._$strokeVertexArrayPool=N(),this._$boundVertexArray=null,this._$fillAttrib_vertex=0,this._$fillAttrib_bezier=1,this._$strokeAttrib_vertex=0,this._$strokeAttrib_option1=1,this._$strokeAttrib_option2=2,this._$strokeAttrib_type=3,this._$vertexBufferData=new a([0,0,0,1,1,0,1,1]),this._$commonVertexArray=this._$getVertexArray(0,1)}_$getVertexArray(t,e){const i=this._$gl.createVertexArray();if(!i)throw new Error("the WebGLVertexArrayObject is null.");this.bind(i);const s=this._$gl.createBuffer();return this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s),this._$vertexBufferData[0]=t,this._$vertexBufferData[2]=t,this._$vertexBufferData[4]=e,this._$vertexBufferData[6]=e,this._$gl.bufferData(this._$gl.ARRAY_BUFFER,this._$vertexBufferData,this._$gl.STATIC_DRAW),this._$gl.enableVertexAttribArray(0),this._$gl.vertexAttribPointer(0,2,this._$gl.FLOAT,!1,0,0),i}_$getFillVertexArray(){if(this._$fillVertexArrayPool.length){const t=this._$fillVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();if(!t)throw new Error("the WebGLVertexArrayObject is null.");this.bind(t);const e=this._$gl.createBuffer();if(!e)throw new Error("the WebGLBuffer is null.");return t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.vertexAttribPointer(this._$fillAttrib_vertex,2,this._$gl.FLOAT,!1,16,0),this._$gl.vertexAttribPointer(this._$fillAttrib_bezier,2,this._$gl.FLOAT,!1,16,8),t}_$getStrokeVertexArray(){if(this._$strokeVertexArrayPool.length){const t=this._$strokeVertexArrayPool.pop();if(t)return t}const t=this._$gl.createVertexArray();if(!t)throw new Error("the WebGLVertexArrayObject is null.");this.bind(t);const e=this._$gl.createBuffer();if(!e)throw new Error("the WebGLBuffer is null.");t.vertexBuffer=e,t.vertexLength=0,this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,e);const i=this._$gl.createBuffer();if(!i)throw new Error("the WebGLBuffer is null.");return t.indexBuffer=i,t.indexLength=0,this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,i),this._$gl.enableVertexAttribArray(0),this._$gl.enableVertexAttribArray(1),this._$gl.enableVertexAttribArray(2),this._$gl.enableVertexAttribArray(3),this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,2,this._$gl.FLOAT,!1,28,0),this._$gl.vertexAttribPointer(this._$strokeAttrib_option1,2,this._$gl.FLOAT,!1,28,8),this._$gl.vertexAttribPointer(this._$strokeAttrib_option2,2,this._$gl.FLOAT,!1,28,16),this._$gl.vertexAttribPointer(this._$strokeAttrib_type,1,this._$gl.FLOAT,!1,28,24),t}createFill(t){const e=Jt.generate(t),i=e.vertexBufferData,s=this._$getFillVertexArray();return s.indexRanges=e.indexRanges,this.bind(s),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,s.vertexBuffer),s.vertexLength<i.length&&(s.vertexLength=X(i.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*s.vertexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,i),s}createStroke(t,e,i){const s=Kt.generate(t,e,i),r=s.vertexBufferData,n=s.indexBufferData,a=this._$getStrokeVertexArray();return a.indexCount=n.length,this.bind(a),this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER,a.vertexBuffer),this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER,a.indexBuffer),a.vertexLength<r.length&&(a.vertexLength=X(r.length),this._$gl.bufferData(this._$gl.ARRAY_BUFFER,4*a.vertexLength,this._$gl.DYNAMIC_DRAW)),a.indexLength<n.length&&(a.indexLength=X(n.length),this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER,2*a.indexLength,this._$gl.DYNAMIC_DRAW)),this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER,0,r),this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER,0,n),a}releaseFill(t){this._$fillVertexArrayPool.push(t)}releaseStroke(t){this._$strokeVertexArrayPool.push(t)}bind(t=null){t!==this._$boundVertexArray&&(this._$boundVertexArray=t,this._$gl.bindVertexArray(t))}bindCommonVertexArray(){this.bind(this._$commonVertexArray)}bindGradientVertexArray(t,e){const i=this._$getVertexArray(t,e);this.bind(i)}}class te{constructor(t,e){this._$context=t,this._$gl=e,this._$clips=[],this._$poolClip=[],this._$clipStatus=!1,this._$containerClip=!1,this._$currentClip=!1}get containerClip(){return this._$containerClip}set containerClip(t){this._$containerClip=t}_$onClear(t){t&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0)}_$onBind(t){!t&&this._$currentClip?(this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1):t&&!this._$currentClip&&(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0,this._$endClipDef())}_$onClearRect(){this._$gl.disable(this._$gl.STENCIL_TEST),this._$currentClip=!1}_$endClip(){const t=this._$context.frameBuffer,e=t.currentAttachment,i=t.getTextureFromCurrentAttachment();this._$context._$bind(this._$context.cacheAttachment),this._$context.cacheAttachment=null,this._$context.blend.disable();const s=this._$context.cacheBounds;this._$context.reset(),this._$context.setTransform(1,0,0,1,0,0),this._$context.drawImage(i,s.xMin,s.yMin,i.width,i.height),this._$context.blend.enable(),t.releaseAttachment(e,!0)}_$enterClip(){this._$currentClip||(this._$gl.enable(this._$gl.STENCIL_TEST),this._$currentClip=!0);const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");t.mask=!0,++t.clipLevel}_$beginClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.stencilMask(1<<t.clipLevel-1),this._$gl.colorMask(!1,!1,!1,!1)}_$endClipDef(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel;let i=0;for(let t=0;t<e;++t)i|=(1<<e-t)-1;this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.EQUAL,255&i,i),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.KEEP,this._$gl.KEEP),this._$gl.stencilMask(255),this._$gl.colorMask(!0,!0,!0,!0)}_$leaveClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");if(--t.clipLevel,t.mask=!!t.clipLevel,!t.clipLevel)return this._$context._$clearRectStencil(0,0,t.width,t.height),void(this._$context.cacheAttachment&&this._$endClip());const e=t.width,i=t.height,s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);U(s.pop()),U(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$currentClip||(this._$currentClip=!0,this._$gl.enable(this._$gl.STENCIL_TEST)),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.REPLACE,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(1<<t.clipLevel),this._$gl.colorMask(!1,!1,!1,!1),a._$containerClip(r,o.first,o.count);const l=r.indexRanges;for(let t=0;t<l.length;++t)Jt.indexRangePool.push(l[t]);U(r.indexRanges),this._$context.vao.releaseFill(r),this._$endClipDef()}_$drawContainerClip(){const t=this._$context.frameBuffer.currentAttachment;if(!t)throw new Error("mask currentAttachment is null.");const e=t.clipLevel,i=this._$context.shaderList.shapeShaderVariants,s=i.getMaskShapeShader(!1,!1),r=s.uniform;let n=e;const a=t.width,h=t.height;this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1);const o=this._$poolClip.length;for(let t=0;t<o;++t){const t=this._$poolClip.shift();if(!t)continue;i.setMaskShapeUniform(r,!1,t.matrixA,t.matrixB,t.matrixC,t.matrixD,t.matrixE,t.matrixF,t.matrixG,t.matrixH,t.matrixI,t.viewportWidth,t.viewportHeight,null);const o=t.vertexArrayObject.indexRanges;for(let e=0;e<o.length;++e){const i=o[e];this._$gl.stencilMask(1<<n-1),s._$containerClip(t.vertexArrayObject,i.first,i.count),Jt.indexRangePool.push(i)}U(o),this._$context.vao.releaseFill(t.vertexArrayObject),++n,n>7&&(this._$unionStencilMask(e,a,h),n=e)}n>e+1&&this._$unionStencilMask(e,a,h)}_$unionStencilMask(t,e,i){const s=this._$context.path.createRectVertices(0,0,e,i),r=this._$context.vao.createFill(s);U(s.pop()),U(s);const n=this._$context.shaderList.shapeShaderVariants,a=n.getMaskShapeShader(!1,!1),h=a.uniform;n.setMaskShapeUniformIdentity(h,e,i);const o=r.indexRanges[0];this._$gl.stencilFunc(this._$gl.LEQUAL,1<<t-1,255),this._$gl.stencilOp(this._$gl.ZERO,this._$gl.REPLACE,this._$gl.REPLACE),this._$gl.stencilMask(~((1<<t-1)-1)),a._$containerClip(r,o.first,o.count),this._$poolClip.length&&(this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT));const l=r.indexRanges;for(let t=0;t<l.length;++t)Jt.indexRangePool.push(l[t]);U(r.indexRanges),this._$context.vao.releaseFill(r)}_$onClip(t,e,i,s){return this._$clipStatus=!0,!!this._$containerClip&&(this._$poolClip.push({vertexArrayObject:t,matrixA:e[0],matrixB:e[1],matrixC:e[2],matrixD:e[3],matrixE:e[4],matrixF:e[5],matrixG:e[6],matrixH:e[7],matrixI:e[8],viewportWidth:i,viewportHeight:s}),!0)}_$onSave(){this._$clips.push(this._$clipStatus)}_$onRestore(){this._$clips.length&&(this._$clipStatus=!!this._$clips.pop())}}class ee{constructor(t,e){this._$context=t,this._$gl=e,this._$enabled=!1,this._$funcCode=600,this.enable()}enable(){this._$enabled||(this._$enabled=!0,this._$gl.enable(this._$gl.BLEND)),this.reset()}disable(){this._$enabled&&(this._$enabled=!1,this._$gl.disable(this._$gl.BLEND))}reset(){613!==this._$funcCode&&(this._$funcCode=613,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE_MINUS_SRC_ALPHA))}toOneZero(){610!==this._$funcCode&&(this._$funcCode=610,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ZERO))}toZeroOne(){601!==this._$funcCode&&(this._$funcCode=601,this._$gl.blendFuncSeparate(this._$gl.ZERO,this._$gl.ONE,this._$gl.ONE,this._$gl.ZERO))}toAdd(){611!==this._$funcCode&&(this._$funcCode=611,this._$gl.blendFunc(this._$gl.ONE,this._$gl.ONE))}toScreen(){641!==this._$funcCode&&(this._$funcCode=641,this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR,this._$gl.ONE))}toAlpha(){606!==this._$funcCode&&(this._$funcCode=606,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.SRC_ALPHA))}toErase(){603!==this._$funcCode&&(this._$funcCode=603,this._$gl.blendFunc(this._$gl.ZERO,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceAtop(){673!==this._$funcCode&&(this._$funcCode=673,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ONE_MINUS_SRC_ALPHA))}toSourceIn(){670!==this._$funcCode&&(this._$funcCode=670,this._$gl.blendFunc(this._$gl.DST_ALPHA,this._$gl.ZERO))}toOperation(t){switch(t){case"add":this.toAdd();break;case"screen":this.toScreen();break;case"alpha":this.toAlpha();break;case"erase":this.toErase();break;case"copy":this.toOneZero();break;default:this.reset()}}drawImage(t,e,s,r,a,h,o,l,_,c,$,u,d,g,f,p,m,x){const b=this._$context.frameBuffer,v=b.currentAttachment,T=1!==h||1!==o||1!==l||1!==_||0!==c||0!==$||0!==u||0!==d,A=this._$context.shaderList.blendShaderVariants;switch(g){case"normal":case"layer":case"add":case"screen":case"alpha":case"erase":case"copy":{b.textureManager.bind0(t,x);const v=A.getNormalBlendShader(T);A.setNormalBlendUniform(v.uniform,e,s,r,a,m,f,p,T,h,o,l,_,c,$,u,d);const y=m[0],M=m[1],E=m[3],w=m[4],C=m[6],S=m[7];if(1!==y||0!==M||0!==E||1!==w){const t=e+r,h=s+a,o=+(t*y+h*E+C),l=+(t*y+s*E+C),_=+(e*y+h*E+C),c=+(e*y+s*E+C),$=+(t*M+h*w+S),u=+(t*M+s*w+S),d=+(e*M+h*w+S),g=+(e*M+s*w+S),m=n.MAX_VALUE,x=+i.min(i.min(i.min(i.min(m,o),l),_),c),b=+i.max(i.max(i.max(i.max(-m,o),l),_),c),v=+i.min(i.min(i.min(i.min(m,$),u),d),g),T=+i.max(i.max(i.max(i.max(-m,$),u),d),g),A=i.max(0,x),B=i.max(0,v),F=i.min(i.max(0,f-A),i.ceil(i.abs(b-x))),R=i.min(i.max(0,p-B),i.ceil(i.abs(T-v)));if(!F||!R)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(A,i.max(0,p-(B+R)),F+1,R+1)}else{const t=i.max(0,e+C),n=i.max(0,s+S),h=i.min(i.max(0,f-t),r),o=i.min(i.max(0,p-n),a);if(!h||!o)return;this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,Math.max(0,p-(n+o)),h+1,o+1)}this.toOperation(g),v._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST)}break;default:{const i=Math.max(0,e+m[6]),n=Math.max(0,s+m[7]),y=Math.min(Math.max(0,f-i),r),M=Math.min(Math.max(0,p-n),a);if(!y||!M)return;const E=b.getTextureFromCurrentAttachment(),w=this._$context.frameBuffer.createTextureAttachment(r,a);this._$context._$bind(w),b.textureManager.bind0(E);const C=A.getClipShader(),S=C.uniform;A.setClipUniform(S,e,s,r,a,V(m),f,p),this.reset(),C._$drawImage();const B=b.getTextureFromCurrentAttachment();this._$context._$bind(v),b.textureManager.bind01(B,t,x);const F=A.getBlendShader(g,T);A.setBlendUniform(F.uniform,e,s,r,a,m,f,p,T,h,o,l,_,c,$,u,d),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(i,Math.max(0,p-(n+M)),y,M),this.toOneZero(),F._$drawImage(),this._$gl.disable(this._$gl.SCISSOR_TEST),b.releaseAttachment(w,!0)}}}}class ie{constructor(t,e){this._$gl=t;const s=i.min(e,t.getParameter(t.MAX_SAMPLES));this._$maxTextureSize=i.min(8192,t.getParameter(t.MAX_TEXTURE_SIZE))-2,this._$contextStyle=new xt,this._$cacheBounds=C(),this._$matrix=L(1,0,0,0,1,0,0,0,1),this._$cacheAttachment=null,this._$stack=[],this._$globalAlpha=1,this._$imageSmoothingEnabled=!1,this._$globalCompositeOperation="normal",this._$clearColorR=1,this._$clearColorG=1,this._$clearColorB=1,this._$clearColorA=1,this._$viewportWidth=0,this._$viewportHeight=0,this._$frameBufferManager=new At(t,s),this._$path=new Mt,this._$grid=new Et,this._$offsetX=0,this._$offsetY=0,this._$blends=N(),this._$positions=N(),this._$isLayer=!1,this._$shaderList=new jt(this,t),this._$gradientLUT=new Qt(this,t),this._$vao=new Zt(t),this._$mask=new te(this,t),this._$blend=new ee(this,t),this._$maskBufferArray=[],this._$maskBoundsArray=[],this._$attachmentArray=[]}reset(){this._$globalAlpha=1,this._$globalCompositeOperation="normal",this._$imageSmoothingEnabled=!1,this._$contextStyle.clear()}get isLayer(){return this._$isLayer}get canvas(){return this._$gl.canvas}get cacheAttachment(){return this._$cacheAttachment}set cacheAttachment(t){this._$cacheAttachment=t}get cacheBounds(){return this._$cacheBounds}get fillStyle(){return this._$contextStyle.fillStyle}set fillStyle(t){this._$contextStyle.fillStyle=t}get strokeStyle(){return this._$contextStyle.strokeStyle}set strokeStyle(t){this._$contextStyle.strokeStyle=t}get lineWidth(){return this._$contextStyle.lineWidth}set lineWidth(t){this._$contextStyle.lineWidth=t}get lineCap(){return this._$contextStyle.lineCap}set lineCap(t){this._$contextStyle.lineCap=t}get lineJoin(){return this._$contextStyle.lineJoin}set lineJoin(t){this._$contextStyle.lineJoin=t}get miterLimit(){return this._$contextStyle.miterLimit}set miterLimit(t){this._$contextStyle.miterLimit=t}get globalAlpha(){return this._$globalAlpha}set globalAlpha(t){this._$globalAlpha=Y(t,0,1,1)}get imageSmoothingEnabled(){return this._$imageSmoothingEnabled}set imageSmoothingEnabled(t){this._$imageSmoothingEnabled=t}get globalCompositeOperation(){return this._$globalCompositeOperation}set globalCompositeOperation(t){this._$globalCompositeOperation=t}get frameBuffer(){return this._$frameBufferManager}get shaderList(){return this._$shaderList}get path(){return this._$path}get grid(){return this._$grid}get vao(){return this._$vao}get blend(){return this._$blend}_$getCurrentPosition(){return this._$positions[this._$positions.length-1]}_$getTextureScale(t,e){const s=i.max(t,e);return s>this._$maxTextureSize?this._$maxTextureSize/s:1}_$bind(t=null){if(!t)return;this._$frameBufferManager.bind(t);const e=t.color,i=t.stencil,s=t.width,r=t.height;this._$viewportWidth===s&&this._$viewportHeight===r||(this._$viewportWidth=s,this._$viewportHeight=r,this._$gl.viewport(0,0,s,r)),(e&&e.dirty||i&&i.dirty)&&(e&&(e.dirty=!1),i&&(i.dirty=!1),this._$gl.clearColor(0,0,0,0),this.clearRect(0,0,this._$viewportWidth,this._$viewportHeight),this._$gl.clearColor(this._$clearColorR,this._$clearColorG,this._$clearColorB,this._$clearColorA),this._$mask._$onClear(t.mask)),this._$mask._$onBind(t.mask)}setTransform(t,e,i,s,r,n){this._$matrix[0]=t,this._$matrix[1]=e,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[6]=r,this._$matrix[7]=n}setMaxSize(t,e){this._$frameBufferManager.setMaxSize(t,e)}transform(t,e,i,s,r,n){const a=this._$matrix[0],h=this._$matrix[1],o=this._$matrix[3],l=this._$matrix[4],_=this._$matrix[6],c=this._$matrix[7];this._$matrix[0]=t*a+e*o,this._$matrix[1]=t*h+e*l,this._$matrix[3]=i*a+s*o,this._$matrix[4]=i*h+s*l,this._$matrix[6]=r*a+n*o+_,this._$matrix[7]=r*h+n*l+c}drawImage(t,e,i,s,r,n=null){let a=1,h=1,o=1,l=0,_=0,c=0;const $=this._$globalAlpha;n&&(a=n[0],h=n[1],o=n[2],l=n[4]/255,_=n[5]/255,c=n[6]/255),this.blend.drawImage(t,e,i,s,r,a,h,o,$,l,_,c,0,this._$globalCompositeOperation,this._$viewportWidth,this._$viewportHeight,this._$matrix,this._$imageSmoothingEnabled)}_$setColor(t=0,e=0,i=0,s=0){this._$clearColorR=t,this._$clearColorG=e,this._$clearColorB=i,this._$clearColorA=s,this._$gl.clearColor(t,e,i,s)}clearRect(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.COLOR_BUFFER_BIT|this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}_$clearRectStencil(t,e,i,s){this._$mask._$onClearRect(),this._$gl.enable(this._$gl.SCISSOR_TEST),this._$gl.scissor(t,e,i,s),this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT),this._$gl.disable(this._$gl.SCISSOR_TEST)}moveTo(t,e){this._$path.moveTo(t,e)}lineTo(t,e){this._$path.lineTo(t,e)}beginPath(){this._$path.begin()}quadraticCurveTo(t,e,i,s){this._$path.quadTo(t,e,i,s)}bezierCurveTo(t,e,i,s,r,n){this._$path.cubicTo(t,e,i,s,r,n)}fill(){const t=this._$path.vertices;if(!t.length)return;const e=N();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void U(e);const i=this._$vao.createFill(e),s=this.fillStyle;let r,n,a,h=this._$matrix;const o=this._$grid.enabled;if(s instanceof pt){const t=s.stops,e="linearRGB"===s.rgb;if(r=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(r,!0),n=this._$shaderList.gradientShapeShaderVariants,"linear"===s.type)a=n.getGradientShapeShader(!1,o,!1,!1,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,s.points,0);else{h=this._$stack[this._$stack.length-1];const t=0!==s.focalPointRatio;a=n.getGradientShapeShader(!1,o,!0,t,s.mode),n.setGradientShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,s.points,s.focalPointRatio)}}else if(s instanceof mt){h=this._$stack[this._$stack.length-1];const t=s.colorTransform;r=s.texture,this._$frameBufferManager.textureManager.bind0(r,this._$imageSmoothingEnabled),n=this._$shaderList.shapeShaderVariants,a=n.getBitmapShapeShader(!1,s.repeat,o),t?n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):n.setBitmapShapeUniform(a.uniform,!1,0,0,0,o,h,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,r.width,r.height,1,1,1,this._$globalAlpha,0,0,0,0)}else n=this._$shaderList.shapeShaderVariants,a=n.getSolidColorShapeShader(!1,this._$grid.enabled),n.setSolidColorShapeUniform(a.uniform,!1,0,0,0,o,h,this._$viewportWidth,this._$viewportHeight,this._$grid,s,this._$globalAlpha);const l=this._$shaderList.shapeShaderVariants,_=l.getMaskShapeShader(!1,o);l.setMaskShapeUniform(_.uniform,o,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],this._$viewportWidth,this._$viewportHeight,this._$grid),this._$gl.enable(this._$gl.STENCIL_TEST),this._$gl.stencilMask(255),this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.ALWAYS,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.INVERT,this._$gl.INVERT),this._$gl.colorMask(!1,!1,!1,!1),_._$fill(i),this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE),this._$gl.stencilFunc(this._$gl.NOTEQUAL,0,255),this._$gl.stencilOp(this._$gl.KEEP,this._$gl.ZERO,this._$gl.ZERO),this._$gl.colorMask(!0,!0,!0,!0),a._$fill(i),this._$gl.disable(this._$gl.STENCIL_TEST),this.releaseFillVertexArray(i)}releaseFillVertexArray(t){this._$vao.releaseFill(t);const e=t.indexRanges;for(let t=0;t<e.length;++t)Jt.indexRangePool.push(e[t]);U(e)}_$enterClip(){this._$mask._$enterClip()}_$beginClipDef(){this._$mask._$beginClipDef()}_$updateContainerClipFlag(t){this._$mask.containerClip=t}_$startClip(t,e){let s=e.xMin,r=e.yMin,n=Math.abs(e.xMax-e.xMin),a=Math.abs(e.yMax-e.yMin);const h=this._$frameBufferManager,o=h.currentAttachment;if(!o||!o.texture)throw new Error("the current Attachment is null.");if(s>o.width||r>o.height)return null;if(n+s>o.width&&(n=o.width-s),a+r>o.height&&(a=o.height-r),0>s&&(n+=s,s=0),0>r&&(a+=r,r=0),0>=n||0>=a)return null;n=i.ceil(n),a=i.ceil(a),this._$cacheBounds.xMin=s,this._$cacheBounds.yMin=r,this._$cacheBounds.xMax=n,this._$cacheBounds.yMax=a,this._$cacheAttachment=o,this._$bind(h.createCacheAttachment(n,a,!0));const l=o.texture;return this.reset(),this.setTransform(1,0,0,1,0,0),this.drawImage(l,-s,-r,l.width,l.height),R(t[0],t[1],t[2],t[3],t[4]-e.xMin,t[5]-e.yMin)}_$endClipDef(){this._$mask._$endClipDef()}_$leaveClip(){this._$mask._$leaveClip()}_$drawContainerClip(){this._$mask._$drawContainerClip()}closePath(){this._$path.close()}stroke(){const t=this._$path.vertices;if(!t.length)return;const e=N();for(let i=0;i<t.length;++i){const s=t[i];6>s.length||e.push(s)}if(!e.length)return void U(e);const s=this._$vao.createStroke(t,this.lineCap,this.lineJoin);let r=this._$matrix;const n=this.strokeStyle;let a=i.sign(r[0]*r[4]);a>0&&0!==r[1]&&0!==r[3]&&(a=-i.sign(r[1]*r[3]));let h,o,l=.5*this.lineWidth;this._$grid.enabled?(h=i.abs(this._$grid.ancestorMatrixA+this._$grid.ancestorMatrixD),o=i.abs(this._$grid.ancestorMatrixB+this._$grid.ancestorMatrixE)):(h=i.abs(r[0]+r[3]),o=i.abs(r[1]+r[4]));const _=i.min(h,o),c=i.max(h,o);l*=c*(1-.3*i.cos(.5*i.PI*(_/c))),l=i.max(1,l);const $=this._$grid.enabled;let u,d,g;if(n instanceof pt){"radial"===n.type&&(r=this._$stack[this._$stack.length-1]);const t=n.stops,e="linearRGB"===n.rgb;if(u=this._$gradientLUT.generateForShape(t,e),this._$frameBufferManager.textureManager.bind0(u,!0),d=this._$shaderList.gradientShapeShaderVariants,"linear"===n.type)g=d.getGradientShapeShader(!0,$,!1,!1,n.mode),d.setGradientShapeUniform(g.uniform,!0,l,a,this.miterLimit,$,r,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!1,n.points,0);else{r=this._$stack[this._$stack.length-1];const t=0!==n.focalPointRatio;g=d.getGradientShapeShader(!0,$,!0,t,n.mode),d.setGradientShapeUniform(g.uniform,!0,l,a,this.miterLimit,$,r,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,!0,n.points,n.focalPointRatio)}}else if(n instanceof mt){r=this._$stack[this._$stack.length-1];const t=n.colorTransform;u=n.texture,this._$frameBufferManager.textureManager.bind0(u),d=this._$shaderList.shapeShaderVariants,g=d.getBitmapShapeShader(!0,n.repeat,this._$grid.enabled),t?d.setBitmapShapeUniform(g.uniform,!0,l,a,this.miterLimit,$,r,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,u.width,u.height,t[0],t[1],t[2],this._$globalAlpha,t[4]/255,t[5]/255,t[6]/255,0):d.setBitmapShapeUniform(g.uniform,!0,l,a,this.miterLimit,$,r,V(this._$matrix),this._$viewportWidth,this._$viewportHeight,this._$grid,u.width,u.height,1,1,1,this._$globalAlpha,0,0,0,0)}else d=this._$shaderList.shapeShaderVariants,g=d.getSolidColorShapeShader(!0,this._$grid.enabled),d.setSolidColorShapeUniform(g.uniform,!0,l,a,this.miterLimit,$,r,this._$viewportWidth,this._$viewportHeight,this._$grid,n,this._$globalAlpha);g._$stroke(s),this._$vao.releaseStroke(s)}arc(t,e,i){this._$path.drawCircle(t,e,i)}clip(){const t=this._$path.vertices;if(!t.length)return;const e=N();for(let i=0;i<t.length;++i){const s=t[i];10>s.length||e.push(s)}if(!e.length)return void U(e);const i=this._$vao.createFill(e),s=this._$shaderList.shapeShaderVariants,r=s.getMaskShapeShader(!1,!1),n=r.uniform;s.setMaskShapeUniform(n,!1,this._$matrix[0],this._$matrix[1],this._$matrix[2],this._$matrix[3],this._$matrix[4],this._$matrix[5],this._$matrix[6],this._$matrix[7],this._$matrix[8],this._$viewportWidth,this._$viewportHeight,null),this._$mask._$onClip(i,this._$matrix,this._$viewportWidth,this._$viewportHeight)||(r._$fill(i),this.beginPath())}save(){const t=this._$matrix;this._$stack.push(L(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])),this._$mask._$onSave()}restore(){var t;this._$stack.length&&(t=this._$matrix,A.push(t),this._$matrix=this._$stack.pop()||L()),this._$mask._$onRestore()}createPattern(t,e,i){return new mt(this,t,e,i)}createLinearGradient(t,e,i,s,r="rgb",n="pad"){return(new pt).linear(t,e,i,s,r,n)}createRadialGradient(t,e,i,s,r,n,a="rgb",h="pad",o=0){return(new pt).radial(t,e,i,s,r,n,a,h,o)}_$applyBlurFilter(t,e,s){const r=this._$frameBufferManager,n=r.currentAttachment;if(!n)throw new Error("the current attachment is null.");const a=n.width,h=n.height;r.textureManager.bind0(t,!0);const o=i.ceil(.5*s),l=1-(o-.5*s),_=1+s,c=this._$shaderList.filterShaderVariants,$=c.getBlurFilterShader(o);c.setBlurFilterUniform($.uniform,a,h,e,l,_),$._$drawImage()}_$applyBitmapFilter(t,e,i,s,r,n,a,h,o,l,_,c,$,u,d,g=null,f=null,p=null,m=0,x=0,b=0,v=0,T=0,A=0,y=0,M=0){const E=this._$frameBufferManager,w="inner"===$,C=E.currentAttachment,S=E.getTextureFromCurrentAttachment();let B=null;const F=null!==g&&null!==f&&null!==p;let R;null!==g&&null!==f&&null!==p&&(B=this._$gradientLUT.generateForFilter(g,f,p)),w?F&&B?E.textureManager.bind02(t,B,!0):E.textureManager.bind0(t):(R=this._$frameBufferManager.createTextureAttachment(e,i),this._$bind(R),F&&B?E.textureManager.bind012(t,S,B,!0):E.textureManager.bind01(t,S));const I=!(w||"full"===$&&u),P=!(e===h&&i===o&&0===l&&0===_),k=!(1===d),L=this._$shaderList.filterShaderVariants,N=L.getBitmapFilterShader(I,P,c,$,u,k,F);L.setBitmapFilterUniform(N.uniform,e,i,s,r,n,a,h,o,l,_,c,d,m,x,b,v,T,A,y,M,I,P,k,F),w?u?this.blend.toSourceIn():this.blend.toSourceAtop():this.blend.toOneZero(),N._$drawImage(),w||E.releaseAttachment(C,!0)}_$applyColorMatrixFilter(t,e){this._$frameBufferManager.textureManager.bind0(t,!0);const i=this._$shaderList.filterShaderVariants,s=i.getColorMatrixFilterShader();i.setColorMatrixFilterUniform(s.uniform,e),this.blend.reset(),s._$drawImage()}_$applyConvolutionFilter(t,e,i,s,r,n,a,h,o,l,_,c){const $=t.width,u=t.height,d=this._$frameBufferManager.createTextureAttachment($,u);this._$bind(d),this._$frameBufferManager.textureManager.bind0(t,!0);const g=this._$shaderList.filterShaderVariants,f=g.getConvolutionFilterShader(e,i,a,h);g.setConvolutionFilterUniform(f.uniform,$,u,s,r,n,h,o,l,_,c),this.blend.reset(),f._$drawImage()}_$applyDisplacementMapFilter(t,e,i,s,r,n,a,h,o,l,_,c,$,u){const d=t.width,g=t.height,f=this._$frameBufferManager.createTextureAttachment(d,g);this._$bind(f),r||(r={x:0,y:0}),this._$frameBufferManager.textureManager.bind01(t,e);const p=this._$shaderList.filterShaderVariants,m=p.getDisplacementMapFilterShader(n,a,l);p.setDisplacementMapFilterUniform(m.uniform,e.width,e.height,i,s,r.x,r.y,h,o,l,_,c,$,u),this.blend.reset(),m._$drawImage()}_$startLayer(t){this._$positions.push(t),this._$blends.push(this._$isLayer),this._$isLayer=!0}_$endLayer(){const t=this._$positions.pop();t&&S(t),this._$isLayer=!!this._$blends.pop()}_$saveCurrentMask(){this._$maskBufferArray.push(this._$cacheAttachment),this._$cacheAttachment=null;const t=this._$cacheBounds;this._$maskBoundsArray.push(C(t.xMin,t.xMax,t.yMin,t.yMax))}_$saveAttachment(t,e,i=!1){const s=this._$frameBufferManager;this._$attachmentArray.push(s.currentAttachment),this._$bind(s.createCacheAttachment(t,e,i))}_$restoreAttachment(t=!1){const e=this._$frameBufferManager;e.releaseAttachment(e.currentAttachment,t),this._$bind(this._$attachmentArray.pop())}_$restoreCurrentMask(){this._$cacheAttachment=this._$maskBufferArray.pop()||null,this._$cacheBounds=this._$maskBoundsArray.pop()||C()}getCurrentPosition(){return this._$positions[this._$positions.length-1]}textureScale(t,e){const s=i.max(t,e);return s>this._$maxTextureSize?this._$maxTextureSize/s:1}}class se extends gt{_$clip(t,s){let r=s;const n=this._$matrix;1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(r=G(s,n));const a=this._$getBounds(),h=W(a,r);S(a);const o=i.ceil(i.abs(h.xMax-h.xMin)),l=i.ceil(i.abs(h.yMax-h.yMin));switch(S(h),!0){case 0===o:case 0===l:case o===-1/0:case l===-1/0:case o===e:case l===e:return}super._$clip(t,r),r!==s&&I(r)}_$draw(t,e,i){if(!this._$visible||!this._$maxAlpha||!this._$canDraw)return;let s=i;const r=this._$colorTransform;if(1===r[0]&&1===r[1]&&1===r[2]&&1===r[3]&&0===r[4]&&0===r[5]&&0===r[6]&&0===r[7]||(s=z(i,r)),!Y(s[3]+s[7]/255,0,1,0))return void(s!==i&&k(s));let n=e;const a=this._$matrix;1===a[0]&&0===a[1]&&0===a[2]&&1===a[3]&&0===a[4]&&0===a[5]||(n=G(e,a)),super._$draw(t,n,s,this._$blendMode,this._$filters),n!==e&&I(n),s!==i&&k(s)}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$recodes=null,super._$remove(),le.push(this)}}class re extends dt{constructor(){super(),this._$background=!1,this._$backgroundColor=16777215,this._$border=!1,this._$borderColor=0,this._$wordWrap=!1,this._$textData=N(),this._$textAreaActive=!1,this._$thickness=0,this._$thicknessColor=0,this._$limitWidth=0,this._$limitHeight=0,this._$autoSize="none",this._$widthTable=N(),this._$heightTable=N(),this._$objectTable=N(),this._$textHeightTable=N(),this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$maxScrollV=null,this._$scrollV=1,this._$textHeight=0,this._$verticalAlign="top"}get width(){const t=W(this._$getBounds(null),this._$matrix),s=i.abs(t.xMax-t.xMin);switch(S(t),!0){case 0===s:case s===e:case s===-1/0:return 0;default:return s}}get height(){const t=W(this._$getBounds(null),this._$matrix),s=i.abs(t.yMax-t.yMin);switch(S(t),s){case 0:case e:case-1/0:return 0;default:return s}}get maxScrollV(){if(null===this._$maxScrollV){this._$maxScrollV=1;const t=this._$textHeightTable.length,e=this.height;if(e>this._$textHeight)return this._$maxScrollV;let i=0,s=0;for(;t>s&&(i+=this._$textHeightTable[s++],!(i>e));)this._$maxScrollV++}return this._$maxScrollV}_$clip(t,e){const s=this._$getBounds(),r=s.xMax,n=s.xMin,a=s.yMax,h=s.yMin;S(s);const o=i.ceil(i.abs(r-n)),l=i.ceil(i.abs(a-h));if(!o||!l)return;let _=e;const c=this._$matrix;1===c[0]&&0===c[1]&&0===c[2]&&1===c[3]&&0===c[4]&&0===c[5]||(_=G(e,c)),t.reset(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(o,0),t.lineTo(o,l),t.lineTo(0,l),t.lineTo(0,0),t.clip(),_!==e&&I(_)}_$draw(t,s,r){if(!this._$visible||this._$textAreaActive)return;if(!this._$background&&!this._$border&&2>this._$textData.length)return;let a=r;const h=this._$colorTransform;1===h[0]&&1===h[1]&&1===h[2]&&1===h[3]&&0===h[4]&&0===h[5]&&0===h[6]&&0===h[7]||(a=z(r,h));const o=Y(a[3]+a[7]/255,0,1);if(!o)return;let l=s;const _=this._$matrix;1===_[0]&&0===_[1]&&0===_[2]&&1===_[3]&&0===_[4]&&0===_[5]||(l=G(s,_));const c=this._$getBounds(null);c.xMin-=this._$thickness,c.xMax+=this._$thickness,c.yMin-=this._$thickness,c.yMax+=this._$thickness;const $=W(c,l),u=+$.xMax,d=+$.xMin,g=+$.yMax,f=+$.yMin;S($);const p=i.ceil(i.abs(u-d)),m=i.ceil(i.abs(g-f));switch(!0){case 0===p:case 0===m:case p===-1/0:case m===-1/0:case p===e:case m===e:return}if(0>d+p||0>f+m)return;const x=t.frameBuffer,b=x.currentAttachment;if(!b||d>b.width||f>b.height)return;let v=+i.sqrt(l[0]*l[0]+l[1]*l[1]);if(!n.isInteger(v)){const t=v.toString(),e=t.indexOf("e");-1!==e&&(v=+t.slice(0,e)),v=+v.toFixed(4)}let T=+i.sqrt(l[2]*l[2]+l[3]*l[3]);if(!n.isInteger(T)){const t=T.toString(),e=t.indexOf("e");-1!==e&&(T=+t.slice(0,e)),T=+T.toFixed(4)}if(0>d+p||0>f+m){if(!(this._$filters&&this._$filters.length&&this._$canApply(this._$filters)))return;{let t=new it(0,0,p,m);for(let e=0;e<this._$filters.length;++e)t=this._$filters[e]._$generateFilterRect(t,v,T);if(0>t.x+t.width||0>t.y+t.height)return}}const A=N(v,T),y=this._$instanceId,M=oe.cacheStore,E=M.generateKeys(y,A);U(A);let w=M.get(E);if(this._$isUpdated()&&(M.removeCache(y),w=null),!w){const t=i.min(1,i.max(v,T)),e=i.ceil(i.abs(c.xMax-c.xMin)*v),n=i.ceil(i.abs(c.yMax-c.yMin)*T);a[3]=1;const h=new OffscreenCanvas(e+2*t,n+2*t).getContext("2d");if(!h)return;if(this._$background||this._$border){if(h.beginPath(),h.moveTo(0,0),h.lineTo(e,0),h.lineTo(e,n),h.lineTo(0,n),h.lineTo(0,0),this._$background){const t=J(this._$backgroundColor),e=i.max(0,i.min(255*t.A*r[3]+r[7],255))/255;h.fillStyle=`rgba(${t.R},${t.G},${t.B},${e})`,h.fill()}if(this._$border){const e=J(this._$borderColor),s=i.max(0,i.min(255*e.A*r[3]+r[7],255))/255;h.lineWidth=t,h.strokeStyle=`rgba(${e.R},${e.G},${e.B},${s})`,h.stroke()}}h.save(),h.beginPath(),h.moveTo(2,2),h.lineTo(e-2,2),h.lineTo(e-2,n-2),h.lineTo(2,n-2),h.lineTo(2,2),h.clip(),h.beginPath(),h.setTransform(v,0,0,T,0,0),this._$doDraw(h,s,r,e/v),h.restore(),w=x.createTextureFromCanvas(h.canvas),M.set(E,w)}let C=!1,B=0,F=0;this._$filters&&this._$filters.length&&this._$canApply(this._$filters)&&(C=!0,w=this._$drawFilter(t,w,l,this._$filters,p,m),B=w._$offsetX,F=w._$offsetY);const R=i.atan2(l[1],l[0]),P=i.atan2(0-l[2],l[3]);if(C||!R&&!P)t.setTransform(1,0,0,1,d-B,f-F);else{const e=c.xMin*v,s=c.yMin*T,r=i.cos(R),n=i.sin(R),a=i.cos(P),h=i.sin(P);t.setTransform(r,n,0-h,a,e*r-s*h+l[4],e*n+s*a+l[5])}t.reset(),t.globalAlpha=o,t.imageSmoothingEnabled=!0,t.globalCompositeOperation=this._$blendMode,t.drawImage(w,0,0,w.width,w.height,a),U(E),S(c),l!==s&&I(l),a!==r&&k(a)}_$doDraw(t,e,s,r){const n=this.width,a=this.height;let h=0,o=0,l=0,_=0;if("top"!==this._$verticalAlign&&this.height>this._$textHeight)switch(this._$verticalAlign){case"middle":_=(this.height-this._$textHeight+2)/2;break;case"bottom":_=this.height-this._$textHeight+2}const c=this._$textData.length;for(let $=0;$<c;++$){const c=this._$textData[$];if(0===c.width)continue;const u=h+c.x;if("none"===this._$autoSize&&(o>a||u>n))continue;const d=c.textFormat,g=J(c.textFormat._$color),f=i.max(0,i.min(255*g.A*s[3]+s[7],255))/255;if(t.fillStyle=`rgba(${g.R},${g.G},${g.B},${f})`,this._$thickness){const e=J(this._$thicknessColor),r=i.max(0,i.min(255*e.A*s[3]+s[7],255))/255;t.lineWidth=this._$thickness,t.strokeStyle=`rgba(${e.R},${e.G},${e.B},${r})`}const p=c.yIndex;switch(c.mode){case"break":case"wrap":if(l++,this._$scrollV>l)continue;if(o+=this._$textHeightTable[p],h=this._$getAlignOffset(this._$objectTable[p],r),d._$underline){const r=c.textFormat._$size/12,n=J(d._$color),a=i.max(0,i.min(255*n.A*s[3]+s[7],255))/255;t.lineWidth=i.max(1,1/i.min(e[0],e[3])),t.strokeStyle=`rgba(${n.R},${n.G},${n.B},${a})`,t.beginPath(),t.moveTo(h,_+o-r),t.lineTo(h+this._$widthTable[p],_+o-r),t.stroke()}break;case"text":{if(this._$scrollV>l)continue;let e=o-this._$heightTable[0];he||(e+=c.textFormat._$size/12*2),t.beginPath(),t.textBaseline="top",t.font=K(d._$font,d._$size,d._$italic,d._$bold),this._$thickness&&t.strokeText(c.text,u,_+e),t.fillText(c.text,u,_+e)}break;case"image":if(!c.loaded)continue;t.beginPath(),t.drawImage(c.image,c.hspace,_+c.y,c.width,c.height)}}}_$getAlignOffset(t,e){const s=this._$widthTable[t.yIndex],r=t.textFormat,n=r._$blockIndent+r._$leftMargin>0?r._$blockIndent+r._$leftMargin:0;switch(!0){case!this._$wordWrap&&s>e:return i.max(0,n);case"center"===r._$align:case"center"===this._$autoSize:return i.max(0,e/2-n-r._$rightMargin-s/2);case"right"===r._$align:case"right"===this._$autoSize:return i.max(0,e-n-s-r._$rightMargin-2);default:return i.max(0,n+2)}}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$textData.length=0,this._$widthTable.length=0,this._$heightTable.length=0,this._$objectTable.length=0,this._$textHeightTable.length=0,this._$textAreaActive=!1,super._$remove(),_e.push(this)}_$updateProperty(t){this._$textAreaActive=!!t.textAreaActive,this._$textData.length=0,this._$widthTable.length=0,this._$heightTable.length=0,this._$objectTable.length=0,this._$textHeightTable.length=0,this._$textData.push(...t.textData),this._$widthTable.push(...t.widthTable),this._$heightTable.push(...t.heightTable),this._$objectTable.push(...t.objectTable),this._$textHeightTable.push(...t.textHeightTable),this._$wordWrap=t.wordWrap,this._$limitWidth=t.limitWidth,this._$limitHeight=t.limitHeight,this._$autoSize=t.autoSize,this._$scrollV=t.scrollV,this._$textHeight=t.textHeight,this._$verticalAlign=t.verticalAlign,this._$border=t.border,this._$border&&(this._$borderColor=t.borderColor),this._$background=t.background,this._$background&&(this._$backgroundColor=t.backgroundColor),"thickness"in t&&(this._$thickness=t.thickness,this._$thicknessColor=t.thicknessColor)}_$update(t){super._$update(t),this._$textAreaActive=!!t.textAreaActive,this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,t.textData&&this._$updateProperty(t)}}class ne extends dt{constructor(){super(),this._$imageBitmap=null,this._$context=null,this._$smoothing=!0}_$clip(t,e){const i=this._$xMax,s=this._$yMax;if(!i||!s)return;let r=e;const n=this._$matrix;1===n[0]&&0===n[1]&&0===n[2]&&1===n[3]&&0===n[4]&&0===n[5]||(r=G(e,n)),t.reset(),t.setTransform(r[0],r[1],r[2],r[3],r[4],r[5]),t.beginPath(),t.moveTo(0,0),t.lineTo(i,0),t.lineTo(i,s),t.lineTo(0,s),t.lineTo(0,0),t.clip(),r!==e&&I(r)}_$draw(t,s,r){if(!this._$visible||!this._$imageBitmap||!this._$context)return;let n=r;const a=this._$colorTransform;1===a[0]&&1===a[1]&&1===a[2]&&1===a[3]&&0===a[4]&&0===a[5]&&0===a[6]&&0===a[7]||(n=z(r,a));const h=Y(n[3]+n[7]/255,0,1,0);if(!h)return void(n!==r&&k(n));let o=s;const l=this._$matrix;1===l[0]&&0===l[1]&&0===l[2]&&1===l[3]&&0===l[4]&&0===l[5]||(o=G(s,l));const _=this._$getBounds();S(_);const c=W(_,o),$=+c.xMax,u=+c.xMin,d=+c.yMax,g=+c.yMin;S(c);const f=i.ceil(i.abs($-u)),p=i.ceil(i.abs(d-g));switch(!0){case 0===f:case 0===p:case f===-1/0:case p===-1/0:case f===e:case p===e:return}const m=t.frameBuffer,x=m.currentAttachment;if(!x||u>x.width||g>x.height)return;if(0>u+f||0>g+p){if(!(this._$filters&&this._$filters.length&&this._$canApply(this._$filters)))return;{const t=+i.sqrt(o[0]*o[0]+o[1]*o[1]),e=+i.sqrt(o[2]*o[2]+o[3]*o[3]);let s=new it(0,0,f,p);for(let i=0;i<this._$filters.length;++i)s=this._$filters[i]._$generateFilterRect(s,t,e);if(0>s.x+s.width||0>s.y+s.height)return}}this._$context.drawImage(this._$imageBitmap,0,0);let b=m.textureManager._$createFromElement(this._$imageBitmap.width,this._$imageBitmap.height,this._$context.canvas,this._$smoothing);if(this._$filters&&this._$filters.length&&this._$canApply(this._$filters)){const e=+i.sqrt(o[0]*o[0]+o[1]*o[1]),s=+i.sqrt(o[2]*o[2]+o[3]*o[3]);if(1!==e||1!==s){const i=m.currentAttachment,r=m.createCacheAttachment(f,p,!1);t._$bind(r);const n=R(e,0,0,s,f/2,p/2),a=R(1,0,0,1,0-b.width/2,0-b.height/2),h=G(n,a);I(n),I(a),t.reset(),t.setTransform(h[0],h[1],h[2],h[3],h[4],h[5]),t.drawImage(b,0,0,b.width,b.height),m.releaseTexture(b),I(h),b=m.getTextureFromCurrentAttachment(),m.releaseAttachment(r,!1),t._$bind(i)}b=this._$drawFilter(t,b,o,this._$filters,f,p),t.reset(),t.globalAlpha=h,t.imageSmoothingEnabled=this._$smoothing,t.globalCompositeOperation=this._$blendMode;const n=this._$getBounds(),a=W(n,o);S(n),t.setTransform(1,0,0,1,a.xMin-b._$offsetX,a.yMin-b._$offsetY),S(a),t.drawImage(b,0,0,b.width,b.height,r)}else t.reset(),t.globalAlpha=h,t.imageSmoothingEnabled=this._$smoothing,t.globalCompositeOperation=this._$blendMode,t.setTransform(o[0],o[1],o[2],o[3],o[4],o[5]),t.drawImage(b,0,0,b.width,b.height,r),m.releaseTexture(b);o!==s&&I(o),n!==r&&k(n)}_$remove(){this._$xMin=0,this._$yMin=0,this._$xMax=0,this._$yMax=0,this._$context=null,this._$imageBitmap=null,this._$smoothing=!0,super._$remove(),$e.push(this)}_$updateProperty(t){if(this._$xMin=t.xMin,this._$yMin=t.yMin,this._$xMax=t.xMax,this._$yMax=t.yMax,this._$imageBitmap=t.imageBitmap,this._$smoothing=t.smoothing,!this._$context&&this._$imageBitmap){const t=new l(this._$imageBitmap.width,this._$imageBitmap.height);this._$context=t.getContext("2d")}}_$update(t){super._$update(t),this._$updateProperty(t)}}let ae=2;let he=!1;const oe=new class{constructor(){this._$instances=new Map,this._$cacheStore=new tt,this._$matrix=R(1,0,0,1,0,0),this._$colorTransform=new a([1,1,1,1,0,0,0,0]),this._$width=0,this._$height=0,this._$stage=new ft,this._$samples=4,this._$canvas=null,this._$context=null,this._$attachment=null}get instances(){return this._$instances}get cacheStore(){return this._$cacheStore}get context(){return this._$context}get scaleX(){return this._$matrix[0]}stop(){this._$cacheStore.reset()}_$initialize(t,e=4,i=2){(t=>{ae=t})(i),this._$samples=e,this._$canvas=t;const s=t.getContext("webgl2",{stencil:!0,premultipliedAlpha:!0,antialias:!1,depth:!1,preserveDrawingBuffer:!0});if(s){const t=new ie(s,e);this._$context=t,this._$cacheStore.context=t}}_$setBackgroundColor(t="transparent"){var e;if(this._$context)if("transparent"===t)this._$context._$setColor(0,0,0,0);else{const i={A:(e=H(t))>>>24,R:(16711680&e)>>16,G:(65280&e)>>8,B:255&e};this._$context._$setColor(i.R/255,i.G/255,i.B/255,1)}}_$bitmapDraw(t,e,i,s){const r=this._$context;if(!r)return;r._$bind(this._$attachment),r.reset(),r.setTransform(1,0,0,1,0,0),r.clearRect(0,0,this._$width,this._$height),r.beginPath(),t._$draw(r,e,i);const n=r.frameBuffer,a=n.getTextureFromCurrentAttachment();n.unbind(),r.reset(),r.setTransform(1,0,0,1,0,0),r.clearRect(0,0,this._$width,this._$height),r.drawImage(a,0,0,this._$width,this._$height),r._$bind(this._$attachment);const h=s.getContext("2d");h&&this._$canvas&&h.drawImage(this._$canvas,0,0)}_$draw(){if(!this._$width||!this._$height)return;const t=this._$context;if(!t)return;t._$bind(this._$attachment),t.reset(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.beginPath(),this._$stage._$draw(t,this._$matrix,g),this._$stage._$updated=!1;const e=t.frameBuffer,i=e.getTextureFromCurrentAttachment();e.unbind(),t.reset(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,this._$width,this._$height),t.drawImage(i,0,0,this._$width,this._$height),t._$bind(this._$attachment)}_$resize(t,e,i,s=0,r=0){if(this._$width=t,this._$height=e,!this._$canvas)return;this._$canvas.width=t,this._$canvas.height=e;const n=this._$context;if(!n)return;n._$gl.viewport(0,0,t,e);const a=n.frameBuffer;this._$attachment&&(a.unbind(),a.releaseAttachment(this._$attachment,!0)),this._$attachment=a.createCacheAttachment(t,e,!1),this._$matrix[0]=i,this._$matrix[3]=i,this._$matrix[4]=s,this._$matrix[5]=r,a.setMaxSize(t,e),this._$stage._$updated=!0,this._$cacheStore.reset()}_$setStage(t){this._$stage._$instanceId=t,this._$instances.set(t,this._$stage)}_$updateStage(){this._$stage._$updated=!0}_$createDisplayObjectContainer(t){const e=ue();e._$instanceId=t.instanceId,t.recodes&&(e._$recodes=t.recodes,e._$maxAlpha=t.maxAlpha||1,e._$canDraw=t.canDraw||!0,e._$xMin=t.xMin||0,e._$yMin=t.yMin||0,e._$xMax=t.xMax||0,e._$yMax=t.yMax||0),t.grid&&(e._$scale9Grid=new it(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),this._$instances.set(e._$instanceId,e)}_$createShape(t){const e=fe();e._$instanceId=t.instanceId,e._$parentId=t.parentId,t.recodes&&(e._$recodes=t.recodes),e._$maxAlpha=t.maxAlpha||1,e._$canDraw=t.canDraw||!0,e._$xMin=t.xMin||0,e._$yMin=t.yMin||0,e._$xMax=t.xMax||0,e._$yMax=t.yMax||0,t.characterId&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId||0),t.grid&&(e._$scale9Grid=new it(t.grid.x,t.grid.y,t.grid.w,t.grid.h)),this._$instances.set(e._$instanceId,e)}_$createVideo(t){const e=ge();e._$instanceId=t.instanceId,t.characterId&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId||0),e._$updateProperty(t),this._$instances.set(e._$instanceId,e)}_$createTextField(t){const e=de();e._$instanceId=t.instanceId,e._$xMin=t.xMin||0,e._$yMin=t.yMin||0,e._$xMax=t.xMax||0,e._$yMax=t.yMax||0,t.characterId&&(e._$characterId=t.characterId),"loaderInfoId"in t&&(e._$loaderInfoId=t.loaderInfoId||0),e._$updateProperty(t),this._$instances.set(e._$instanceId,e)}},le=[],_e=[],ce=[],$e=[],ue=()=>ce.pop()||new ft,de=()=>_e.pop()||new re,ge=()=>$e.pop()||new ne,fe=()=>le.pop()||new se;const pe=new class{constructor(){this.state="deactivate",this.queue=[]}execute(){for(this.state="active";this.queue.length;){const e=this.queue.shift();switch(e.command){case"draw":oe._$draw();break;case"setProperty":{const t=oe.instances;if(!t.has(e.instanceId))continue;t.get(e.instanceId)._$update(e)}break;case"setChildren":{const t=oe.instances;if(!t.has(e.instanceId))continue;t.get(e.instanceId)._$children=e.children}break;case"doChanged":{const t=oe.instances;if(!t.has(e.instanceId))continue;t.get(e.instanceId)._$updated=!0}break;case"remove":{const t=oe.instances;if(!t.has(e.instanceId))continue;t.get(e.instanceId)._$remove(),t.delete(e.instanceId)}break;case"createShape":oe._$createShape(e);break;case"createDisplayObjectContainer":oe._$createDisplayObjectContainer(e);break;case"createTextField":oe._$createTextField(e);break;case"createVideo":oe._$createVideo(e);break;case"resize":oe._$resize(e.width,e.height,e.scale,e.tx,e.ty);break;case"initialize":oe._$initialize(e.canvas,e.samples,e.devicePixelRatio);break;case"setSafari":t=e.isSafari,he=t;break;case"setBackgroundColor":oe._$setBackgroundColor(e.backgroundColor);break;case"setStage":oe._$setStage(e.instanceId);break;case"stop":oe.stop();break;case"removeCache":oe.cacheStore.removeCache(e.id);break;case"bitmapDraw":{const t=oe.instances;if(!t.has(e.sourceId))continue;const i=t.get(e.sourceId),s=new l(e.width,e.height);oe._$bitmapDraw(i,e.matrix||d,e.colorTransform||g,s);const r=s.transferToImageBitmap();globalThis.postMessage({command:"bitmapDraw",sourceId:e.sourceId,imageBitmap:r},[r])}}}var t;this.state="deactivate"}};self.addEventListener("message",(t=>{return e=void 0,i=void 0,r=function*(){pe.queue.push(t.data),"deactivate"===pe.state&&pe.execute()},new((s=void 0)||(s=Promise))((function(t,n){function a(t){try{o(r.next(t))}catch(t){n(t)}}function h(t){try{o(r.throw(t))}catch(t){n(t)}}function o(e){var i;e.done?t(e.value):(i=e.value,i instanceof s?i:new s((function(t){t(i)}))).then(a,h)}o((r=r.apply(e,i||[])).next())}));var e,i,s,r}))})();'],{type:"text/javascript"}))):null,Zi&&(es=t=>{t._$createWorkerInstance(),t._$postProperty();const e=t._$needsChildren?t._$getChildren():t._$children,i=U();for(let t=0;t<e.length;++t){const s=e[t];s&&(i.push(s._$instanceId),"_$children"in s?es(s):(s._$createWorkerInstance(),s._$postProperty()))}t._$postChildrenIds(i),G(i)},ts=t=>{t._$removeWorkerInstance();const e=t._$needsChildren?t._$getChildren():t._$children;for(let t=0;t<e.length;++t){const i=e[t];i&&("_$children"in i?ts(i):i._$removeWorkerInstance())}},Zi.onmessage=t=>{if("bitmapDraw"!==t.data.command)return;const e=t.data.sourceId,i=Ci.get(e);if(Ci.delete(e),!i)return;const s=i.source;if("_$children"in s?ts(s):s._$removeWorkerInstance(),i.callback){const e=i.context;e.drawImage(t.data.imageBitmap,0,0),i.callback(e.canvas)}})}return new Promise((t=>{const e=navigator.userAgentData;if(e)e.getHighEntropyValues(["platform","mobile"]).then((e=>{const i=e.brands;for(let t=0;t<i.length;++t)if(-1!==i[t].brand.indexOf("Chrome")){Si=!0;break}Ri="Android"===e.platform,Ii="iOS"===e.platform,Li=Ri||Ii,t()}));else{const e=navigator.userAgent;Ri=e.indexOf("Android")>-1,Ii=e.indexOf("iPhone")>-1||e.indexOf("iPod")>-1,Si=e.indexOf("Chrome")>-1,Bi=e.indexOf("Firefox")>-1,Fi=-1===e.indexOf("Chrome")&&e.indexOf("Safari")>-1,Li=Ri||Ii,t()}}))};class ls extends $t{_$status;_$responseHeaders;_$responseURL;constructor(t,e=!1,i=!1,s=0,r="",n=[]){super(t,e,i),this._$status=0|s,this._$responseHeaders=n,this._$responseURL=r}static toString(){return"[class HTTPStatusEvent]"}static get namespace(){return"next2d.events.HTTPStatusEvent"}toString(){return this.formatToString("HTTPStatusEvent","type","bubbles","cancelable","eventPhase","status","responseURL")}get namespace(){return"next2d.events.HTTPStatusEvent"}static get HTTP_STATUS(){return"httpStatus"}get responseHeaders(){return this._$responseHeaders}get responseURL(){return this._$responseURL}get status(){return this._$status}}const _s={Event:$t,EventDispatcher:At,EventPhase:_t,FocusEvent:qe,HTTPStatusEvent:ls,IOErrorEvent:Xe,MouseEvent:jt,ProgressEvent:ze,VideoEvent:ti};Object.entries(_s).forEach((([t,e])=>{Object.defineProperty(_s,t,{get:()=>e})}));class $s extends At{_$id;_$content;_$data;_$bytesLoaded;_$bytesTotal;_$url;_$format;constructor(){super(),this._$id=dt++,this._$bytesLoaded=0,this._$bytesTotal=0,this._$url="",this._$content=null,this._$data=null,this._$format="json"}static toString(){return"[class LoaderInfo]"}static get namespace(){return"next2d.display.LoaderInfo"}toString(){return"[object LoaderInfo]"}get namespace(){return"next2d.display.LoaderInfo"}get bytesLoaded(){return this._$bytesLoaded}set bytesLoaded(t){this._$bytesLoaded=0|t}get bytesTotal(){return this._$bytesTotal}set bytesTotal(t){this._$bytesTotal=0|t}get content(){return this._$content}set content(t){this._$content=t}get url(){return this._$url}set url(t){this._$url=t}get format(){return this._$format}set format(t){this._$format=t}}class cs extends Gt{constructor(){super(),this._$loaderInfo=new $s}static toString(){return"[class Loader]"}static get namespace(){return"next2d.display.Loader"}toString(){return"[object Loader]"}get namespace(){return"next2d.display.Loader"}get content(){return this._$loaderInfo?this._$loaderInfo.content:null}get contentLoaderInfo(){return this._$loaderInfo}load(t){const e=this._$loaderInfo;e&&(e.url=t.url,e.format=t.responseDataFormat,Qi({format:t.responseDataFormat,url:t.url,method:t.method,data:t.data,headers:t.headers,withCredentials:t.withCredentials,event:{loadstart:t=>{this._$loadstart(t)},progress:t=>{this._$progress(t)},loadend:t=>{this._$loadend(t)}}}))}_$loadend(t){const e=this._$loaderInfo;if(!e)return;e.bytesLoaded=t.loaded,e.bytesTotal=t.total,e.willTrigger(ze.PROGRESS)&&e.dispatchEvent(new ze(ze.PROGRESS,!1,!1,t.loaded,t.total));const i=t.target;if(e.willTrigger(ls.HTTP_STATUS)){const t=(t=>{const e=U();if(t){const i=t.trim().split("\n"),s=i.length;for(let t=0;t<s;++t){const s=i[t].split(":");e.push(new lt(`${s[0].trim()}`,`${s[1].trim()}`))}}return e})(i.getAllResponseHeaders());e.dispatchEvent(new ls(ls.HTTP_STATUS,!1,!1,i.status,i.responseURL,t))}if(199<i.status&&400>i.status){if("json"!==e.format)throw new Error("LoaderInfo format is `json`");{const t=i.response;if("zlib"===t.type){if(as)return void ss.push({json:t,scope:this});hs(!0);const e=ns(),i=new Uint8Array(t.buffer);e.onmessage=async t=>{this._$unzipHandler(t)},e.postMessage(i,[i.buffer])}else this._$build(t)}}else e.willTrigger(Xe.IO_ERROR)&&e.dispatchEvent(new Xe(Xe.IO_ERROR,!1,!1,i.statusText))}_$unzipHandler(t){if(this._$build(t.data),ss.length){const t=ss.pop();if(!t)return;const e=new Uint8Array(t.json.buffer),i=ns();i.onmessage=e=>{t.scope._$unzipHandler(e)},i.postMessage(e,[e.buffer])}else hs(!1)}_$loadstart(t){const e=this._$loaderInfo;e&&(e.bytesLoaded=t.loaded,e.bytesTotal=t.total,e.willTrigger($t.OPEN)&&e.dispatchEvent(new $t($t.OPEN)),e.willTrigger(ze.PROGRESS)&&e.dispatchEvent(new ze(ze.PROGRESS,!1,!1,t.loaded,t.total)))}_$progress(t){const e=this._$loaderInfo;e&&(e.bytesLoaded=t.loaded,e.bytesTotal=t.total,e.willTrigger(ze.PROGRESS)&&e.dispatchEvent(new ze(ze.PROGRESS,!1,!1,t.loaded,t.total)))}_$build(t){const e=this._$loaderInfo;if(!e)return;const i=Y();if(t.symbols.length)for(let e=0;e<t.symbols.length;++e){const s=t.symbols[e];i.set(s[0],s[1])}e._$data={stage:t.stage,characters:t.characters,symbols:i},e._$content=new We;const s=t.characters[0];e._$content._$build({characterId:0,clipDepth:0,depth:0,endFrame:s.controller.length,startFrame:1},this),e._$content._$parent=null,this.addChild(e._$content),e._$content._$added=!1,e._$content._$addedStage=!1;const r=Ui();r._$loaders.push(e),1===r._$loadStatus&&(r._$loadStatus=2)}}const us={DisplayObject:Dt,InteractiveObject:Ut,DisplayObjectContainer:Gt,Sprite:Ge,MovieClip:We,BitmapData:ii,BlendMode:class{static toString(){return"[class BlendMode]"}static get namespace(){return"next2d.display.BlendMode"}toString(){return"[object BlendMode]"}get namespace(){return"next2d.display.BlendMode"}static get ADD(){return"add"}static get ALPHA(){return"alpha"}static get DARKEN(){return"darken"}static get DIFFERENCE(){return"difference"}static get ERASE(){return"erase"}static get HARDLIGHT(){return"hardlight"}static get INVERT(){return"invert"}static get LAYER(){return"layer"}static get LIGHTEN(){return"lighten"}static get MULTIPLY(){return"multiply"}static get NORMAL(){return"normal"}static get OVERLAY(){return"overlay"}static get SCREEN(){return"screen"}static get SUBTRACT(){return"subtract"}},FrameLabel:Ve,Graphics:De,Loader:cs,LoaderInfo:$s,Shape:si,Stage:Ht};Object.entries(us).forEach((([t,e])=>{Object.defineProperty(us,t,{get:()=>e})}));const ds={BevelFilter:Ft,BlurFilter:St,ColorMatrixFilter:Bt,ConvolutionFilter:Rt,DisplacementMapFilter:It,DropShadowFilter:Lt,GlowFilter:Pt,GradientBevelFilter:Ot,GradientGlowFilter:kt};Object.entries(ds).forEach((([t,e])=>{Object.defineProperty(ds,t,{get:()=>e})}));const gs={ColorTransform:ot,Matrix:ht,Point:at,Rectangle:wt,Transform:Nt};Object.entries(gs).forEach((([t,e])=>{Object.defineProperty(gs,t,{get:()=>e})}));const fs={Sound:He,SoundMixer:Pe,SoundTransform:Ue,Video:ei};Object.entries(fs).forEach((([t,e])=>{Object.defineProperty(fs,t,{get:()=>e})}));const ps={URLRequest:Ye,URLRequestHeader:lt};Object.entries(ps).forEach((([t,e])=>{Object.defineProperty(ps,t,{get:()=>e})}));const ms={TextField:Ze,TextFormat:je};Object.entries(ms).forEach((([t,e])=>{Object.defineProperty(ms,t,{get:()=>e})}));const xs={Easing:Ke,Job:Qe,Tween:Je};Object.entries(xs).forEach((([t,e])=>{Object.defineProperty(xs,t,{get:()=>e})}));"next2d"in window||(console.log("%c Next2D Player %c 1.14.18 %c https://next2d.app","color: #fff; background: #5f5f5f","color: #fff; background: #4bc729",""),window.next2d=new class{_$promises;_$player;display;events;filters;geom;media;net;text;ui;constructor(t){this._$promises=t,this._$player=new Oe,this.display=us,this.events=_s,this.filters=ds,this.geom=gs,this.media=fs,this.net=ps,this.text=ms,this.ui=xs}get player(){return this._$player}load(t,e){Promise.all(this._$promises).then((()=>{if(G(this._$promises),"develop"===t){const e=location.search.slice(1).split("&")[0];if(!e)return;t=`${location.origin}/${e}`}if(!t)return;"/"===t.charAt(1)&&(t=t.slice(1)),e&&"base"in e||!(t.indexOf("//")>-1)||(this._$player.base=t),this._$player.setOptions(e),this._$player._$initialize();const i=new cs;i.contentLoaderInfo.addEventListener(Xe.IO_ERROR,(t=>{t.target&&t.target.removeEventListener(Xe.IO_ERROR,t.listener),alert("Error: "+t.text)})),i.contentLoaderInfo.addEventListener($t.COMPLETE,(t=>{const e=t.target,i=this._$player;if(e.removeEventListener($t.COMPLETE,t.listener),e._$data){const t=e._$data.stage;i.bgColor=t.bgColor,i._$setBackgroundColor(t.bgColor),i.stage.addChild(e.content),i.width=t.width,i.height=t.height,i.stage._$frameRate=W(+t.fps,1,60,60)}i._$resize()})),i.load(new Ye(t))}))}createRootMovieClip(t=240,e=240,i=24,s=null){return Promise.all(this._$promises).then((()=>{G(this._$promises);const r=this._$player;r.width=0|t,r.height=0|e,r.mode="create",r.stage._$frameRate=0|i,r.setOptions(s),r._$initialize();const n=r.stage.addChild(new Ge);return r._$loadStatus=Oe.LOAD_END,r.play(),Promise.resolve(n)}))}}([new Promise((t=>{if("loading"===document.readyState){const e=()=>{window.removeEventListener("DOMContentLoaded",e),os().then((()=>{Zi&&Zi.postMessage({command:"setSafari",isSafari:Fi}),Ui()._$initializeCanvas(),t()}))};window.addEventListener("DOMContentLoaded",e)}else os().then((()=>{Zi&&Zi.postMessage({command:"setSafari",isSafari:Fi}),Ui()._$initializeCanvas(),t()}))}))]))})();