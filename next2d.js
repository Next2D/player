/*!
 * licenses: MIT Licenses.
 * version: 1.12.1
 * author: Toshiyuki Ienaga <ienaga@tvon.jp>
 * copyright: (c) 2013-2022 Toshiyuki Ienaga.
 */
if (!("next2d" in window)) {
    ((window) => {
        "use strict";

"use strict";

/**
 * @type {number}
 */
// eslint-disable-next-line no-unused-vars
let instanceId = 0;

/**
 * @type {number}
 */
// eslint-disable-next-line no-unused-vars
let loaderInfoId = 0;

/**
 * @type {number}
 */
// eslint-disable-next-line no-unused-vars
let programId = 0;

/**
 * @shortcut
 * @type {Math}
 * @const
 */
const $Math = window.Math;

/**
 * @shortcut
 * @type {Number}
 * @const
 */
const $Number = window.Number;

/**
 * @shortcut
 * @type {RegExp}
 * @const
 */
const $RegExp = window.RegExp;

/**
 * @shortcut
 * @type {Float32Array}
 * @const
 */
const $Float32Array = window.Float32Array;

/**
 * @shortcut
 * @type {Int16Array}
 * @const
 */
const $Int16Array = window.Int16Array;

/**
 * @description Global Object
 * @type {object}
 */
const Util = {};

/**
 * @type {string}
 * @const
 * @static
 */
Util.$PREFIX = "__next2d__";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$HIGH_SAMPLES = 4;

/**
 * @type {number}
 * @const
 * @static
 */
Util.$MEDIUM_SAMPLES = 2;

/**
 * @type {number}
 * @const
 * @static
 */
Util.$LOW_SAMPLES = 0;

/**
 * @type {number}
 * @const
 * @static
 */
Util.$LOAD_START = "loadstart";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$PROGRESS = "progress";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$LOADEND = "loadend";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$TOUCH_START = "touchstart";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$TOUCH_MOVE = "touchmove";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$TOUCH_END = "touchend";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$MOUSE_DOWN = "mousedown";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$MOUSE_MOVE = "mousemove";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$MOUSE_UP = "mouseup";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$MOUSE_WHEEL = "wheel";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$DOUBLE_CLICK = "dblclick";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$MOUSE_LEAVE = "mouseleave";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$KEY_DOWN = "keydown";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$KEY_UP = "keyup";

/**
 * @type {number}
 * @const
 * @static
 */
Util.$SCROLL = "scroll";

/**
 * @type {HTMLParagraphElement}
 * @const
 * @static
 */
Util.$P_TAG = window.document.createElement("p");

/**
 * @type {Float32Array}
 * @const
 * @static
 */
Util.$COLOR_ARRAY_IDENTITY = new $Float32Array([1, 1, 1, 1, 0, 0, 0, 0]);

/**
 * @type {array}
 * @const
 * @static
 */
Util.$COLOR_MATRIX_FILTER = [
    1, 0, 0, 0, 0,
    0, 1, 0, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 1, 0
];

/**
 * @type {number}
 * @static
 */
Util.$soundMixerVolume = 1;

/**
 * @type {array}
 * @static
 */
Util.$bezierConverterBuffer = new Array(32);

/**
 * @shortcut
 * @type {Window}
 * @const
 * @static
 */
Util.$window = window;

/**
 * @shortcut
 * @type {Document}
 * @const
 * @static
 */
Util.$document = window.document;

/**
 * @shortcut
 * @type {Navigator}
 * @const
 * @static
 */
Util.$navigator = window.navigator;

/**
 * @shortcut
 * @type {string}
 * @const
 * @static
 */
Util.$userAgent = window.navigator.userAgent;

/**
 * @shortcut
 * @type {Location}
 * @const
 * @static
 */
Util.$location = window.location;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$isNaN = window.isNaN;

/**
 * @shortcut
 * @type {number}
 * @const
 * @static
 */
Util.$Deg2Rad = $Math.PI / 180;

/**
 * @shortcut
 * @type {number}
 * @const
 * @static
 */
Util.$Rad2Deg = 180 / $Math.PI;

/**
 * @shortcut
 * @type {ArrayConstructor}
 * @const
 * @static
 */
Util.$Array = window.Array;

/**
 * @shortcut
 * @type {MapConstructor}
 * @const
 * @static
 */
Util.$Map = window.Map;

/**
 * @shortcut
 * @type {Image}
 * @const
 * @static
 */
Util.$Image = window.Image;

/**
 * @shortcut
 * @type {URL}
 * @const
 * @static
 */
Util.$URL = window.URL;

/**
 * @shortcut
 * @type {Blob}
 * @const
 * @static
 */
Util.$Blob = window.Blob;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$parseFloat = window.parseFloat;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$setTimeout = window.setTimeout;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$encodeURIComponent = window.encodeURIComponent;

/**
 * @shortcut
 * @type {number}
 * @const
 * @static
 */
Util.$Infinity = window.Infinity;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$WebGLTexture = window.WebGLTexture;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$clearTimeout = window.clearTimeout;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$setTimeout = window.setTimeout;

/**
 * @type {AudioContext}
 * @static
 */
Util.$audioContext = null;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$CanvasRenderingContext2D = window.CanvasRenderingContext2D;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$requestAnimationFrame = window.requestAnimationFrame;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$cancelAnimationFrame = window.cancelAnimationFrame;

/**
 * @shortcut
 * @type {function}
 * @const
 * @static
 */
Util.$performance = window.performance;

/**
 * @type {Map}
 * @const
 * @static
 */
Util.$variables = new Map();

/**
 * @type {Map}
 * @const
 * @static
 */
Util.$loadedImages = new Map();

/**
 * @type {boolean}
 * @default false
 * @static
 */
Util.$isUpdated = false;

/**
 * @type {window.Event|null}
 * @default null
 * @static
 */
Util.$event = null;

/**
 * @type {DisplayObject|null}
 * @default null
 * @static
 */
Util.$dropTarget = null;

/**
 * @type {{bounds: null, lock: boolean, position: {x: number, y: number}}}
 * @const
 * @static
 */
Util.$dragRules = {
    "lock": false,
    "position": {
        "x": 0,
        "y": 0
    },
    "bounds": null
};

/**
 * @description RGB to Linear Table
 * @type {Float32Array}
 * @const
 * @static
 */
Util.$rgbToLinearTable = new $Float32Array(256);

/**
 * @description RGB to Linear Table
 * @type {Float32Array}
 * @const
 * @static
 */
Util.$rgbIdentityTable = new $Float32Array(256);
for (let idx = 0; idx < 256; ++idx) {
    Util.$rgbToLinearTable[idx] = $Math.pow(idx / 255, 2.23333333);
    Util.$rgbIdentityTable[idx] = idx / 255;
}

/**
 * @type {number}
 * @const
 * @static
 */
Util.$SHORT_INT_MIN = -32768;

/**
 * @type {number}
 * @const
 * @static
 */
Util.$SHORT_INT_MAX = 32767;

/**
 * @type {number}
 * @const
 * @static
 */
Util.$devicePixelRatio = $Math.min(2, window.devicePixelRatio);

/**
 * @type {Float32Array}
 * @const
 * @static
 */
Util.$MATRIX_HIT_ARRAY_IDENTITY = new $Float32Array([1, 0, 0, 1, 0, 0]);

/**
 * @type {Float32Array}
 * @const
 * @static
 */
Util.$MATRIX_ARRAY_IDENTITY = new $Float32Array([1, 0, 0, 1, 0, 0]);

/**
 * @type {Float32Array}
 * @const
 * @static
 */
Util.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0 = new Float32Array([
    Util.$devicePixelRatio, 0, 0,
    Util.$devicePixelRatio, 0, 0
]);

/**
 * 使用済みになったbounds Objectをプール
 * Pool bounds objects that are no longer in use.
 *
 * @type {object[]}
 * @const
 * @static
 */
Util.$bounds = [];

/**
 * 使用済みになったArray Objectをプール
 * Pool Array objects that are no longer in use.
 *
 * @type {array[]}
 * @const
 * @static
 */
Util.$arrays = [];

/**
 * @type {Sound[]}
 * @const
 * @static
 */
Util.$audios = [];

/**
 * 使用済みになったMap Objectをプール
 * Pool Map objects that are no longer in use.
 *
 * @type {Map[]}
 * @const
 * @static
 */
Util.$maps = [];

/**
 * フィルター・ブレンドモードで使用済みになったPre Objectをプール
 * Pools Pre Objects that are no longer used in Filter Blend mode.
 *
 * @type {Object[]}
 * @const
 * @static
 */
Util.$preObjects = [];

/**
 * 使用済みになったMatrix Objectをプール
 * Pool Matrix objects that are no longer in use.
 *
 * @type {Matrix[]}
 * @const
 * @static
 */
Util.$matrices = [];

/**
 * 使用済みになったColorTransform Objectをプール
 * Pool ColorTransform objects that are no longer in use.
 *
 * @type {ColorTransform[]}
 * @const
 * @static
 */
Util.$colors = [];

/**
 * 使用済みになったFloat32Arrayをプール、サイズは4固定
 * Pool used Float32Array, size fixed at 4.
 *
 * @type {Float32Array[]}
 * @const
 * @static
 */
Util.$float32Array4 = [];

/**
 * 使用済みになったFloat32Arrayをプール、サイズは6固定
 * Pool used Float32Array, size fixed at 6.
 *
 * @type {Float32Array[]}
 * @const
 * @static
 */
Util.$float32Array6 = [];

/**
 * 使用済みになったFloat32Arrayをプール、サイズは8固定
 * Pool used Float32Array, size fixed at 8.
 *
 * @type {Float32Array[]}
 * @const
 * @static
 */
Util.$float32Array8 = [];

/**
 * 使用済みになったFloat32Arrayをプール、サイズは9固定
 * Pool used Float32Array, size fixed at 9.
 *
 * @type {Float32Array[]}
 * @const
 * @static
 */
Util.$float32Array9 = [];

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isAndroid = Util.$userAgent.indexOf("Android") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.isiOS = Util.$userAgent.indexOf("iPhone") > -1 || Util.$userAgent.indexOf("iPod") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isTouch = Util.$isAndroid || Util.isiOS;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isChrome = Util.$userAgent.indexOf("Chrome") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isFireFox = Util.$userAgent.indexOf("Firefox") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isSafari = Util.$userAgent.indexOf("Chrome") === -1 && Util.$userAgent.indexOf("Safari") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isEdge = Util.$userAgent.indexOf("Edge") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isMac = Util.$userAgent.indexOf("Mac") > -1;

/**
 * @type {boolean}
 * @const
 * @static
 */
Util.$isWindows = Util.$isMac === false;

/**
 * @type {LoaderInfo}
 * @default null
 * @static
 */
Util.$currentLoaderInfo = null;

/**
 * @type {HTMLCanvasElement}
 * @const
 */
const hitCanvas  = window.document.createElement("canvas");
hitCanvas.width  = 1;
hitCanvas.height = 1;

/**
 * @type {CanvasRenderingContext2D}
 * @const
 * @static
 */
Util.$hitContext = hitCanvas.getContext("2d");
Util.$hitContext.globalAlpha = 0;
Util.$hitContext.imageSmoothingEnabled = false;

/**
 * @type {HTMLCanvasElement}
 * @const
 */
const textCanvas  = window.document.createElement("canvas");
textCanvas.width  = 1;
textCanvas.height = 1;

/**
 * @type {CanvasRenderingContext2D}
 * @const
 * @static
 */
Util.$textContext = textCanvas.getContext("2d");
Util.$hitContext.globalAlpha = 0;
Util.$hitContext.imageSmoothingEnabled = false;

/**
 * @type {HTMLDivElement}
 * @default null
 * @static
 */
Util.$DIV = null;

/**
 * @param  {*} source
 * @return {boolean}
 * @method
 * @static
 */
Util.$isArray = (source) =>
{
    return Util.$Array.isArray(source);
};

/**
 * @param  {array} args
 * @return {array}
 * @method
 * @static
 */
Util.$getArray = (...args) =>
{
    const array = Util.$arrays.pop() || [];
    if (args.length) {
        array.push.apply(array, args);
    }
    return array;
};

/**
 * @param  {array} array
 * @return {void}
 * @method
 * @static
 */
Util.$poolArray = (array) =>
{
    if (array.length) {
        array.length = 0;
    }
    Util.$arrays.push(array);
};

/**
 * @param  {number} value
 * @param  {number} min
 * @param  {number} max
 * @param  {number} [default_value=null]
 * @return {number}
 * @method
 * @static
 */
Util.$clamp = (value, min, max, default_value = null) =>
{
    const number = +value;
    return Util.$isNaN(number) && default_value !== null
        ? default_value
        : $Math.min($Math.max(min, Util.$isNaN(number) ? 0 : number), max);
};

/**
 * @param   {Float32Array} a
 * @param   {Float32Array} b
 * @returns {Float32Array}
 * @method
 * @static
 */
Util.$multiplicationColor = (a, b) =>
{
    return Util.$getFloat32Array8(
        a[0] * b[0],
        a[1] * b[1],
        a[2] * b[2],
        a[3] * b[3],
        a[0] * b[4] + a[4],
        a[1] * b[5] + a[5],
        a[2] * b[6] + a[6],
        a[3] * b[7] + a[7]
    );
};

/**
 * @param   {Float32Array} a
 * @param   {Float32Array} b
 * @returns {Float32Array}
 * @static
 */
Util.$multiplicationMatrix = (a, b) =>
{
    return Util.$getFloat32Array6(
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5]
    );
};

/**
 * @param  {number} x_min
 * @param  {number} x_max
 * @param  {number} y_min
 * @param  {number} y_max
 * @return {object}
 * @method
 * @static
 */
Util.$getBoundsObject = (x_min = 0, x_max = 0, y_min = 0, y_max = 0) =>
{
    const object = Util.$bounds.pop() || { "xMin": 0, "xMax": 0, "yMin": 0, "yMax": 0 };

    object.xMin = x_min;
    object.xMax = x_max;
    object.yMin = y_min;
    object.yMax = y_max;

    return object;
};

/**
 * @return {object}
 * @method
 * @static
 */
Util.$poolBoundsObject = (bounds) =>
{
    Util.$bounds.push(bounds);
};

/**
 * @param  {Map} map
 * @return void
 * @method
 * @static
 */
Util.$poolMap = (map) =>
{
    if (map.size) {
        map.clear();
    }
    Util.$maps.push(map);
};

/**
 * @return {Map}
 * @method
 * @static
 */
Util.$getMap = () =>
{
    return Util.$maps.pop() || new Util.$Map();
};

/**
 * @param  {number} [f0=0]
 * @param  {number} [f1=0]
 * @param  {number} [f2=0]
 * @param  {number} [f3=0]
 * @return {Float32Array}
 * @method
 * @static
 */
Util.$getFloat32Array4 = (f0 = 0, f1 = 0, f2 = 0, f3 = 0) =>
{
    const array = Util.$float32Array4.pop()
        || new $Float32Array(4);

    array[0] = f0;
    array[1] = f1;
    array[2] = f2;
    array[3] = f3;

    return array;
};

/**
 * @param  {Float32Array} array
 * @return {void}
 * @method
 * @static
 */
Util.$poolFloat32Array4 = (array) =>
{
    Util.$float32Array4.push(array);
};

/**
 * @param  {number} [f0=0]
 * @param  {number} [f1=0]
 * @param  {number} [f2=0]
 * @param  {number} [f3=0]
 * @param  {number} [f4=0]
 * @param  {number} [f5=0]
 * @return {Float32Array}
 * @method
 * @static
 */
Util.$getFloat32Array6 = (f0 = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0) =>
{
    const array = Util.$float32Array6.pop()
        || new $Float32Array(6);

    array[0] = f0;
    array[1] = f1;
    array[2] = f2;
    array[3] = f3;
    array[4] = f4;
    array[5] = f5;

    return array;
};

/**
 * @param  {Float32Array} array
 * @return {void}
 * @method
 * @static
 */
Util.$poolFloat32Array6 = (array) =>
{
    Util.$float32Array6.push(array);
};

/**
 * @param  {number} [f0=0]
 * @param  {number} [f1=0]
 * @param  {number} [f2=0]
 * @param  {number} [f3=0]
 * @param  {number} [f4=0]
 * @param  {number} [f5=0]
 * @param  {number} [f6=0]
 * @param  {number} [f7=0]
 * @return {Float32Array}
 * @method
 * @static
 */
Util.$getFloat32Array8 = (
    f0 = 1, f1 = 1, f2 = 1, f3 = 1, f4 = 0, f5 = 0, f6 = 0, f7 = 0
) => {
    const array = Util.$float32Array8.pop()
        || new $Float32Array(8);

    array[0] = f0;
    array[1] = f1;
    array[2] = f2;
    array[3] = f3;
    array[4] = f4;
    array[5] = f5;
    array[6] = f6;
    array[7] = f7;

    return array;
};

/**
 * @param  {Float32Array} array
 * @return {void}
 * @method
 * @static
 */
Util.$poolFloat32Array8 = (array) =>
{
    Util.$float32Array8.push(array);
};

/**
 * @param  {number} [f0=0]
 * @param  {number} [f1=0]
 * @param  {number} [f2=0]
 * @param  {number} [f3=0]
 * @param  {number} [f4=0]
 * @param  {number} [f5=0]
 * @param  {number} [f6=0]
 * @param  {number} [f7=0]
 * @param  {number} [f8=0]
 * @return {Float32Array}
 * @method
 * @static
 */
Util.$getFloat32Array9 = (
    f0 = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0, f6 = 0, f7 = 0, f8 = 0
) => {
    const array = Util.$float32Array9.pop()
        || new $Float32Array(9);

    array[0] = f0;
    array[1] = f1;
    array[2] = f2;
    array[3] = f3;
    array[4] = f4;
    array[5] = f5;
    array[6] = f6;
    array[7] = f7;
    array[8] = f8;

    return array;
};

/**
 * @param  {Float32Array} array
 * @return {void}
 * @method
 * @static
 */
Util.$poolFloat32Array9 = (array) =>
{
    Util.$float32Array9.push(array);
};

/**
 * @return {Player}
 * @method
 * @static
 */
Util.$currentPlayer = () =>
{
    return window.next2d._$player;
};

/**
 * @return {Point}
 * @method
 * @static
 */
Util.$currentMousePoint = () =>
{
    // setup
    const player = Util.$currentPlayer();

    let x = Util.$window.pageXOffset;
    let y = Util.$window.pageYOffset;

    const div = Util.$document.getElementById(player.contentElementId);
    if (div) {
        const rect = div.getBoundingClientRect();
        x += rect.left;
        y += rect.top;
    }

    let touchX = Util.$event.pageX;
    let touchY = Util.$event.pageY;
    if (Util.$isTouch) {
        const changedTouche = Util.$event.changedTouches[0];
        touchX = changedTouche.pageX;
        touchY = changedTouche.pageY;
    }

    const pointX = (touchX - x) / player._$scale - player._$tx / player._$scale / Util.$devicePixelRatio;
    const pointY = (touchY - y) / player._$scale - player._$ty / player._$scale / Util.$devicePixelRatio;

    return new Point(pointX, pointY);
};

/**
 * @param  {object} bounds
 * @param  {Float32Array} matrix
 * @return {object}
 * @method
 * @static
 */
Util.$boundsMatrix = (bounds, matrix) =>
{
    const x0 = bounds.xMax * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x1 = bounds.xMax * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const x2 = bounds.xMin * matrix[0] + bounds.yMax * matrix[2] + matrix[4];
    const x3 = bounds.xMin * matrix[0] + bounds.yMin * matrix[2] + matrix[4];
    const y0 = bounds.xMax * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y1 = bounds.xMax * matrix[1] + bounds.yMin * matrix[3] + matrix[5];
    const y2 = bounds.xMin * matrix[1] + bounds.yMax * matrix[3] + matrix[5];
    const y3 = bounds.xMin * matrix[1] + bounds.yMin * matrix[3] + matrix[5];

    const xMin = $Math.min( $Number.MAX_VALUE, x0, x1, x2, x3);
    const xMax = $Math.max(-$Number.MAX_VALUE, x0, x1, x2, x3);
    const yMin = $Math.min( $Number.MAX_VALUE, y0, y1, y2, y3);
    const yMax = $Math.max(-$Number.MAX_VALUE, y0, y1, y2, y3);

    return Util.$getBoundsObject(xMin, xMax, yMin, yMax);
};

/**
 * @param  {number} v
 * @return {number}
 * @method
 * @static
 */
Util.$upperPowerOfTwo = (v) =>
{
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
};

/**
 * @param  {number} [a=1]
 * @param  {number} [b=0]
 * @param  {number} [c=0]
 * @param  {number} [d=1]
 * @param  {number} [tx=0]
 * @param  {number} [ty=0]
 * @return {Matrix}
 */
Util.$getMatrix = (a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) =>
{
    if (!Util.$matrices.length) {
        return new Matrix(a, b, c, d, tx, ty);
    }
    const matrix = Util.$matrices.pop();
    matrix._$matrix = Util.$getFloat32Array6(a, b, c, d, tx, ty);
    return matrix;
};

/**
 * @param  {Matrix} matrix
 * @return {void}
 * @method
 * @static
 */
Util.$poolMatrix = (matrix) =>
{
    Util.$poolFloat32Array6(matrix._$matrix);
    matrix._$matrix = null;
    Util.$matrices.push(matrix);
};

/**
 * @description ECMA-262 section 9.2
 * @param  {*} value
 * @return {boolean}
 */
Util.$toBoolean = (value = false) =>
{
    switch (typeof value) {

        case "boolean":
            return value;

        case "function":
            return true;

        case "object":
        case "string":
        case "number":
            return value ? true : false;

        default:
            return false;

    }
};

/**
 * @param  {number} [red_multiplier=1]
 * @param  {number} [green_multiplier=1]
 * @param  {number} [blue_multiplier=1]
 * @param  {number} [alpha_multiplier=1]
 * @param  {number} [red_offset=0]
 * @param  {number} [green_offset=0]
 * @param  {number} [blue_offset=0]
 * @param  {number} [alpha_offset=0]
 * @return {ColorTransform}
 */
Util.$getColorTransform = (
    red_multiplier = 1, green_multiplier = 1, blue_multiplier = 1, alpha_multiplier = 1,
    red_offset = 0, green_offset = 0, blue_offset = 0, alpha_offset = 0
) => {

    if (!Util.$colors.length) {
        return new ColorTransform(
            red_multiplier, green_multiplier, blue_multiplier, alpha_multiplier,
            red_offset, green_offset, blue_offset, alpha_offset
        );
    }

    const colorTransform = Util.$colors.pop();
    colorTransform._$colorTransform = Util.$getFloat32Array8(
        red_multiplier, green_multiplier, blue_multiplier, alpha_multiplier,
        red_offset, green_offset, blue_offset, alpha_offset
    );

    return colorTransform;

};

/**
 * @param  {ColorTransform} color_transform
 * @return {void}
 * @method
 * @static
 */
Util.$poolColorTransform = (color_transform) =>
{
    Util.$poolFloat32Array8(color_transform._$colorTransform);
    color_transform._$colorTransform = null;
    Util.$colors.push(color_transform);
};

/**
 * @param   {number|string} rgb
 * @returns {number}
 * @method
 * @static
 */
Util.$toColorInt = (rgb) =>
{
    return Util.$isNaN(+rgb)
        ? Util.$colorStringToInt(rgb)
        : +rgb;
};

/**
 * @param   {string} str
 * @returns {number}
 * @method
 * @static
 */
Util.$colorStringToInt = (str) =>
{
    Util.$hitContext.fillStyle = str;
    const color = Util.$hitContext.fillStyle.substr(1);

    // reset
    Util.$hitContext.fillStyle = "rgba(0, 0, 0, 1)";

    return `0x${color}` | 0;
};

/**
 * @param  {number}  int
 * @param  {number}  alpha
 * @param  {boolean} premultiplied
 * @return {number}
 * @method
 * @static
 */
Util.$intToR = (int, alpha, premultiplied) =>
{
    return (int >> 16) * (premultiplied ? alpha : 1) / 255;
};

/**
 * @param  {number}  int
 * @param  {number}  alpha
 * @param  {boolean} premultiplied
 * @return {number}
 * @method
 * @static
 */
Util.$intToG = (int, alpha, premultiplied) =>
{
    return (int >> 8 & 0xFF) * (premultiplied ? alpha : 1) / 255;
};

/**
 * @param  {number}  int
 * @param  {number}  alpha
 * @param  {boolean} premultiplied
 * @return {number}
 * @method
 * @static
 */
Util.$intToB = (int, alpha, premultiplied) =>
{
    return (int & 0xFF) * (premultiplied ? alpha : 1) / 255;
};

/**
 * @param  {number} uint
 * @return {object}
 * @method
 * @static
 */
Util.$uintToRGBA = (uint) =>
{
    return {
        "A": uint >>> 24,
        "R": (uint & 0x00ff0000) >> 16,
        "G": (uint & 0x0000ff00) >> 8,
        "B": uint & 0x000000ff
    };
};

/**
 * @param   {number} color
 * @param   {number} [alpha=1]
 * @returns {{R: number, G: number, B: number, A: number}}
 * @method
 * @static
 */
Util.$intToRGBA = (color, alpha = 1) =>
{
    return {
        "R": (color & 0xff0000) >> 16,
        "G": (color & 0x00ff00) >> 8,
        "B": color & 0x0000ff,
        "A": alpha * 255
    };
};

/**
 * @param  {object} object
 * @param  {Float32Array} color
 * @return {object}
 * @method
 * @static
 */
Util.$generateColorTransform = (object, color) =>
{
    return {
        "R": $Math.max(0, $Math.min(object.R * color[0] + color[4], 255)),
        "G": $Math.max(0, $Math.min(object.G * color[1] + color[5], 255)),
        "B": $Math.max(0, $Math.min(object.B * color[2] + color[6], 255)),
        "A": $Math.max(0, $Math.min(object.A * 255 * color[3] + color[7], 255)) / 255
    };
};

/**
 * @return {CacheStore}
 * @method
 * @static
 */
Util.$cacheStore = () =>
{
    return Util.$currentPlayer()._$cacheStore;
};

/**
 * @param   {Float32Array} m
 * @returns {Float32Array}
 * @method
 * @static
 */
Util.$inverseMatrix = (m) =>
{
    const rdet = 1 / (m[0] * m[4] - m[3] * m[1]);
    const tx  = m[3] * m[7] - m[4] * m[6];
    const ty  = m[1] * m[6] - m[0] * m[7];

    return Util.$getFloat32Array9(
        m[4] * rdet,  -m[1] * rdet, 0,
        -m[3] * rdet,  m[0] * rdet, 0,
        tx * rdet, ty * rdet, 1
    );
};

/**
 * @return {void}
 * @method
 * @static
 */
Util.$decodeAudioFailed = function ()
{
    const buffer = this._$character
        ? this._$character.buffer
        : this._$buffer;

    let idx = 0;
    for(;;) {

        idx = buffer.indexOf(0xff, idx);

        if (idx === -1 || (buffer[idx + 1] & 0xe0) === 0xe0) {
            break;
        }

        ++idx;

    }

    if (idx > -1) {

        Util
            .$audioContext
            .decodeAudioData(
                buffer.buffer.subarray(idx),
                Util.$decodeAudioSuccess.bind(this)
            );

    }
};

/**
 * @param  {Uint8Array} buffer
 * @return {void}
 * @method
 * @static
 */
Util.$decodeAudioSuccess = function (buffer)
{
    if (this._$character) {

        this._$character.buffer      = null;
        this._$character.audioBuffer = buffer;

    } else {

        this._$buffer      = null;
        this._$audioBuffer = buffer;

    }
};

/**
 * @param  {Sound} sound
 * @return {void}
 * @method
 * @static
 */
Util.$decodeAudioData = (sound) =>
{
    const buffer = sound._$character
        ? sound._$character.buffer
        : sound._$buffer;

    if (!buffer) {
        return ;
    }

    Util
        .$audioContext
        .decodeAudioData(
            buffer.buffer,
            Util.$decodeAudioSuccess.bind(sound),
            Util.$decodeAudioFailed.bind(sound)
        );
};

/**
 * @return {void}
 * @method
 * @static
 */
Util.$loadAudioData = () =>
{
    // create AudioContext
    if (!Util.$audioContext) {

        Util.$audioContext = new Util.$window.AudioContext();
        Util.$audioContext.resume();

    }

    if (Util.$audioContext) {

        const length = Util.$audios.length;
        for (let idx = 0; idx < length; ++idx) {

            const sound = Util.$audios[idx];

            if (sound._$character && sound._$character.audioBuffer) {
                return ;
            }

            if (sound._$audioBuffer) {
                return ;
            }

            Util.$decodeAudioData(sound);
        }

        // reset
        Util.$audios.length = 0;
    }

};

/**
 * @param  {Uint8Array} buffer
 * @return {string|null}
 * @method
 * @static
 */
Util.$getImageType = (buffer) =>
{
    if (buffer[0] === 0xff && buffer[1] === 0xd8) {
        return "jpeg";
    }

    if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46) {
        return "gif";
    }

    if (buffer[0] === 0x89 && buffer[1] === 0x50 &&
        buffer[2] === 0x4E && buffer[3] === 0x47 &&
        buffer[4] === 0x0D && buffer[5] === 0x0A &&
        buffer[6] === 0x1A && buffer[7] === 0x0A
    ) {
        return "png";
    }

    if (buffer[0] === 0x42 && buffer[1] === 0x4d) {
        return "bmp";
    }

    return null;
};

/**
 * @type {number}
 * @static
 */
Util.$resizeTimerId = 0;

/**
 * @return {void}
 * @method
 * @static
 */
Util.$resize = () =>
{
    const clearTimer = Util.$clearTimeout;
    clearTimer(Util.$resizeTimerId);

    const timer = Util.$setTimeout;
    Util.$resizeTimerId = timer(Util.$resizeExecute, 300);
};

/**
 * @return {void}
 * @method
 * @static
 */
Util.$resizeExecute = () =>
{
    const player = Util.$currentPlayer();
    if (player._$loadStatus === Player.LOAD_END) {

        player._$resize();

        const stage = player._$stage;
        if (stage.willTrigger(Event.RESIZE)) {
            stage.dispatchEvent(new Event(Event.RESIZE));
        }
    }
};

/**
 * added resize event
 */
Util.$window.addEventListener("resize", Util.$resize);

/**
 * @param  {CanvasToWebGLContext} context
 * @return {void}
 * @method
 * @static
 */
Util.$resetContext = (context) =>
{
    // reset color
    const style = context._$contextStyle;
    switch (style._$fillStyle.constructor) {

        case CanvasGradientToWebGL:
        case CanvasPatternToWebGL:
            style._$fillStyle = Util.$getFloat32Array4(1, 1, 1, 1); // fixed size 4
            break;

        default:
            style._$fillStyle[0] = 1;
            style._$fillStyle[1] = 1;
            style._$fillStyle[2] = 1;
            style._$fillStyle[3] = 1;
            break;

    }

    switch (style._$strokeStyle.constructor) {

        case CanvasGradientToWebGL:
        case CanvasPatternToWebGL:
            style._$strokeStyle = Util.$getFloat32Array4(1, 1, 1, 1); // fixed size 4
            break;

        default:
            style._$strokeStyle[0] = 1;
            style._$strokeStyle[1] = 1;
            style._$strokeStyle[2] = 1;
            style._$strokeStyle[3] = 1;
            break;

    }

    // reset
    context._$style                    = style;
    context._$globalAlpha              = 1;
    context._$globalCompositeOperation = BlendMode.NORMAL;
    context._$imageSmoothingEnabled    = false;
};

/**
 * @return {object}
 * @static
 */
Util.$getPreObject = () =>
{
    return Util.$preObjects.pop() ||
        {
            "isFilter":           false,
            "isUpdated":          null,
            "canApply":           null,
            "matrix":             null,
            "color":              null,
            "basePosition":       { "x": 0, "y": 0 },
            "position":           { "dx": 0, "dy": 0 },
            "baseMatrix":         null,
            "baseColor":          null,
            "currentAttachment":  null,
            "currentMaskBuffer":  null,
            "currentMaskBounds":  null,
            "cacheCurrentBounds": null,
            "blendMode":          null,
            "filters":            null,
            "layerWidth":         null,
            "layerHeight":        null
        };
};

/**
 * @param {object} object
 * @return void
 * @static
 */
Util.$poolPreObject = (object) =>
{
    // reset
    object.isFilter           = false;
    object.isUpdated          = null;
    object.canApply           = null;
    object.matrix             = null;
    object.color              = null;
    object.baseMatrix         = null;
    object.baseColor          = null;
    object.currentAttachment  = null;
    object.currentMaskBuffer  = null;
    object.currentMaskBounds  = null;
    object.cacheCurrentBounds = null;
    object.blendMode          = null;
    object.filters            = null;
    object.layerWidth         = null;
    object.layerHeight        = null;

    // pool
    Util.$preObjects.push(object);
};

/**
 * @param  {number} x1
 * @param  {number} y1
 * @param  {number} x2
 * @param  {number} y2
 * @return {number}
 * @method
 * @static
 */
Util.$cross = (x1, y1, x2, y2) =>
{
    return x1 * y2 - x2 * y1;
};

/**
 * @param   {Float32Array} matrix
 * @returns {Float32Array}
 */
Util.$linearGradientXY = (matrix) =>
{
    const x0  = -819.2 * matrix[0] - 819.2 * matrix[2] + matrix[4];
    const x1  =  819.2 * matrix[0] - 819.2 * matrix[2] + matrix[4];
    const x2  = -819.2 * matrix[0] + 819.2 * matrix[2] + matrix[4];
    const y0  = -819.2 * matrix[1] - 819.2 * matrix[3] + matrix[5];
    const y1  =  819.2 * matrix[1] - 819.2 * matrix[3] + matrix[5];
    const y2  = -819.2 * matrix[1] + 819.2 * matrix[3] + matrix[5];

    let vx2 = x2 - x0;
    let vy2 = y2 - y0;

    const r1 = $Math.sqrt(vx2 * vx2 + vy2 * vy2);
    if (r1) {
        vx2 = vx2 / r1;
        vy2 = vy2 / r1;
    } else {
        vx2 = 0;
        vy2 = 0;
    }

    const r2 = (x1 - x0) * vx2 + (y1 - y0) * vy2;

    return Util.$getArray(x0 + r2 * vx2, y0 + r2 * vy2, x1, y1);
};

/**
 * @param  {object} [option = null]
 * @return void
 */
Util.$ajax = (option = null) =>
{

    if (!option) {
        option = {
            "method": "GET"
        };
    }

    if (!("method" in option)) {
        option.method = "GET";
    }

    // get or post
    let postData = null;
    switch (option.method.toUpperCase()) {

        case URLRequestMethod.GET:
            if (option.data) {
                const urls = option.url.split("?");

                urls[1] = urls.length === 1
                    ? option.data.toString()
                    : urls[1] + "&" + option.data.toString();

                option.url = urls.join("?");
            }
            break;

        case URLRequestMethod.PUT:
        case URLRequestMethod.POST:
            postData = option.data ? option.data.toString() : null;
            break;

        default:
            break;

    }

    // start
    const xmlHttpRequest = new XMLHttpRequest();

    xmlHttpRequest.open(option.method, option.url, true);

    // use cookie
    if (option.withCredentials) {
        xmlHttpRequest.withCredentials = true;
    }

    // add event
    if (option.event) {

        const keys = Object.keys(option.event);

        const length = keys.length;
        for (let idx = 0; idx < length; ++idx) {

            const name = keys[idx];

            xmlHttpRequest.addEventListener(name, option.event[name]);
        }

        Util.$poolArray(keys);
    }

    // set mimeType
    if (option.format === URLLoaderDataFormat.ARRAY_BUFFER) {
        xmlHttpRequest.responseType = URLLoaderDataFormat.ARRAY_BUFFER;
    }

    // set request header
    if (option.headers) {
        for (const [name, value] of option.headers) {
            xmlHttpRequest.setRequestHeader(name, value);
        }
    }

    xmlHttpRequest.send(postData);
};

/**
 * @param  {string} header
 * @return {array}
 */
Util.$headerToArray = (header) =>
{
    const results = Util.$getArray();
    if (header) {

        const headers = header.trim().split("\n");

        const length = headers.length;
        for (let idx = 0; idx < length; ++idx) {

            const values = headers[idx].split(":");
            results.push({
                "name":  values[0],
                "value": values[1].trim()
            });

        }

    }
    return results;
};

/**
 * @param  {string} symbol
 * @return {function}
 * @method
 * @static
 */
Util.$getClass = (symbol) =>
{
    const names = symbol.split(".");

    let object = Util.$window;
    for (let idx = 0; idx < names.length; ++idx) {

        const name = names[idx];
        if (!(name in object)) {
            return null;
        }

        object = object[name];
    }

    return object;
};

/**
 * @type {boolean}
 * @static
 */
Util.$imageWorkerActive = false;

/**
 * @type {array}
 * @static
 */
Util.$imageQueues = [];

/**
 * @return void
 * @static
 */
Util.$decodeImage = function ()
{
    const player = Util.$currentPlayer();

    // size
    const width  = this.image.width;
    const height = this.image.height;

    const bitmapData = new BitmapData(width, height, true, 0xff000000);

    const context = player._$context;

    const currentAttachment = context
        .frameBuffer
        .currentAttachment;

    bitmapData._$texture = context
        .frameBuffer
        .createTextureFromImage(this.image);

    const shape = new Shape();

    shape
        .graphics
        .beginBitmapFill(bitmapData, null, false)
        .drawRect(0, 0, width, height);

    // setup
    const loaderInfo = this.scope.contentLoaderInfo;
    loaderInfo._$content = shape;
    shape._$loaderInfo   = loaderInfo;

    player._$loaders.push(loaderInfo);

    if (currentAttachment) {
        context._$bind(currentAttachment);
    } else {
        context.frameBuffer.unbind();
    }

    // next
    if (Util.$imageQueues.length) {

        const object = Util.$imageQueues.shift();

        object.image.decode()
            .then(Util.$decodeImage.bind(object))
            .catch(() =>
            {
                throw new Error("image encoding error");
            });

    } else {

        Util.$imageWorkerActive = false;

    }
};

/**
 * @type {string}
 * @static
 */
Util.$unzipURL = URL.createObjectURL(
    new Blob(["/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function(){\"use strict\";var t=void 0,r=this;function i(i,e){var s,h=i.split(\".\"),n=r;!(h[0]in n)&&n.execScript&&n.execScript(\"var \"+h[0]);for(;h.length&&(s=h.shift());)h.length||e===t?n=n[s]?n[s]:n[s]={}:n[s]=e}var e=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array&&\"undefined\"!=typeof DataView;function s(t){var r,i,s,h,n,a,o,f,l,u,c=t.length,b=0,y=Number.POSITIVE_INFINITY;for(f=0;f<c;++f)t[f]>b&&(b=t[f]),t[f]<y&&(y=t[f]);for(r=1<<b,i=new(e?Uint32Array:Array)(r),s=1,h=0,n=2;s<=b;){for(f=0;f<c;++f)if(t[f]===s){for(a=0,o=h,l=0;l<s;++l)a=a<<1|1&o,o>>=1;for(u=s<<16|f,l=a;l<r;l+=n)i[l]=u;++h}++s,h<<=1,n<<=1}return[i,b,y]}function h(t,r){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=e?new Uint8Array(t):t,this.m=!1,this.i=a,this.r=!1,!r&&(r={})||(r.index&&(this.a=r.index),r.bufferSize&&(this.h=r.bufferSize),r.bufferType&&(this.i=r.bufferType),r.resize&&(this.r=r.resize)),this.i){case n:this.b=32768,this.c=new(e?Uint8Array:Array)(32768+this.h+258);break;case a:this.b=0,this.c=new(e?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error(\"invalid inflate mode\")}}var n=0,a=1,o={t:n,s:a};h.prototype.k=function(){for(;!this.m;){var r=S(this,3);switch(1&r&&(this.m=!0),r>>>=1){case 0:var i=this.input,h=this.a,o=this.c,f=this.b,l=i.length,u=t,b=o.length,y=t;if(this.d=this.f=0,h+1>=l)throw Error(\"invalid uncompressed block header: LEN\");if(u=i[h++]|i[h++]<<8,h+1>=l)throw Error(\"invalid uncompressed block header: NLEN\");if(u===~(i[h++]|i[h++]<<8))throw Error(\"invalid uncompressed block header: length verify\");if(h+u>i.length)throw Error(\"input buffer is broken\");switch(this.i){case n:for(;f+u>o.length;){if(u-=y=b-f,e)o.set(i.subarray(h,h+y),f),f+=y,h+=y;else for(;y--;)o[f++]=i[h++];this.b=f,o=this.e(),f=this.b}break;case a:for(;f+u>o.length;)o=this.e({p:2});break;default:throw Error(\"invalid inflate mode\")}if(e)o.set(i.subarray(h,h+u),f),f+=u,h+=u;else for(;u--;)o[f++]=i[h++];this.a=h,this.b=f,this.c=o;break;case 1:this.j(E,z);break;case 2:var p,d,g,v,w=S(this,5)+257,A=S(this,5)+1,k=S(this,4)+4,U=new(e?Uint8Array:Array)(c.length),m=t,I=t,x=t,N=t,j=t;for(j=0;j<k;++j)U[c[j]]=S(this,3);if(!e)for(j=k,k=U.length;j<k;++j)U[c[j]]=0;for(p=s(U),m=new(e?Uint8Array:Array)(w+A),j=0,v=w+A;j<v;)switch(I=T(this,p),I){case 16:for(N=3+S(this,2);N--;)m[j++]=x;break;case 17:for(N=3+S(this,3);N--;)m[j++]=0;x=0;break;case 18:for(N=11+S(this,7);N--;)m[j++]=0;x=0;break;default:x=m[j++]=I}d=s(e?m.subarray(0,w):m.slice(0,w)),g=s(e?m.subarray(w):m.slice(w)),this.j(d,g);break;default:throw Error(\"unknown BTYPE: \"+r)}}return this.n()};var f,l,u=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],c=e?new Uint16Array(u):u,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],y=e?new Uint16Array(b):b,p=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],d=e?new Uint8Array(p):p,g=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],v=e?new Uint16Array(g):g,w=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],A=e?new Uint8Array(w):w,k=new(e?Uint8Array:Array)(288);for(f=0,l=k.length;f<l;++f)k[f]=143>=f?8:255>=f?9:279>=f?7:8;var U,m,E=s(k),I=new(e?Uint8Array:Array)(30);for(U=0,m=I.length;U<m;++U)I[U]=5;var z=s(I);function S(t,r){for(var i,e=t.f,s=t.d,h=t.input,n=t.a,a=h.length;s<r;){if(n>=a)throw Error(\"input buffer is broken\");e|=h[n++]<<s,s+=8}return i=e&(1<<r)-1,t.f=e>>>r,t.d=s-r,t.a=n,i}function T(t,r){for(var i,e,s=t.f,h=t.d,n=t.input,a=t.a,o=n.length,f=r[0],l=r[1];h<l&&!(a>=o);)s|=n[a++]<<h,h+=8;if((e=(i=f[s&(1<<l)-1])>>>16)>h)throw Error(\"invalid code length: \"+e);return t.f=s>>e,t.d=h-e,t.a=a,65535&i}function x(t,r){var i,e;if(this.input=t,this.a=0,!r&&(r={})||(r.index&&(this.a=r.index),r.verify&&(this.A=r.verify)),i=t[this.a++],e=t[this.a++],(15&i)!==N)throw Error(\"unsupported compression method\");if(this.method=N,0!=((i<<8)+e)%31)throw Error(\"invalid fcheck flag:\"+((i<<8)+e)%31);if(32&e)throw Error(\"fdict flag is not supported\");this.q=new h(t,{index:this.a,bufferSize:r.bufferSize,bufferType:r.bufferType,resize:r.resize})}h.prototype.j=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length-258;256!==(s=T(this,t));)if(256>s)e>=o&&(this.b=e,i=this.e(),e=this.b),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e>=o&&(this.b=e,i=this.e(),e=this.b);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.w=function(t,r){var i=this.c,e=this.b;this.o=t;for(var s,h,n,a,o=i.length;256!==(s=T(this,t));)if(256>s)e>=o&&(o=(i=this.e()).length),i[e++]=s;else for(a=y[h=s-257],0<d[h]&&(a+=S(this,d[h])),s=T(this,r),n=v[s],0<A[s]&&(n+=S(this,A[s])),e+a>o&&(o=(i=this.e()).length);a--;)i[e]=i[e++-n];for(;8<=this.d;)this.d-=8,this.a--;this.b=e},h.prototype.e=function(){var t,r,i=new(e?Uint8Array:Array)(this.b-32768),s=this.b-32768,h=this.c;if(e)i.set(h.subarray(32768,i.length));else for(t=0,r=i.length;t<r;++t)i[t]=h[t+32768];if(this.g.push(i),this.l+=i.length,e)h.set(h.subarray(s,s+32768));else for(t=0;32768>t;++t)h[t]=h[s+t];return this.b=32768,h},h.prototype.z=function(t){var r,i,s,h=this.input.length/this.a+1|0,n=this.input,a=this.c;return t&&(\"number\"==typeof t.p&&(h=t.p),\"number\"==typeof t.u&&(h+=t.u)),2>h?i=(s=(n.length-this.a)/this.o[2]/2*258|0)<a.length?a.length+s:a.length<<1:i=a.length*h,e?(r=new Uint8Array(i)).set(a):r=a,this.c=r},h.prototype.n=function(){var t,r,i,s,h,n=0,a=this.c,o=this.g,f=new(e?Uint8Array:Array)(this.l+(this.b-32768));if(0===o.length)return e?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(r=0,i=o.length;r<i;++r)for(s=0,h=(t=o[r]).length;s<h;++s)f[n++]=t[s];for(r=32768,i=this.b;r<i;++r)f[n++]=a[r];return this.g=[],this.buffer=f},h.prototype.v=function(){var t,r=this.b;return e?this.r?(t=new Uint8Array(r)).set(this.c.subarray(0,r)):t=this.c.subarray(0,r):(this.c.length>r&&(this.c.length=r),t=this.c),this.buffer=t},x.prototype.k=function(){var t,r,i=this.input;if(t=this.q.k(),this.a=this.q.a,this.A){r=(i[this.a++]<<24|i[this.a++]<<16|i[this.a++]<<8|i[this.a++])>>>0;var e=t;if(\"string\"==typeof e){var s,h,n=e.split(\"\");for(s=0,h=n.length;s<h;s++)n[s]=(255&n[s].charCodeAt(0))>>>0;e=n}for(var a,o=1,f=0,l=e.length,u=0;0<l;){l-=a=1024<l?1024:l;do{f+=o+=e[u++]}while(--a);o%=65521,f%=65521}if(r!==(f<<16|o)>>>0)throw Error(\"invalid adler-32 checksum\")}return t};var N=8;i(\"Zlib.Inflate\",x),i(\"Zlib.Inflate.prototype.decompress\",x.prototype.k);var j,C,O,L,Z={ADAPTIVE:o.s,BLOCK:o.t};if(Object.keys)j=Object.keys(Z);else for(C in j=[],O=0,Z)j[O++]=C;for(O=0,L=j.length;O<L;++O)i(\"Zlib.Inflate.BufferType.\"+(C=j[O]),Z[C])}).call(this),this.addEventListener(\"message\",(function(t){const r=new Zlib.Inflate(t.data).decompress();let i=\"\";for(let t=0;t<r.length;++t)i+=String.fromCharCode(r[t]);this.postMessage(JSON.parse(decodeURIComponent(i)))}));"], { "type": "text/javascript" })
);

/**
 * @default null
 * @type {Worker}
 * @static
 */
Util.$unzipWorker = null;

/**
 * @type {array}
 * @static
 */
Util.$unzipQueues = [];

/**
 * @type {boolean}
 * @static
 */
Util.$unzipWorkerActive = false;

/**
 *
 * @param  {MessageEvent} event
 * @method
 * @static
 */
Util.$unzipHandler = function (event)
{
    this._$build(event.data);

    if (Util.$unzipQueues.length) {

        const object = Util.$unlzmaQueues.pop();

        const buffer = new Uint8Array(object.json.buffer);
        Util.$unzipWorker.onmessage = Util.$unzipHandler.bind(object.scope);
        Util.$unzipWorker.postMessage(buffer, [buffer.buffer]);

    } else {

        Util.$unzipWorkerActive = false;

    }
};

/**
 * @param  {Next2D} object
 * @return {void}
 * @method
 * @static
 */
Util.$packages = (object) =>
{
    object.display = {
        "BitmapData": BitmapData,
        "BitmapDataChannel": BitmapDataChannel,
        "BlendMode": BlendMode,
        "CapsStyle": CapsStyle,
        "DisplayObject": DisplayObject,
        "DisplayObjectContainer": DisplayObjectContainer,
        "FrameLabel": FrameLabel,
        "GradientType": GradientType,
        "Graphics": Graphics,
        "GraphicsGradientFill": GraphicsGradientFill,
        "InteractiveObject": InteractiveObject,
        "InterpolationMethod": InterpolationMethod,
        "JointStyle": JointStyle,
        "Loader": Loader,
        "LoaderInfo": LoaderInfo,
        "LoopConfig": LoopConfig,
        "LoopType": LoopType,
        "MovieClip": MovieClip,
        "Shape": Shape,
        "SpreadMethod": SpreadMethod,
        "Sprite": Sprite,
        "Stage": Stage
    };

    object.events = {
        "Event": Event,
        "EventDispatcher": EventDispatcher,
        "EventPhase": EventPhase,
        "FocusEvent": FocusEvent,
        "HTTPStatusEvent": HTTPStatusEvent,
        "IOErrorEvent": IOErrorEvent,
        "MouseEvent": MouseEvent,
        "ProgressEvent": ProgressEvent,
        "VideoEvent": VideoEvent
    };

    object.filters = {
        "BevelFilter": BevelFilter,
        "BitmapFilterQuality": BitmapFilterQuality,
        "BitmapFilterType": BitmapFilterType,
        "BlurFilter": BlurFilter,
        "ColorMatrixFilter": ColorMatrixFilter,
        "ConvolutionFilter": ConvolutionFilter,
        "DisplacementMapFilter": DisplacementMapFilter,
        "DisplacementMapFilterMode": DisplacementMapFilterMode,
        "DropShadowFilter": DropShadowFilter,
        "GlowFilter": GlowFilter,
        "GradientBevelFilter": GradientBevelFilter,
        "GradientGlowFilter": GradientGlowFilter
    };

    object.geom = {
        "ColorTransform": ColorTransform,
        "Matrix": Matrix,
        "Point": Point,
        "Rectangle": Rectangle,
        "Transform": Transform
    };

    object.media = {
        "Sound": Sound,
        "SoundMixer": SoundMixer,
        "SoundTransform": SoundTransform,
        "Video": Video
    };

    object.net = {
        "URLLoaderDataFormat": URLLoaderDataFormat,
        "URLRequest": URLRequest,
        "URLRequestHeader": URLRequestHeader,
        "URLRequestMethod": URLRequestMethod
    };

    object.text = {
        "TextField": TextField,
        "TextFieldAutoSize": TextFieldAutoSize,
        "TextFieldType": TextFieldType,
        "TextFormat": TextFormat,
        "TextFormatAlign": TextFormatAlign,
        "TextFormatVerticalAlign": TextFormatVerticalAlign
    };

    object.ui = {
        "Easing": Easing,
        "Job": Job,
        "Tween": Tween
    };
};

/**
 * Event クラスのメソッドは、イベントリスナー関数で使用してイベントオブジェクトの動作に影響を与えることができます。
 * 一部のイベントにはデフォルトの動作が関連付けられています。
 * 例えば、doubleClick イベントには、イベント時にマウスポインター位置の単語がハイライト表示されるというデフォルトの動作が関連付けられています。
 * イベントリスナーで preventDefault() メソッドを呼び出してこの動作をキャンセルできます。
 * また、stopPropagation() メソッドまたは stopImmediatePropagation() メソッドを呼び出すと、
 * 現在のイベントリスナーを、イベントを処理する最後のイベントリスナーにすることができます。
 *
 * The methods of the Event class can be used in event listener functions to affect the behavior of the event object.
 * Some events have an associated default behavior. For example,
 * the doubleClick event has an associated default behavior that highlights the word under the mouse pointer at the time of the event.
 * Your event listener can cancel this behavior by calling the preventDefault() method.
 * You can also make the current event listener the last one to process
 * an event by calling the stopPropagation() or stopImmediatePropagation() method.
 *
 * @example <caption>Example usage of Event.</caption>
 * // new Event
 * const {Event} = next2d.events;
 * displayObject.dispatchEvent(new Event(Event.ENTER_FRAME));
 *
 * @class
 * @memberOf next2d.events
 */
class Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=false]
     * @param {boolean} [cancelable=false]
     *
     * @constructor
     * @public
     */
    constructor (type, bubbles = false, cancelable = false)
    {
        /**
         * @type {string}
         * @private
         */
        this._$type = `${type}`;

        /**
         * @type {boolean}
         * @private
         */
        this._$bubbles = !!bubbles;

        /**
         * @type {boolean}
         * @private
         */
        this._$cancelable = !!cancelable;

        /**
         * @type {object|null}
         * @private
         */
        this._$target = null;

        /**
         * @type {object|null}
         * @private
         */
        this._$currentTarget = null;

        /**
         * @type    {number}
         * @default EventPhase.AT_TARGET
         * @private
         */
        this._$eventPhase = EventPhase.AT_TARGET;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$listener = null;

        /**
         * @type {boolean}
         * @private
         */
        this._$stopImmediatePropagation = false;

        /**
         * @type {boolean}
         * @private
         */
        this._$stopPropagation = false;

        /**
         * @type {boolean}
         * @private
         */
        this._$preventDefault = false;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Event]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Event]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.Event
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.Event";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString("Event", "type", "bubbles", "cancelable", "eventPhase");
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.Event
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.Event";
    }

    /**
     * @description ACTIVATE 定数は、type プロパティ（activate イベントオブジェクト）の値を定義します。
     *              The ACTIVATE constant defines the value
     *              of the type property of an activate event object.
     *
     * @return  {string}
     * @default activate
     * @const
     * @static
     */
    static get ACTIVATE ()
    {
        return "activate";
    }

    /**
     * @description Event.ADDED 定数は、added イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.ADDED constant defines the value
     *              of the type property of an added event object.
     *
     * @return  {string}
     * @default added
     * @const
     * @static
     */
    static get ADDED ()
    {
        return "added";
    }

    /**
     * @description Event.ADDED_TO_STAGE 定数は、type プロパティ（addedToStage イベントオブジェクト）の値を定義します。
     *              The Event.ADDED_TO_STAGE constant defines the value
     *              of the type property of an addedToStage event object.
     *
     * @return  {string}
     * @default addedToStage
     * @const
     * @static
     */
    static get ADDED_TO_STAGE ()
    {
        return "addedToStage";
    }

    /**
     * @description Event.CHANGE 定数は、type プロパティ（change イベントオブジェクト）の値を定義します。
     *              The Event.CHANGE constant defines the value
     *              of the type property of a change event object.
     *
     * @return  {string}
     * @default change
     * @const
     * @static
     */
    static get CHANGE ()
    {
        return "change";
    }

    /**
     * @description Event.COMPLETE 定数は、complete イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.COMPLETE constant defines the value
     *              of the type property of a complete event object.
     *
     * @return  {string}
     * @default complete
     * @const
     * @static
     */
    static get COMPLETE ()
    {
        return "complete";
    }

    /**
     * @description Event.DEACTIVATE 定数は、deactivate イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.DEACTIVATE constant defines the value
     *              of the type property of a deactivate event object.
     *
     * @return  {string}
     * @default deactivate
     * @const
     * @static
     */
    static get DEACTIVATE ()
    {
        return "deactivate";
    }

    /**
     * @description Event.ENTER_FRAME 定数は、enterFrame イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.ENTER_FRAME constant defines the value
     *              of the type property of an enterFrame event object.
     *
     * @return  {string}
     * @default enterFrame
     * @const
     * @static
     */
    static get ENTER_FRAME ()
    {
        return "enterFrame";
    }

    /**
     * @description Event.EXIT_FRAME 定数は、exitFrame イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.EXIT_FRAME constant defines the value
     *              of the type property of an exitFrame event object.
     *
     * @return  {string}
     * @default exitFrame
     * @const
     * @static
     */
    static get EXIT_FRAME ()
    {
        return "exitFrame";
    }

    /**
     * @description Event.FRAME_CONSTRUCTED 定数は、frameConstructed イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.FRAME_CONSTRUCTED constant defines the value
     *              of the type property of an frameConstructed event object.
     *
     * @return  {string}
     * @default frameConstructed
     * @const
     * @static
     */
    static get FRAME_CONSTRUCTED ()
    {
        return "frameConstructed";
    }

    /**
     * @description Event.FRAME_LABEL 定数は、frameLabel イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.FRAME_LABEL constant defines the value
     *              of the type property of an frameLabel event object.
     *
     * @return  {string}
     * @default frameLabel
     * @const
     * @static
     */
    static get FRAME_LABEL ()
    {
        return "frameLabel";
    }

    /**
     * @description Event.INIT 定数は、init イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.INIT constant defines the value
     *              of the type property of an init event object.
     *
     * @return  {string}
     * @default frameConstructed
     * @const
     * @static
     */
    static get INIT ()
    {
        return "init";
    }

    /**
     * @description Event.MOUSE_LEAVE 定数は、mouseLeave イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.MOUSE_LEAVE constant defines the value
     *              of the type property of a mouseLeave event object.
     *
     * @return  {string}
     * @default mouseLeave
     * @const
     * @static
     */
    static get MOUSE_LEAVE ()
    {
        return "mouseLeave";
    }

    /**
     * @description Event.REMOVED 定数は、removed プロパティ（paste イベントオブジェクト）の値を定義します。
     *              The Event.REMOVED constant defines the value
     *              of the type property of a removed event object.
     *
     * @return  {string}
     * @default removed
     * @const
     * @static
     */
    static get REMOVED ()
    {
        return "removed";
    }

    /**
     * @description Event.REMOVED_FROM_STAGE 定数は、removedFromStage イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.REMOVED_FROM_STAGE constant defines the value
     *              of the type property of a removedFromStage event object.
     *
     * @return  {string}
     * @default removedFromStage
     * @const
     * @static
     */
    static get REMOVED_FROM_STAGE ()
    {
        return "removedFromStage";
    }

    /**
     * @description Event.REMOVED 定数は、render イベントオブジェクトの
     *              type プロパティの値を定義します。
     *              The Event.REMOVED constant defines the value
     *              of the type property of a render event object.
     *
     * @return {string}
     * @default render
     * @const
     * @static
     */
    static get RENDER ()
    {
        return "render";
    }

    /**
     * @description Event.RESIZE 定数は、resize イベントオブジェクトの
     *              type プロパティの値を定義します。
     *              The Event.RESIZE constant defines the value
     *              of the type property of a resize event object.
     *
     * @return {string}
     * @default resize
     * @const
     * @static
     */
    static get RESIZE ()
    {
        return "resize";
    }

    /**
     * @description Event.SCROLL 定数は、render イベントオブジェクトの
     *              type プロパティの値を定義します。
     *              The Event.SCROLL constant defines the value
     *              of the type property of a render event object.
     *
     * @return {string}
     * @default scroll
     * @const
     * @static
     */
    static get SCROLL ()
    {
        return "scroll";
    }

    /**
     * @description Event.STOP 定数は、render イベントオブジェクトの
     *              type プロパティの値を定義します。
     *              The Event.STOP constant defines the value
     *              of the type property of a render event object.
     *
     * @return {string}
     * @default stop
     * @const
     * @static
     */
    static get STOP ()
    {
        return "stop";
    }

    /**
     * @description Event.SOUND_COMPLETE 定数は、soundComplete イベントオブジェクトの type プロパティの値を定義します。
     *              The Event.SOUND_COMPLETE constant defines the value
     *              of the type property of a soundComplete event object.
     *
     * @return {string}
     * @default render
     * @const
     * @static
     */
    static get SOUND_COMPLETE ()
    {
        return "soundComplete";
    }

    /**
     * @description Event.UPDATE 定数は、render イベントオブジェクトの
     *              type プロパティの値を定義します。
     *              The Event.STOP constant defines the value
     *              of the type property of a render event object.
     *
     * @return {string}
     * @default update
     * @const
     * @static
     */
    static get UPDATE ()
    {
        return "update";
    }

    /**
     * @description イベントがバブリングイベントかどうかを示します。
     *              Indicates whether an event is a bubbling event.
     *
     * @member {boolean}
     * @readonly
     * @public
     */
    get bubbles ()
    {
        return this._$bubbles;
    }

    /**
     * @description イベントに関連付けられた動作を回避できるかどうかを示します。
     *              Indicates whether the behavior associated
     *              with the event can be prevented.
     *
     * @member {boolean}
     * @readonly
     * @public
     */
    get cancelable ()
    {
        return this._$cancelable;
    }

    /**
     * @description イベントリスナーで Event オブジェクトをアクティブに処理しているオブジェクトです。
     *              The object that is actively processing the Event object
     *              with an event listener.
     *
     * @member {object}
     * @readonly
     * @public
     */
    get currentTarget ()
    {
        return this._$currentTarget;
    }

    /**
     * @description イベントフローの現在の段階です。
     *              The current phase in the event flow.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get eventPhase ()
    {
        return this._$eventPhase;
    }

    /**
     * @description 現在コールされている関数
     *              Function currently being called.
     *
     * @member {function}
     * @readonly
     * @public
     */
    get listener ()
    {
        return this._$listener;
    }

    /**
     * @description イベントターゲットです。
     *              The event target.
     *
     * @member {object}
     * @readonly
     * @public
     */
    get target ()
    {
        return this._$target ? this._$target : this._$currentTarget;
    }

    /**
     * @description イベントのタイプです。
     *              The type of event.
     *
     * @member {string}
     * @readonly
     * @public
     */
    get type ()
    {
        return this._$type;
    }

    /**
     * @description カスタム ActionScript 3.0 Event クラスに
     *              toString() メソッドを実装するためのユーティリティ関数です。
     *              A utility function for implementing the toString() method
     *              in custom ActionScript 3.0 Event classes.
     *
     * @return {string}
     * @method
     * @public
     */
    formatToString ()
    {
        let str = `[${arguments[0]}`;

        for (let idx = 1; idx < arguments.length; ++idx) {

            const name = arguments[idx];

            str += ` ${name}=`;

            const value = this[name];
            if (typeof value === "string") {
                str += `"${value}"`;
            } else {
                str += `${value}`;
            }

        }

        return `${str}]`;
    }

    /**
     * @description イベントで preventDefault() メソッドが呼び出されたかどうかを確認します。
     *              Checks whether the preventDefault() method has been called on the event.
     *
     * @return {boolean}
     * @method
     * @public
     */
    isDefaultPrevented ()
    {
        return Util.$event ? Util.$event.defaultPrevented : false;
    }

    /**
     * @description イベントのデフォルト動作をキャンセルできる場合に、その動作をキャンセルします。
     *              Cancels an event's default behavior if that behavior can be canceled.
     *
     * @return {void}
     * @method
     * @public
     */
    preventDefault ()
    {
        this._$preventDefault = true;
    }

    /**
     * @description イベントフローの現在のノードおよび後続するノードで、
     *              イベントリスナーが処理されないようにします。
     *              Prevents processing of any event listeners in the current node
     *              and any subsequent nodes in the event flow.
     *
     * @return {void}
     * @method
     * @public
     */
    stopImmediatePropagation ()
    {
        this._$stopImmediatePropagation = true;
    }

    /**
     * @description イベントフローの現在のノードに後続するノードで
     *              イベントリスナーが処理されないようにします。
     *              Prevents processing of any event listeners in nodes subsequent
     *              to the current node in the event flow.
     *
     * @return {void}
     * @method
     * @public
     */
    stopPropagation ()
    {
        this._$stopPropagation = true;
    }
}
/**
 * EventDispatcher クラスは、イベントを送出するすべてのクラスの基本クラスです。
 *
 * The EventDispatcher class is the base class for all classes that dispatch events.
 *
 * @example <caption>Example usage of EventDispatcher.</caption>
 * // new ColorTransform
 * const {EventDispatcher} = next2d.events;
 * const eventDispatcher   = new EventDispatcher();
 * eventDispatcher.addEventListener(Event.ENTER_FRAME, function (event)
 * {
 *     // more...
 * });
 *
 * @class
 * @memberOf next2d.events
 */
class EventDispatcher
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        /**
         * @type {Map}
         * @default null
         * @private
         */
        this._$events = null;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class EventDispatcher]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class EventDispatcher]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.EventDispatcher
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.EventDispatcher";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return "[object EventDispatcher]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.EventDispatcher
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.EventDispatcher";
    }

    /**
     * @description イベントリスナーオブジェクトを EventDispatcher オブジェクトに登録し、
     *              リスナーがイベントの通知を受け取るようにします。
     *              Registers an event listener object with an EventDispatcher object
     *              so that the listener receives notification of an event.
     *
     * @param  {string}   type
     * @param  {function} listener
     * @param  {boolean}  [use_capture=false]
     * @param  {number}   [priority=0]
     * @return {void}
     * @method
     * @public
     */
    addEventListener (type, listener, use_capture = false, priority = 0)
    {

        let events,
            player,
            isBroadcast = false;

        type = `${type}`;
        switch (type) {

            // broadcast event
            case Event.ENTER_FRAME:
            case Event.EXIT_FRAME:
            case Event.FRAME_CONSTRUCTED:
            case Event.RENDER:
            case Event.ACTIVATE:
            case Event.DEACTIVATE:
            case "keyDown":
            case "keyUp":

                player = Util.$currentPlayer();
                if (!player.broadcastEvents.size
                    || !player.broadcastEvents.has(type)
                ) {
                    player.broadcastEvents.set(type, Util.$getArray());
                }

                events = player.broadcastEvents.get(type);

                isBroadcast = true;

                break;

            // normal event
            default:

                // init
                if (!this._$events) {
                    this._$events = Util.$getMap();
                }
                if (!this._$events.size || !this._$events.has(type)) {
                    this._$events.set(type, Util.$getArray());
                }

                events = this._$events.get(type);

                break;

        }

        // duplicate check
        let length = events.length;
        for (let idx = 0; idx < length; ++idx) {

            const event = events[idx];
            if (use_capture !== event.useCapture) {
                continue;
            }

            if (event.target !== this) {
                continue;
            }

            if (event.listener === listener) {
                length = idx;
            }

        }

        // add or overwrite
        events[length] = {
            "listener":   listener,
            "priority":   priority,
            "useCapture": use_capture,
            "target":     this
        };

        // set new event
        if (isBroadcast) {

            player.broadcastEvents.set(type, events);

        } else {

            // sort(DESC)
            events.sort(function (a, b)
            {
                switch (true) {

                    case a.priority > b.priority:
                        return -1;

                    case a.priority < b.priority:
                        return 1;

                    default:
                        return 0;

                }
            });

            this._$events.set(type, events);
        }
    }

    /**
     * @description イベントをイベントフローに送出します。
     *              Dispatches an event into the event flow.
     *
     * @param  {Event} event
     * @return {boolean}
     * @method
     * @public
     */
    dispatchEvent (event)
    {
        switch (event.type) {

            case Event.ENTER_FRAME:
            case Event.EXIT_FRAME:
            case Event.FRAME_CONSTRUCTED:
            case Event.RENDER:
            case Event.ACTIVATE:
            case Event.DEACTIVATE:
            case "keyDown":
            case "keyUp":
                {
                    const stage = this.stage;

                    const player = stage
                        ? stage._$player
                        : Util.$currentPlayer();

                    if (player && player.broadcastEvents.size
                        && player.broadcastEvents.has(event.type)
                    ) {

                        const events = player.broadcastEvents.get(event.type);

                        const length = events.length;
                        for (let idx = 0; idx < length; ++idx) {

                            const obj = events[idx];
                            if (obj.target !== this) {
                                continue;
                            }

                            // start target
                            event._$eventPhase = EventPhase.AT_TARGET;

                            // event execute
                            event._$currentTarget = obj.target;

                            try {

                                event._$listener = obj.listener;
                                obj.listener.call(Util.$window, event);

                            } catch (e) {

                                // TODO
                                // player
                                //     .stage
                                //     .loaderInfo
                                //     .uncaughtErrorEvents
                                //     .dispatchEvent(
                                //         new UncaughtErrorEvent(
                                //             UncaughtErrorEvent.UNCAUGHT_ERROR, true, true, Util.$errorObject
                                //         )
                                //     );

                                return false;

                            }
                        }

                        return true;
                    }
                }
                break;

            default:
                {

                    let events = Util.$getArray();
                    if (this._$events
                        && this._$events.size
                        && this._$events.has(event.type)
                    ) {
                        events = this._$events.get(event.type).slice(0);
                    }

                    // parent
                    const parentEvents = Util.$getArray();
                    if (this instanceof DisplayObject) {

                        let parent = this._$parent;
                        while (parent) {

                            if (parent.hasEventListener(event.type)) {
                                parentEvents[parentEvents.length] = parent._$events.get(event.type);
                            }

                            parent = parent._$parent;

                        }

                    }

                    event._$target = this;
                    if (events.length || parentEvents.length) {

                        // start capture
                        event._$eventPhase = EventPhase.CAPTURING_PHASE;

                        // stage => parent... end
                        if (parentEvents.length) {

                            switch (true) {

                                case event._$stopImmediatePropagation:
                                case event._$stopPropagation:
                                    break;

                                default:

                                    parentEvents.reverse();
                                    for (let idx = 0; idx < parentEvents.length; ++idx) {

                                        const targets = parentEvents[idx];
                                        for (let idx = 0; idx < targets.length; ++idx) {

                                            const obj = targets[idx];
                                            if (!obj.useCapture) {
                                                continue;
                                            }

                                            // event execute
                                            event._$currentTarget   = obj.target;
                                            Util.$currentLoaderInfo = obj.target._$loaderInfo;

                                            try {

                                                event._$listener = obj.listener;
                                                obj.listener.call(Util.$window, event);

                                            } catch (e) {

                                                // TODO
                                                // player
                                                //     .stage
                                                //     .loaderInfo
                                                //     .uncaughtErrorEvents
                                                //     .dispatchEvent(
                                                //         new UncaughtErrorEvent(
                                                //             UncaughtErrorEvent.UNCAUGHT_ERROR, true, true, Util.$errorObject
                                                //         )
                                                //     );
                                                return false;
                                            }

                                            if (event._$stopImmediatePropagation) {
                                                break;
                                            }

                                        }

                                        if (event._$stopImmediatePropagation) {
                                            break;
                                        }

                                    }
                                    parentEvents.reverse();

                                    break;
                            }

                        }

                        // start target
                        event._$eventPhase = EventPhase.AT_TARGET;
                        if (!event._$stopImmediatePropagation && !event._$stopPropagation) {
                            const length = events.length;
                            for (let idx = 0; idx < length; ++idx) {

                                const obj = events[idx];
                                if (obj.useCapture) {
                                    continue;
                                }

                                // event execute
                                event._$currentTarget   = obj.target;
                                Util.$currentLoaderInfo = obj.target._$loaderInfo;

                                try {

                                    event._$listener = obj.listener;
                                    obj.listener.call(Util.$window, event);

                                } catch (e) {

                                    // TODO
                                    // player
                                    //     .stage
                                    //     .loaderInfo
                                    //     .uncaughtErrorEvents
                                    //     .dispatchEvent(
                                    //         new UncaughtErrorEvent(
                                    //             UncaughtErrorEvent.UNCAUGHT_ERROR, true, true, Util.$errorObject
                                    //         )
                                    //     );
                                    return false;
                                }

                                if (event._$stopImmediatePropagation) {
                                    break;
                                }

                            }
                        }

                        // start bubbling
                        event._$eventPhase = EventPhase.BUBBLING_PHASE;
                        switch (true) {

                            case event._$stopImmediatePropagation:
                            case event._$stopPropagation:
                            case !event.bubbles:
                                break;

                            default:

                                // this => parent... => stage end
                                for (let idx = 0; idx < parentEvents.length; ++idx) {

                                    const targets = parentEvents[idx];
                                    for (let idx = 0; idx < targets.length; ++idx) {

                                        const obj = targets[idx];
                                        if (obj.useCapture) {
                                            continue;
                                        }

                                        // event execute
                                        event._$currentTarget   = obj.target;
                                        Util.$currentLoaderInfo = obj.target._$loaderInfo;

                                        try {

                                            event._$listener = obj.listener;
                                            obj.listener.call(Util.$window, event);

                                        } catch (e) {

                                            // TODO
                                            // player
                                            //     .stage
                                            //     .loaderInfo
                                            //     .uncaughtErrorEvents
                                            //     .dispatchEvent(
                                            //         new UncaughtErrorEvent(
                                            //             UncaughtErrorEvent.UNCAUGHT_ERROR, true, true, Util.$errorObject
                                            //         )
                                            //     );

                                            return false;
                                        }

                                        if (event._$stopImmediatePropagation) {
                                            break;
                                        }
                                    }

                                    if (event._$stopImmediatePropagation) {
                                        break;
                                    }

                                }

                                break;

                        }

                        Util.$poolArray(events);
                        Util.$poolArray(parentEvents);

                        return true;

                    }

                    Util.$poolArray(events);
                    Util.$poolArray(parentEvents);
                }
                break;

        }

        return false;
    }

    /**
     * @description EventDispatcher オブジェクトに、特定のイベントタイプに対して登録されたリスナーがあるかどうかを確認します。
     *              Checks whether the EventDispatcher object has any listeners registered for a specific type of event.
     *
     * @param  {string}  type
     * @return {boolean}
     * @method
     * @public
     */
    hasEventListener (type)
    {
        type = `${type}`;
        switch (type) {

            case Event.ENTER_FRAME:
            case Event.EXIT_FRAME:
            case Event.FRAME_CONSTRUCTED:
            case Event.RENDER:
            case Event.ACTIVATE:
            case Event.DEACTIVATE:
            case "keyDown":
            case "keyUp":
            {
                const stage  = this.stage;
                const player = stage
                    ? stage._$player
                    : Util.$currentPlayer();

                if (player && player.broadcastEvents.size
                        && player.broadcastEvents.has(type)
                ) {
                    const events = player.broadcastEvents.get(type);

                    for (let idx = 0; idx < events.length; idx++) {
                        if (events[idx].target === this) {
                            return true;
                        }
                    }
                }
                return false;
            }

            default:
                return !!(this._$events
                    && this._$events.size
                    && this._$events.has(type));

        }
    }

    /**
     * @description EventDispatcher オブジェクトからリスナーを削除します。
     *              Removes a listener from the EventDispatcher object.
     *
     * @param  {string}   type
     * @param  {function} listener
     * @param  {boolean}  [use_capture=false]
     * @return {void}
     * @method
     * @public
     */
    removeEventListener (type, listener, use_capture = false)
    {
        type = `${type}`;
        if (!this.hasEventListener(type)) {
            return;
        }

        let
            events,
            player,
            isBroadcast = false;

        switch (type) {

            case Event.ENTER_FRAME:
            case Event.EXIT_FRAME:
            case Event.FRAME_CONSTRUCTED:
            case Event.RENDER:
            case Event.ACTIVATE:
            case Event.DEACTIVATE:
            case "keyDown":
            case "keyUp":

                isBroadcast = true;

                player = Util.$currentPlayer();
                if (player) {
                    events = player.broadcastEvents.get(type);
                }

                break;

            default:
                events = this._$events.get(type);
                break;

        }

        // remove listener
        const length = events.length;
        for (let idx = 0; idx < length; ++idx) {

            // event object
            const obj = events[idx];
            if (use_capture === obj.useCapture
                && obj.listener === listener
            ) {
                events.splice(idx, 1);
                break;
            }

        }

        if (!events.length) {

            if (isBroadcast) {

                player.broadcastEvents.delete(type);

            } else {

                this._$events.delete(type);

                if (!this._$events.size) {
                    Util.$poolMap(this._$events);
                    this._$events = null;
                }

            }

            return ;
        }

        if (isBroadcast) {

            player.broadcastEvents.set(type, events);

        } else {

            // event sort
            events.sort(function (a, b)
            {
                switch (true) {

                    case a.priority > b.priority:
                        return -1;

                    case a.priority < b.priority:
                        return 1;

                    default:
                        return 0;

                }
            });

            this._$events.set(type, events);

        }
    }

    /**
     * @description EventDispatcherオブジェクトから指定したタイプのリスナーを全て削除します。
     *              Removes all listeners of the specified type from the EventDispatcher object.
     *
     * @param  {string}   type
     * @param  {boolean}  [use_capture=false]
     * @return {void}
     * @method
     * @public
     */
    removeAllEventListener (type, use_capture = false)
    {
        type = `${type}`;
        if (!this.hasEventListener(type)) {
            return;
        }

        let
            events,
            player,
            isBroadcast = false;

        switch (type) {

            case Event.ENTER_FRAME:
            case Event.EXIT_FRAME:
            case Event.FRAME_CONSTRUCTED:
            case Event.RENDER:
            case Event.ACTIVATE:
            case Event.DEACTIVATE:
            case "keyDown":
            case "keyUp":

                isBroadcast = true;

                player = Util.$currentPlayer();
                if (player) {
                    events = player.broadcastEvents.get(type);
                }

                break;

            default:
                events = this._$events.get(type);
                break;

        }

        // remove listener
        const results = Util.$getArray();

        const length = events.length;
        for (let idx = 0; idx < length; ++idx) {

            // event object
            const obj = events[idx];
            if (use_capture !== obj.useCapture) {
                results.push(obj);
            }

        }

        if (!results.length) {

            if (isBroadcast) {

                player.broadcastEvents.delete(type);

            } else {

                this._$events.delete(type);

                if (!this._$events.size) {
                    Util.$poolMap(this._$events);
                    this._$events = null;
                }

            }

            return ;
        }

        if (isBroadcast) {

            player.broadcastEvents.set(type, results);

        } else {

            // event sort
            results.sort(function (a, b)
            {
                switch (true) {

                    case a.priority > b.priority:
                        return -1;

                    case a.priority < b.priority:
                        return 1;

                    default:
                        return 0;

                }
            });

            this._$events.set(type, results);

        }
    }

    /**
     * @description 指定されたイベントタイプについて、
     *              この EventDispatcher オブジェクトまたはその祖先にイベントリスナーが
     *              登録されているかどうかを確認します。
     *              Checks whether an event listener is registered
     *              with this EventDispatcher object or
     *              any of its ancestors for the specified event type.
     *
     * @param  {string}  type
     * @return {boolean}
     * @method
     * @public
     */
    willTrigger (type)
    {
        if (this.hasEventListener(type)) {
            return true;
        }

        let parent = this._$parent;
        while (parent) {

            if (parent.hasEventListener(type)) {
                return true;
            }

            parent = parent._$parent;
        }

        return false;
    }
}
/**
 * EventPhase クラスは、Event クラスの eventPhase プロパティの値を提供します。
 *
 * The EventPhase class provides values for the eventPhase property of the Event class.
 *
 * @class
 * @memberOf next2d.events
 */
class EventPhase
{
    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class EventPhase]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class EventPhase]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.EventPhase
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.EventPhase";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @default [object EventPhase]
     * @method
     * @public
     */
    toString ()
    {
        return "[object EventPhase]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.EventPhase
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.EventPhase";
    }

    /**
     * @description ターゲット段階（イベントフローの 2 番目の段階）です。
     *              The target phase, which is the second phase of the event flow.
     *
     * @return  {number}
     * @default 2
     * @const
     * @static
     */
    static get AT_TARGET ()
    {
        return 2;
    }

    /**
     * @description ターゲット段階（イベントフローの 2 番目の段階）です。
     *              The target phase, which is the second phase of the event flow.
     *
     * @return  {number}
     * @default 3
     * @const
     * @static
     */
    static get BUBBLING_PHASE ()
    {
        return 3;
    }

    /**
     * @description キャプチャ段階（イベントフローの最初の段階）です。
     *              The capturing phase, which is the first phase of the event flow.
     *
     * @return  {number}
     * @default 1
     * @const
     * @static
     */
    static get CAPTURING_PHASE ()
    {
        return 1;
    }
}
/**
 * FocusEvent オブジェクトは、ユーザーが表示リストの1つのオブジェクトから
 * 別のオブジェクトにフォーカスを変更したときにオブジェクトによって送出されます。
 * 次の2種類のフォーカスイベントがあります。
 *
 * An object dispatches a FocusEvent object when the user changes
 * the focus from one object in the display list to another.
 * There are two types of focus events:
 *
 * <ul>
 *     <li>FocusEvent.FOCUS_IN</li>
 *     <li>FocusEvent.FOCUS_OUT</li>
 * </ul>
 *
 * @class
 * @memberOf next2d.events
 * @extends  Event
 */
class FocusEvent extends Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=true]
     * @param {boolean} [cancelable=false]
     *
     * @constructor
     * @public
     */
    constructor (type, bubbles = true, cancelable = false)
    {
        super(type, bubbles, cancelable);
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class FocusEvent]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class FocusEvent]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.FocusEvent
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.FocusEvent";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString(
            "FocusEvent", "type", "bubbles", "cancelable", "eventPhase"
        );
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.FocusEvent
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.FocusEvent";
    }

    /**
     * @description focusIn イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a focusIn event object.
     *
     * @return {string}
     * @default focusIn
     * @const
     * @static
     */
    static get FOCUS_IN ()
    {
        return "focusIn";
    }

    /**
     * @description focusOut イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a focusOut event object.
     *
     * @return {string}
     * @default focusOut
     * @const
     * @static
     */
    static get FOCUS_OUT ()
    {
        return "focusOut";
    }
}
/**
 * ネットワーク要求が HTTP ステータスコードを返すと、アプリケーションによって HTTPStatusEvent オブジェクトが送出されます。
 *
 * The application dispatches HTTPStatusEvent objects when a network request returns an HTTP status code.
 *
 * @class
 * @memberOf next2d.events
 * @extends  Event
 */
class HTTPStatusEvent extends Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=false]
     * @param {boolean} [cancelable=false]
     * @param {number}  [status=0]
     *
     * @constructor
     * @public
     */
    constructor (type, bubbles = false, cancelable = false, status = 0)
    {
        super(type, bubbles, cancelable);

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$status = status | 0;

        /**
         * @type {array}
         * @default {array}
         * @private
         */
        this._$responseHeaders = [];

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$responseURL = "";
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class HTTPStatusEvent]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class HTTPStatusEvent]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.HTTPStatusEvent
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.HTTPStatusEvent";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString(
            "HTTPStatusEvent",
            "type", "bubbles", "cancelable",
            "eventPhase", "status", "responseURL"
        );
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.HTTPStatusEvent
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.HTTPStatusEvent";
    }

    /**
     * @description HTTPStatusEvent.HTTP_STATUS 定数は、
     *              httpStatus イベントオブジェクトの type プロパティの値を定義します。
     *              The HTTPStatusEvent.HTTP_STATUS constant defines the value
     *              of the type property of a httpStatus event object.
     *
     * @return {string}
     * @default httpStatus
     * @const
     * @static
     */
    static get HTTP_STATUS ()
    {
        return "httpStatus";
    }

    /**
     * @description 返された応答ヘッダー（URLRequestHeader オブジェクトの配列）です。
     *              The response headers that the response returned,
     *              as an array of URLRequestHeader objects.
     *
     * @return {array}
     * @readonly
     * @public
     */
    get responseHeaders ()
    {
        return this._$responseHeaders;
    }

    /**
     * @description 応答の返送元の URL です。
     *              The URL that the response was returned from.
     *
     * @return {string}
     * @readonly
     * @public
     */
    get responseURL ()
    {
        return this._$responseURL;
    }

    /**
     * @description サーバーから返された HTTP ステータスコードです。
     *              The HTTP status code returned by the server.
     *
     * @return {number}
     * @readonly
     * @public
     */
    get status ()
    {
        return this._$status;
    }
}
/**
 * IOErrorEvent オブジェクトは、エラーが発生して入力操作または出力操作が失敗したときに送出されます。
 *
 * An IOErrorEvent object is dispatched when an error causes input or output operations to fail.
 *
 * @class
 * @memberOf next2d.events
 * @extends  Event
 */
class IOErrorEvent extends Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=true]
     * @param {boolean} [cancelable=false]
     * @param {string}  [text=""]
     *
     * @constructor
     * @public
     */
    constructor (type, bubbles = false, cancelable = false, text = "")
    {
        super(type, bubbles, cancelable);

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$text = `${text}`;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class IOErrorEvent]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class IOErrorEvent]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.IOErrorEvent
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.IOErrorEvent";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString(
            "IOErrorEvent",
            "type", "bubbles", "cancelable",
            "eventPhase", "text"
        );
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.IOErrorEvent
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.IOErrorEvent";
    }

    /**
     * @description ioError イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of an ioError event object.
     *
     * @return {string}
     * @default ioError
     * @const
     * @static
     */
    static get IO_ERROR ()
    {
        return "ioError";
    }

    /**
     * @description エラーテキストです。
     *              error text.
     *
     * @return {string}
     * @default ""
     * @readonly
     * @public
     */
    get text ()
    {
        return this._$text;
    }
}
/**
 * MouseEvent オブジェクトは、マウスイベントが発生するたびにイベントフローに送出されます。
 * 通常、マウスイベントは、マウスやトラックボールなど、ポインターを使用したユーザー入力デバイスによって生成されます。
 *
 * A MouseEvent object is dispatched into the event flow whenever mouse events occur.
 * A mouse event is usually generated by a user input device,
 * such as a mouse or a trackball, that uses a pointer.
 *
 * @class
 * @memberOf next2d.events
 * @extends  Event
 */
class MouseEvent extends Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=true]
     * @param {boolean} [cancelable=false]
     *
     * @constructor
     * @public
     */
    constructor (type, bubbles = true, cancelable = false)
    {

        super(type, bubbles, cancelable);

        return new Proxy(this, {
            "get": function (object, name)
            {
                if (name in object) {
                    return object[name];
                }

                if (Util.$event && name in Util.$event) {
                    return Util.$event[name];
                }

                return undefined;
            }
        });

    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class MouseEvent]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class MouseEvent]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.MouseEvent
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.MouseEvent";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString(
            "MouseEvent",
            "type", "bubbles", "cancelable", "eventPhase",
            "localX", "localY", "stageX", "stageY",
            "ctrlKey", "altKey", "shiftKey", "buttonDown",
            "delta", "commandKey", "controlKey", "clickCount"
        );
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.MouseEvent
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.MouseEvent";
    }

    /**
     * @description click イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a click event object.
     *
     * @return {string}
     * @default click
     * @const
     * @static
     */
    static get CLICK ()
    {
        return "click";
    }

    /**
     * @description dblclick イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a dblclick event object.
     *
     * @return {string}
     * @default dblclick
     * @const
     * @static
     */
    static get DOUBLE_CLICK ()
    {
        return "dblclick";
    }

    /**
     * @description mouseDown イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a mouseDown event object.
     *
     * @return {string}
     * @default mouseDown
     * @const
     * @static
     */
    static get MOUSE_DOWN ()
    {
        return "mouseDown";
    }

    /**
     * @description mouseMove イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a mouseMove event object.
     *
     * @return {string}
     * @default mouseMove
     * @const
     * @static
     */
    static get MOUSE_MOVE ()
    {
        return "mouseMove";
    }

    /**
     * @description mouseOut イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a mouseOut event object.
     *
     * @return {string}
     * @default mouseOut
     * @const
     * @static
     */
    static get MOUSE_OUT ()
    {
        return "mouseOut";
    }

    /**
     * @description mouseOver イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a mouseOver event object.
     *
     * @return {string}
     * @default mouseOver
     * @const
     * @static
     */
    static get MOUSE_OVER ()
    {
        return "mouseOver";
    }

    /**
     * @description mouseUp イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a mouseUp event object.
     *
     * @return {string}
     * @default mouseUp
     * @const
     * @static
     */
    static get MOUSE_UP ()
    {
        return "mouseUp";
    }

    /**
     * @description mouseWheel イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a mouseWheel event object.
     *
     * @return {string}
     * @default mouseWheel
     * @const
     * @static
     */
    static get MOUSE_WHEEL ()
    {
        return "mouseWheel";
    }

    /**
     * @description rollOut イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a rollOut event object.
     *
     * @return {string}
     * @default rollOut
     * @const
     * @static
     */
    static get ROLL_OUT ()
    {
        return "rollOut";
    }

    /**
     * @description rollOver イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a rollOver event object.
     *
     * @return {string}
     * @default rollOver
     * @const
     * @static
     */
    static get ROLL_OVER ()
    {
        return "rollOver";
    }
}
/**
 * ProgressEvent オブジェクトは、ロード処理が開始されたとき、またはソケットがデータを受信したときに送出されます。
 * これらのイベントは通常、JSON ファイル、イメージまたはデータがアプリケーションにロードされるときに生成されます。
 *
 * A ProgressEvent object is dispatched when a load operation has begun or a socket has received data.
 * These events are usually generated when JSON files, images or data are loaded into an application.
 *
 * @class
 * @memberOf next2d.events
 * @extends  Event
 */
class ProgressEvent extends Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=true]
     * @param {boolean} [cancelable=false]
     * @param {number}  [bytes_loaded=0]
     * @param {number}  [bytes_total=0]
     *
     * @constructor
     * @public
     */
    constructor (
        type, bubbles = false, cancelable = false,
        bytes_loaded = 0, bytes_total = 0
    ) {

        super(type, bubbles, cancelable);

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesLoaded = bytes_loaded | 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesTotal  = bytes_total | 0;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class ProgressEvent]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class ProgressEvent]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.ProgressEvent
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.ProgressEvent";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString(
            "ProgressEvent",
            "type", "bubbles", "cancelable",
            "eventPhase", "bytesLoaded", "bytesTotal"
        );
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.ProgressEvent
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.ProgressEvent";
    }

    /**
     * @description progress イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a progress event object.
     *
     * @return {string}
     * @default progress
     * @const
     * @static
     */
    static get PROGRESS ()
    {
        return "progress";
    }

    /**
     * @description リスナーがイベントを処理しているときに読み込まれたアイテム数またはバイト数です。
     *              The number of items or bytes loaded when the listener processes the event.
     *
     * @return {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesLoaded ()
    {
        return this._$bytesLoaded;
    }

    /**
     * @description 読み込みプロセスが成功した場合に読み込まれるアイテムまたはバイトの総数です。
     *              The total number of items or bytes that will be loaded
     *              if the loading process succeeds.
     *
     * @return {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesTotal ()
    {
        return this._$bytesTotal;
    }
}
/**
 * ビデオを再生または停止すると、VideoEvent オブジェクトを送出します。
 *
 * When a video is played or stopped, it sends out a VideoEvent object.
 *
 * @class
 * @memberOf next2d.events
 * @extends  Event
 */
class VideoEvent extends Event
{
    /**
     * @param {string}  type
     * @param {boolean} [bubbles=true]
     * @param {boolean} [cancelable=false]
     * @param {number}  [bytes_loaded=0]
     * @param {number}  [bytes_total=0]
     *
     * @constructor
     * @public
     */
    constructor (
        type, bubbles = false, cancelable = false,
        bytes_loaded = 0, bytes_total = 0
    ) {

        super(type, bubbles, cancelable);

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesLoaded = bytes_loaded | 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesTotal  = bytes_total | 0;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class VideoEvent]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class VideoEvent]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.events.VideoEvent
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.events.VideoEvent";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return this.formatToString(
            "VideoEvent",
            "type", "bubbles", "cancelable",
            "eventPhase", "bytesLoaded", "bytesTotal"
        );
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.events.VideoEvent
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.events.VideoEvent";
    }

    /**
     * @description progress イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a progress event object.
     *
     * @return {string}
     * @default progress
     * @const
     * @static
     */
    static get PROGRESS ()
    {
        return "progress";
    }

    /**
     * @description play イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a play event object.
     *
     * @return {string}
     * @default play
     * @const
     * @static
     */
    static get PLAY ()
    {
        return "play";
    }

    /**
     * @description playStart イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a playStart event object.
     *
     * @return {string}
     * @default playStart
     * @const
     * @static
     */
    static get PLAY_START ()
    {
        return "playStart";
    }

    /**
     * @description playEnd イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a playEnd event object.
     *
     * @return {string}
     * @default playEnd
     * @const
     * @static
     */
    static get PLAY_END ()
    {
        return "playEnd";
    }

    /**
     * @description pause イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a pause event object.
     *
     * @return {string}
     * @default pause
     * @const
     * @static
     */
    static get PAUSE ()
    {
        return "pause";
    }

    /**
     * @description seek イベントオブジェクトの type プロパティ値を定義します。
     *              Defines the value of the type property of a seek event object.
     *
     * @return {string}
     * @default seek
     * @const
     * @static
     */
    static get SEEK ()
    {
        return "seek";
    }

    /**
     * @description リスナーがイベントを処理しているときに読み込まれたアイテム数またはバイト数です。
     *              The number of items or bytes loaded when the listener processes the event.
     *
     * @return {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesLoaded ()
    {
        return this._$bytesLoaded;
    }

    /**
     * @description 読み込みプロセスが成功した場合に読み込まれるアイテムまたはバイトの総数です。
     *              The total number of items or bytes that will be loaded
     *              if the loading process succeeds.
     *
     * @return {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesTotal ()
    {
        return this._$bytesTotal;
    }
}
/**
 * ColorTransform クラスを使用すると、表示オブジェクトのカラー値を調整することができます。
 * カラー調整、つまり "カラー変換" は、赤、緑、青、アルファ透明度の 4 つのチャンネルすべてに適用できます。
 * <ul>
 *     <li>新しい red 値 = (古い red 値 * redMultiplier ) + redOffset</li>
 *     <li>新しい green 値 = (古い green 値 * greenMultiplier ) + greenOffset</li>
 *     <li>新しい blue 値 = (古い blue 値 * blueMultiplier ) + blueOffset</li>
 *     <li>新しい alpha 値 = (古い alpha 値 * alphaMultiplier ) + alphaOffset</li>
 * </ul>
 * 算出後、カラーチャンネル値が 255 よりも大きい場合は 255 に設定されます。
 * 0 より小さい場合は 0 に設定されます。
 *
 * The ColorTransform class lets you adjust the color values in a display object.
 * The color adjustment or color transformation can be applied
 * to all four channels: red, green, blue, and alpha transparency.
 * <ul>
 *     <li>New red value = (old red value * redMultiplier) + redOffset</li>
 *     <li>New green value = (old green value * greenMultiplier) + greenOffset</li>
 *     <li>New blue value = (old blue value * blueMultiplier) + blueOffset</li>
 *     <li>New alpha value = (old alpha value * alphaMultiplier) + alphaOffset</li>
 * </ul>
 * If any of the color channel values is greater than 255 after the calculation,
 * it is set to 255. If it is less than 0, it is set to 0.
 *
 * @class
 * @memberOf next2d.geom
 */
class ColorTransform
{
    /**
     * @param {number} [red_multiplier=1]
     * @param {number} [green_multiplier=1]
     * @param {number} [blue_multiplier=1]
     * @param {number} [alpha_multiplier=1]
     * @param {number} [red_offset=0]
     * @param {number} [green_offset=0]
     * @param {number} [blue_offset=0]
     * @param {number} [alpha_offset=0]
     *
     * @example <caption>Example usage of ColorTransform.</caption>
     * // new ColorTransform
     * const {ColorTransform} = next2d.geom;
     * const colorTransform   = new ColorTransform();
     * // set new ColorTransform
     * const {MovieClip} = next2d.display;
     * const movieClip   = new MovieClip();
     * movieClip.transform.colorTransform = colorTransform;
     *
     * @constructor
     * @public
     */
    constructor(
        red_multiplier = 1, green_multiplier = 1, blue_multiplier = 1, alpha_multiplier = 1,
        red_offset = 0, green_offset = 0, blue_offset = 0, alpha_offset = 0
    ) {

        /**
         * @type {Float32Array}
         * @private
         */
        this._$colorTransform = Util.$getFloat32Array8(
            1, 1, 1, 1, 0, 0, 0, 0
        );

        // setup
        this.redMultiplier   = red_multiplier;
        this.greenMultiplier = green_multiplier;
        this.blueMultiplier  = blue_multiplier;
        this.alphaMultiplier = alpha_multiplier;
        this.redOffset       = red_offset;
        this.greenOffset     = green_offset;
        this.blueOffset      = blue_offset;
        this.alphaOffset     = alpha_offset;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class ColorTransform]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class ColorTransform]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member {string}
     * @default next2d.geom.ColorTransform
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.geom.ColorTransform";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return "(redMultiplier=" + this._$colorTransform[0] + ", " +
            "greenMultiplier="   + this._$colorTransform[1] + ", " +
            "blueMultiplier="    + this._$colorTransform[2] + ", " +
            "alphaMultiplier="   + this._$colorTransform[3] + ", " +
            "redOffset="         + this._$colorTransform[4] + ", " +
            "greenOffset="       + this._$colorTransform[5] + ", " +
            "blueOffset="        + this._$colorTransform[6] + ", " +
            "alphaOffset="       + this._$colorTransform[7] + ")";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.geom.ColorTransform
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.geom.ColorTransform";
    }

    /**
     * @description アルファ透明度チャンネル値に乗算する 10 進数値です。
     *              A decimal value that is multiplied with the alpha transparency channel value.
     *
     * @member {number}
     * @default 1
     * @public
     */
    get alphaMultiplier ()
    {
        return this._$colorTransform[3];
    }
    set alphaMultiplier (alpha_multiplier)
    {
        this._$colorTransform[3] = Util.$clamp(+alpha_multiplier, 0, 1, 0);
    }

    /**
     * @description アルファ透明度チャンネル値に alphaMultiplier 値を乗算した後に加算する数値です。
     *              数値の範囲は -255 ～ 255 です。
     *              A number from -255 to 255 that is added to the alpha transparency channel value after
     *              it has been multiplied by the alphaMultiplier value.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get alphaOffset ()
    {
        return this._$colorTransform[7];
    }
    set alphaOffset (alpha_offset)
    {
        this._$colorTransform[7] = Util.$clamp(alpha_offset | 0, -255, 255, 0);
    }

    /**
     * @description 青チャンネル値に乗算する 10 進数値です。
     *              A decimal value that is multiplied with the blue channel value.
     *
     * @member {number}
     * @default 1
     * @public
     */
    get blueMultiplier ()
    {
        return this._$colorTransform[2];
    }
    set blueMultiplier (blue_multiplier)
    {
        this._$colorTransform[2] = Util.$clamp(+blue_multiplier, 0, 1, 0);
    }

    /**
     * @description 青チャンネル値に blueMultiplier 値を乗算した後に加算する数値です。
     *              数値の範囲は -255 ～ 255 です。
     *              A number from -255 to 255 that is added to the blue channel value after
     *              it has been multiplied by the blueMultiplier value.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get blueOffset ()
    {
        return this._$colorTransform[6];
    }
    set blueOffset (blue_offset)
    {
        this._$colorTransform[6] = Util.$clamp(blue_offset | 0, -255, 255, 0);
    }

    /**
     * @description 緑チャンネル値に乗算する 10 進数値です。
     *              A decimal value that is multiplied with the green channel value.
     *
     * @member {number}
     * @default 1
     * @public
     */
    get greenMultiplier ()
    {
        return this._$colorTransform[1];
    }
    set greenMultiplier (green_multiplier)
    {
        this._$colorTransform[1] = Util.$clamp(+green_multiplier, 0, 1, 0);
    }

    /**
     * @description 緑チャンネル値に greenMultiplier 値を乗算した後に加算する数値です。
     *              数値の範囲は -255 ～ 255 です。
     *              A number from -255 to 255 that is added to the green channel value after
     *              it has been multiplied by the greenMultiplier value.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get greenOffset ()
    {
        return this._$colorTransform[5];
    }
    set greenOffset (green_offset)
    {
        this._$colorTransform[5] = Util.$clamp(green_offset | 0, -255, 255, 0);
    }

    /**
     * @description 赤チャンネル値に乗算する 10 進数値です。
     *              A decimal value that is multiplied with the red channel value.
     *
     * @member {number}
     * @default 1
     * @public
     */
    get redMultiplier ()
    {
        return this._$colorTransform[0];
    }
    set redMultiplier (red_multiplier)
    {
        this._$colorTransform[0] = Util.$clamp(+red_multiplier, 0, 1, 0);
    }

    /**
     * @description 赤チャンネル値に redMultiplier 値を乗算した後に加算する数値です。
     *              数値の範囲は -255 ～ 255 です。
     *              A number from -255 to 255 that is added to the red channel value after
     *              it has been multiplied by the redMultiplier value.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get redOffset ()
    {
        return this._$colorTransform[4];
    }
    set redOffset (red_offset)
    {
        this._$colorTransform[4] = Util.$clamp(red_offset | 0, -255, 255, 0);
    }

    /**
     * @description 2 番目のパラメーターで指定された ColorTransform オブジェクトと
     *              現在の ColorTransform オブジェクトを連結し
     *              2 つのカラー変換を加算的に組み合わせた結果を現在のオブジェクトに設定します。
     *              Concatenates the ColorTransform object specified
     *              by the second parameter with the current ColorTransform object
     *              and sets the current object as the result,
     *              which is an additive combination of the two color transformations.
     *
     * @param  {ColorTransform} second - ColorTransformオブジェクト
     * @return {void}
     * @method
     * @public
     */
    concat (second)
    {
        const multiColor = Util.$multiplicationColor(
            this._$colorTransform,
            second._$colorTransform
        );

        // update
        this.redMultiplier   = multiColor[0];
        this.greenMultiplier = multiColor[1];
        this.blueMultiplier  = multiColor[2];
        this.alphaMultiplier = multiColor[3];
        this.redOffset       = multiColor[4];
        this.greenOffset     = multiColor[5];
        this.blueOffset      = multiColor[6];
        this.alphaOffset     = multiColor[7];

        Util.$poolFloat32Array8(multiColor);
    }

    /**
     * @return {ColorTransform}
     * @method
     * @private
     */
    _$clone ()
    {
        return Util.$getColorTransform(
            this._$colorTransform[0], this._$colorTransform[1],
            this._$colorTransform[2], this._$colorTransform[3],
            this._$colorTransform[4], this._$colorTransform[5],
            this._$colorTransform[6], this._$colorTransform[7]
        );
    }
}

/**
 * Matrix クラスは、2 つの座標空間の間におけるポイントのマッピング方法を決定する変換マトリックスを表します。
 * Matrix オブジェクトのプロパティを設定し、Matrix オブジェクトを Transform オブジェクトの matrix プロパティに適用し、
 * 次に Transform オブジェクトを表示オブジェクトの transform プロパティとして適用することで、表示オブジェクトに対する各種グラフィック変換を実行できます。
 * これらの変換機能には、平行移動（x と y の位置変更）、回転、拡大 / 縮小、傾斜などが含まれます。
 *
 * The Matrix class represents a transformation matrix that determines how to map points from one coordinate space to another.
 * You can perform various graphical transformations on a display object by setting the properties of a Matrix object,
 * applying that Matrix object to the matrix property of a Transform object,
 * and then applying that Transform object as the transform property of the display object.
 * These transformation functions include translation (x and y repositioning), rotation, scaling, and skewing.
 *
 * @example <caption>Example usage of Matrix.</caption>
 * // new Matrix
 * const {Matrix} = next2d.geom;
 * const matrix   = new Matrix();
 * // set new Matrix
 * const {MovieClip} = next2d.display;
 * const movieClip   = new MovieClip();
 * movieClip.transform.matrix = matrix;
 *
 * @class
 * @memberOf next2d.geom
 */
class Matrix
{
    /**
     * @param   {number} [a=1]
     * @param   {number} [b=0]
     * @param   {number} [c=0]
     * @param   {number} [d=1]
     * @param   {number} [tx=0]
     * @param   {number} [ty=0]
     *
     * @constructor
     * @public
     */
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)
    {
        /**
         * @type {Float32Array}
         * @private
         */
        this._$matrix = Util.$getFloat32Array6(1, 0, 0, 1, 0, 0);

        // setup
        this.a  = a;
        this.b  = b;
        this.c  = c;
        this.d  = d;
        this.tx = tx;
        this.ty = ty;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Matrix]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Matrix]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.geom.Matrix
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.geom.Matrix";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return `(a=${this.a}, b=${this.b}, c=${this.c}, d=${this.d}, tx=${this.tx}, ty=${this.ty})`;
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.geom.Matrix
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.geom.Matrix";
    }

    /**
     * @description イメージを拡大 / 縮小または回転するときに x 軸方向のピクセルの配置に影響を与える値です。
     *              The value that affects the positioning
     *              of pixels along the x axis when scaling or rotating an image.
     *
     * @member {number}
     * @default 1
     * @public
     */
    get a ()
    {
        return this._$matrix[0];
    }
    set a (a)
    {
        this._$matrix[0] = Util.$clamp(+a, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description イメージを回転または傾斜させるときに y 軸方向のピクセルの配置に影響を与える値です。
     *              The value that affects the positioning
     *              of pixels along the y axis when rotating or skewing an image.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get b ()
    {
        return this._$matrix[1];
    }
    set b (b)
    {
        this._$matrix[1] = Util.$clamp(+b, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description イメージを回転または傾斜させるときに x 軸方向のピクセルの配置に影響を与える値です。
     *              The value that affects the positioning
     *              of pixels along the x axis when rotating or skewing an image.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get c ()
    {
        return this._$matrix[2];
    }
    set c (c)
    {
        this._$matrix[2] = Util.$clamp(+c, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description イメージを拡大 / 縮小または回転するときに y 軸方向のピクセルの配置に影響を与える値です。
     *              The value that affects the positioning
     *              of pixels along the y axis when scaling or rotating an image.
     *
     * @member {number}
     * @default 1
     * @public
     */
    get d ()
    {
        return this._$matrix[3];
    }
    set d (d)
    {
        this._$matrix[3] = Util.$clamp(+d, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description x 軸方向に各ポイントを平行移動する距離です。
     *              The distance by which to translate each point along the x axis.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get tx ()
    {
        return this._$matrix[4];
    }
    set tx (tx)
    {
        this._$matrix[4] = Util.$clamp(+tx, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description y 軸方向に各ポイントを平行移動する距離です。
     *              The distance by which to translate each point along the y axis.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get ty ()
    {
        return this._$matrix[5];
    }
    set ty (ty)
    {
        this._$matrix[5] = Util.$clamp(+ty, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @return {Matrix}
     * @method
     * @private
     */
    _$clone ()
    {
        return this.clone();
    }

    /**
     * @description 新しい Matrix オブジェクトとして、このマトリックスのクローンを返します。
     *              含まれるオブジェクトはまったく同じコピーになります。
     *              Returns a new Matrix object that is a clone of this matrix,
     *              with an exact copy of the contained object.
     *
     * @return {Matrix}
     * @method
     * @public
     */
    clone ()
    {
        return Util.$getMatrix(
            this._$matrix[0], this._$matrix[1],
            this._$matrix[2], this._$matrix[3],
            this._$matrix[4], this._$matrix[5]
        );
    }

    /**
     * @description マトリックスを現在のマトリックスと連結して、
     *              2 つのマトリックスの図形効果を効果的に組み合わせます。
     *              Concatenates a matrix with the current matrix,
     *              effectively combining the geometric effects of the two.
     *
     * @param  {Matrix} m
     * @return {void}
     * @method
     * @public
     */
    concat (m)
    {
        const matrix = this._$matrix;
        const target = m._$matrix;

        let a =  matrix[0] * target[0];
        let b =  0.0;
        let c =  0.0;
        let d =  matrix[3] * target[3];
        let tx = matrix[4] * target[0] + target[4];
        let ty = matrix[5] * target[3] + target[5];

        if (matrix[1] || matrix[2] || target[1] || target[2]) {
            a  += matrix[1] * target[2];
            d  += matrix[2] * target[1];
            b  += matrix[0] * target[1] + matrix[1] * target[3];
            c  += matrix[2] * target[0] + matrix[3] * target[2];
            tx += matrix[5] * target[2];
            ty += matrix[4] * target[1];
        }

        this.a  = a;
        this.b  = b;
        this.c  = c;
        this.d  = d;
        this.tx = tx;
        this.ty = ty;
    }

    /**
     * @description すべてのマトリックスデータを、ソース Matrix オブジェクトから、
     *              呼び出し元の Matrix オブジェクトにコピーします。
     *
     * @param  {Matrix} source_matrix
     * @method
     * @return {void}
     */
    copyFrom (source_matrix)
    {
        this.a  = source_matrix.a;
        this.b  = source_matrix.b;
        this.c  = source_matrix.c;
        this.d  = source_matrix.d;
        this.tx = source_matrix.tx;
        this.ty = source_matrix.ty;
    }

    /**
     * @description 拡大 / 縮小、回転、平行移動に関するパラメーターなどがあります。
     *              Includes parameters for scaling, rotation, and translation.
     *
     * @param  {number} scale_x
     * @param  {number} scale_y
     * @param  {number} [rotation=0]
     * @param  {number} [tx=0]
     * @param  {number} [ty=0]
     * @return {void}
     * @method
     * @public
     */
    createBox (scale_x, scale_y, rotation = 0, tx = 0, ty = 0)
    {
        this.identity();
        this.rotate(rotation);
        this.scale(scale_x, scale_y);
        this.translate(tx, ty);
    }

    /**
     * @description Graphics クラスの beginGradientFill() メソッドで使用する特定のスタイルを作成します。
     *              Creates the specific style of matrix expected
     *              by the beginGradientFill() and lineGradientStyle() methods of the Graphics class.
     *
     * @param  {number} width
     * @param  {number} height
     * @param  {number} [rotation=0]
     * @param  {number} [tx=0]
     * @param  {number} [ty=0]
     * @return {void}
     * @method
     * @public
     */
    createGradientBox (width, height, rotation = 0, tx = 0, ty = 0)
    {
        this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
    }

    /**
     * @description 変換前の座標空間内のポイントが指定されると、そのポイントの変換後の座標を返します。
     *              Given a point in the pretransform coordinate space,
     *              returns the coordinates of that point after the transformation occurs.
     *
     * @param  {Point} point
     * @return {Point}
     * @method
     * @public
     */
    deltaTransformPoint (point)
    {
        return new Point(
            point.x * this._$matrix[0] + point.y * this._$matrix[2],
            point.x * this._$matrix[1] + point.y * this._$matrix[3]
        );
    }

    /**
     * @description 各行列プロパティを null 変換になる値に設定します。
     *              Sets each matrix property to a value that causes a null transformation.
     *
     * @return {void}
     * @method
     * @public
     */
    identity ()
    {
        this._$matrix[0] = 1;
        this._$matrix[1] = 0;
        this._$matrix[2] = 0;
        this._$matrix[3] = 1;
        this._$matrix[4] = 0;
        this._$matrix[5] = 0;
    }

    /**
     * @description 元のマトリックスの逆の変換を実行します。
     *              Performs the opposite transformation of the original matrix.
     *
     * @return {void}
     * @method
     * @public
     */
    invert ()
    {
        let a  = this._$matrix[0];
        let b  = this._$matrix[1];
        let c  = this._$matrix[2];
        let d  = this._$matrix[3];
        let tx = this._$matrix[4];
        let ty = this._$matrix[5];

        if (b === 0 && c === 0) {

            this.a  = 1 / a;
            this.b  = 0;
            this.c  = 0;
            this.d  = 1 / d;
            this.tx = -this.a * tx;
            this.ty = -this.d * ty;

        } else {

            const det = a * d - b * c;

            if (det) {

                const rdet = 1 / det;

                this.a  = d  * rdet;
                this.b  = -b * rdet;
                this.c  = -c * rdet;
                this.d  = a  * rdet;
                this.tx = -(this.a * tx + this.c * ty);
                this.ty = -(this.b * tx + this.d * ty);

            }

        }
    }

    /**
     * @description Matrix オブジェクトに回転変換を適用します。
     *              Applies a rotation transformation to the Matrix object.
     *
     * @param  {number} rotation
     * @return {void}
     * @method
     * @public
     */
    rotate (rotation)
    {
        const a  = this._$matrix[0];
        const b  = this._$matrix[1];
        const c  = this._$matrix[2];
        const d  = this._$matrix[3];
        const tx = this._$matrix[4];
        const ty = this._$matrix[5];

        this.a  = a  * $Math.cos(rotation) - b  * $Math.sin(rotation);
        this.b  = a  * $Math.sin(rotation) + b  * $Math.cos(rotation);
        this.c  = c  * $Math.cos(rotation) - d  * $Math.sin(rotation);
        this.d  = c  * $Math.sin(rotation) + d  * $Math.cos(rotation);
        this.tx = tx * $Math.cos(rotation) - ty * $Math.sin(rotation);
        this.ty = tx * $Math.sin(rotation) + ty * $Math.cos(rotation);
    }

    /**
     * @description 行列に拡大 / 縮小の変換を適用します。
     *              Applies a scaling transformation to the matrix.
     *
     * @param  {number} sx
     * @param  {number} sy
     * @return {void}
     * @method
     * @public
     */
    scale (sx, sy)
    {
        this.a  *= sx;
        this.c  *= sx;
        this.tx *= sx;

        this.b  *= sy;
        this.d  *= sy;
        this.ty *= sy;
    }

    /**
     * @description Matrix のメンバーを指定の値に設定します。
     *              Sets the members of Matrix to the specified values
     *
     * @param  {number} a
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @param  {number} tx
     * @param  {number} ty
     * @return {void}
     * @method
     * @public
     */
    setTo (a, b, c, d, tx, ty)
    {
        this.a  = a;
        this.b  = b;
        this.c  = c;
        this.d  = d;
        this.tx = tx;
        this.ty = ty;
    }

    /**
     * @description Matrix オブジェクトで表現される図形変換を、指定されたポイントに適用した結果を返します。
     *              Returns the result of applying the geometric transformation represented
     *              by the Matrix object to the specified point.
     *
     * @param  {Point} point
     * @return {Point}
     * @method
     * @public
     */
    transformPoint (point)
    {
        return new Point(
            point.x * this._$matrix[0] + point.y * this._$matrix[2] + this._$matrix[4],
            point.x * this._$matrix[1] + point.y * this._$matrix[3] + this._$matrix[5]
        );
    }

    /**
     * @description 行列を x 軸と y 軸に沿って、
     *              dx パラメーターと dy パラメーターで指定された量だけ平行移動します。
     *              Translates the matrix along the x and y axes,
     *              as specified by the dx and dy parameters.
     *
     * @param  {number} dx
     * @param  {number} dy
     * @return {void}
     * @method
     * @public
     */
    translate (dx, dy)
    {
        this.tx += dx;
        this.ty += dy;
    }
}

/**
 * Point オブジェクトは 2 次元の座標系の位置を表します。
 * x は水平方向の軸を表し、y は垂直方向の軸を表します。
 *
 * The Point object represents a location in a two-dimensional coordinate system,
 * where x represents the horizontal axis and y represents the vertical axis.
 *
 * @example <caption>Example usage of Point.</caption>
 * // new Point
 * const {Point} = next2d.geom;
 * const point   = new Point();
 *
 * @class
 * @memberOf next2d.geom
 */
class Point
{
    /**
     * @param {number} [x=0]
     * @param {number} [y=0]
     *
     * @constructor
     * @public
     */
    constructor(x = 0, y = 0)
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$x = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$y = 0;

        // setup
        this.x = x;
        this.y = y;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Point]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Point]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.geom.Point
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.geom.Point";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return `(x=${this.x}, y=${this.y})`;
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.geom.Point
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.geom.Point";
    }

    /**
     * @description (0,0) からこのポイントまでの線のセグメントの長さです。
     *              The length of the line segment from (0,0) to this point.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get length ()
    {
        return $Math.sqrt($Math.pow(this.x, 2) + $Math.pow(this.y, 2));
    }

    /**
     * @description ポイントの水平座標です。
     *              The horizontal coordinate of the point.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get x ()
    {
        return this._$x;
    }
    set x (x)
    {
        this._$x = Util.$clamp(+x, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description ポイントの垂直座標です。
     *              The vertical coordinate of the point.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get y ()
    {
        return this._$y;
    }
    set y (y)
    {
        this._$y = Util.$clamp(+y, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description このポイントの座標に他のポイントの座標を加算して、新しいポイントを作成します。
     *              Adds the coordinates of another point
     *              to the coordinates of this point to create a new point.
     *
     * @param   {Point} v
     * @returns {Point}
     * @method
     * @public
     */
    add (v)
    {
        return new Point(this.x + v.x, this.y + v.y);
    }

    /**
     * @description この Point オブジェクトのコピーを作成します。
     *              Creates a copy of this Point object.
     *
     * @returns {Point}
     * @method
     * @public
     */
    clone ()
    {
        return new Point(this.x, this.y);
    }

    /**
     * @description すべてのポイントデータを、ソース Point オブジェクトから、
     *              呼び出し元の Point オブジェクトにコピーします。
     *              Copies all of the point data from
     *              the source Point object into the calling Point object.
     *
     * @param   {Point} source_point
     * @returns void
     * @public
     */
    copyFrom (source_point)
    {
        this._$x = source_point._$x;
        this._$y = source_point._$y;
    }

    /**
     * @description point1 と point2 との距離を返します。
     *              Returns the distance between point1 and point2.
     *
     * @param  {Point} point1
     * @param  {Point} point2
     * @return {number}
     * @method
     * @static
     */
    static distance (point1, point2)
    {
        return $Math.sqrt(
            $Math.pow(point1._$x - point2._$x, 2)
            + $Math.pow(point1._$y - point2._$y, 2)
        );
    }

    /**
     * @description 2 つのポイントが等しいかどうかを判別します。
     *              Determines whether two points are equal.
     *
     * @param  {Point} to_compare
     * @return {boolean}
     * @method
     * @public
     */
    equals (to_compare)
    {
        return this._$x === to_compare._$x && this._$y === to_compare._$y;
    }

    /**
     * @description 2 つの指定されたポイント間にあるポイントを判別します。
     *              Determines a point between two specified points.
     *
     * @param  {Point}  point1
     * @param  {Point}  point2
     * @param  {number} f
     * @return {Point}
     * @static
     */
    static interpolate (point1, point2, f)
    {
        return new Point(
            point1.x + (point2.x - point1.x) * (1 - f),
            point1.y + (point2.y - point1.y) * (1 - f)
        );
    }

    /**
     * @description (0,0) と現在のポイント間の線のセグメントを設定された長さに拡大 / 縮小します。
     *              Scales the line segment between (0,0) and the current point to a set length.
     *
     * @param  {number} thickness
     * @return {void}
     * @method
     * @public
     */
    normalize (thickness)
    {
        const length = this.length;
        this.x = this.x * thickness / length;
        this.y = this.y * thickness / length;
    }

    /**
     * @description Point オブジェクトを指定された量だけオフセットします。
     *              Offsets the Point object by the specified amount.
     *
     * @param  {number} dx
     * @param  {number} dy
     * @return {Point}
     * @method
     * @public
     */
    offset (dx, dy)
    {
        this.x += dx;
        this.y += dy;
    }

    /**
     * @description 極座標ペアを直交点座標に変換します。
     *              Converts a pair of polar coordinates to a Cartesian point coordinate.
     *
     * @param  {number} len
     * @param  {number} angle
     * @return {Point}
     * @method
     * @static
     */
    static polar (len, angle)
    {
        return new Point(len * $Math.cos(angle), len * $Math.sin(angle));
    }

    /**
     * @description Point のメンバーを指定の値に設定します。
     *              Sets the members of Point to the specified values
     *
     * @param  {number} xa
     * @param  {number} ya
     * @return {void}
     * @method
     * @public
     */
    setTo (xa, ya)
    {
        this.x = xa;
        this.y = ya;
    }

    /**
     * @description このポイントの座標から他のポイントの座標を減算して、新しいポイントを作成します。
     *              Subtracts the coordinates of another point
     *              from the coordinates of this point to create a new point.
     *
     * @param  {Point} v
     * @return {Point}
     * @method
     * @public
     */
    subtract (v)
    {
        return new Point(this.x - v.x, this.y - v.y);
    }
}

/**
 * Rectangle オブジェクトは、その位置（左上隅のポイント (x, y) で示される)、および幅と高さで定義される領域です。
 * Rectangle クラスの x、y、width、および height の各プロパティは、互いに独立しているため、
 * あるプロパティの値を変更しても、他のプロパティに影響はありません。
 * ただし、right プロパティと bottom プロパティはこれら 4 つのプロパティと不可分に関連しています。
 * 例えば、right プロパティの値を変更すると width プロパティの値も変更されます。
 * bottom プロパティの値を変更すると、height プロパティの値も変更されます。
 *
 * A Rectangle object is an area defined by its position,
 * as indicated by its top-left corner point (x, y) and by its width and its height.
 * The x, y, width, and height properties of the Rectangle class are independent of each other;
 * changing the value of one property has no effect on the others. However,
 * the right and bottom properties are integrally related to those four properties.
 * For example, if you change the value of the right property, the value of the width property changes;
 * if you change the bottom property, the value of the height property changes.
 *
 * @example <caption>Example usage of Rectangle.</caption>
 * // new Rectangle
 * const {Rectangle} = next2d.geom;
 * const rectangle   = new Rectangle(0, 0, 100, 100);
 *
 * @class
 * @memberOf next2d.geom
 */
class Rectangle
{
    /**
     * @param   {number} [x=0]
     * @param   {number} [y=0]
     * @param   {number} [width=0]
     * @param   {number} [height=0]
     *
     * @constructor
     * @public
     */
    constructor (x = 0, y = 0, width = 0, height = 0)
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$x = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$y = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$width = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$height = 0;

        // init
        this.setTo(x, y, width, height);
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Rectangle]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Rectangle]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.geom.Rectangle
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.geom.Rectangle";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return `(x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height})`;
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.geom.Rectangle
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.geom.Rectangle";
    }

    /**
     * @description y プロパティと height プロパティの合計です。
     *              The sum of the y and height properties.
     *
     * @member {number}
     * @public
     */
    get bottom ()
    {
        return this.y + this.height;
    }
    set bottom (bottom)
    {
        this.height = +bottom - this.y;
    }

    /**
     * @description Rectangle オブジェクトの右下隅の位置で、
     *              right プロパティと bottom プロパティの値で決まります。
     *              The location of the Rectangle object's bottom-right corner,
     *              determined by the values of the right and bottom properties.
     *
     * @member {Point}
     * @public
     */
    get bottomRight ()
    {
        return new Point(this.right, this.bottom);
    }
    set bottomRight (point)
    {
        this.right  = point.x;
        this.bottom = point.y;
    }

    /**
     * @description 矩形の高さ（ピクセル単位）です。
     *              The height of the rectangle, in pixels.
     *
     * @member {number}
     * @public
     */
    get height ()
    {
        return this._$height;
    }
    set height (height)
    {
        this._$height = Util.$clamp(+height, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description 矩形の左上隅の x 座標です。
     *              The x coordinate of the top-left corner of the rectangle.
     *
     * @member {number}
     * @public
     */
    get left ()
    {
        return this.x;
    }
    set left (left)
    {
        this.width = this.right - +left;
        this.x     = left;
    }

    /**
     * @description x プロパティと width プロパティの合計です。
     *              The sum of the x and width properties.
     *
     * @member {number}
     * @public
     */
    get right ()
    {
        return this.x + this.width;
    }
    set right (right)
    {
        this.width = +right - this.x;
    }

    /**
     * @description Rectangle オブジェクトのサイズで、
     *              width プロパティと height プロパティの値を持つ Point オブジェクトとして表現されます。
     *              The size of the Rectangle object,
     *              expressed as a Point object with the values of the width and height properties.
     *
     * @member {Point}
     * @public
     */
    get size ()
    {
        return new Point(this.width, this.height);
    }
    set size (point)
    {
        this.width  = point.x;
        this.height = point.y;
    }

    /**
     * @description 矩形の左上隅の y 座標です。
     *              The y coordinate of the top-left corner of the rectangle.
     *
     * @member {number}
     * @public
     */
    get top ()
    {
        return this.y;
    }
    set top (top)
    {
        this.height = +(this.bottom - +top);
        this.y      = top;
    }

    /**
     * @description Rectangle オブジェクトの左上隅の位置で、
     *              そのポイントの x 座標と y 座標で決まります。
     *              The location of the Rectangle object's top-left corner,
     *              determined by the x and y coordinates of the point.
     *
     * @member {Point}
     * @public
     */
    get topLeft ()
    {
        return new Point(this.x, this.y);
    }
    set topLeft (point)
    {
        this.left = point.x;
        this.top  = point.y;
    }

    /**
     * @description 矩形の幅（ピクセル単位）です。
     *              The width of the rectangle, in pixels.
     *
     * @member {number}
     * @public
     */
    get width ()
    {
        return this._$width;
    }
    set width (width)
    {
        this._$width = Util.$clamp(+width, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description 矩形の左上隅の x 座標です。
     *              The x coordinate of the top-left corner of the rectangle.
     *
     * @member {number}
     * @public
     */
    get x ()
    {
        return this._$x;
    }
    set x (x)
    {
        this._$x = Util.$clamp(+x, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description 矩形の左上隅の y 座標です。
     *              The y coordinate of the top-left corner of the rectangle.
     *
     * @member {number}
     * @public
     */
    get y ()
    {
        return this._$y;
    }
    set y (y)
    {
        this._$y = Util.$clamp(+y, Util.$SHORT_INT_MIN, Util.$SHORT_INT_MAX, 0);
    }

    /**
     * @description 元の Rectangle オブジェクトと x、y、width、および height の各プロパティの値が同じである、
     *              新しい Rectangle オブジェクトを返します。
     *              Returns a new Rectangle object with the same values for the x, y, width,
     *              and height properties as the original Rectangle object.
     *
     * @return {Rectangle}
     *
     * @public
     */
    clone ()
    {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }

    /**
     * @description 指定されたポイントがこの Rectangle オブジェクトで定義される矩形領域内にあるかどうかを判別します。
     *              Determines whether the specified point is contained within
     *              the rectangular region defined by this Rectangle object.
     *
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     * @method
     * @public
     */
    contains (x, y)
    {
        return this.x <= x && this.y <= y && this.right > x && this.bottom > y;
    }

    /**
     * @description 指定されたポイントがこの Rectangle オブジェクトで定義される矩形領域内にあるかどうかを判別します。
     *              Determines whether the specified point is contained within
     *              the rectangular region defined by this Rectangle object.
     *
     * @param  {Point}   point
     * @return {boolean}
     * @method
     * @public
     */
    containsPoint (point)
    {
        return this.x <= point.x && this.y <= point.y &&
            this.right > point.x && this.bottom > point.y;
    }

    /**
     * @description rect パラメーターで指定された Rectangle オブジェクトがこの Rectangle オブジェクト内にあるかどうかを判別します。
     *              Determines whether the Rectangle object specified by
     *              the rect parameter is contained within this Rectangle object.
     *
     * @param  {Rectangle} rect
     * @return {boolean}
     * @method
     * @public
     */
    containsRect (rect)
    {
        return this.x <= rect.x && this.y <= rect.y &&
            this.right >= rect.right && this.bottom >= rect.bottom;
    }

    /**
     * @description すべての矩形データを、ソース Rectangle オブジェクトから、
     *              呼び出し元の Rectangle オブジェクトにコピーします。
     *              Copies all of rectangle data from
     *              the source Rectangle object into the calling Rectangle object.
     *
     * @param  {Rectangle} source_rect
     * @return {void}
     * @method
     * @public
     */
    copyFrom (source_rect)
    {
        this.x      = source_rect.x;
        this.y      = source_rect.y;
        this.width  = source_rect.width;
        this.height = source_rect.height;
    }

    /**
     * @description toCompare パラメーターで指定されたオブジェクトが
     *              この Rectangle オブジェクトと等しいかどうかを判別します。
     *              Determines whether the object specified
     *              in the toCompare parameter is equal to this Rectangle object.
     *
     * @param  {Rectangle} to_compare
     * @return {boolean}
     * @method
     * @public
     */
    equals (to_compare)
    {
        return this.x === to_compare.x && this.y === to_compare.y &&
            this.width === to_compare.width && this.height === to_compare.height;
    }

    /**
     * @description Rectangle オブジェクトのサイズを、指定された量（ピクセル単位）だけ大きくします。
     *              Increases the size of the Rectangle object by the specified amounts, in pixels.
     *
     * @param  {number} dx
     * @param  {number} dy
     * @return void
     * @method
     * @public
     */
    inflate (dx, dy)
    {
        this.x      = this.x - +dx;
        this.width  = this.width + 2 * +dx;

        this.y      = this.y - +dy;
        this.height = this.height + 2 * +dy;
    }

    /**
     * @description Rectangle オブジェクトのサイズを大きくします。
     *              Increases the size of the Rectangle object.
     *
     * @param  {Point} point
     * @return {void}
     * @method
     * @public
     */
    inflatePoint (point)
    {
        this.x      = this.x - point.x;
        this.width  = this.width + 2 * point.x;

        this.y      = this.y - point.y;
        this.height = this.height + 2 * point.y;
    }

    /**
     * @description toIntersect パラメーターで指定された Rectangle オブジェクトが
     *              この Rectangle オブジェクトと交差する場合に、交差領域を Rectangle オブジェクトとして返します。
     *              If the Rectangle object specified in the toIntersect parameter intersects
     *              with this Rectangle object, returns the area of intersection as a Rectangle object.
     *
     * @param  {Rectangle} to_intersect
     * @return {Rectangle}
     * @method
     * @public
     */
    intersection (to_intersect)
    {
        const sx = $Math.max(this.x, to_intersect.x);
        const sy = $Math.max(this.y, to_intersect.y);
        const ex = $Math.min(this.right,  to_intersect.right);
        const ey = $Math.min(this.bottom, to_intersect.bottom);

        const w = ex - sx;
        const h = ey - sy;
        return w > 0 && h > 0 ? new Rectangle(sx, sy, w, h) : new Rectangle(0, 0, 0, 0);
    }

    /**
     * @description toIntersect パラメーターで指定されたオブジェクトが
     *              この Rectangle オブジェクトと交差するかどうかを判別します。
     *              Determines whether the object specified
     *              in the toIntersect parameter intersects with this Rectangle object.
     *
     * @param  {Rectangle} to_intersect
     * @return {boolean}
     * @method
     * @public
     */
    intersects (to_intersect)
    {
        const sx = $Math.max(this.x, to_intersect.x);
        const sy = $Math.max(this.y, to_intersect.y);
        const ex = $Math.min(this.right,  to_intersect.right);
        const ey = $Math.min(this.bottom, to_intersect.bottom);
        return ex - sx > 0 && ey - sy > 0;
    }

    /**
     * @description この Rectangle オブジェクトが空かどうかを判別します。
     *              Determines whether or not this Rectangle object is empty.
     *
     * @return {boolean}
     * @method
     * @public
     */
    isEmpty ()
    {
        return this.width <= 0 || this.height <= 0;
    }

    /**
     * @description Rectangle オブジェクトの位置（左上隅で決定される）を、指定された量だけ調整します。
     *              Adjusts the location of the Rectangle object,
     *              as determined by its top-left corner, by the specified amounts.
     *
     * @param  {number} dx
     * @param  {number} dy
     * @return {void}
     * @method
     * @public
     */
    offset (dx ,dy)
    {
        this.x += dx;
        this.y += dy;
    }

    /**
     * @description Point オブジェクトをパラメーターとして使用して、Rectangle オブジェクトの位置を調整します。
     *              Adjusts the location of the Rectangle object using a Point object as a parameter.
     *
     * @param  {Point} point
     * @return {void}
     * @method
     * @public
     */
    offsetPoint (point)
    {
        this.x += point.x;
        this.y += point.y;
    }

    /**
     * @description Rectangle オブジェクトのすべてのプロパティを 0 に設定します。
     *              Sets all of the Rectangle object's properties to 0.
     *
     * @return {void}
     * @method
     * @public
     */
    setEmpty ()
    {
        this._$x      = 0;
        this._$y      = 0;
        this._$width  = 0;
        this._$height = 0;
    }

    /**
     * @description Rectangle のメンバーを指定の値に設定します。
     *              Sets the members of Rectangle to the specified values
     *
     * @param  {number} x
     * @param  {number} y
     * @param  {number} width
     * @param  {number} height
     * @return {void}
     * @method
     * @public
     */
    setTo (x, y, width, height)
    {
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
    }

    /**
     * @description 2 つの矩形間の水平と垂直の空間を塗りつぶすことにより、
     *              2 つの矩形を加算して新しい Rectangle オブジェクトを作成します。
     *              Adds two rectangles together to create a new Rectangle object,
     *              by filling in the horizontal and vertical space between the two rectangles.
     *
     * @param  {Rectangle} to_union
     * @return {Rectangle}
     * @method
     * @public
     */
    union (to_union)
    {
        if (this.isEmpty()) {
            return to_union.clone();
        }

        if (to_union.isEmpty()) {
            return this.clone();
        }

        return new Rectangle(
            $Math.min(this.x, to_union.x),
            $Math.min(this.y, to_union.y),
            $Math.max(this.right - to_union.left, to_union.right - this.left),
            $Math.max(this.bottom - to_union.top, to_union.bottom - this.top)
        );
    }
}

/**
 * Transform クラスは、表示オブジェクトに適用されるカラー調整プロパティと 2 次元の変換オブジェクトへのアクセスを提供します。
 * 変換時に、表示オブジェクトのカラーまたは方向と位置が、現在の値または座標から新しい値または座標に調整（オフセット）されます。
 * Transform クラスは、表示オブジェクトおよびすべての親オブジェクトに適用されるカラー変換と 2 次元マトリックス変換に関するデータも収集します。
 * concatenatedColorTransform プロパティと concatenatedMatrix プロパティを使用して、これらの結合された変換にアクセスできます。
 * カラー変換を適用するには、ColorTransform オブジェクトを作成し、オブジェクトのメソッドとプロパティを使用してカラー調整を設定した後、
 * colorTransformation プロパティ（表示オブジェクトの transform プロパティの）を新しい ColorTransformation オブジェクトに割り当てます。
 * 2 次元変換を適用するには、Matrix オブジェクトを作成し、マトリックスの 2 次元変換を設定した後、表示オブジェクトの transform.matrix プロパティを新しい Matrix オブジェクトに割り当てます。
 *
 * The Transform class provides access to color adjustment properties and two--dimensional transformation objects that can be applied to a display object.
 * During the transformation, the color or the orientation and position of a display object is adjusted (offset) from the current values or coordinates to new values or coordinates.
 * The Transform class also collects data about color and two-dimensional matrix transformations that are applied to a display object and all of its parent objects.
 * You can access these combined transformations through the concatenatedColorTransform and concatenatedMatrix properties.
 * To apply color transformations: create a ColorTransform object,
 * set the color adjustments using the object's methods and properties,
 * and then assign the colorTransformation property of the transform property of the display object to the new ColorTransformation object.
 * To apply two-dimensional transformations: create a Matrix object,
 * set the matrix's two-dimensional transformation,
 * and then assign the transform.matrix property of the display object to the new Matrix object.
 *
 * @example <caption>Example usage of Transform.</caption>
 * // new Transform
 * const {Transform} = next2d.geom;
 * const transform   = new Transform(displayObject);
 *
 * @class
 * @memberOf next2d.geom
 */
class Transform
{
    /**
     * @param {DisplayObject} src
     *
     * @constructor
     * @public
     */
    constructor(src)
    {
        if (!(src instanceof DisplayObject)) {
            throw new Error("Transform params is DisplayObject only.");
        }

        /**
         * @type {DisplayObject}
         * @private
         */
        this._$displayObject = src;

        /**
         * @type {Matrix|null}
         * @default null
         * @private
         */
        this._$matrix = null;

        /**
         * @type {ColorTransform|null}
         * @default null
         * @private
         */
        this._$colorTransform = null;

        /**
         * @type {string|null}
         * @default null
         * @private
         */
        this._$blendMode = null;

        /**
         * @type {array|null}
         * @default null
         * @private
         */
        this._$filters = null;
    }

    /**
     * 指定されたクラスのストリングを返します。
     * Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Transform]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Transform]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @member  {string}
     * @default next2d.geom.Transform
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.geom.Transform";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return {string}
     * @method
     * @public
     */
    toString ()
    {
        return "[object Transform]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @member  {string}
     * @default next2d.geom.Transform
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.geom.Transform";
    }

    /**
     * @description 表示オブジェクトのカラーを全体的に調整する値を格納している
     *              ColorTransform オブジェクトです。
     *              A ColorTransform object containing values that universally adjust
     *              the colors in the display object.
     *
     * @member {ColorTransform}
     * @public
     */
    get colorTransform ()
    {
        if (this._$colorTransform) {
            return this._$colorTransform._$clone();
        }

        const object = this
            ._$displayObject
            ._$getPlaceObject();

        if (object) {

            const buffer = object.colorTransform;
            const colorTransform = new ColorTransform();
            colorTransform._$colorTransform = Util.$getFloat32Array8(
                buffer[0], buffer[1], buffer[2], buffer[3],
                buffer[4], buffer[5], buffer[6], buffer[7]
            );

            return colorTransform;
        }

        this._$transform();
        return this._$colorTransform._$clone();
    }
    set colorTransform (color_transform)
    {
        if (color_transform instanceof ColorTransform) {
            this._$transform(null, color_transform._$colorTransform);
        }
    }

    /**
     * @description この表示オブジェクトおよびルートレベルまでのすべての親オブジェクトに適用される、
     *              結合されたカラー変換を表す ColorTransform オブジェクトです。
     *              A ColorTransform object representing
     *              the combined color transformations applied to the display object
     *              and all of its parent objects, back to the root level.
     *
     * @member {ColorTransform}
     * @readonly
     * @public
     */
    get concatenatedColorTransform ()
    {
        let colorTransform = this._$rawColorTransform();

        let parent = this._$displayObject._$parent;
        while (parent) {

            colorTransform = Util.$multiplicationColor(
                parent._$transform._$rawColorTransform(),
                colorTransform
            );

            parent = parent._$parent;
        }

        return Util.$getColorTransform(
            colorTransform[0], colorTransform[1],
            colorTransform[2], colorTransform[3],
            colorTransform[4], colorTransform[5],
            colorTransform[6], colorTransform[7]
        );
    }

    /**
     * @description 表示オブジェクトの拡大 / 縮小、回転、および移動を変更する値を格納している
     *              Matrix オブジェクトです。
     *              A Matrix object containing values that alter the scaling,
     *              rotation, and translation of the display object.
     *
     * @member {Matrix}
     * @public
     */
    get matrix ()
    {
        if (this._$matrix) {
            return this._$matrix._$clone();
        }

        const object = this
            ._$displayObject
            ._$getPlaceObject();

        if (object) {
            const buffer = object.matrix;
            return Util.$getMatrix(
                buffer[0], buffer[1], buffer[2],
                buffer[3], buffer[4], buffer[5]
            );
        }

        this._$transform();
        return this._$matrix._$clone();
    }
    set matrix (matrix)
    {
        if (matrix instanceof Matrix) {
            this._$transform(matrix._$matrix, null);
        }
    }

    /**
     * @description この表示オブジェクトおよびルートレベルまでのそのすべての親オブジェクトの結合された
     *              変換マトリックスを表す Matrix オブジェクトです。
     *              A Matrix object representing the combined transformation matrixes
     *              of the display object and all of its parent objects, back to the root level.
     *
     * @member {Matrix}
     * @readonly
     * @method
     * @public
     */
    get concatenatedMatrix ()
    {
        let matrix = this._$rawMatrix();

        let parent = this._$displayObject._$parent;
        while (parent) {

            matrix = Util.$multiplicationMatrix(
                parent._$transform._$rawMatrix(),
                matrix
            );

            parent = parent._$parent;
        }

        return Util.$getMatrix(
            matrix[0], matrix[1], matrix[2],
            matrix[3], matrix[4], matrix[5]
        );
    }

    /**
     * @description ステージ上の表示オブジェクトの境界を示す矩形を定義する Transform オブジェクトです。
     *              A Transform object that defines the bounding rectangle of
     *              the display object on the stage.
     *
     * @member {Transform}
     * @readonly
     * @method
     * @public
     */
    pixelBounds ()
    {
        const rectangle = new Rectangle(0, 0, 0, 0);

        if (!this._$displayObject) {
            return rectangle;
        }

        const bounds = this._$displayObject._$getBounds(null);

        rectangle._$x      = bounds.xMin;
        rectangle._$y      = bounds.yMin;
        rectangle._$width  = +$Math.abs(bounds.xMax - bounds.xMin);
        rectangle._$height = +$Math.abs(bounds.yMax - bounds.yMin);

        Util.$poolBoundsObject(bounds);

        return rectangle;
    }

    /**
     * matrix プロパティから取得される Matrix の Matrix._$matrix と同じ値を返しますが、matrix プロパティと異なり Matrix を複製しません。
     * 返される値は一時的に使用することのみできます。返される値の要素を直接更新してはいけません。返される値をプール（Util.$poolFloat32Array）してはいけません。
     *
     * @return {Float32Array}
     * @method
     * @private
     */
    _$rawMatrix ()
    {
        if (this._$matrix !== null) {
            return this._$matrix._$matrix;
        }

        const placeObject = this._$displayObject._$getPlaceObject();
        if (placeObject) {
            return placeObject.matrix;
        }

        return Util.$MATRIX_ARRAY_IDENTITY;
    }

    /**
     * colorTransform プロパティから取得される ColorTransform の colorTransform._$colorTransform と同じ値を返しますが、colorTransform プロパティと異なり ColorTransform を複製しません。
     * 返される値は一時的に使用することのみできます。返される値の要素を直接更新してはいけません。返される値をプール（Util.$poolFloat32Array）してはいけません。
     *
     * @return {Float32Array}
     * @method
     * @private
     */
    _$rawColorTransform ()
    {
        if (this._$colorTransform !== null) {
            return this._$colorTransform._$colorTransform;
        }

        const placeObject = this._$displayObject._$getPlaceObject();
        if (placeObject) {
            return placeObject.colorTransform;
        }

        return Util.$COLOR_ARRAY_IDENTITY;
    }

    /**
     * @param  {Float32Array} [matrix=null]
     * @param  {Float32Array} [color_transform=null]
     * @param  {array}        [filters=null]
     * @param  {string}       [blend_mode=""]
     * @return {void}
     * @method
     * @private
     */
    _$transform (matrix = null, color_transform = null, filters = null, blend_mode = "")
    {

        const object = this
            ._$displayObject
            ._$getPlaceObject();

        // Matrix
        this._$setMatrix(matrix, object);

        // ColorTransform
        this._$setColorTransform(color_transform, object);

        // Filter
        this._$setFilters(filters, object);

        // BlendMode
        this._$setBlendMode(blend_mode, object);

    }

    /**
     * @param {Float32Array} [matrix=null]
     * @param {object} [object=null]
     * @method
     * @private
     */
    _$setMatrix (matrix = null, object = null)
    {
        if (matrix || object) {
            this._$displayObject._$doChanged();
            Util.$isUpdated = true;
        }

        // Matrix
        if (!this._$matrix) {
            this._$matrix = Util.$getMatrix(1, 0, 0, 1, 0, 0);
            if (!matrix && object) {
                matrix = object.matrix;
            }
        }

        // update
        if (matrix) {
            const currentMatrix = this._$matrix._$matrix;
            currentMatrix[0] = matrix[0];
            currentMatrix[1] = matrix[1];
            currentMatrix[2] = matrix[2];
            currentMatrix[3] = matrix[3];
            currentMatrix[4] = matrix[4];
            currentMatrix[5] = matrix[5];
        }
    }

    /**
     * @param {Float32Array} [color_transform=null]
     * @param {object} [object=null]
     * @method
     * @private
     */
    _$setColorTransform (color_transform = null, object = null)
    {
        if (color_transform || object) {
            this._$displayObject._$doChanged();
            Util.$isUpdated = true;
        }

        if (!this._$colorTransform) {
            this._$colorTransform = Util.$getColorTransform(1, 1, 1, 1, 0, 0, 0, 0);
            if (!color_transform && object) {
                color_transform = object.colorTransform;
            }
        }

        if (color_transform) {
            const colorTransform = this._$colorTransform._$colorTransform;
            colorTransform[0] = color_transform[0];
            colorTransform[1] = color_transform[1];
            colorTransform[2] = color_transform[2];
            colorTransform[3] = color_transform[3];
            colorTransform[4] = color_transform[4];
            colorTransform[5] = color_transform[5];
            colorTransform[6] = color_transform[6];
            colorTransform[7] = color_transform[7];
        }
    }

    /**
     * @param {array}  [filters=null]
     * @param {object} [object=null]
     * @method
     * @private
     */
    _$setFilters (filters = null, object = null)
    {

        if (Util.$isArray(filters)) {

            if (this._$filters) {
                Util.$poolArray(this._$filters);
            }

            this._$filters = filters.slice(0);

            this._$displayObject._$doChanged();
            Util.$isUpdated = true;

            return ;
        }

        if (this._$filters) {
            return ;
        }

        if (!object) {
            this._$filters = Util.$getArray();
            return ;
        }

        if (object.filters) {
            this._$filters = object.filters.slice(0);
            return ;
        }

        if (object.surfaceFilterList) {

            const filterList = Util.$getArray();

            const length = object.surfaceFilterList.length;
            for (let idx = 0; idx < length; ++idx) {

                const filter = object.surfaceFilterList[idx];

                const filterClass = next2d.filters[filter.class];

                filterList.push(
                    new (filterClass.bind.apply(filterClass, filter.params))()
                );

            }

            object.filters = filterList;
            this._$filters = filterList.slice(0);
        }

    }

    /**
     * @param {string} [blend_mode=""]
     * @param {object} [object=null]
     * @method
     * @private
     */
    _$setBlendMode (blend_mode = "", object = null)
    {
        if (blend_mode) {

            this._$blendMode = blend_mode;

            this._$displayObject._$doChanged();
            Util.$isUpdated = true;

            return ;
        }

        if (this._$blendMode) {
            return ;
        }

        this._$blendMode = object
            ? object.blendMode
            : BlendMode.NORMAL;

    }
}

/**
 * DisplayObject クラスは、表示リストに含めることのできるすべてのオブジェクトに関する基本クラスです。
 * DisplayObject クラス自体は、画面上でのコンテンツの描画のための API を含みません。
 * そのため、DisplayObject クラスのカスタムサブクラスを作成する場合は、
 * Shape、Sprite、Bitmap、TextField または MovieClip など、
 * 画面上にコンテンツを描画する API を持つサブクラスの 1 つを拡張する必要があります。
 *
 * The DisplayObject class is the base class for all objects that can be placed on the display list.
 * The DisplayObject class itself does not include any APIs for rendering content onscreen.
 * For that reason, if you want create a custom subclass of the DisplayObject class,
 * you will want to extend one of its subclasses that do have APIs for rendering content onscreen,
 * such as the Shape, Sprite, Bitmap, TextField, or MovieClip class.
 *
 * @class
 * @memberOf next2d.display
 * @extends  EventDispatcher
 */
class DisplayObject extends EventDispatcher
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {number}
         * @private
         */
        this._$id = -1;

        /**
         * @type {number}
         * @private
         */
        this._$instanceId = instanceId++;

        /**
         * @type {number}
         * @private
         */
        this._$dictionaryId = 0;

        /**
         * @type {number}
         * @private
         */
        this._$characterId = 0;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$active = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$isMask = false;

        /**
         * @type {null}
         * @default null
         * @private
         */
        this._$buffer = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$updated = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$added = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$addedStage = false;

        /**
         * @type {array|null}
         * @default null
         * @private
         */
        this._$filters = null;

        /**
         * @type {string|null}
         * @default null
         * @private
         */
        this._$blendMode = null;

        /**
         * @type {Sprite|null}
         * @default null
         * @private
         */
        this._$hitObject = null;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$isNext = true;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$clipDepth = 0;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$name = "";

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$visible = true;

        /**
         * @type {DisplayObject|null}
         * @default null
         * @private
         */
        this._$mask = null;

        /**
         * @type {Rectangle|null}
         * @default null
         * @private
         */
        this._$scale9Grid = null;

        /**
         * @type {DisplayObjectContainer|null}
         * @default null
         * @private
         */
        this._$parent = null;

        /**
         * @type {Stage|null}
         * @default null
         * @private
         */
        this._$stage = null;

        /**
         * @type {Sprite|null}
         * @default null
         * @private
         */
        this._$root = null;

        /**
         * @type {number|null}
         * @default null
         * @private
         */
        this._$loaderInfo = null;

        /**
         * @type {number|null}
         * @default null
         * @private
         */
        this._$placeId = null;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$startFrame = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$endFrame = 0;

        /**
         * @type {Transform}
         * @private
         */
        this._$transform = new Transform(this);

        /**
         * @type {Map}
         * @default null
         * @private
         */
        this._$variables = null;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$placeObject = null;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$currentPlaceId = -1;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$changePlace = false;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class DisplayObject]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class DisplayObject]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.DisplayObject
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.DisplayObject";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object DisplayObject]
     * @method
     * @public
     */
    toString ()
    {
        return "[object DisplayObject]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.DisplayObject
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.DisplayObject";
    }

    /**
     * @description 指定されたオブジェクトのアルファ透明度値を示します。
     *              有効な値は 0.0（完全な透明）～ 1.0（完全な不透明）です。
     *              デフォルト値は 1.0 です。alpha が 0.0 に設定されている表示オブジェクトは、
     *              表示されない場合でも、アクティブです。
     *              Indicates the alpha transparency value of the object specified.
     *              Valid values are 0.0 (fully transparent) to 1.0 (fully opaque).
     *              The default value is 1.0. Display objects with alpha set to 0.0 are active,
     *              even though they are invisible.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get alpha ()
    {
        const colorTransform = this._$transform._$rawColorTransform();
        return colorTransform[3] + colorTransform[7] / 255;
    }
    set alpha (alpha)
    {
        alpha = Util.$clamp(alpha, 0, 1, 0);

        // clone
        const colorTransform = this._$transform.colorTransform;

        colorTransform._$colorTransform[3] = alpha;
        colorTransform._$colorTransform[7] = 0;

        this._$transform.colorTransform = colorTransform;
        Util.$poolColorTransform(colorTransform);
    }

    /**
     * @description 使用するブレンドモードを指定する BlendMode クラスの値です。
     *              A value from the BlendMode class that specifies which blend mode to use.
     *
     * @member  {string}
     * @default BlendMode.NORMAL
     * @public
     */
    get blendMode ()
    {
        if (this._$blendMode) {
            return this._$blendMode;
        }

        const transform = this._$transform;
        if (transform._$blendMode) {
            this._$blendMode = transform._$blendMode;
            return this._$blendMode;
        }

        const placeObject = this._$getPlaceObject();
        if (placeObject) {
            this._$blendMode = placeObject.blendMode;
            return this._$blendMode;
        }

        // create Transform
        transform._$transform();
        this._$blendMode = transform._$blendMode;
        return this._$blendMode;
    }
    set blendMode (blend_mode)
    {
        this._$transform._$transform(null, null, null, blend_mode);
        this._$blendMode = blend_mode;
    }

    /**
     * @description 表示オブジェクトに現在関連付けられている各フィルターオブジェクトが
     *              格納されているインデックス付きの配列です。
     *              An indexed array that contains each filter object
     *              currently associated with the display object.
     *
     * @member  {array}
     * @default {array}
     * @public
     */
    get filters ()
    {
        if (this._$filters) {
            return this._$filters;
        }

        const transform = this._$transform;
        if (transform._$filters) {
            this._$filters = transform._$filters.slice(0);
            return this._$filters;
        }

        const placeObject = this._$getPlaceObject();
        if (placeObject) {

            // create filter
            if (!placeObject.filters) {

                const filters = [];

                if (placeObject.surfaceFilterList) {

                    const length = placeObject.surfaceFilterList.length;
                    for (let idx = 0; idx < length; ++idx) {

                        const filter = placeObject.surfaceFilterList[idx];

                        const filterClass = next2d.filters[filter.class];

                        filters.push(
                            new (filterClass.bind.apply(filterClass, filter.params))()
                        );

                    }

                }

                placeObject.filters = filters;
            }

            if (!this._$filters) {
                this._$filters = placeObject.filters ;
            }

            return placeObject.filters.slice(0);
        }

        transform._$transform();
        this._$filters = transform._$filters;
        return this._$filters.slice(0);
    }
    set filters (filters)
    {
        if (!filters) {
            filters = Util.$getArray();
        }

        this._$transform._$transform(null, null, filters, null);
        this._$filters = filters;
    }

    /**
     * @description 表示オブジェクトの高さを示します（ピクセル単位）。
     *              Indicates the height of the display object, in pixels.
     *
     * @member {number}
     * @public
     */
    get height ()
    {
        const bounds = Util.$boundsMatrix(
            this._$getBounds(null),
            this._$transform._$rawMatrix()
        );

        const height = $Math.abs(bounds.yMax - bounds.yMin);

        // object pool
        Util.$poolBoundsObject(bounds);

        switch (height) {

            case 0:
            case Util.$Infinity:
            case -Util.$Infinity:
                return 0;

            default:
                return height;

        }
    }
    set height (height)
    {
        height = +height;
        if (!Util.$isNaN(height) && height > -1) {

            const bounds = this.rotation
                ? Util.$boundsMatrix(this._$getBounds(null), this._$transform._$rawMatrix())
                : this._$getBounds(null);

            const exHeight = $Math.abs(bounds.yMax - bounds.yMin);
            Util.$poolBoundsObject(bounds);

            switch (exHeight) {

                case 0:
                case Util.$Infinity:
                case -Util.$Infinity:
                    this.scaleY = 0;
                    break;

                default:
                    this.scaleY = height / exHeight;
                    break;

            }
        }
    }

    /**
     * @description この表示オブジェクトが属するファイルの読み込み情報を含む LoaderInfo オブジェクトを返します。
     *              Returns a LoaderInfo object containing information
     *              about loading the file to which this display object belongs.
     *
     * @member   {LoaderInfo}
     * @readonly
     * @public
     */
    get loaderInfo ()
    {
        return this._$loaderInfo;
    }

    /**
     * @description 呼び出し元の表示オブジェクトは、指定された mask オブジェクトによってマスクされます。
     *              The calling display object is masked by the specified mask object.
     *
     * @member {DisplayObject|null}
     * @public
     */
    get mask ()
    {
        return this._$mask;
    }
    set mask (mask)
    {
        if (mask === this._$mask) {
            return ;
        }

        // reset
        if (this._$mask) {
            this._$mask._$isMask = false;
            this._$mask = null;
        }

        if (mask instanceof DisplayObject) {
            mask._$isMask = true;
            this._$mask   = mask;
        }

        this._$doChanged();
    }

    /**
     * @description マウスまたはユーザー入力デバイスの x 軸の位置をピクセルで示します。
     *              Indicates the x coordinate of the mouse or user input device position, in pixels.
     *
     * @member  {number}
     * @default 0
     * @readonly
     * @public
     */
    get mouseX ()
    {
        return Util.$event
            ? this.globalToLocal(Util.$currentMousePoint()).x
            : 0;
    }

    /**
     * @description マウスまたはユーザー入力デバイスの y 軸の位置をピクセルで示します。
     *              Indicates the y coordinate of the mouse or user input device position, in pixels.
     *
     * @member  {number}
     * @default 0
     * @readonly
     * @public
     */
    get mouseY ()
    {
        return Util.$event
            ? this.globalToLocal(Util.$currentMousePoint()).y
            : 0;
    }

    /**
     * @description DisplayObject のインスタンス名を示します。
     *              Indicates the instance name of the DisplayObject.
     *
     * @member {string}
     * @public
     */
    get name ()
    {
        if (this._$name) {
            return this._$name;
        }
        return `instance${this._$instanceId}`;
    }
    set name (name)
    {
        this._$name = `${name}`;

        const parent = this._$parent;
        if (parent && parent._$names) {

            parent._$names.clear();

            const children = parent._$getChildren();
            const length = children.length;
            for (let idx = 0; idx < length; ++idx) {
                const child = children[idx];
                if (child._$name) {
                    parent._$names.set(child.name, child);
                }
            }
        }
    }

    /**
     * @description この表示オブジェクトを含む DisplayObjectContainer オブジェクトを示します。
     *              Indicates the DisplayObjectContainer object that contains this display object.
     *
     * @member  {DisplayObjectContainer|null}
     * @readonly
     * @public
     */
    get parent ()
    {
        return this._$parent;
    }

    /**
     * @description 読み込まれた SWF ファイル内の表示オブジェクトの場合、
     *              root プロパティはその SWF ファイルが表す表示リストのツリー構造部分の一番上にある表示オブジェクトとなります。
     *              For a display object in a loaded SWF file,
     *              the root property is the top-most display object
     *              in the portion of the display list's tree structure represented by that SWF file.
     *
     * @member   {DisplayObject|null}
     * @readonly
     * @public
     */
    get root ()
    {
        return this._$root;
    }

    /**
     * @description DisplayObject インスタンスの元の位置からの回転角を度単位で示します。
     *              Indicates the rotation of the DisplayObject instance,
     *              in degrees, from its original orientation.
     *
     * @member {number}
     * @public
     */
    get rotation ()
    {
        const matrix = this._$transform._$rawMatrix();
        return $Math.atan2(matrix[1], matrix[0]) * Util.$Rad2Deg;
    }
    set rotation (rotation)
    {
        rotation = Util.$clamp(rotation % 360, -360, 360, 0);

        const transform = this._$transform;
        const matrix    = transform.matrix;

        const scaleX = $Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
        const scaleY = $Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
        if (rotation === 0) {

            matrix.a = scaleX;
            matrix.b = 0;
            matrix.c = 0;
            matrix.d = scaleY;

        } else {

            let radianX  = $Math.atan2(matrix.b,  matrix.a);
            let radianY  = $Math.atan2(-matrix.c, matrix.d);

            const radian = rotation * Util.$Deg2Rad;
            radianY      = radianY + radian - radianX;
            radianX      = radian;

            matrix.b = scaleX * $Math.sin(radianX);
            if (matrix.b === 1 || matrix.b === -1) {
                matrix.a = 0;
            } else {
                matrix.a = scaleX * $Math.cos(radianX);
            }

            matrix.c = -scaleY * $Math.sin(radianY);
            if (matrix.c === 1 || matrix.c === -1) {
                matrix.d = 0;
            } else {
                matrix.d = scaleY * $Math.cos(radianY);
            }
        }

        transform.matrix = matrix;
        Util.$poolMatrix(matrix);
    }

    /**
     * @description 現在有効な拡大 / 縮小グリッドです。
     *              The current scaling grid that is in effect.
     *
     * @member {Rectangle}
     * @public
     */
    get scale9Grid ()
    {
        return this._$scale9Grid;
    }
    set scale9Grid (scale_9_grid)
    {
        this._$scale9Grid = null;
        if (scale_9_grid instanceof Rectangle) {
            this._$scale9Grid = scale_9_grid;
        }
    }

    /**
     * @description 基準点から適用されるオブジェクトの水平スケール（パーセンテージ）を示します。
     *              Indicates the horizontal scale (percentage)
     *              of the object as applied from the registration point.
     *
     * @member {number}
     * @public
     */
    get scaleX ()
    {
        const matrix = this._$transform._$rawMatrix();
        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        return 0 > matrix[0] ? xScale * -1 : xScale;
    }
    set scaleX (scale_x)
    {
        const transform = this._$transform;
        const matrix    = transform.matrix;
        if (matrix.b === 0 || Util.$isNaN(matrix.b)) {

            matrix.a = scale_x;

        } else {

            const radianX = $Math.atan2(matrix.b, matrix.a);

            matrix.b = scale_x * $Math.sin(radianX);
            matrix.a = matrix.b === 1 || matrix.b === -1
                ? 0
                : scale_x * $Math.cos(radianX);

        }

        transform.matrix = matrix;
        Util.$poolMatrix(matrix);
    }

    /**
     * @description 基準点から適用されるオブジェクトの垂直スケール（パーセンテージ）を示します。
     *              IIndicates the vertical scale (percentage)
     *              of an object as applied from the registration point.
     *
     * @member {number}
     * @public
     */
    get scaleY ()
    {
        const matrix = this._$transform._$rawMatrix();
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);
        return 0 > matrix[3] ? yScale * -1 : yScale;
    }
    set scaleY (scale_y)
    {
        const transform = this._$transform;
        const matrix    = transform.matrix;

        if (matrix.c === 0 || Util.$isNaN(matrix.c)) {

            matrix.d = scale_y;

        } else {

            const radianY = $Math.atan2(-matrix.c, matrix.d);
            matrix.c = -scale_y * $Math.sin(radianY);
            matrix.d = matrix.c === 1 || matrix.c === -1
                ? 0
                : scale_y  * $Math.cos(radianY);

        }

        transform.matrix = matrix;
        Util.$poolMatrix(matrix);
    }

    /**
     * @description 表示オブジェクトのステージです。
     *              The Stage of the display object.
     *
     * @member   {Stage}
     * @readonly
     * @public
     */
    get stage ()
    {
        if (this._$stage) {
            return this._$stage;
        }

        // find parent
        const parent = this._$parent;
        if (parent) {

            if (parent instanceof Stage) {
                return parent;
            }

            return parent._$stage;
        }

        return null;
    }

    /**
     * @description 表示オブジェクトのマトリックス、カラー変換、
     *              ピクセル境界に関係するプロパティを持つオブジェクトです。
     *              An object with properties pertaining
     *              to a display object's matrix, color transform, and pixel bounds.
     *
     * @member {Transform}
     * @public
     */
    get transform ()
    {
        return this._$transform;
    }
    set transform (transform)
    {
        if (transform instanceof Transform) {
            this._$transform = transform;
        }
    }

    /**
     * @description 表示オブジェクトが可視かどうかを示します。
     *              Whether or not the display object is visible.
     *
     * @member {boolean}
     * @public
     */
    get visible ()
    {
        return this._$visible;
    }
    set visible (visible)
    {
        visible = !!visible;
        if (this._$visible !== visible) {
            this._$doChanged();
            Util.$isUpdated = true;
        }
        this._$visible = !!visible;
    }

    /**
     * @description 表示オブジェクトの幅を示します（ピクセル単位）。
     *              Indicates the width of the display object, in pixels.
     *
     * @member {number}
     * @public
     */
    get width ()
    {
        const bounds = Util.$boundsMatrix(
            this._$getBounds(null),
            this._$transform._$rawMatrix()
        );

        const width = $Math.abs(bounds.xMax - bounds.xMin);
        Util.$poolBoundsObject(bounds);

        switch (true) {

            case width === 0:
            case width === Util.$Infinity:
            case width === -Util.$Infinity:
                return 0;

            default:
                return width;

        }
    }
    set width (width)
    {
        width = +width;
        if (!Util.$isNaN(width) && width > -1) {

            const bounds = this.rotation
                ? Util.$boundsMatrix(this._$getBounds(null), this._$transform._$rawMatrix())
                : this._$getBounds(null);

            const exWidth = $Math.abs(bounds.xMax - bounds.xMin);
            Util.$poolBoundsObject(bounds);

            switch (true) {

                case exWidth === 0:
                case exWidth === Util.$Infinity:
                case exWidth === -Util.$Infinity:
                    this.scaleX = 0;
                    break;

                default:
                    this.scaleX = width / exWidth;
                    break;

            }
        }
    }

    /**
     * @description 親 DisplayObjectContainer のローカル座標を基準にした
     *              DisplayObject インスタンスの x 座標を示します。
     *              Indicates the x coordinate
     *              of the DisplayObject instance relative to the local coordinates
     *              of the parent DisplayObjectContainer.
     *
     * @member {number}
     * @public
     */
    get x ()
    {
        return this._$transform._$rawMatrix()[4];
    }
    set x (x)
    {
        const transform = this._$transform;

        const matrix = this._$transform.matrix;

        matrix.tx = x;

        transform.matrix = matrix;
        Util.$poolMatrix(matrix);
    }

    /**
     * @description 親 DisplayObjectContainer のローカル座標を基準にした
     *              DisplayObject インスタンスの y 座標を示します。
     *              Indicates the y coordinate
     *              of the DisplayObject instance relative to the local coordinates
     *              of the parent DisplayObjectContainer.
     *
     * @member {number}
     * @public
     */
    get y ()
    {
        return this._$transform._$rawMatrix()[5];
    }
    set y (y)
    {
        const transform = this._$transform;

        const matrix = transform.matrix;

        matrix.ty = y;

        transform.matrix = matrix;
        Util.$poolMatrix(matrix);
    }

    /**
     * @description targetCoordinateSpace オブジェクトの座標系を基準にして、
     *              表示オブジェクトの領域を定義する矩形を返します。
     *              Returns a rectangle that defines the area
     *              of the display object relative to the coordinate system
     *              of the targetCoordinateSpace object.
     *
     * @param  {DisplayObject} [target=null]
     * @return {Rectangle}
     */
    getBounds (target = null)
    {
        const baseBounds = this._$getBounds(null);

        const matrix = this._$transform.concatenatedMatrix;

        // to global
        const bounds = Util.$boundsMatrix(baseBounds, matrix._$matrix);

        // pool
        Util.$poolMatrix(matrix);
        Util.$poolBoundsObject(baseBounds);

        // create bounds object
        const targetBaseBounds = Util.$getBoundsObject(
            bounds.xMin,
            bounds.xMax,
            bounds.yMin,
            bounds.yMax
        );

        // pool
        Util.$poolBoundsObject(bounds);

        if (!target) {
            target = this;
        }

        const targetMatrix = target._$transform.concatenatedMatrix;
        targetMatrix.invert();

        const resultBounds = Util.$boundsMatrix(
            targetBaseBounds, targetMatrix._$matrix
        );

        const xMin = resultBounds.xMin;
        const yMin = resultBounds.yMin;
        const xMax = resultBounds.xMax;
        const yMax = resultBounds.yMax;

        // pool
        Util.$poolBoundsObject(targetBaseBounds);
        Util.$poolBoundsObject(resultBounds);
        Util.$poolMatrix(targetMatrix);

        return new Rectangle(
            xMin, yMin,
            $Math.abs(xMax - xMin),
            $Math.abs(yMax - yMin)
        );
    }

    /**
     * @description point オブジェクトをステージ（グローバル）座標から
     *              表示オブジェクトの（ローカル）座標に変換します。
     *              Converts the point object from the Stage (global) coordinates
     *              to the display object's (local) coordinates.
     *
     * @param  {Point} point
     * @return {Point}
     * @public
     */
    globalToLocal (point)
    {
        const matrix = this._$transform.concatenatedMatrix;
        matrix.invert();

        const newPoint = new Point(
            point.x * matrix.a + point.y * matrix.c + matrix.tx,
            point.x * matrix.b + point.y * matrix.d + matrix.ty
        );

        Util.$poolMatrix(matrix);

        return newPoint;
    }

    /**
     * @description 表示オブジェクトの境界ボックスを評価して、
     *              obj 表示オブジェクトの境界ボックスと重複または交差するかどうかを調べます。
     *              Evaluates the bounding box of the display object to see
     *              if it overlaps or intersects with the bounding box of the obj display object.
     *
     * @param   {DisplayObject} object
     * @returns {boolean}
     * @public
     */
    hitTestObject (object)
    {
        const baseBounds1 = this._$getBounds(null);
        const matrix1 = this._$transform.concatenatedMatrix;
        const bounds1 = Util.$boundsMatrix(baseBounds1, matrix1._$matrix);

        // pool
        Util.$poolMatrix(matrix1);
        Util.$poolBoundsObject(baseBounds1);

        const baseBounds2 = object._$getBounds(null);
        const matrix2 = object._$transform.concatenatedMatrix;
        const bounds2 = Util.$boundsMatrix(baseBounds2, matrix2._$matrix);

        // pool
        Util.$poolMatrix(matrix2);
        Util.$poolBoundsObject(baseBounds2);

        // calc
        const sx = $Math.max(bounds1.xMin, bounds2.xMin);
        const sy = $Math.max(bounds1.yMin, bounds2.yMin);
        const ex = $Math.min(bounds1.xMax, bounds2.xMax);
        const ey = $Math.min(bounds1.yMax, bounds2.yMax);

        // pool
        Util.$poolBoundsObject(bounds1);
        Util.$poolBoundsObject(bounds2);

        return ex - sx >= 0 && ey - sy >= 0;
    }

    /**
     * @description 表示オブジェクトを評価して、x および y パラメーターで指定された
     *              ポイントと重複または交差するかどうかを調べます。
     *              Evaluates the display object to see if it overlaps
     *              or intersects with the point specified by the x and y parameters.
     *
     * @param   {number}  x
     * @param   {number}  y
     * @param   {boolean} [shape_flag=false]
     * @returns {boolean}
     * @public
     */
    hitTestPoint (x, y, shape_flag = false)
    {
        if (shape_flag) {

            let matrix = Util.$MATRIX_ARRAY_IDENTITY;
            let parent = this._$parent;

            while (parent) {

                matrix = Util.$multiplicationMatrix(
                    parent._$transform._$rawMatrix(),
                    matrix
                );

                parent = parent._$parent;
            }

            Util.$hitContext.setTransform(1, 0, 0, 1, 0, 0);
            Util.$hitContext.beginPath();
            const result = this._$hit(Util.$hitContext, matrix, { "x": x, "y": y }, true);

            Util.$poolFloat32Array6(matrix);

            return result;
        }

        const baseBounds = this._$getBounds(null);
        const bounds = Util.$boundsMatrix(baseBounds, this._$transform._$rawMatrix());

        const rectX = bounds.xMin;
        const rectY = bounds.yMin;
        const rectW = bounds.xMax - bounds.xMin;
        const rectH = bounds.yMax - bounds.yMin;

        const point = this._$parent
            ? this._$parent.globalToLocal(new Point(x, y))
            : new Point(x, y);

        // pool
        Util.$poolBoundsObject(bounds);
        Util.$poolBoundsObject(baseBounds);

        return new Rectangle(rectX, rectY, rectW, rectH).containsPoint(point);
    }

    /**
     * @description point オブジェクトを表示オブジェクトの（ローカル）座標から
     *              ステージ（グローバル）座標に変換します。
     *              Converts the point object from the display object's (local) coordinates
     *              to the Stage (global) coordinates.
     *
     *
     * @param   {Point} point
     * @returns {Point}
     * @public
     */
    localToGlobal (point)
    {
        const matrix = this
            ._$transform
            .concatenatedMatrix;

        const newPoint = new Point(
            point.x * matrix.a + point.y * matrix.c + matrix.tx,
            point.x * matrix.b + point.y * matrix.d + matrix.ty
        );

        Util.$poolMatrix(matrix);

        return newPoint;
    }

    /**
     * @description クラスのローカル変数空間から値を取得
     *              Get a value from the local variable space of the class
     *
     * @param  {*} key
     * @return {*}
     * @method
     * @public
     */
    getLocalVariable (key)
    {
        if (!this._$variables) {
            return null;
        }

        if (this._$variables.has(key)) {
            return this._$variables.get(key);
        }
    }

    /**
     * @description クラスのローカル変数空間へ値を保存
     *              Store values in the local variable space of the class
     *
     * @param  {*} key
     * @param  {*} value
     * @return {void}
     * @method
     * @public
     */
    setLocalVariable (key, value)
    {
        if (!this._$variables) {
            this._$variables = Util.$getMap();
        }
        this._$variables.set(key, value);
    }

    /**
     * @description クラスのローカル変数空間に値があるかどうかを判断します。
     *              Determines if there is a value in the local variable space of the class.
     *
     * @param  {*} key
     * @return {boolean}
     * @method
     * @public
     */
    hasLocalVariable (key)
    {
        return this._$variables
            ? this._$variables.has(key)
            : false;
    }

    /**
     * @description クラスのローカル変数空間の値を削除
     *              Remove values from the local variable space of a class
     *
     * @param  {*} key
     * @return {void}
     * @method
     * @public
     */
    deleteLocalVariable (key)
    {
        if (this._$variables && this._$variables.has(key)) {
            this._$variables.delete(key);
            if (!this._$variables.size) {
                Util.$poolMap(this._$variables);
                this._$variables = null;
            }
        }
    }

    /**
     * @description グローバル変数空間から値を取得
     *              Get a value from the global variable space
     *
     * @param  {*} key
     * @return {*}
     * @method
     * @public
     */
    getGlobalVariable (key)
    {
        if (Util.$variables.has(key)) {
            return Util.$variables.get(key);
        }
        return null;
    }

    /**
     * @description グローバル変数空間へ値を保存
     *              Save values to global variable space
     *
     * @param  {*} key
     * @param  {*} value
     * @return {void}
     * @method
     * @public
     */
    setGlobalVariable (key, value)
    {
        Util.$variables.set(key, value);
    }

    /**
     * @description グローバル変数空間に値があるかどうかを判断します。
     *              Determines if there is a value in the global variable space.
     *
     * @param  {*} key
     * @return {boolean}
     * @method
     * @public
     */
    hasGlobalVariable (key)
    {
        return Util.$variables.has(key);
    }

    /**
     * @description グローバル変数空間の値を削除
     *              Remove values from global variable space.
     *
     * @param  {*} key
     * @return {void}
     * @method
     * @public
     */
    deleteGlobalVariable (key)
    {
        if (Util.$variables.has(key)) {
            Util.$variables.delete(key);
        }
    }

    /**
     * @description グローバル変数空間に値を全てクリアします。
     *              Clear all values in the global variable space.
     *
     * @return {void}
     * @method
     * @public
     */
    clearGlobalVariable ()
    {
        return Util.$variables.clear();
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$getPlaceObject ()
    {
        if (!this._$placeObject) {

            const index = this._$placeId;
            if (index === null) {
                return null;
            }

            const parent = this._$parent;
            if (!parent) {
                return null;
            }

            const placeMap = parent._$placeMap;
            if (!placeMap || !placeMap.length) {
                return null;
            }

            const map = placeMap[parent._$currentFrame || 1];
            if (!map) {
                return null;
            }

            const currentPlaceId  = map[index];
            this._$changePlace    = currentPlaceId !== this._$currentPlaceId;
            this._$currentPlaceId = currentPlaceId;
            this._$placeObject    = parent._$placeObjects[currentPlaceId];
        }
        return this._$placeObject;
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$sync ()
    {
        const name = this.contentName;

        let loaderInfo = null;
        if (next2d.fw.response.has(name)) {
            loaderInfo = next2d.fw.response.get(name)._$loaderInfo;
        }

        if (!loaderInfo && next2d.fw.cache.has(name)) {
            loaderInfo = next2d.fw.cache.get(name)._$loaderInfo;
        }

        if (!loaderInfo) {
            loaderInfo = this._$loaderInfo || Util.$currentLoaderInfo;
        }

        if (!loaderInfo) {
            return null;
        }

        const characterId  = loaderInfo._$data.symbols.get(this.namespace);
        const character    = loaderInfo._$data.characters[characterId];

        this._$characterId = characterId;
        this._$loaderInfo  = loaderInfo;

        return character;
    }

    /**
     * @param  {object} tag
     * @param  {DisplayObjectContainer} parent
     * @return {object}
     * @method
     * @private
     */
    _$build (tag, parent)
    {
        const loaderInfo = parent._$loaderInfo;

        // setup
        this._$parent     = parent;
        this._$root       = parent._$root;
        this._$stage      = parent._$stage;
        this._$loaderInfo = loaderInfo;

        // bind tag data
        this._$characterId = tag.characterId | 0;
        this._$clipDepth   = tag.clipDepth | 0;
        this._$startFrame  = tag.startFrame | 0;
        this._$endFrame    = tag.endFrame | 0;
        this._$name        = tag.name || "";

        return loaderInfo._$data.characters[tag.characterId];
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$isUpdated ()
    {
        return this._$updated;
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$updateState ()
    {
        this._$isNext = true;

        let parent = this._$parent;
        if (parent) {
            parent._$updateState();
        }
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$doChanged ()
    {
        this._$isNext  = true;
        this._$updated = true;

        let parent = this._$parent;
        if (parent) {
            parent._$doChanged();
        }
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {WebGLTexture}         target_texture
     * @param  {Float32Array}         matrix
     * @param  {array}                filters
     * @param  {number}               width
     * @param  {number}               height
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$drawFilter (
        context, target_texture, matrix,
        filters, width, height
    ) {

        const cacheKeys = [this._$instanceId, "f"];
        let cache = Util.$cacheStore().get(cacheKeys);

        const updated = this._$isFilterUpdated(
            width, height, matrix, filters, true
        );

        let texture;
        if (!cache || updated) {

            // cache clear
            if (cache) {

                Util.$cacheStore().set(cacheKeys, null);
                cache.layerWidth     = 0;
                cache.layerHeight    = 0;
                cache._$offsetX      = 0;
                cache._$offsetY      = 0;
                cache.matrix         = null;
                cache.colorTransform = null;

                context
                    .frameBuffer
                    .releaseTexture(cache);

                cache = null;
            }

            texture = this._$applyFilter(
                context, filters, target_texture,
                matrix, width, height
            );

            Util.$cacheStore().set(cacheKeys, texture);
        }

        if (cache) {
            texture = cache;
        }

        return texture;
    }

    /**
     * @param   {array}  [matrix=null]
     * @returns {object}
     * @private
     */
    _$getLayerBounds (matrix = null)
    {
        const baseBounds = this._$getBounds(matrix);
        if (!matrix) {
            return baseBounds;
        }

        const filters = this._$filters || this.filters;
        const length = filters.length;
        if (!length) {
            return baseBounds;
        }

        let rect = new Rectangle(
            baseBounds.xMin,
            baseBounds.yMin,
            baseBounds.xMax - baseBounds.xMin,
            baseBounds.yMax - baseBounds.yMin
        );
        Util.$poolBoundsObject(baseBounds);
        for (let idx = 0; idx < length; ++idx) {
            rect = filters[idx]._$generateFilterRect(rect, null, null, true);
        }

        const xMin = rect._$x;
        const xMax = rect._$x + rect._$width;
        const yMin = rect._$y;
        const yMax = rect._$y + rect._$height;

        return Util.$getBoundsObject(xMin, xMax, yMin, yMax);
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$executeAddedEvent ()
    {
        if (!this._$parent) {
            return ;
        }

        // add event
        if (!this._$added) {

            // added event
            if (this.willTrigger(Event.ADDED)) {
                this.dispatchEvent(new Event(Event.ADDED, true));
            }

            // update
            this._$added = true;
        }

        if (!this._$addedStage && this._$stage !== null) {

            if (this.willTrigger(Event.ADDED_TO_STAGE)) {
                this.dispatchEvent(new Event(Event.ADDED_TO_STAGE));
            }

            // update
            this._$addedStage = true;
        }
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$prepareActions ()
    {
        this._$nextFrame();
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$nextFrame ()
    {
        // added event
        this._$executeAddedEvent();

        this._$isNext = false;

        return false;
    }

    /**
     * @param  {array} [filters=null]
     * @return {boolean}
     * @private
     */
    _$canApply (filters = null)
    {
        if (filters) {
            for (let idx = 0; idx < filters.length; ++idx) {
                if (filters[idx]._$canApply()) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * @param  {number}       width
     * @param  {number}       height
     * @param  {Float32Array} matrix
     * @param  {array}        [filters=null]
     * @param  {boolean}      [can_apply=false]
     * @param  {number}       [position_x=0]
     * @param  {number}       [position_y=0]
     * @return {boolean}
     * @private
     */
    _$isFilterUpdated (
        width, height, matrix,
        filters = null, can_apply = false,
        position_x = 0, position_y = 0
    ) {

        // cache flag
        let updated = this._$isUpdated();
        if (updated) {
            return true;
        }

        // check filter data
        if (can_apply) {

            for (let idx = 0; idx < filters.length; ++idx) {

                if (filters[idx]._$isUpdated()) {
                    return true;
                }

            }

        }

        // check status
        const cache = Util.$cacheStore().get([this._$instanceId, "f"]);
        switch (true) {

            case cache === null:
            case cache.filterState !== can_apply:
            case cache.layerWidth  !== $Math.ceil(width):
            case cache.layerHeight !== $Math.ceil(height):
            case cache.matrix !==
            matrix[0] + "_" + matrix[1] + "_" + matrix[2] + "_" + matrix[3] + "_" +
            position_x + "_" + position_y:
                return true;

            default:
                break;

        }

        return false;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array} filters
     * @param  {WebGLTexture} target_texture
     * @param  {Float32Array} matrix
     * @param  {number} width
     * @param  {number} height
     * @return {WebGLTexture}
     * @private
     */
    _$applyFilter (
        context, filters, target_texture,
        matrix, width, height
    ) {

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        const buffer = context
            .frameBuffer
            .createCacheAttachment(width, height);

        context._$bind(buffer);

        Util.$resetContext(context);

        const radianX = $Math.atan2(matrix[1], matrix[0]);
        const radianY = $Math.atan2(-matrix[2], matrix[3]);
        if (radianX || radianY) {

            const w = target_texture.width  / 2;
            const h = target_texture.height / 2;

            const a = $Math.cos(radianX);
            const b = $Math.sin(radianX);
            const c = -$Math.sin(radianY);
            const d = $Math.cos(radianY);

            const baseMatrix = Util.$getFloat32Array6(
                1, 0, 0, 1, -w, -h
            );
            const parentMatrix = Util.$getFloat32Array6(
                a, b, c, d,
                (width  - target_texture.width)  / 2,
                (height - target_texture.height) / 2
            );
            const multiMatrix = Util.$multiplicationMatrix(
                parentMatrix, baseMatrix
            );

            context.setTransform(a, b, c, d,
                multiMatrix[4] + w,
                multiMatrix[5] + h
            );

            // pool
            Util.$poolFloat32Array6(baseMatrix);
            Util.$poolFloat32Array6(parentMatrix);
            Util.$poolFloat32Array6(multiMatrix);

        } else {

            context.setTransform(1, 0, 0, 1, 0, 0);

        }

        context.drawImage(target_texture,
            0, 0, target_texture.width, target_texture.height
        );

        // init
        context._$offsetX = 0;
        context._$offsetY = 0;

        let texture = null;
        for (let idx = 0; idx < filters.length; ++idx) {
            texture = filters[idx]._$applyFilter(context, matrix);
        }

        let offsetX = context._$offsetX;
        let offsetY = context._$offsetY;

        // reset
        context._$offsetX = 0;
        context._$offsetY = 0;

        // set offset
        texture._$offsetX = offsetX;
        texture._$offsetY = offsetY;

        // cache texture
        texture.matrix =
              matrix[0] + "_" + matrix[1] + "_"
            + matrix[2] + "_" + matrix[3] + "_0_0";

        texture.filterState = true;
        texture.layerWidth  = width;
        texture.layerHeight = height;

        context._$bind(currentAttachment);
        context
            .frameBuffer
            .releaseAttachment(buffer, false);

        return texture;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @return {object}
     * @private
     */
    _$preDraw (context, matrix)
    {
        const originMatrix = this._$transform._$rawMatrix();
        const tMatrix = Util.$multiplicationMatrix(matrix, originMatrix);

        // size zero
        if (!tMatrix[0] && !tMatrix[1] || !tMatrix[2] && !tMatrix[3]) {
            return false;
        }

        // return object
        const object = Util.$getPreObject();

        // setup
        object.matrix = tMatrix;

        // check
        const filters   = this._$filters   || this.filters;
        const blendMode = this._$blendMode || this.blendMode;
        if (filters.length > 0 || blendMode !== BlendMode.NORMAL) {

            // check size
            const baseBounds = this._$getBounds(null);
            const bounds = Util.$boundsMatrix(baseBounds, tMatrix);
            const xMax   = +bounds.xMax;
            const xMin   = +bounds.xMin;
            const yMax   = +bounds.yMax;
            const yMin   = +bounds.yMin;

            // pool
            Util.$poolBoundsObject(baseBounds);
            Util.$poolBoundsObject(bounds);

            const width  = $Math.abs(xMax - xMin);
            const height = $Math.abs(yMax - yMin);
            if (0 >= width || 0 >= height) {
                return false;
            }

            if (0 > xMin + width || 0 > yMin + height) {
                return false;
            }

            const currentAttachment = context
                .frameBuffer
                .currentAttachment;
            if (xMin > currentAttachment.width
                || yMin > currentAttachment.height
            ) {
                return false;
            }

            // set origin position
            object.basePosition.x = originMatrix[4];
            object.basePosition.y = originMatrix[5];

            // check after size
            let baseLayerBounds = this._$getLayerBounds(null);
            const layerBounds = Util.$boundsMatrix(baseLayerBounds, tMatrix);

            // filter size
            let layerWidth  = $Math.abs(layerBounds.xMax - layerBounds.xMin);
            let layerHeight = $Math.abs(layerBounds.yMax - layerBounds.yMin);
            Util.$poolBoundsObject(layerBounds);

            if (layerWidth === width && layerHeight === height) {
                Util.$poolBoundsObject(baseLayerBounds);
                baseLayerBounds = null;
            }

            // move size
            let tx = tMatrix[4] - $Math.floor(xMin);
            let ty = tMatrix[5] - $Math.floor(yMin);

            let moveBounds = null;
            if (baseLayerBounds) {

                const layerMatrix = Util.$getFloat32Array6(
                    tMatrix[0], tMatrix[1], tMatrix[2], tMatrix[3], 0, 0
                );
                moveBounds = Util.$boundsMatrix(baseLayerBounds, layerMatrix);

                // pool
                Util.$poolBoundsObject(baseLayerBounds);
                Util.$poolFloat32Array6(layerMatrix);

                tx += -$Math.floor(moveBounds.xMin) - tx;
                ty += -$Math.floor(moveBounds.yMin) - ty;
            }

            let dx = $Math.floor(xMin);
            let dy = $Math.floor(yMin);
            let originX = xMin;
            let originY = yMin;

            if (moveBounds) {
                dx -= -$Math.floor(moveBounds.xMin) - (tMatrix[4] - dx);
                dy -= -$Math.floor(moveBounds.yMin) - (tMatrix[5] - dy);

                originX -= -moveBounds.xMin - (tMatrix[4] - originX);
                originY -= -moveBounds.yMin - (tMatrix[5] - originY);

                Util.$poolBoundsObject(moveBounds);
            }

            // set position
            object.position.dx = dx > 0 ? dx : 0;
            object.position.dy = dy > 0 ? dy : 0;

            // resize
            if (layerWidth + originX > currentAttachment.texture.width) {
                layerWidth -= layerWidth - currentAttachment.texture.width + originX;
            }

            if (layerHeight + originY > currentAttachment.texture.height) {
                layerHeight -= layerHeight - currentAttachment.texture.height + originY;
            }

            if (0 > dx) {
                tx += dx;
                layerWidth += originX;
            }

            if (0 > dy) {
                ty += dy;
                layerHeight += originY;
            }

            if (0 >= layerWidth || 0 >= layerHeight // size (-)
                || !layerWidth || !layerHeight // NaN or Infinity
            ) {
                Util.$poolPreObject(object);
                return false;
            }

            // start layer
            context._$startLayer(
                Util.$getBoundsObject(originX, 0, originY, 0)
            );

            // check cache
            object.canApply = this._$canApply(filters);
            let updated = this._$isFilterUpdated(
                layerWidth, layerHeight, tMatrix, filters,
                object.canApply, object.basePosition.x, object.basePosition.y
            );

            // cache
            const currentMaskBuffer = context._$cacheCurrentBuffer;
            context._$cacheCurrentBuffer = null;

            const rect = context._$cacheCurrentBounds;
            const currentMaskBounds = Util.$getBoundsObject(rect.x, rect.w, rect.y, rect.h);

            if (updated) {
                this._$buffer = context
                    .frameBuffer
                    .createCacheAttachment(
                        $Math.ceil(layerWidth),
                        $Math.ceil(layerHeight),
                        false
                    );
                context._$bind(this._$buffer);
            }

            // setup
            object.isFilter          = true;
            object.isUpdated         = updated;
            object.color             = Util.$getFloat32Array8();
            object.baseMatrix        = tMatrix;
            object.currentAttachment = currentAttachment;
            object.currentMaskBuffer = currentMaskBuffer;
            object.currentMaskBounds = currentMaskBounds;
            object.filters           = filters;
            object.blendMode         = blendMode;
            object.layerWidth        = layerWidth;
            object.layerHeight       = layerHeight;
            object.matrix            = Util.$getFloat32Array6(
                tMatrix[0], tMatrix[1], tMatrix[2], tMatrix[3], tx, ty
            );
        }

        return object;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @param  {object} object
     * @return {void}
     * @method
     * @private
     */
    _$postDraw (context, matrix, color_transform, object)
    {

        // cache
        const cacheKeys = [this._$instanceId, "f"];

        // cache or new texture
        let texture = null;
        if (this._$buffer) {

            texture = context
                .frameBuffer
                .getTextureFromCurrentAttachment();

            const cacheTexture = Util.$cacheStore().get(cacheKeys);
            if (cacheTexture) {
                Util.$cacheStore().set(cacheKeys, null);
                context
                    .frameBuffer
                    .releaseTexture(cacheTexture);
            }

        } else {
            texture = Util.$cacheStore().get(cacheKeys);
        }

        // blend only
        if (!object.canApply) {
            texture._$offsetX = 0;
            texture._$offsetY = 0;
        }

        // set cache offset
        let offsetX = texture._$offsetX;
        let offsetY = texture._$offsetY;

        // execute filter
        if (object.isUpdated && object.canApply) {

            // cache clear
            let cache = Util.$cacheStore().get(cacheKeys);
            if (cache) {

                // reset cache params
                Util.$cacheStore().set(cacheKeys, null);
                cache.layerWidth     = 0;
                cache.layerHeight    = 0;
                cache._$offsetX      = 0;
                cache._$offsetY      = 0;
                cache.matrix         = null;
                cache.colorTransform = null;
                context.frameBuffer.releaseTexture(cache);

                cache  = null;
            }

            // apply filter
            const length = object.filters.length;
            if (length) {

                // init
                context._$offsetX = 0;
                context._$offsetY = 0;

                for (let idx = 0; idx < length; ++idx) {
                    texture = object.filters[idx]._$applyFilter(context, matrix);
                }

                offsetX = context._$offsetX;
                offsetY = context._$offsetY;

                // reset
                context._$offsetX = 0;
                context._$offsetY = 0;

                // set offset
                texture._$offsetX = offsetX;
                texture._$offsetY = offsetY;

            }
        }

        // update cache params
        if (object.isUpdated) {

            texture.filterState = object.canApply;

            // cache texture
            const mat = object.baseMatrix;
            texture.matrix = mat[0] + "_" + mat[1] + "_" + mat[2] + "_" + mat[3]
                + "_" + object.basePosition.x + "_" + object.basePosition.y;

            texture.layerWidth  = object.layerWidth;
            texture.layerHeight = object.layerHeight;
        }

        // cache texture
        Util.$cacheStore().set(cacheKeys, texture);
        Util.$poolArray(cacheKeys);

        // set current buffer
        context._$bind(object.currentAttachment);

        // setup
        const width  = texture.width;
        const height = texture.height;

        // set
        Util.$resetContext(context);

        context._$globalAlpha = Util.$clamp(color_transform[3] + color_transform[7] / 255, 0, 1);
        context._$globalCompositeOperation = object.blendMode;

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.drawImage(texture,
            -offsetX + object.position.dx,
            -offsetY + object.position.dy,
            width, height,
            color_transform
        );

        // end blend
        context._$endLayer();

        // pool buffer
        if (this._$buffer) {

            context
                .frameBuffer
                .releaseAttachment(this._$buffer, false);

            this._$buffer = null;
        }

        // reset
        context._$cacheCurrentBuffer   = object.currentMaskBuffer;
        context._$cacheCurrentBounds.x = object.currentMaskBounds.xMin;
        context._$cacheCurrentBounds.y = object.currentMaskBounds.yMin;
        context._$cacheCurrentBounds.w = object.currentMaskBounds.xMax;
        context._$cacheCurrentBounds.h = object.currentMaskBounds.yMax;

        // object pool
        Util.$poolFloat32Array8(object.color);
        Util.$poolFloat32Array6(object.matrix);
        Util.$poolFloat32Array6(object.baseMatrix);
        Util.$poolBoundsObject(object.currentMaskBounds);
        Util.$poolPreObject(object);
    }

    /**
     * @param  {Float32Array} matrix
     * @return {boolean}
     * @method
     * @private
     */
    _$shouldClip (matrix)
    {
        if (this instanceof TextField) {
            if (!this.textWidth || !this.textHeight) {
                return false;
            }
            return true;
        }

        const bounds = this._$getBounds(matrix);
        const width  = $Math.abs(bounds.xMax - bounds.xMin);
        const height = $Math.abs(bounds.yMax - bounds.yMin);
        Util.$poolBoundsObject(bounds);

        // size 0
        if (!width || !height) {
            return false;
        }
        return true;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @return {Float32Array|boolean|null}
     * @method
     * @private
     */
    _$startClip (context, matrix)
    {
        let clipMatrix = null;

        // ネストしてない初回のマスクだけ実行
        // ネストしてる場合は初回に作られたbufferを流用
        if (!context._$cacheCurrentBuffer) {

            clipMatrix = context._$startClip(this, matrix);
            if (!clipMatrix) {
                return false;
            }

        }

        // start clip
        context._$enterClip();

        // mask start
        context._$beginClipDef();

        if (this instanceof DisplayObjectContainer) {
            context._$mask._$containerClip = true;
        }

        this._$clip(context, clipMatrix || matrix);
        this._$updated = false;

        // container clip
        if (context._$mask._$containerClip) {

            // update flag
            context._$mask._$containerClip = false;

            // execute clip
            context._$drawContainerClip();
        }

        // mask end
        context._$endClipDef();

        return clipMatrix;
    }
}

/**
 * InteractiveObject クラスは、マウス、キーボードまたは他のユーザー入力デバイスを使用して
 * ユーザーが操作できるすべての表示オブジェクトの抽象基本クラスです。
 *
 * The InteractiveObject class is the abstract base class for all display objects
 * with which the user can interact, using the mouse, keyboard, or other user input device.
 *
 * @class
 * @memberOf next2d.display
 * @extends  DisplayObject
 */
class InteractiveObject extends DisplayObject
{

    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$mouseEnabled = true;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class InteractiveObject]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class InteractiveObject]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.InteractiveObject
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.InteractiveObject";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object InteractiveObject]
     * @method
     * @public
     */
    toString ()
    {
        return "[object InteractiveObject]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.InteractiveObject
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.InteractiveObject";
    }

    /**
     * @description このオブジェクトでマウスまたはその他のユーザー入力メッセージを
     *              受け取るかどうかを指定します。
     *              Specifies whether this object receives mouse,
     *              or other user input, messages.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get mouseEnabled ()
    {
        return this._$mouseEnabled;
    }
    set mouseEnabled (mouse_enabled)
    {
        this._$mouseEnabled = !!mouse_enabled;
    }
}

/**
 * DisplayObjectContainer クラスは、表示リストで表示オブジェクトコンテナとして機能するすべてのオブジェクトの基本クラスです。
 * このクラス自体は、画面上でのコンテンツの描画のための API を含みません。
 * そのため、DisplayObject クラスのカスタムサブクラスを作成する場合は、
 * Sprite、または MovieClip など、画面上にコンテンツを描画する API を持つサブクラスの 1 つを拡張する必要があります。
 *
 * The DisplayObjectContainer class is the base class for all objects that can serve
 * as display object containers on the display list.
 * This class itself does not contain any API for drawing content on the screen.
 * Therefore, if you want to create a custom subclass of the DisplayObject class,
 * you need to extend one of its subclasses that has an API for drawing content on the screen,
 * such as Sprite or MovieClip.
 *
 * @class
 * @memberOf next2d.display
 * @extends  InteractiveObject
 */
class DisplayObjectContainer extends InteractiveObject
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$placeMap = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$placeObjects = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$controller = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$dictionary = null;

        /**
         * @type {array}
         * @private
         */
        this._$children = Util.$getArray();

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$needsChildren = true;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$mouseChildren = true;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$wait = true;

        /**
         * @type {Map}
         * @private
         */
        this._$names = Util.$getMap();

        return new Proxy(this, {
            "get": (object, name) =>
            {
                if (object._$names.size && object._$names.has(name)) {
                    return object._$names.get(name);
                }
                return object[name];
            }
        });
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class DisplayObjectContainer]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class DisplayObjectContainer]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.DisplayObjectContainer
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.DisplayObjectContainer";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object DisplayObjectContainer]
     * @method
     * @public
     */
    toString ()
    {
        return "[object DisplayObjectContainer]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.DisplayObjectContainer
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.DisplayObjectContainer";
    }

    /**
     * @description オブジェクトの子がマウスまたはユーザー入力デバイスに対応しているかどうかを判断します。
     *              Determines whether or not the children of the object are mouse, or user input device, enabled.
     *
     * @member {boolean}
     * @public
     */
    get mouseChildren ()
    {
        return this._$mouseChildren;
    }
    set mouseChildren (mouse_children)
    {
        this._$mouseChildren = !!mouse_children;
    }

    /**
     * @description このオブジェクトの子の数を返します。
     *              Returns the number of children of this object.
     *
     * @member   {number}
     * @readonly
     * @public
     */
    get numChildren ()
    {
        return this._$needsChildren
            ? this._$getChildren().length
            : this._$children.length;
    }

    /**
     * @description この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。
     *              Adds a child DisplayObject instance to this DisplayObjectContainer instance.
     *
     * @param  {DisplayObject} child
     * @return {DisplayObject}
     * @method
     * @public
     */
    addChild (child)
    {
        if (!(child instanceof DisplayObject)) {
            throw new TypeError("TypeError: addChild: not DisplayObject.");
        }

        if (child._$parent) {
            child._$parent._$remove(child,
                !(child._$parent._$instanceId === this._$instanceId)
            );
        }

        const children = this._$getChildren();
        children.push(child);

        if (child._$name) {
            this._$names.set(child._$name, child);
        }

        return this._$addChild(child);
    }

    /**
     * @description この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。
     *              Adds a child DisplayObject instance to this DisplayObjectContainer instance.
     *
     * @param  {DisplayObject} child
     * @param  {number}        index
     * @return {DisplayObject}
     * @method
     * @public
     */
    addChildAt (child, index)
    {
        if (!(child instanceof DisplayObject)) {
            throw new TypeError("TypeError: addChildAt: not DisplayObject.");
        }

        if (child._$parent) {
            child._$parent._$remove(child,
                !(child._$parent._$instanceId === this._$instanceId)
            );
        }

        const children = this._$getChildren();
        const length = children.length;
        if (0 > index || index > length) {
            throw new RangeError(`RangeError: addChildAt: index error: ${index}`);
        }

        if (length && length > index) {

            children.splice(index, 0, child);

            for (let idx = 0; idx < index; ++idx) {
                const instance = children[idx];
                if (instance._$name) {
                    this._$names.set(instance._$name, instance);
                }
            }

        } else {

            children.push(child);
            if (child._$name) {
                this._$names.set(child._$name, child);
            }

        }

        return this._$addChild(child);
    }

    /**
     * @description 指定された表示オブジェクトが、DisplayObjectContainer インスタンスの子であるか
     *              インスタンス自体であるかを指定します。
     *              Determines whether the specified display object is a child
     *              of the DisplayObjectContainer instance or the instance itself.
     *
     * @param  {DisplayObject} child
     * @return {boolean}
     * @method
     * @public
     */
    contains (child)
    {
        if (!(child instanceof DisplayObject)) {
            throw new TypeError("TypeError: contains: not DisplayObject.");
        }

        if (this._$instanceId === child._$instanceId) {
            return true;
        }

        const children = this._$getChildren();
        const length   = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];

            if (instance._$instanceId === child._$instanceId) {
                return true;
            }

            if (instance instanceof DisplayObjectContainer) {

                if (instance.contains(child)) {
                    return true;
                }

            }

        }

        return false;
    }

    /**
     * @description 指定のインデックス位置にある子表示オブジェクトインスタンスを返します。
     *              Returns the child display object instance that exists at the specified index.
     *
     * @param  {number} index
     * @return {DisplayObject}
     * @method
     * @public
     */
    getChildAt (index)
    {
        const children = this._$getChildren();

        const numChildren = children.length;
        if (0 > index || index > numChildren) {
            throw new RangeError(`RangeError: getChildAt: index error: ${index}`);
        }

        return index in children ? children[index] : null;
    }

    /**
     * @description 指定された名前に一致する子表示オブジェクトを返します。
     *              Returns the child display object that exists with the specified name.
     *
     * @param  {string} name
     * @return {{DisplayObject}|null}
     * @method
     * @public
     */
    getChildByName (name)
    {
        if (!name) {
            return null;
        }

        // fixed logic
        const children = this._$getChildren();
        const length   = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const child = children[idx];
            if (child.name !== name) {
                continue;
            }

            return child;
        }

        return null;
    }

    /**
     * @description 子 DisplayObject インスタンスのインデックス位置を返します。
     *              Returns the index position of a child DisplayObject instance.
     *
     * @param  {DisplayObject} child
     * @return {number}
     * @method
     * @public
     */
    getChildIndex (child)
    {
        if (!(child instanceof DisplayObject)) {
            throw new TypeError("TypeError: getChildIndex: not DisplayObject.");
        }

        if (child._$parent !== this) {
            throw new ArgumentError("ArgumentError: getChildIndex: not child");
        }

        const children = this._$getChildren();
        const index = children.indexOf(child);
        if (index === -1) {
            throw new ArgumentError("ArgumentError: getChildIndex: not found.");
        }

        return index;
    }

    /**
     * @description DisplayObjectContainer インスタンスの子リストから指定の
     *              child DisplayObject インスタンスを削除します。
     *              Removes the specified child DisplayObject instance from the
     *              child list of the DisplayObjectContainer instance.
     *
     * @param  {DisplayObject} child
     * @return {DisplayObject}
     * @method
     * @public
     */
    removeChild (child)
    {
        if (!(child instanceof DisplayObject)) {
            throw new TypeError("TypeError: removeChild: not DisplayObject.");
        }

        if (child._$parent !== this) {
            throw new ArgumentError(`ArgumentError: removeChild: index error: ${index}`);
        }

        return this._$remove(child);
    }

    /**
     * @description DisplayObjectContainer の子リストの指定された index 位置から子 DisplayObject を削除します。
     *              Removes a child DisplayObject from the specified index position
     *              in the child list of the DisplayObjectContainer.
     *
     * @param  {number} index
     * @return {DisplayObject}
     * @method
     * @public
     */
    removeChildAt (index)
    {
        return this._$remove(this.getChildAt(index));
    }

    /**
     * @description DisplayObjectContainer インスタンスの子リストから
     *              すべての child DisplayObject インスタンスを削除します。
     *              Removes all child DisplayObject instances from
     *              the child list of the DisplayObjectContainer instance.
     *
     * @param  {number} [begin_index=0]
     * @param  {number} [end_index=0x7fffffff]
     * @return {void}
     * @method
     * @public
     */
    removeChildren (begin_index = 0, end_index = 0x7fffffff)
    {
        const children = this._$getChildren();
        const numChildren = children.length;
        if (!numChildren) {
            return ;
        }

        begin_index = Util.$clamp(begin_index, 0, 0x7ffffffe, 0) - 1;
        end_index   = Util.$clamp(end_index, 1, 0x7ffffff, 0x7ffffff);

        for (let idx = $Math.min(end_index, numChildren - 1); idx > begin_index; --idx) {
            this._$remove(children[idx]);
        }
    }

    /**
     * @description 表示オブジェクトコンテナの既存の子の位置を変更します。
     *              Changes the position of an existing child in the display object container.
     *
     * @param  {DisplayObject} child
     * @param  {number} index
     * @return {void}
     * @method
     * @public
     */
    setChildIndex (child, index)
    {
        if (!(child instanceof DisplayObject)) {
            throw new TypeError("TypeError: removeChild: not DisplayObject.");
        }

        const currentIndex = this.getChildIndex(child);
        if (currentIndex === index) {
            return ;
        }

        const children = this._$getChildren();
        children.splice(currentIndex, 1);
        children.splice(index, 0, child);

        this._$doChanged();
    }

    /**
     * @description 指定された 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。
     *              Swaps the z-order (front-to-back order) of the two specified child objects.
     *
     * @param  {DisplayObject} child1
     * @param  {DisplayObject} child2
     * @return {void}
     * @method
     * @public
     */
    swapChildren (child1, child2)
    {
        if (!(child1 instanceof DisplayObject)
            || !(child2 instanceof DisplayObject)
        ) {
            throw new TypeError("TypeError: removeChild: not DisplayObject.");
        }

        const children = this._$getChildren();
        const index1 = this.getChildIndex(child1);
        const index2 = this.getChildIndex(child2);

        children[index1] = child2;
        children[index2] = child1;

        this._$doChanged();
    }

    /**
     * @description 子リスト内の指定されたインデックス位置に該当する 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。
     *              Swaps the z-order (front-to-back order) of the child objects at
     *              the two specified index positions in the child list.
     *
     * @param  {number} index1
     * @param  {number} index2
     * @return {void}
     * @method
     * @public
     */
    swapChildrenAt (index1, index2)
    {
        this.swapChildren(
            this.getChildAt(index1),
            this.getChildAt(index2)
        );
    }

    /**
     * @param  {array} [matrix=null]
     * @return {object}
     * @private
     */
    _$getBounds (matrix = null)
    {
        let multiMatrix = Util.$MATRIX_ARRAY_IDENTITY;
        if (matrix) {

            multiMatrix = matrix;

            const rawMatrix = this._$transform._$rawMatrix();
            if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
                multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
            }
        }

        const isGraphics = this._$graphics && this._$graphics._$getBounds();

        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const length = children.length;

        // size zero
        if (!length && !isGraphics) {
            const bounds = Util.$getBoundsObject(
                multiMatrix[4], -multiMatrix[4],
                multiMatrix[5], -multiMatrix[5]
            );
            if (matrix && multiMatrix !== matrix) {
                Util.$poolFloat32Array6(multiMatrix);
            }
            return bounds;
        }

        // data init
        const no = $Number.MAX_VALUE;
        let xMin = no;
        let xMax = -no;
        let yMin = no;
        let yMax = -no;

        if (isGraphics) {
            const bounds = Util.$boundsMatrix(this._$graphics._$getBounds(), multiMatrix);
            xMin   = bounds.xMin;
            xMax   = bounds.xMax;
            yMin   = bounds.yMin;
            yMax   = bounds.yMax;
            Util.$poolBoundsObject(bounds);
        }

        for (let idx = 0; idx < length; ++idx) {

            const bounds = children[idx]._$getBounds(multiMatrix);

            xMin = $Math.min(xMin, bounds.xMin);
            xMax = $Math.max(xMax, bounds.xMax);
            yMin = $Math.min(yMin, bounds.yMin);
            yMax = $Math.max(yMax, bounds.yMax);

            Util.$poolBoundsObject(bounds);

        }

        if (matrix && multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        // end
        return Util.$getBoundsObject(xMin, xMax, yMin, yMax);
    }

    /**
     * @param  {array} [matrix=null]
     * @return {object}
     * @private
     */
    _$getLayerBounds (matrix = null)
    {

        let multiMatrix = Util.$MATRIX_ARRAY_IDENTITY;
        if (matrix) {

            multiMatrix = matrix;

            const rawMatrix = this._$transform._$rawMatrix();
            if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
                multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
            }
        }

        const isGraphics = this._$graphics && this._$graphics._$getBounds();

        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const length = children.length;

        // size zero
        if (!length && !isGraphics) {
            const bounds = Util.$getBoundsObject(
                multiMatrix[4], -multiMatrix[4],
                multiMatrix[5], -multiMatrix[5]
            );
            if (matrix && multiMatrix !== matrix) {
                Util.$poolFloat32Array6(multiMatrix);
            }
            return bounds;
        }

        // data init
        const no   = $Number.MAX_VALUE;
        let xMin = no;
        let xMax = -no;
        let yMin = no;
        let yMax = -no;

        if (isGraphics) {
            const bounds = Util.$boundsMatrix(this._$graphics._$getBounds(), multiMatrix);
            xMin   = +bounds.xMin;
            xMax   = +bounds.xMax;
            yMin   = +bounds.yMin;
            yMax   = +bounds.yMax;
            Util.$poolBoundsObject(bounds);
        }

        for (let idx = 0; idx < length; ++idx) {

            const bounds = children[idx]._$getLayerBounds(multiMatrix);

            xMin = $Math.min(xMin, bounds.xMin);
            xMax = $Math.max(xMax, bounds.xMax);
            yMin = $Math.min(yMin, bounds.yMin);
            yMax = $Math.max(yMax, bounds.yMax);

            Util.$poolBoundsObject(bounds);

        }

        if (matrix && multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        // end
        if (!matrix) {
            return Util.$getBoundsObject(xMin, xMax, yMin, yMax);
        }

        const filters = this._$filters || this.filters;
        const fLength = filters.length;
        if (!fLength) {
            return Util.$getBoundsObject(xMin, xMax, yMin, yMax);
        }

        let rect = new Rectangle(xMin, yMin, xMax - xMin, yMax - yMin);
        for (let idx = 0; idx < fLength; ++idx) {
            rect = filters[idx]._$generateFilterRect(rect, null, null, true);
        }

        xMin = rect._$x;
        xMax = rect._$x + rect._$width;
        yMin = rect._$y;
        yMax = rect._$y + rect._$height;

        return Util.$getBoundsObject(xMin, xMax, yMin, yMax);
    }

    /**
     * @return {array}
     * @private
     */
    _$getChildren ()
    {
        if (this._$needsChildren) {

            // set flag
            this._$needsChildren = false;

            const frame = this._$currentFrame || 1;
            if (!this._$controller) {
                return this._$children;
            }

            let controller = this._$controller[frame];

            // first build
            const length = this._$children.length;
            if (!length) {

                if (controller) {
                    const length = controller.length;
                    for (let idx = 0; idx < length; ++idx) {

                        const instance = this._$createInstance(controller[idx]);
                        instance._$placeId = idx;

                        const loopConfig = instance.loopConfig;
                        if (loopConfig) {
                            instance._$currentFrame = instance._$getLoopFrame(loopConfig);
                        }

                        this._$children.push(instance);
                        if (instance._$name) {
                            this._$names.set(instance._$name, instance);
                        }
                    }
                }

                return this._$children;
            }

            const skipIds       = Util.$getMap();
            const poolInstances = Util.$getMap();

            let depth = 0;
            const children = Util.$getArray();
            for (let idx = 0; idx < length; ++idx) {

                const instance = this._$children[idx];

                const parent = instance._$parent;
                if (!parent || parent._$instanceId !== this._$instanceId) {
                    continue;
                }

                const startFrame = instance._$startFrame;
                const endFrame   = instance._$endFrame;
                if (startFrame === 1 && endFrame === 0
                    || startFrame <= frame && endFrame > frame
                ) {

                    // reset
                    instance._$isNext      = true;
                    instance._$placeObject = null;
                    instance._$filters     = null;
                    instance._$blendMode   = null;

                    if (instance._$id === -1) {
                        children.push(instance);
                        if (instance._$name) {
                            this._$names.set(instance._$name, instance);
                        }
                        continue;
                    }

                    const id = controller[depth];
                    if (instance._$id === id) {

                        instance._$placeId = depth;
                        children.push(instance);

                        if (instance._$name) {
                            this._$names.set(instance._$name, instance);
                        }

                        if (poolInstances.has(id)) {
                            poolInstances.delete(id);
                        }

                        skipIds.set(id, true);
                        depth++;

                        continue;
                    }

                    poolInstances.set(instance._$id, instance);

                    continue;
                }

                // remove event
                if (instance.willTrigger(Event.REMOVED)) {
                    instance.dispatchEvent(new Event(Event.REMOVED, true));
                }
                if (instance.willTrigger(Event.REMOVED_FROM_STAGE)) {
                    instance.dispatchEvent(new Event(Event.REMOVED_FROM_STAGE, true));
                }

                // reset
                instance._$added       = false;
                instance._$addedStage  = false;
                instance._$active      = false;
                instance._$updated     = true;
                instance._$filters     = null;
                instance._$blendMode   = null;
                instance._$isNext      = true;
                instance._$placeObject = null;

                if (instance instanceof DisplayObjectContainer) {
                    instance._$executeRemovedFromStage();
                    instance._$removeParentAndStage();
                }

            }

            if (controller) {
                for (let idx = 0; idx < controller.length; ++idx) {

                    const id = controller[idx];
                    if (skipIds.has(id)) {
                        continue;
                    }

                    const instance = poolInstances.has(id)
                        ? poolInstances.get(id)
                        : this._$createInstance(id);

                    instance._$placeId = idx;

                    const loopConfig = instance.loopConfig;
                    if (loopConfig) {
                        instance._$currentFrame = instance._$getLoopFrame(loopConfig);
                    }

                    children.push(instance);
                    if (instance._$name) {
                        this._$names.set(instance._$name, instance);
                    }
                }
            }

            // object pool
            Util.$poolMap(skipIds);
            Util.$poolMap(poolInstances);
            Util.$poolArray(this._$children);

            this._$children = null;
            this._$children = children;
        }

        return this._$children;
    }

    /**
     * @return void
     * @private
     */
    _$clearChildren ()
    {
        this._$doChanged();
        Util.$isUpdated = true;

        // reset
        this._$names.clear();

        // clear
        this._$needsChildren = true;
    }

    /**
     * @param   {DisplayObject} child
     * @returns {DisplayObject}
     * @private
     */
    _$addChild (child)
    {
        // init
        child._$stage  = this.constructor === Stage ? this : this._$stage;
        child._$parent = this;
        child._$root   = this.constructor === Stage ? child : this._$root;

        // setup
        if (child instanceof DisplayObjectContainer) {
            child._$setParentAndStage();
            child._$wait = true;
        }

        // added event
        if (!child._$added) {
            if (child.willTrigger(Event.ADDED)) {
                child.dispatchEvent(new Event(Event.ADDED, true));
            }
            child._$added = true;
        }

        if (this._$stage !== null && !child._$addedStage) {

            if (child.willTrigger(Event.ADDED_TO_STAGE)) {
                child.dispatchEvent(new Event(Event.ADDED_TO_STAGE));
            }

            child._$addedStage = true;

            // set params
            if (child instanceof DisplayObjectContainer) {
                child._$executeAddedToStage();
            }
        }

        this._$doChanged();
        child._$active  = true;
        child._$updated = true;
        child._$isNext  = true;

        return child;
    }

    /**
     * @return  {void}
     * @private
     */
    _$setParentAndStage ()
    {
        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];

            instance._$root  = this._$root;
            instance._$stage = this._$stage;

            if (instance instanceof DisplayObjectContainer) {
                instance._$setParentAndStage();
                instance._$wait = true;
            }

        }
    }

    /**
     * @return  void
     * @private
     */
    _$executeAddedToStage ()
    {
        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];
            if (!instance) {
                continue;
            }

            if (!instance._$addedStage) {
                if (instance.willTrigger(Event.ADDED_TO_STAGE)) {
                    instance.dispatchEvent(new Event(Event.ADDED_TO_STAGE));
                }
                instance._$addedStage = true;
            }

            if (instance instanceof DisplayObjectContainer) {
                instance._$executeAddedToStage();
            }

        }
    }

    /**
     * @param  {DisplayObject} child
     * @param  {boolean} do_event
     * @return {DisplayObject}
     * @private
     */
    _$remove (child, do_event = true)
    {
        child._$transform._$transform();

        // remove
        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const depth = this.getChildIndex(child);
        children.splice(depth, 1);

        this._$names.delete(child.name);
        if (do_event) {

            // event
            if (child.willTrigger(Event.REMOVED)) {
                child.dispatchEvent(new Event(Event.REMOVED, true));
            }

            // remove stage event
            if (this._$stage !== null) {

                if (child.willTrigger(Event.REMOVED_FROM_STAGE)) {
                    child.dispatchEvent(new Event(Event.REMOVED_FROM_STAGE));
                }

                if (child instanceof DisplayObjectContainer) {
                    child._$executeRemovedFromStage();
                }
            }

            // reset params
            if (child instanceof DisplayObjectContainer) {
                child._$removeParentAndStage();
            }

            // reset
            child._$stage      = null;
            child._$parent     = null;
            child._$root       = null;
            child._$active     = false;
            child._$wait       = true;
            child._$updated    = true;
            child._$added      = false;
            child._$addedStage = false;
            this._$doChanged();

        }

        return child;
    }

    /**
     * @return {void}
     * @private
     */
    _$executeRemovedFromStage ()
    {
        const children = this._$getChildren().slice(0);
        const length   = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];
            if (!instance) {
                continue;
            }

            if (instance._$addedStage) {
                if (instance.willTrigger(Event.REMOVED_FROM_STAGE)) {
                    instance.dispatchEvent(new Event(Event.REMOVED_FROM_STAGE));
                }
                instance._$addedStage = false;
            }

            if (instance instanceof DisplayObjectContainer) {
                instance._$executeRemovedFromStage();
            }

        }
    }

    /**
     * @return {void}
     * @private
     */
    _$removeParentAndStage ()
    {
        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const length = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];
            if (instance instanceof DisplayObjectContainer) {
                instance._$removeParentAndStage();
            }

            instance._$stage      = null;
            instance._$root       = null;
            instance._$addedStage = false;
        }

        if (this._$sounds) {
            const values = this._$sounds.values();
            for (const sounds of values) {
                for (let idx = 0; idx < sounds.length; ++idx) {
                    const sound = sounds[idx];
                    sound.stop();
                }
            }
        }
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$prepareActions ()
    {
        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        for (let idx = children.length - 1; idx > -1; --idx) {
            children[idx]._$prepareActions();
        }

        // added event
        this._$executeAddedEvent();
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$nextFrame ()
    {
        let isNext = false;

        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        for (let idx = children.length - 1; idx > -1; --idx) {

            const child = children[idx];

            if (!child._$isNext) {
                continue;
            }

            if (isNext) {

                child._$nextFrame();

            } else {

                isNext = child._$nextFrame();

            }
        }

        // added event
        this._$executeAddedEvent();

        this._$isNext = isNext;

        return this._$isNext;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @return {void}
     * @method
     * @private
     */
    _$clip (context, matrix)
    {
        let multiMatrix = matrix;

        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        if (this._$graphics && this._$graphics._$getBounds()) {
            this._$graphics._$clip(context, multiMatrix);
        }

        const children = this._$getChildren();
        const length   = children.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];

            // mask instance
            if (instance._$isMask) {
                continue;
            }

            instance._$clip(context, multiMatrix);
            instance._$updated = false;

        }

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array} matrix
     * @param  {array} color_transform
     * @return {void}
     * @method
     * @private
     */
    _$draw (context, matrix, color_transform)
    {
        // not draw
        if (!this._$visible) {
            return ;
        }

        let multiColor = color_transform;
        const rawColor = this._$transform._$rawColorTransform();
        if (rawColor !== Util.$COLOR_ARRAY_IDENTITY) {
            multiColor = Util.$multiplicationColor(color_transform, rawColor);
        }

        // not draw
        const alpha = Util.$clamp(multiColor[3] + multiColor[7] / 255, 0, 1, 0);
        if (!alpha) {
            return ;
        }

        // not draw
        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        const length = children.length;
        if (!length && (!this._$graphics || !this._$graphics._$canDraw)) {
            return ;
        }

        // pre data
        const preData = this._$preDraw(context, matrix);
        if (!preData) {
            return ;
        }

        // use cache
        if (preData.isFilter && !preData.isUpdated) {
            this._$postDraw(context, matrix, multiColor, preData);
            return ;
        }

        let preMatrix = preData.matrix;
        const preColorTransform = preData.isFilter ? preData.color : multiColor;

        // if graphics draw
        if (this._$graphics && this._$graphics._$canDraw) {
            this._$graphics._$draw(context, preMatrix, preColorTransform);
        }

        // init clip params
        let shouldClip        = true;
        let clipDepth         = null;
        const clipMatrix      = Util.$getArray();
        const instanceMatrix  = Util.$getArray();
        const clipStack       = Util.$getArray();
        const shouldClips     = Util.$getArray();

        // draw children
        const isLayer  = context._$isLayer;
        const isUpdate = this._$isUpdated();
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];

            if (isUpdate) {
                instance._$placeObject = null;
            }

            // mask instance
            if (instance._$isMask) {
                continue;
            }

            // not layer mode
            const blendMode = instance._$blendMode || instance.blendMode;
            if ((blendMode === BlendMode.ALPHA || blendMode === BlendMode.ERASE)
                && !isLayer
            ) {
                continue;
            }

            // mask end
            if (clipDepth
                && (instance._$placeId > clipDepth || instance._$clipDepth > 0)
            ) {

                context.restore();

                if (shouldClip) {
                    context._$leaveClip();

                    if (clipMatrix.length) {
                        Util.$poolFloat32Array6(preMatrix);
                        preMatrix = clipMatrix.pop();
                    }

                }

                // clear
                clipDepth  = clipStack.length ? clipStack.pop() : null;
                shouldClip = shouldClips.pop();
            }

            // mask size 0
            if (!shouldClip) {
                continue;
            }

            // mask start
            if (instance._$clipDepth > 0) {

                context.save();

                if (clipDepth) {
                    clipStack.push(clipDepth);
                }

                shouldClips.push(shouldClip);

                clipDepth  = instance._$clipDepth;
                shouldClip = instance._$shouldClip(preMatrix);
                if (shouldClip) {

                    const adjMatrix = instance._$startClip(context, preMatrix);
                    if (adjMatrix === false) { // fixed
                        shouldClip = false;
                        continue;
                    }

                    if (adjMatrix) {
                        clipMatrix.push(preMatrix);
                        preMatrix = adjMatrix;
                    }

                }

                continue;
            }

            // mask start
            const maskInstance = instance._$mask;
            if (maskInstance) {

                maskInstance._$updated = false;

                let maskMatrix;

                if (this === maskInstance._$parent) {

                    maskMatrix = preMatrix;

                } else {

                    maskMatrix = Util.$MATRIX_ARRAY_IDENTITY;

                    let parent = maskInstance._$parent;
                    while (parent) {

                        maskMatrix = Util.$multiplicationMatrix(
                            parent._$transform._$rawMatrix(),
                            maskMatrix
                        );

                        parent = parent._$parent;
                    }

                    const player = this.stage._$player;
                    const mScale = player._$scale * player._$ratio / 20;
                    const playerMatrix = Util.$getFloat32Array6(mScale, 0, 0, mScale, 0, 0);

                    maskMatrix = Util.$multiplicationMatrix(playerMatrix, maskMatrix);

                    if (context._$isLayer) {
                        const currentPosition = context._$getCurrentPosition();
                        maskMatrix[4] -= currentPosition.xMin;
                        maskMatrix[5] -= currentPosition.yMin;
                    }

                    if (context._$cacheCurrentBuffer) {
                        maskMatrix[4] -= context._$cacheCurrentBounds.x;
                        maskMatrix[5] -= context._$cacheCurrentBounds.y;
                    }

                }

                if (!maskInstance._$shouldClip(maskMatrix)) {
                    continue;
                }

                let adjMatrix = maskInstance._$startClip(context, maskMatrix);

                context.save();

                if (adjMatrix === false) { // fixed
                    context.restore();
                    continue;
                }

                if (adjMatrix) {

                    instanceMatrix.push(preMatrix);

                    if (this !== maskInstance._$parent) {
                        const maskTargetParentMatrix = this._$transform._$rawMatrix();
                        adjMatrix[0] = $Math.abs(preMatrix[0]) * $Math.sign(maskTargetParentMatrix[0]);
                        adjMatrix[1] = $Math.abs(preMatrix[1]) * $Math.sign(maskTargetParentMatrix[1]);
                        adjMatrix[2] = $Math.abs(preMatrix[2]) * $Math.sign(maskTargetParentMatrix[2]);
                        adjMatrix[3] = $Math.abs(preMatrix[3]) * $Math.sign(maskTargetParentMatrix[3]);
                        adjMatrix[4] = preMatrix[4] - context._$cacheCurrentBounds.x;
                        adjMatrix[5] = preMatrix[5] - context._$cacheCurrentBounds.y;
                    }

                    preMatrix = adjMatrix;
                }

            }

            instance._$draw(context, preMatrix, preColorTransform);
            instance._$updated = false;

            // mask end
            if (maskInstance) {

                context.restore();

                context._$leaveClip();

                if (instanceMatrix.length) {
                    Util.$poolFloat32Array6(preMatrix);
                    preMatrix = instanceMatrix.pop();
                }

            }

        }

        // end mask
        if (clipDepth) {

            context.restore();

            if (shouldClips.pop()) {
                context._$leaveClip();
            }

        }

        // object pool
        Util.$poolArray(clipMatrix);
        Util.$poolArray(instanceMatrix);
        Util.$poolArray(clipStack);
        Util.$poolArray(shouldClips);

        // filter and blend
        if (preData.isFilter) {
            return this._$postDraw(context, matrix, multiColor, preData);
        }

        Util.$poolFloat32Array6(preMatrix);
        Util.$poolPreObject(preData);

    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object} options
     * @param  {boolean} [mouse_children=true]
     * @return {boolean}
     * @method
     * @private
     */
    _$mouseHit (context, matrix, options, mouse_children = true)
    {
        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        const children = this._$getChildren();

        // mask set
        const clips       = Util.$getArray();
        const targets     = Util.$getArray();
        const clipIndexes = Util.$getMap();

        let length        = children.length;
        let clipDepth     = null;
        let clipIdx       = null;
        for (let idx = 0; idx < length; ++idx) {

            const instance = children[idx];

            if (!instance._$visible && !instance._$hitObject) {
                continue;
            }

            if (instance._$clipDepth) {
                clipIdx   = clips.length;
                clipDepth = instance._$clipDepth;
                clips.push(instance);
                continue;
            }

            // clip end
            if (clipDepth && instance._$placeId > clipDepth) {
                clipIdx   = null;
                clipDepth = null;
            }

            // clip check on
            if (clipIdx !== null) {
                clipIndexes.set(instance._$instanceId, clipIdx);
            }

            targets.push(instance);

        }

        // setup
        const mouseChildren = $Math.min(this._$mouseChildren, mouse_children);

        let hit      = false;
        const isRoot = this._$root === this;

        length = targets.length;
        for (let idx = 0; idx < length; ++idx) {

            const instance = targets.pop();

            if (instance._$isMask) {
                continue;
            }

            if (isRoot && !(instance instanceof InteractiveObject)) {
                continue;
            }

            // mask target
            if (clipIndexes.has(instance._$instanceId)) {

                const clip = clips[clipIndexes.get(instance._$instanceId)];

                if (!clip._$hit(context, multiMatrix, options, true)) {
                    continue;
                }

            }

            // mask hit test
            const maskInstance = instance._$mask;
            if (maskInstance) {

                if (this === maskInstance._$parent) {

                    if (!maskInstance._$hit(context, multiMatrix, options, true)) {
                        continue;
                    }

                } else {

                    let maskMatrix = Util.$MATRIX_ARRAY_IDENTITY;

                    let parent = maskInstance._$parent;
                    while (parent) {

                        maskMatrix = Util.$multiplicationMatrix(
                            parent._$transform._$rawMatrix(),
                            maskMatrix
                        );

                        parent = parent._$parent;
                    }

                    if (!maskInstance._$hit(context, maskMatrix, options, true)) {
                        continue;
                    }

                }

            }

            if (instance._$mouseHit(context, multiMatrix, options, mouseChildren)
                || instance._$hitArea
                    && instance
                        ._$hitArea
                        ._$mouseHit(context, multiMatrix, options, mouseChildren)
            ) {

                if (instance._$root === instance) {
                    return true;
                }

                if (!mouseChildren) {
                    return true;
                }

                hit = true;
                if (instance instanceof InteractiveObject) {

                    if (!instance._$mouseEnabled && !instance._$hitObject) {
                        continue;
                    }

                    if (!Util.$isTouch && !options.pointer) {

                        switch (true) {

                            case instance instanceof TextField:
                                if (instance._$type === TextFieldType.INPUT) {
                                    options.pointer = "text";
                                }
                                break;

                            case instance.buttonMode && instance.useHandCursor:
                                options.pointer = "pointer";
                                break;

                        }

                    }

                    if (!options.hit) {

                        options.hit = !instance._$mouseEnabled && instance._$hitObject
                            ? instance._$hitObject
                            : instance;

                    }

                    return true;
                }

            }

        }

        // pool
        Util.$poolArray(clips);
        Util.$poolArray(targets);
        Util.$poolMap(clipIndexes);

        // graphics
        if (!hit && this._$graphics) {
            hit = this._$graphics._$hit(context, multiMatrix, options);
        }

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        // not found
        return hit;
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object}  options
     * @param  {boolean} [is_clip=false]
     * @return {boolean}
     * @method
     * @private
     */
    _$hit (context, matrix, options, is_clip = false)
    {

        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        const children = this._$getChildren();

        const length = children.length - 1;
        for (let idx = length; idx > -1; --idx) {

            const instance = children[idx];
            if (instance._$isMask) {
                continue;
            }

            if (instance._$hit(context, multiMatrix, options, is_clip)) {
                return true;
            }

        }

        let hit = false;
        if (this._$graphics) {
            hit = this._$graphics._$hit(context, multiMatrix, options);
        }

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        return hit;
    }

    /**
     * @param  {number} index
     * @return {DisplayObject}
     * @method
     * @private
     */
    _$createInstance (index)
    {
        // build
        const tag        = this._$dictionary[index];
        const loaderInfo = this._$loaderInfo;
        const character  = loaderInfo._$data.characters[tag.characterId];

        // symbol class
        if (!character.class) {
            character.class = character.symbol
                ? Util.$getClass(character.symbol) || Util.$getClass(character.extends)
                : Util.$getClass(character.extends);
        }

        Util.$currentLoaderInfo = null;
        const instance = new character.class();
        instance._$build(tag, this);
        instance._$id = index;

        return instance;
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     * @method
     * @private
     */
    _$outCheck (x, y)
    {
        let matrix = Util.$MATRIX_ARRAY_IDENTITY;
        let parent = this._$parent;
        while (parent) {

            matrix = Util.$multiplicationMatrix(
                parent._$transform._$rawMatrix(),
                matrix
            );

            parent = parent._$parent;
        }

        Util.$hitContext.setTransform(1, 0, 0, 1, 0, 0);
        Util.$hitContext.beginPath();

        return this._$mouseHit(Util.$hitContext, matrix, { "x": x, "y": y });
    }
}

/**
 * Sprite クラスは、表示リストの基本的要素です。
 * グラフィックを表示でき、子を持つこともできる表示リストノードです。
 *
 * The Sprite class is a basic display list building block:
 * a display list node that can display graphics and can also contain children.
 *
 * @class
 * @memberOf next2d.display
 * @extends  DisplayObjectContainer
 */
class Sprite extends DisplayObjectContainer
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$buttonMode = false;

        /**
         * @type {Sprite|null}
         * @default null
         * @private
         */
        this._$hitArea = null;

        /**
         * @type {SoundTransform}
         * @default null
         * @private
         */
        this._$soundTransform = null;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$useHandCursor = true;

        /**
         * @type {Graphics|null}
         * @default null
         * @private
         */
        this._$graphics = null;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Sprite]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Sprite]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.Sprite
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.Sprite";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Sprite]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Sprite]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.Sprite
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.Sprite";
    }

    /**
     * @description このスプライトのボタンモードを指定します。
     *              Specifies the button mode of this sprite.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get buttonMode ()
    {
        return this._$buttonMode;
    }
    set buttonMode (button_mode)
    {
        this._$buttonMode = !!button_mode;
    }

    /**
     * @description スプライトのドラッグ先またはスプライトがドロップされた先の表示オブジェクトを指定します。
     *              Specifies the display object over which the sprite is being dragged,
     *              or on which the sprite was dropped.
     *
     * @member  {DisplayObject|null}
     * @readonly
     * @public
     */
    get dropTarget ()
    {
        return Util.$dropTarget;
    }

    /**
     * @description ベクターの描画コマンドが発生するこのスプライトに属する Graphics オブジェクトを指定します。
     *              Specifies the Graphics object that belongs to this sprite
     *              where vector drawing commands can occur.
     *
     * @member  {Graphics}
     * @readonly
     * @public
     */
    get graphics ()
    {
        if (!this._$graphics) {
            this._$graphics = new Graphics();
            this._$graphics
                ._$displayObject = this;
        }
        return this._$graphics;
    }

    /**
     * @description スプライトのヒット領域となる別のスプライトを指定します。
     *              Designates another sprite to serve as the hit area for a sprite.
     *
     * @member {Sprite|null}
     * @public
     */
    get hitArea ()
    {
        return this._$hitArea;
    }
    set hitArea (hit_area)
    {
        // reset
        if (this._$hitArea) {
            this._$hitArea._$hitObject = null;
        }

        this._$hitArea = null;
        if (hit_area instanceof Sprite) {
            this._$hitArea = hit_area;
            hit_area._$hitObject = this;
        }
    }

    /**
     * @description このスプライト内のサウンドを制御します。
     *              Controls sound within this sprite.
     *
     * @member  {SoundTransform}
     * @public
     */
    get soundTransform ()
    {
        if (!this._$soundTransform) {
            this._$soundTransform = new SoundTransform();
        }
        return this._$soundTransform;
    }
    set soundTransform (sound_transform)
    {
        if (sound_transform instanceof SoundTransform) {
            this._$soundTransform = sound_transform;
        }
    }

    /**
     * @description buttonMode プロパティが true に設定されたスプライト上にポインターが移動したときに、
     *              指差しハンドポインター（ハンドカーソル）を表示するかどうかを示すブール値です。
     *              A Boolean value that indicates whether the pointing hand (hand cursor)
     *              appears when the pointer rolls over a sprite
     *              in which the buttonMode property is set to true.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get useHandCursor ()
    {
        return this._$useHandCursor;
    }
    set useHandCursor (use_hand_cursor)
    {
        this._$useHandCursor = !!use_hand_cursor;
    }

    /**
     * @description 指定されたスプライトをユーザーがドラッグできるようにします。
     *              Lets the user drag the specified sprite.
     *
     * @param  {boolean}   [lock_center=false]
     * @param  {Rectangle} [bounds=null]
     * @return {void}
     * @method
     * @public
     */
    startDrag (lock_center = false, bounds = null)
    {
        let x = 0;
        let y = 0;

        if (!lock_center) {
            const point = this._$dragMousePoint();
            x = this.x - point.x;
            y = this.y - point.y;
        }

        Util.$dropTarget           = this;
        Util.$dragRules.lock       = lock_center;
        Util.$dragRules.position.x = x;
        Util.$dragRules.position.y = y;
        Util.$dragRules.bounds     = bounds;
    }

    /**
     * @description startDrag() メソッドを終了します。
     *              Ends the startDrag() method.
     *
     * @return void
     * @method
     * @public
     */
    stopDrag ()
    {
        // reset
        Util.$dropTarget           = null;
        Util.$dragRules.lock       = false;
        Util.$dragRules.position.x = 0;
        Util.$dragRules.position.y = 0;
        Util.$dragRules.bounds     = null;
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$sync ()
    {
        const character = super._$sync();

        if (character) {
            this._$controller   = character.controller;
            this._$dictionary   = character.dictionary;
            this._$placeMap     = character.placeMap;
            this._$placeObjects = character.placeObjects;
        }

        return character;
    }

    /**
     * @param  {object} tag
     * @param  {DisplayObjectContainer} parent
     * @return {object}
     * @method
     * @private
     */
    _$build (tag, parent)
    {
        const character = super._$build(tag, parent);

        this._$controller   = character.controller;
        this._$dictionary   = character.dictionary;
        this._$placeMap     = character.placeMap;
        this._$placeObjects = character.placeObjects;

        return character;
    }

    /**
     * @return {Point}
     * @method
     * @private
     */
    _$dragMousePoint ()
    {
        return this._$parent
            ? this._$parent.globalToLocal(Util.$currentMousePoint())
            : this.globalToLocal(Util.$currentMousePoint());
    }
}

/**
 * MovieClip クラスは、Sprite、DisplayObjectContainer、InteractiveObject、DisplayObject
 * および EventDispatcher クラスを継承します。
 * MovieClip オブジェクトには、Sprite オブジェクトとは違ってタイムラインがあります。
 * タイムラインの再生ヘッドが停止されても、その MovieClip オブジェクトの子 MovieClip オブジェクトの再生ヘッドは停止しません。
 *
 * The MovieClip class inherits from the following classes: Sprite, DisplayObjectContainer,
 * InteractiveObject, DisplayObject, and EventDispatcher.
 * Unlike the Sprite object, a MovieClip object has a timeline.
 * When the playback head of the timeline is stopped,
 * the playback head of the child MovieClip object of that MovieClip object will not be stopped.
 *
 * @class
 * @memberOf next2d.display
 * @extends  Sprite
 */
class MovieClip extends Sprite
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$stopFlag = false;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$canAction = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$childRemove = false;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$canSound = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$actionProcess = false;

        /**
         * @type {Map}
         * @private
         */
        this._$actions = Util.$getMap();

        /**
         * @type {Map}
         * @private
         */
        this._$frameCache = Util.$getMap();

        /**
         * @type {Map}
         * @default null
         * @private
         */
        this._$labels = null;

        /**
         * @type {Map}
         * @private
         */
        this._$sounds = Util.$getMap();

        /**
         * @type {Map}
         * @private
         */
        this._$channels = Util.$getMap();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$actionOffset = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$actionLimit = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$currentFrame = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$totalFrames = 1;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$isPlaying = false;

        /**
         * @type {LoopConfig}
         * @default null
         * @private
         */
        this._$loopConfig = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$tweenFrame = 0;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class MovieClip]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class MovieClip]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.MovieClip
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.MovieClip";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object MovieClip]
     * @method
     * @public
     */
    toString ()
    {
        return "[object MovieClip]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.MovieClip
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.MovieClip";
    }

    /**
     * @description MovieClip インスタンスのタイムライン内の再生ヘッドが置かれているフレームの番号を示します。
     *              Specifies the number of the frame in which the playhead is located
     *              in the timeline of the MovieClip instance.
     *
     * @member {number}
     * @default 1
     * @readonly
     * @public
     */
    get currentFrame ()
    {
        return this._$currentFrame;
    }

    /**
     * @description MovieClip インスタンスのタイムライン内の現在のフレームにあるラベルです。
     *              The label at the current frame in the timeline of the MovieClip instance.
     *
     * @member  {FrameLabel|null}
     * @readonly
     * @public
     */
    get currentFrameLabel ()
    {
        if (!this._$labels) {
            return null;
        }

        const frame = this._$currentFrame;
        if (!this._$labels.has(frame)) {
            return null;
        }

        return this._$labels.get(frame);
    }

    /**
     * @description 現在のシーンの FrameLabel オブジェクトの配列を返します。
     *              Returns an array of FrameLabel objects from the current scene.
     *
     * @member  {array|null}
     * @readonly
     * @public
     */
    get currentLabels ()
    {
        return !this._$labels ? null : Util.$Array.from(this._$labels.values());
    }

    /**
     * @description ムービークリップが現在再生されているかどうかを示すブール値です。
     *              A Boolean value that indicates whether a movie clip is curently playing.
     *
     * @member  {boolean}
     * @default false
     * @readonly
     * @public
     */
    get isPlaying ()
    {
        return this._$isPlaying;
    }

    /**
     * @description MovieClip インスタンス内のフレーム総数です。
     *              The total number of frames in the MovieClip instance.
     *
     * @member  {number}
     * @default 1
     * @readonly
     * @public
     */
    get totalFrames ()
    {
        return this._$totalFrames;
    }

    /**
     * @description MovieClipのフレームヘッダーの移動方法の設定オブジェクトを返します。
     *              Returns a configuration object for how MovieClip's frame headers are moved.
     *
     * @member  {object}
     * @default null
     * @public
     */
    get loopConfig ()
    {
        if (this._$loopConfig) {
            return this._$loopConfig;
        }

        const place = this._$getPlaceObject();
        if (!place || !place.loop) {
            return null;
        }

        if (this._$tweenFrame) {
            this._$changePlace = this._$tweenFrame !== this._$parent._$currentFrame;
            this._$tweenFrame  = 0;
        }

        if (place.loop.tweenFrame) {
            this._$tweenFrame = place.loop.tweenFrame;
        }

        return place.loop;
    }
    set loopConfig (loop_config)
    {
        this._$loopConfig = null;
        if (loop_config instanceof LoopConfig) {
            loop_config._$frame = this._$startFrame;
            this._$loopConfig   = loop_config;
            this._$currentFrame = this._$getLoopFrame(loop_config);
        }
    }

    /**
     * @description 指定されたフレームで SWF ファイルの再生を開始します。
     *              Starts playing the SWF file at the specified frame.
     *
     * @param   {number|string} frame
     * @return {void}
     * @method
     * @public
     */
    gotoAndPlay (frame)
    {
        this.play();
        this._$goToFrame(frame);
    }

    /**
     * @description このムービークリップの指定されたフレームに再生ヘッドを送り、そこで停止させます。
     *              Brings the playhead to the specified frame
     *              of the movie clip and stops it there.
     *
     * @param  {number|string} frame
     * @return {void}
     * @method
     * @public
     */
    gotoAndStop (frame)
    {
        this.stop();
        this._$goToFrame(frame);
    }

    /**
     * @description 次のフレームに再生ヘッドを送り、停止します。
     *              Sends the playhead to the next frame and stops it.
     *
     * @return {void}
     * @method
     * @public
     */
    nextFrame ()
    {
        this.stop();
        if (this._$totalFrames > this._$currentFrame) {
            this._$goToFrame(this._$currentFrame + 1);
        }
    }

    /**
     * @description ムービークリップのタイムライン内で再生ヘッドを移動します。
     *              Moves the playhead in the timeline of the movie clip.
     *
     * @return {void}
     * @method
     * @public
     */
    play ()
    {
        this._$stopFlag  = false;
        this._$isPlaying = true;
        this._$updateState();
    }

    /**
     * @description 直前のフレームに再生ヘッドを戻し、停止します。
     *              Sends the playhead to the previous frame and stops it.
     *
     * @return {void}
     * @method
     * @public
     */
    prevFrame ()
    {
        const frame = this._$currentFrame - 1;
        if (frame) {
            this.stop();
            this._$goToFrame(frame);
        }
    }

    /**
     * @description ムービークリップ内の再生ヘッドを停止します。
     *              Stops the playhead in the movie clip.
     *
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        this._$stopFlag  = true;
        this._$isPlaying = false;
    }

    /**
     * @description タイムラインに対して動的にLabelを追加できます。
     *              Labels can be added dynamically to the timeline.
     *
     * @example <caption>Example1 usage of addFrameLabel.</caption>
     * // case 1
     * const {MovieClip, FrameLabel} = next2d.display;
     * const movieClip = new MovieClip();
     * movieClip.addFrameLabel(new FrameLabel(1, "start"));
     *
     * @param  {FrameLabel} frame_label
     * @return {void}
     * @public
     */
    addFrameLabel (frame_label)
    {
        if (!this._$labels) {
            this._$labels = Util.$getMap();
        }

        if (frame_label instanceof FrameLabel) {
            this._$labels.set(frame_label.frame, frame_label);
        }
    }

    /**
     * @description 指定のフレームのアクションを追加できます
     *              You can add an action for a given frame.
     *
     * @example <caption>Example1 usage of addFrameScript.</caption>
     * // case 1
     * const {MovieClip} = next2d.display;
     * const movieClip = new MovieClip();
     * movieClip.addFrameScript(1 , function ()
     * {
     *     this.stop();
     * });
     *
     * @example <caption>Example3 usage of addFrameScript.</caption>
     * // case 2
     * const {MovieClip} = next2d.display;
     * const movieClip = new MovieClip();
     * movieClip.addFrameScript(1, method_1, 2, method_2, 10, method_10);
     *
     * @return {void}
     * @method
     * @public
     */
    addFrameScript ()
    {
        const length = arguments.length;
        for (let idx = 0; idx < length; idx += 2) {

            let frame = arguments[idx];
            if (Util.$isNaN(frame | 0)) {
                frame = this._$getFrameForLabel(frame);
            }

            frame |= 0;

            const script = arguments[idx + 1];
            if (script && frame && this._$totalFrames >= frame) {
                this._$addAction(frame, script);
            }

            // end action add
            if (frame === this._$currentFrame) {

                // set action position
                const player = Util.$currentPlayer();
                player._$actionOffset = player._$actions.length;

                // execute action stack
                this._$canAction = true;
                this._$setAction();

                // adjustment
                if (player._$actionOffset !== player._$actions.length) {

                    // marge
                    const actions = player._$actions.splice(0, player._$actionOffset);
                    player._$actions.push.apply(player._$actions, actions);

                    // reset
                    player._$actionOffset = 0;
                }

            }
        }
    }

    /**
     * @param  {string} name
     * @return {number}
     * @private
     */
    _$getFrameForLabel (name)
    {
        for (let [frame, frameLabel] of this._$labels) {
            if (frameLabel.name === name) {
                return frame | 0;
            }
        }
        return 0;
    }

    /**
     * @param {number}   frame
     * @param {function} script
     * @private
     */
    _$addAction(frame, script)
    {
        frame |= 0;
        if (frame) {
            if (!this._$actions.has(frame)) {
                this._$actions.set(frame, Util.$getArray());
            }
            this._$actions.get(frame).push(script);
        }
    }

    /**
     * @return {void}
     * @private
     */
    _$setAction ()
    {
        // added event
        this._$executeAddedEvent();

        if (this._$canAction) {

            const frame = this._$currentFrame;

            // frame label event
            if (this._$labels && this._$labels.has(frame)) {
                const frameLabel = this._$labels.get(frame);
                if (frameLabel.willTrigger(Event.FRAME_LABEL)) {
                    frameLabel.dispatchEvent(new Event(Event.FRAME_LABEL));
                }
            }

            // add action queue
            if (this._$actions.size && this._$actions.has(frame)) {

                const player = Util.$currentPlayer();
                if (player) {
                    const index = player._$actions.indexOf(this);
                    if (index === -1) {
                        player._$actions.push(this);
                    }
                }
            }
        }
    }

    /**
     * @param  {number|string} frame
     * @return {void}
     * @private
     */
    _$goToFrame (frame)
    {
        if (Util.$isNaN(+frame)) {
            frame = this._$getFrameForLabel(frame);
        }

        if (frame < 1) {
            frame = 1;
        }

        // over
        if (frame > this._$totalFrames) {
            this._$currentFrame = this._$totalFrames;
            this._$clearChildren();

            // flag off
            this._$canAction = false;
            this._$wait      = false;

            return ;
        }

        const player = Util.$currentPlayer();
        switch (true) {

            case frame !== this._$currentFrame:
                {
                    // flag off
                    this._$wait = false;

                    const currentFrame = this._$currentFrame;

                    if (this._$actionProcess) {
                        this._$frameCache.set("nextFrame", frame);
                        this._$frameCache.set("stopFlag",  this._$stopFlag);
                        this._$frameCache.set("isPlaying", this._$isPlaying);
                    }

                    // setup
                    this._$currentFrame = frame;
                    this._$clearChildren();

                    // set action position
                    player._$actionOffset = player._$actions.length;
                    const position = player._$actionOffset
                        ? player._$actions.indexOf(this)
                        : -1;

                    this._$canAction = true;
                    this._$prepareActions();

                    // adjustment
                    if (player._$actionOffset && player._$actionOffset !== player._$actions.length) {

                        // marge
                        const actions = player._$actions.splice(0, player._$actionOffset);
                        player._$actions.push.apply(player._$actions, actions);

                        // reset
                        player._$actionOffset = 0;
                    }

                    if (!this._$actionProcess && (position > -1 || !player._$actionOffset)) {

                        while (player._$actions.length) {

                            if (player._$actions.length === position) {
                                break;
                            }

                            // target object
                            const mc = player._$actions.pop();
                            mc._$canAction    = false;
                            mc._$actionOffset = 0;
                            mc._$actionLimit  = 0;

                            if (mc._$actionProcess && mc._$frameCache.size) {

                                mc._$currentFrame = mc._$frameCache.get("nextFrame");
                                mc._$clearChildren();

                                mc._$stopFlag  = mc._$frameCache.get("stopFlag");
                                mc._$isPlaying = mc._$frameCache.get("isPlaying");
                                mc._$frameCache.clear();
                            }

                            const frame = mc._$currentFrame;
                            if (!mc._$actions.has(frame)) {
                                continue;
                            }

                            const actions = mc._$actions.get(frame);
                            const length  = actions.length;
                            for (let idx = 0; idx < length; ++idx) {

                                try {

                                    Util.$currentLoaderInfo = mc._$loaderInfo;
                                    actions[idx].apply(mc);

                                } catch (e) {

                                    mc.stop();

                                    // TODO

                                }
                            }
                        }
                    }

                    if (this._$actionProcess) {
                        this._$currentFrame = currentFrame;
                        this._$clearChildren();
                    }
                }
                break;

            case !this._$actionProcess && player._$actions.indexOf(this) > -1:
                {
                    if (!this._$actionLimit) {
                        break;
                    }

                    // flag off
                    this._$wait = false;

                    const myActions = player._$actions.splice(
                        this._$actionOffset, this._$actionLimit
                    );

                    while (myActions.length) {

                        const mc = myActions.pop();

                        // target reset
                        mc._$canAction    = false;
                        mc._$actionOffset = 0;
                        mc._$actionLimit  = 0;

                        const frame = mc._$currentFrame;
                        if (!mc._$actions.has(frame)) {
                            continue;
                        }

                        const actions = mc._$actions.get(frame);
                        const length  = actions.length;
                        for (let idx = 0; idx < length; ++idx) {

                            try {

                                Util.$currentLoaderInfo = mc._$loaderInfo;
                                actions[idx].apply(mc);

                            } catch (e) {

                                mc.stop();

                                // TODO
                                // mc
                                //     .loaderInfo
                                //     .uncaughtErrorEvents
                                //     .dispatchEvent(
                                //         new UncaughtErrorEvent(
                                //             UncaughtErrorEvent.UNCAUGHT_ERROR, true, true, Util.$errorObject
                                //         )
                                //     );

                            }

                        }

                    }
                }
                break;

            default:
                break;

        }

        Util.$currentLoaderInfo = null;

        // set sound
        if (this._$canSound && this._$sounds.size
            && this._$sounds.has(this._$currentFrame)
            && !player._$sounds.has(this._$instanceId)
        ) {
            player._$sounds.set(this._$instanceId, this);
        }
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$prepareActions ()
    {
        // draw flag
        this._$wait = false;

        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        for (let idx = children.length - 1; idx > -1; --idx) {
            children[idx]._$prepareActions();
        }

        this._$setAction();
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array} matrix
     * @param  {array} color_transform
     * @return {void}
     * @method
     * @private
     */
    _$draw (context, matrix, color_transform)
    {
        super._$draw(context, matrix, color_transform);

        // set sound
        const player = Util.$currentPlayer();

        if (this._$canSound && this._$sounds.size
            && this._$sounds.has(this._$currentFrame)
            && !player._$sounds.has(this._$instanceId)
        ) {
            player._$sounds.set(this._$instanceId, this);
        }
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$nextFrame ()
    {

        let isNext = this._$needsChildren;
        switch (true) {

            case this._$wait:
                isNext = true;
                this._$wait = false;
                break;

            case this._$stopFlag:
            case this._$totalFrames === 1:
                break;

            default:
                {
                    isNext = true;

                    // action on
                    this._$canAction = true;

                    // sound on
                    this._$canSound = true;

                    const loopConfig = this.loopConfig;
                    if (!loopConfig) {

                        // next frame point
                        ++this._$currentFrame;
                        if (this._$currentFrame > this._$totalFrames) {
                            this._$currentFrame = 1;
                        }

                    } else {

                        const totalFrames = loopConfig.end
                            ? loopConfig.end
                            : this._$totalFrames;

                        switch (loopConfig.type) {

                            case LoopType.REPEAT:
                                if (this._$changePlace) {

                                    this._$currentFrame = loopConfig.start;

                                } else {

                                    ++this._$currentFrame;
                                    if (this._$currentFrame > totalFrames) {
                                        this._$currentFrame = loopConfig.start;
                                    }

                                }
                                break;

                            case LoopType.NO_REPEAT:
                                if (this._$changePlace) {

                                    this._$currentFrame = loopConfig.start;

                                } else {

                                    ++this._$currentFrame;
                                    if (this._$currentFrame > totalFrames) {

                                        this._$currentFrame = totalFrames;
                                        isNext = false;

                                        // action on
                                        this._$canAction = false;

                                        // sound on
                                        this._$canSound = false;
                                    }

                                }
                                break;

                            case LoopType.FIXED:
                                if (this._$changePlace) {

                                    this._$currentFrame = loopConfig.start;

                                } else {

                                    isNext = false;

                                    // action on
                                    this._$canAction = false;

                                    // sound on
                                    this._$canSound = false;

                                }
                                break;

                            case LoopType.NO_REPEAT_REVERSAL:
                                if (this._$changePlace) {

                                    this._$currentFrame = ltotalFrames;

                                } else {

                                    --this._$currentFrame;
                                    if (loopConfig.start > this._$currentFrame) {
                                        this._$currentFrame = loopConfig.start;

                                        isNext = false;

                                        // action on
                                        this._$canAction = false;

                                        // sound on
                                        this._$canSound = false;
                                    }

                                }
                                break;

                            case LoopType.REPEAT_REVERSAL:
                                if (this._$changePlace) {

                                    this._$currentFrame = totalFrames;

                                } else {

                                    --this._$currentFrame;
                                    if (loopConfig.start > this._$currentFrame) {
                                        this._$currentFrame = totalFrames;
                                    }

                                }
                                break;

                        }
                    }

                    // clear
                    if (isNext) {
                        this._$clearChildren();
                    }

                }
                break;

        }

        const children = this._$needsChildren
            ? this._$getChildren()
            : this._$children;

        for (let idx = children.length - 1; idx > -1; --idx) {

            const child = children[idx];

            if (!child._$isNext) {
                continue;
            }

            if (isNext) {

                child._$nextFrame();

            } else {

                isNext = child._$nextFrame();

            }

        }

        // frame action
        this._$setAction();

        this._$isNext = isNext;

        return this._$isNext;
    }

    /**
     * @param  {LoopConfig} loop_config
     * @return {number}
     * @method
     * @private
     */
    _$getLoopFrame (loop_config)
    {
        const parent = this._$parent;
        const length = parent._$currentFrame - loop_config.frame;

        let frame = 1;
        switch (loop_config.type) {

            case LoopType.REPEAT:
                {
                    const totalFrame = loop_config.end
                        ? loop_config.end
                        : this._$totalFrames;

                    frame = loop_config.start;
                    for (let idx = 0; idx < length; ++idx) {

                        ++frame;

                        if (frame > totalFrame) {
                            frame = loop_config.start;
                        }

                    }
                }
                break;

            case LoopType.NO_REPEAT:
                {
                    const totalFrame = loop_config.end
                        ? loop_config.end
                        : this._$totalFrames;

                    frame = $Math.min(totalFrame, loop_config.start + length);
                }
                break;

            case LoopType.FIXED:
                frame = loop_config.start;
                break;

            case LoopType.NO_REPEAT_REVERSAL:

                frame = loop_config.end
                    ? loop_config.end
                    : this._$totalFrames;

                frame = $Math.max(loop_config.start, frame - length);
                break;

            case LoopType.REPEAT_REVERSAL:
                {
                    const totalFrame = loop_config.end
                        ? loop_config.end
                        : this._$totalFrames;

                    frame = totalFrame;
                    for (let idx = 0; idx < length; ++idx) {

                        --frame;

                        if (loop_config.start > frame) {
                            frame = totalFrame;
                        }

                    }
                }
                break;

        }

        return frame;
    }

    /**
     * @param  {object} character
     * @return {void}
     * @method
     * @private
     */
    _$buildCharacter (character)
    {
        for (let idx = 0; idx < character.sounds.length; ++idx) {

            const object = character.sounds[idx];

            const sounds = Util.$getArray();
            for (let idx = 0; idx < object.sound.length; ++idx) {

                const sound = new Sound();
                sound._$build(object.sound[idx], this);

                sounds.push(sound);
            }

            this._$sounds.set(object.frame, sounds);
        }

        for (let idx = 0; idx < character.actions.length; ++idx) {

            const object = character.actions[idx];
            if (!object.script) {
                object.script = Function(object.action);
            }

            this._$addAction(object.frame, object.script);
        }

        for (let idx = 0; idx < character.labels.length; ++idx) {

            const label = character.labels[idx];

            this.addFrameLabel(new FrameLabel(label.name, label.frame));

        }

        this._$totalFrames = character.totalFrame || 1;
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$sync ()
    {
        const character = super._$sync();

        if (character) {
            this._$buildCharacter(character);
        }

        return character;
    }

    /**
     * @param  {object} tag
     * @param  {DisplayObjectContainer} parent
     * @return {object}
     * @method
     * @private
     */
    _$build (tag, parent)
    {
        const character = super._$build(tag, parent);

        this._$buildCharacter(character);

        return character;
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$soundPlay ()
    {
        const sounds = this._$sounds.get(this._$currentFrame);
        if (!sounds) {
            return;
        }

        const length = sounds.length;
        if (length) {

            // set SoundTransform
            let soundTransform = this._$soundTransform;

            let parent = this._$parent;
            while (parent) {

                if (parent._$soundTransform) {
                    soundTransform = parent._$soundTransform;
                }

                parent = parent._$parent;
            }

            // play sound
            for (let idx = 0; idx < length; ++idx) {

                const sound = sounds[idx];

                if (soundTransform) {
                    sound.loop   = soundTransform.loop;
                    sound.volume = soundTransform.volume;
                }
                sound.play();
            }
        }

        this._$canSound = false;
    }
}

/**
 * BitmapData クラスを使用すると、Bitmap オブジェクトのデータ (ピクセル) を処理できます。
 * BitmapData クラスのメソッドを使用して、任意のサイズの透明または不透明のビットマップイメージを作成し
 * 実行時に様々な方法で操作できます。
 *
 * The BitmapData class lets you work with the data (pixels) of a Bitmap object.
 * You can use the methods of the BitmapData class to create arbitrarily sized transparent or
 * opaque bitmap images and manipulate them in various ways at runtime.
 *
 * @class
 * @memberOf next2d.display
 */
class BitmapData
{
    /**
     * @param   {number}  [width=0]
     * @param   {number}  [height=0]
     * @param   {boolean} [transparent=true]
     * @param   {number}  [color=0xffffffff]
     *
     * @constructor
     * @public
     */
    constructor (width = 0, height = 0, transparent = true, color = 0xffffffff)
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$width = width | 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$height = height | 0;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$transparent = transparent;

        /**
         * @type {number}
         * @default 0xffffffff
         * @private
         */
        this._$color = this._$toRGBA(Util.$clamp(color, 0, 0xffffffff, 0xffffffff));

        /**
         * @type {number}
         * @private
         */
        this._$instanceId = instanceId++;

        /**
         * @type {Uint8Array}
         * @default null
         * @private
         */
        this._$buffer = null;

        /**
         * @type {HTMLImageElement}
         * @default null
         * @private
         */
        this._$image = null;

        /**
         * @type {CanvasRenderingContext2D}
         * @default null
         * @private
         */
        this._$canvas = null;

        /**
         * @type {WebGLBuffer}
         * @type {null}
         * @private
         */
        this._$pixelBuffer = null;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BitmapData]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BitmapData]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.BitmapData
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.BitmapData";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BitmapData]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BitmapData]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.BitmapData
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.BitmapData";
    }

    /**
     * @description ビットマップイメージの高さ（ピクセル単位）です。
     *              The height of the bitmap image in pixels.
     *
     * @return  {number}
     * @readonly
     * @public
     */
    get height ()
    {
        return this._$height;
    }

    /**
     * @description Imageクラスを利用して BitmapData を生成します。
     *              Use the Image class to generate BitmapData.
     *
     * @return {HTMLImageElement}
     * @public
     */
    get image ()
    {
        return this._$image;
    }
    set image (image)
    {
        this._$canvas = null;
        this._$image  = image;
        this._$width  = image.width;
        this._$height = image.height;
    }

    /**
     * @description Canvasクラス利用して BitmapData を生成します。
     *              Use the Canvas class to generate BitmapData.
     *
     * @return {CanvasRenderingContext2D}
     * @public
     */
    get canvas ()
    {
        return this._$canvas;
    }
    set canvas (canvas)
    {
        this._$image  = null;
        this._$canvas = canvas;
        this._$width  = canvas.width;
        this._$height = canvas.height;
    }

    /**
     * @description ビットマップイメージがピクセル単位の透明度をサポートするかどうかを定義します。
     *              Defines whether the bitmap image supports per-pixel transparency.
     *
     * @return  {boolean}
     * @readonly
     * @public
     */
    get transparent ()
    {
        return this._$transparent;
    }

    /**
     * @description ビットマップイメージの幅（ピクセル単位）です。
     *              The width of the bitmap image in pixels.
     *
     * @return  {number}
     * @readonly
     * @public
     */
    get width ()
    {
        return this._$width;
    }

    /**
     * @member {WebGLTexture}
     * @private
     */
    get _$texture ()
    {
        const { width, height } = this;
        if (!width || !height) {
            return null;
        }

        const player     = Util.$currentPlayer();
        const cacheStore = player._$cacheStore;
        const cacheKeys  = cacheStore.generateKeys(this._$instanceId);
        let texture      = cacheStore.get(cacheKeys);

        // delay init
        if (!texture) {

            const context = player._$context;
            switch (true) {

                case this._$image !== null:

                    texture = context
                        .frameBuffer
                        .createTextureFromImage(this._$image);

                    this._$image = null;

                    break;

                case this._$canvas !== null:

                    texture = context
                        .frameBuffer
                        .createTextureFromCanvas(this._$canvas);

                    this._$canvas = null;

                    break;

                case this._$pixelBuffer !== null:

                    texture = context
                        .frameBuffer
                        .createTextureFromPixels(
                            width, height,
                            context.pbo.getBufferSubDataAsync(this._$pixelBuffer), true
                        );

                    this._$pixelBuffer = null;

                    break;

                case this._$buffer !== null:

                    texture = context
                        .frameBuffer
                        .createTextureFromPixels(
                            width, height, this._$buffer, true
                        );

                    break;

                default:
                    {
                        const currentAttachment = context
                            .frameBuffer
                            .currentAttachment;

                        // new attachment
                        const attachment = context
                            .frameBuffer
                            .createCacheAttachment(width, height, false);
                        context._$bind(attachment);

                        Util.$resetContext(context);
                        context.fillStyle = [
                            this._$color.R / 255, this._$color.G / 255,
                            this._$color.B / 255, this._$color.A / 255
                        ];
                        context.setTransform(1, 0, 0, 1, 0, 0);
                        context.beginPath();
                        context.fillRect(0, 0, width, height);

                        texture = context
                            .frameBuffer
                            .getTextureFromCurrentAttachment();

                        // reset
                        if (currentAttachment) {
                            context._$bind(currentAttachment);
                        } else {
                            context.frameBuffer.unbind();
                        }

                        context
                            .frameBuffer
                            .releaseAttachment(attachment, false);

                    }
                    break;

            }

            cacheStore.set(cacheKeys, texture);
        }

        Util.$poolArray(cacheKeys);
        // this._$flushSetPixelQueue();

        if (!this._$buffer && !texture._$bitmapData) {
            texture._$bitmapData = this;
        }

        return texture;

    }
    set _$texture (texture)
    {
        // 未反映の setPixel/setPixel32 は破棄する。
        // if (this._$setPixelQueue) {
        //     Util.$poolFloat32Array(this._$setPixelQueue);
        // }
        this._$setPixelQueue = null;
        this._$setPixelCount = 0;

        // if (this._$linePixelsCache) {
        //     Util.$poolUint8Array(this._$linePixelsCache);
        // }
        this._$linePixelsCache = null;
        this._$linePixelsCacheY = null;

        const player     = Util.$currentPlayer();
        const cacheStore = player._$cacheStore;
        const cacheKeys  = cacheStore.generateKeys(this._$instanceId);

        const currentTexture = cacheStore.get(cacheKeys);
        if (currentTexture) {

            if (currentTexture._$bitmapData) {
                delete currentTexture._$bitmapData;
            }

            player._$context
                .frameBuffer
                .releaseTexture(currentTexture);

            cacheStore.set(cacheKeys, null);
        }

        if (this._$buffer) {
            this._$buffer = null;
        }

        cacheStore.set(cacheKeys, texture);
        Util.$poolArray(cacheKeys);

        if (!texture._$bitmapData) {
            texture._$bitmapData = this;
        }
    }

    /**
     * @param  {DisplayObject}  source
     * @param  {Matrix}         [matrix=null]
     * @param  {ColorTransform} [color_transform=null]
     * @param  {string}         [blend_mode=BlendMode.NORMAL]
     * @param  {Rectangle}      [clip_rect=null]
     * @param  {boolean}        [smoothing=false]
     * @return {void}
     * @public
     */
    draw (
        source, matrix = null, color_transform = null,
        blend_mode = BlendMode.NORMAL, clip_rect = null, smoothing = false
    ) {

        const width  = this._$width;
        const height = this._$height;
        if (!width || !height) {
            return ;
        }

        const player = Util.$currentPlayer();

        const context = player._$context;

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // new buffer
        const sourceAttachment = context
            .frameBuffer
            .createCacheAttachment(width, height, false);
        context._$bind(sourceAttachment);

        Util.$resetContext(context);
        context.setTransform(1, 0, 0, 1, 0, 0);

        // id clip
        if (clip_rect) {

            const dx = clip_rect.x;
            const dy = clip_rect.y;
            const dw = clip_rect.width;
            const dh = clip_rect.height;

            context.save();
            context._$enterClip();
            context._$beginClipDef();

            context.setTransform(1, 0, 0, 1, 0, 0);
            context.beginPath();
            context.moveTo(dx     , dy);
            context.lineTo(dx + dw, dy);
            context.lineTo(dx + dw, dy + dh);
            context.lineTo(dx     , dy + dh);
            context.lineTo(dx     , dy);
            context.clip(true);
            context._$endClipDef();

        }

        let tMatrix = matrix
            ? matrix._$matrix
            : Util.$MATRIX_ARRAY_IDENTITY;

        let colorTransform = color_transform
            ? color_transform._$colorTransform
            : Util.$COLOR_ARRAY_IDENTITY;

        if (source instanceof DisplayObject) {

            // matrix invert
            const clone = source._$transform.matrix;
            clone.invert();

            if (matrix) {
                tMatrix = Util.$multiplicationMatrix(
                    tMatrix, clone._$matrix
                );
            }

            source._$draw(context, tMatrix, colorTransform);

            Util.$poolMatrix(clone);

        } else {

            // clone canvas
            const bitmap = new Bitmap(source, PixelSnapping.AUTO, smoothing);
            bitmap._$draw(context, tMatrix, colorTransform);

        }

        // clip end
        if (clip_rect) {
            context.restore();
            context._$leaveClip();
        }

        const sourceTexture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();

        // setup
        const attachment = context
            .frameBuffer
            .createTextureAttachmentFrom(this._$texture);
        context._$bind(attachment);

        // pool
        context
            .frameBuffer
            .releaseAttachment(sourceAttachment, false);

        // draw source
        Util.$resetContext(context);
        context.setTransform(1, 0, 0, 1, 0, 0);
        context._$imageSmoothingEnabled    = smoothing;
        context._$globalCompositeOperation = blend_mode;
        context.drawImage(sourceTexture, 0, 0, width, height);

        if (currentAttachment) {
            context._$bind(currentAttachment);
        } else {
            context.frameBuffer.unbind();
        }

        // pool
        context.frameBuffer.releaseTexture(sourceTexture);
        context.frameBuffer.releaseAttachment(attachment, false);
    }

    /**
     * @param  {uint} color
     * @return {object}
     * @private
     */
    _$toRGBA (color)
    {
        return this._$transparent
            ? Util.$uintToRGBA(color)
            : Util.$intToRGBA(color);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @param  {string} [byte_order="RGBA"]
     * @return {void}
     * @private
     */
    _$getPixelsAsync (x, y, w, h, byte_order = "RGBA")
    {
        x = Math.max(x, 0);
        y = Math.max(y, 0);

        const width  = $Math.min(w, this.width  - x);
        const height = $Math.min(h, this.height - y);
        if (width <= 0 || height <= 0) {
            return ;
        }

        const context = Util
            .$currentPlayer()
            ._$context;

        if (!context) {
            return ;
        }

        const shader = context
            ._$shaderList
            ._$bitmapData
            .getPixels[byte_order]
            .instance;

        context
            ._$shaderList
            .bitmapShaderVariants
            .setGetPixelsUniform(
                shader.uniform,
                width / this.width, -height / this.height,
                x / this.width, 1 - y / this.height
            );

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        const attachment = context
            .frameBuffer
            .createCacheAttachment(width, height, false);
        context._$bind(attachment);

        context
            ._$frameBufferManager
            ._$textureManager
            .bind0(this._$texture, false);

        context.blend.disable();
        shader._$drawImage();
        context.blend.enable();

        this._$pixelBuffer = context
            .pbo
            .readPixelsAsync(
                0, 0, this.width, this.height
            );

        if (currentAttachment) {
            context._$bind(currentAttachment);
        } else {
            context.frameBuffer.unbind();
        }
        context.frameBuffer.releaseAttachment(attachment);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @param  {string} [byte_order="ARGB"]
     * @param  {function} [allocator=null]
     * @return {Uint8Array}
     * @private
     */
    _$getPixels (x, y, w, h, byte_order = "ARGB", allocator = null)
    {
        switch (byte_order) {

            case "ARGB":
            case "RGBA":
            case "BGRA":
                break;

            default:
                throw new Error(`Unsupported byteOrder: ${byte_order}`);

        }

        x = Math.max(x, 0);
        y = Math.max(y, 0);
        const width  = $Math.min(w, this.width  - x);
        const height = $Math.min(h, this.height - y);

        if (width <= 0 || height <= 0) {
            return new Uint8Array(0);
        }

        const pixels = allocator
            ? allocator(width * height * 4)
            : new Uint8Array(width * height * 4);

        const context = Util
            .$currentPlayer()
            ._$context;

        if (!context) {
            return pixels;
        }

        const shader = context
            ._$shaderList
            ._$bitmapData
            .getPixels[byte_order]
            .instance;

        context
            ._$shaderList
            .bitmapShaderVariants
            .setGetPixelsUniform(
                shader.uniform,
                width / this.width, -height / this.height,
                x / this.width, 1 - y / this.height
            );

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        const attachment = context
            .frameBuffer
            .createCacheAttachment(width, height, false);
        context._$bind(attachment);

        context
            ._$frameBufferManager
            ._$textureManager
            .bind0(this._$texture, false);

        context.blend.disable();
        shader._$drawImage();
        context.blend.enable();

        const gl = context._$gl;
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        if (currentAttachment) {
            context._$bind(currentAttachment);
        } else {
            context.frameBuffer.unbind();
        }
        context.frameBuffer.releaseAttachment(attachment);

        return pixels;
    }

    /**
     * @return {string}
     * @method
     * @public
     */
    toDataURL ()
    {
        const context = this.getContext2D();
        const base64  = context.canvas.toDataURL();

        // recycle
        Util.$cacheStore().destroy(context);

        return base64;
    }

    /**
     * @return {CanvasRenderingContext2D}
     * @method
     * @public
     */
    getContext2D ()
    {
        const { width, height } = this;

        const canvas  = Util.$cacheStore().getCanvas();
        canvas.width  = width;
        canvas.height = height;

        const ctx = canvas.getContext("2d");
        if (width || height) {

            const player  = Util.$currentPlayer();
            const context = player._$context;

            const cacheWidth  = player._$canvas.width;
            const cacheHeight = player._$canvas.height;

            context.frameBuffer.unbind();
            Util.$resetContext(context);
            context.setTransform(1, 0, 0, 1, 0, 0);
            context._$setColor(0, 0, 0, 0);
            context.clearRect(0, 0, cacheWidth, cacheHeight);

            // resize
            const resize = width > cacheWidth || height > cacheHeight;
            if (resize) {
                // canvas
                player._$canvas.width  = width;
                player._$canvas.height = height;

                // webgl
                context._$gl.viewport(0, 0, width, height);
                context._$viewportWidth  = width;
                context._$viewportHeight = height;
            }

            // reset and draw to canvas
            context.drawImage(this._$texture, 0, 0, width, height);
            ctx.drawImage(player._$canvas, 0, 0);

            if (resize) {
                // canvas
                player._$canvas.width  = cacheWidth;
                player._$canvas.height = cacheHeight;

                // webgl
                context._$gl.viewport(0, 0, cacheWidth, cacheHeight);
                context._$viewportWidth  = cacheWidth;
                context._$viewportHeight = cacheHeight;
            }

            // end
            context._$bind(player._$buffer);
        }

        return ctx;
    }

    /**
     * @return {Uint8Array}
     * @method
     * @public
     */
    toUint8Array ()
    {
        return this._$buffer
            ? this._$buffer
            : this._$getPixels(0, 0, this.width, this.height, "RGBA");
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    dispose ()
    {
        const player  = Util.$currentPlayer();
        const texture = this._$texture;

        if (texture) {
            texture._$bitmapData = false;
        }

        // set null
        player
            ._$cacheStore
            .removeCache(this._$instanceId);
    }
}

/**
 * BitmapDataChannel クラスは、赤、青、緑、またはアルファ透明度の
 * いずれのチャンネルを使用するかを示す定数値の列挙です。
 * メソッドを呼び出すとき、ビット単位の OR 演算子（|）を使って
 * BitmapDataChannel 定数を結合すれば、複数のカラーチャンネルを指定することができます。
 *
 * The BitmapDataChannel class is an enumeration of constant values that indicate
 * which channel to use: red, blue, green, or alpha transparency.
 * When you call some methods, you can use the bitwise OR operator (|)
 * to combine BitmapDataChannel constants to indicate multiple color channels.
 *
 * @class
 * @memberOf next2d.display
 */
class BitmapDataChannel
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BitmapDataChannel]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BitmapDataChannel]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.BitmapDataChannel
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.BitmapDataChannel";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BitmapDataChannel]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BitmapDataChannel]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.BitmapDataChannel
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.BitmapDataChannel";
    }

    /**
     * @description アルファチャンネルです。
     *              The alpha channel.
     *
     * @return  {number}
     * @default 8
     * @const
     * @static
     */
    static get ALPHA ()
    {
        return 8;
    }

    /**
     * @description 青チャンネルです。
     *              The blue channel.
     *
     * @return  {number}
     * @default 4
     * @const
     * @static
     */
    static get BLUE ()
    {
        return 4;
    }

    /**
     * @description 緑チャンネルです。
     *              The green channel.
     *
     * @return  {number}
     * @default 2
     * @const
     * @static
     */
    static get GREEN ()
    {
        return 2;
    }

    /**
     * @description 赤チャンネルです。
     *              The red channel.
     *
     * @return  {number}
     * @default 1
     * @const
     * @static
     */
    static get RED ()
    {
        return 1;
    }
}

/**
 * ブレンドモードの視覚効果のために定数値を提供するクラスです。
 * 全てのDisplayObjectに設定が可能です。
 * A class that provides constant values for visual blend mode effects.
 * It can be set for all DisplayObjects.
 *
 * @example <caption>usage of BlendMode.</caption>
 * // static BlendMode
 * const {BlendMode, MovieClip} = next2d.display;
 * const movieClip = new MovieClip();
 * movieClip.blendMode = BlendMode.ADD;
 *
 * @class
 * @memberOf next2d.display
 */
class BlendMode
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BlendMode]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BlendMode]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.BlendMode
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.BlendMode";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BlendMode]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BlendMode]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.BlendMode
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.BlendMode";
    }

    /**
     * @description 表示オブジェクトの要素カラーの値を背景色に加算し、その際に上限 0xFF を適用します。
     *              Adds the values of the constituent colors of the display object
     *              to the colors of its background, applying a ceiling of 0xFF.
     *
     * @return  {string}
     * @default add
     * @const
     * @static
     */
    static get ADD ()
    {
        return "add";
    }

    /**
     * @description 表示オブジェクトの各ピクセルのアルファ値を背景に適用します。
     *              Applies the alpha value of each pixel of the display object to the background.
     *
     * @return  {string}
     * @default alpha
     * @const
     * @static
     */
    static get ALPHA ()
    {
        return "alpha";
    }

    /**
     * @description 表示オブジェクトの要素カラーと背景色のうち暗い方（値が小さい方）の色を選択します。
     *              Selects the darker of the constituent colors of the display object
     *              and the colors of the background (the colors with the smaller values).
     *
     * @return  {string}
     * @default darken
     * @const
     * @static
     */
    static get DARKEN ()
    {
        return "darken";
    }

    /**
     * @description 表示オブジェクトの要素カラーと背景色を比較し、2 つの要素カラーのうち明るい方の値から暗い方の値を差し引きます。
     *              Compares the constituent colors of the display object with the colors of its background,
     *              and subtracts the darker of the values of the two constituent colors from the lighter value.
     *
     * @return  {string}
     * @default difference
     * @const
     * @static
     */
    static get DIFFERENCE ()
    {
        return "difference";
    }

    /**
     * @description 表示オブジェクトのアルファ値に基づいて背景を消去します。
     *              Erases the background based on the alpha value of the display object.
     *
     * @return  {string}
     * @default erase
     * @const
     * @static
     */
    static get ERASE ()
    {
        return "erase";
    }

    /**
     * @description 表示オブジェクトの暗さに基づいて、各ピクセルの色を調整します。
     *              Adjusts the color of each pixel based on the darkness of the display object.
     *
     * @return  {string}
     * @default hardlight
     * @const
     * @static
     */
    static get HARDLIGHT ()
    {
        return "hardlight";
    }

    /**
     * @description 背景を反転します。
     *              Inverts the background.
     *
     * @return  {string}
     * @default invert
     * @const
     * @static
     */
    static get INVERT ()
    {
        return "invert";
    }

    /**
     * @description 表示オブジェクトに関する透明度グループを強制的に作成します。
     *              Forces the creation of a transparency group for the display object.
     *
     * @return  {string}
     * @default layer
     * @const
     * @static
     */
    static get LAYER ()
    {
        return "layer";
    }

    /**
     * @description 表示オブジェクトの要素カラーと背景色のうち明るい方（値が大きい方）の色を選択します。
     *              Selects the lighter of the constituent colors of the display object
     *              and the colors of the background (the colors with the larger values).
     *
     * @return  {string}
     * @default lighten
     * @const
     * @static
     */
    static get LIGHTEN ()
    {
        return "lighten";
    }

    /**
     * @description 表示オブジェクトの要素カラーの値と背景色の要素カラーの値を乗算した後、0xFF で割って正規化し、色を暗くします。
     *              Multiplies the values of the display object constituent colors by the constituent colors
     *              of the background color, and normalizes by dividing by 0xFF, resulting in darker colors.
     *
     * @return  {string}
     * @default multiply
     * @const
     * @static
     */
    static get MULTIPLY ()
    {
        return "multiply";
    }

    /**
     * @description 表示オブジェクトは、背景の前に表示されます。
     *              The display object appears in front of the background.
     *
     * @return  {string}
     * @default normal
     * @const
     * @static
     */
    static get NORMAL ()
    {
        return "normal";
    }

    /**
     * @description 背景の暗さに基づいて、各ピクセルの色を調整します。
     *              Adjusts the color of each pixel based on the darkness of the background.
     *
     * @return  {string}
     * @default overlay
     * @const
     * @static
     */
    static get OVERLAY ()
    {
        return "overlay";
    }

    /**
     * @description 表示オブジェクトの色の補数（逆）と背景色の補数を乗算して、ブリーチ効果を得ます。
     *              Multiplies the complement (inverse) of the display object color by the complement
     *              of the background color, resulting in a bleaching effect.
     *
     * @return  {string}
     * @default screen
     * @const
     * @static
     */
    static get SCREEN ()
    {
        return "screen";
    }

    /**
     * @description 結果の下限を 0 として、表示オブジェクトの要素カラーの値をその背景色の値から減算します。
     *              Subtracts the values of the constituent colors in the display object
     *              from the values of the background color, applying a floor of 0.
     *
     * @return  {string}
     * @default subtract
     * @const
     * @static
     */
    static get SUBTRACT ()
    {
        return "subtract";
    }
}

/**
 * CapsStyle クラスは、線の描画で使用されるキャップのスタイルを指定する定数値の列挙です。
 * この定数は、caps パラメーター（next2d.display.Graphics.lineStyle() メソッドのパラメーター）の値として使用されます。
 *
 * he CapsStyle class is an enumeration of constant values that specify the caps style to use in drawing lines.
 * The constants are provided for use as values in the caps parameter of the next2d.display.Graphics.lineStyle() method.
 *
 * @class
 * @memberOf next2d.display
 */
class CapsStyle
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class CapsStyle]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class CapsStyle]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.CapsStyle
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.CapsStyle";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object CapsStyle]
     * @method
     * @public
     */
    toString ()
    {
        return "[object CapsStyle]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.CapsStyle
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.CapsStyle";
    }

    /**
     * @description flash.display.Graphics.lineStyle() メソッドの caps パラメーターで
     *              キャップなしを指定するのに使用します。
     *              Used to specify no caps in the caps parameter of the
     *              flash.display.Graphics.lineStyle() method.
     *
     * @return  {string}
     * @default none
     * @const
     * @static
     */
    static get NONE ()
    {
        return "none";
    }

    /**
     * @description flash.display.Graphics.lineStyle() メソッドの caps パラメーターで
     *              丸いキャップを指定するのに使用します。
     *              Used to specify round caps in the caps parameter of the
     *              flash.display.Graphics.lineStyle() method.
     *
     * @return  {string}
     * @default round
     * @const
     * @static
     */
    static get ROUND ()
    {
        return "round";
    }

    /**
     * @description flash.display.Graphics.lineStyle() メソッドの caps パラメーターで
     *              四角形のキャップを指定するのに使用します。
     *              Used to specify square caps in the caps parameter of the
     *              flash.display.Graphics.lineStyle() method.
     *
     * @return  {string}
     * @default square
     * @const
     * @static
     */
    static get SQUARE ()
    {
        return "square";
    }
}

/**
 * FrameLabel オブジェクトには、フレーム番号および対応するラベル名を指定するプロパティがあります。
 * MovieClip クラスには、currentLabels プロパティがあります。
 * これは、現在のシーンの FrameLabel オブジェクトの配列です。
 * MovieClip インスタンスがシーンを使用していない場合、配列には MovieClip インスタンス全体のすべてのフレームラベルが含まれます。
 *
 * The FrameLabel object contains properties that specify a frame number and the corresponding label name.
 * The MovieClip class includes a currentLabels property,
 * which is an Array of FrameLabel objects for the current scene.
 * If the MovieClip instance does not use scenes,
 * the Array includes all frame labels from the entire MovieClip instance.
 *
 * @example <caption>Example usage of FrameLabel.</caption>
 * // static BlendMode
 * const {FrameLabel} = next2d.display;
 * const frameLabel = new FrameLabel();
 * frameLabel.addEventListener(Event.FRAME_LABEL, (event) =>
 * {
 *     // more...
 * }
 *
 * @class
 * @memberOf next2d.display
 * @extends  EventDispatcher
 */
class FrameLabel extends EventDispatcher
{
    /**
     * @param {string} name
     * @param {number} frame
     *
     * @constructor
     * @public
     */
    constructor (name, frame)
    {
        super();

        /**
         * @type {string}
         * @private
         */
        this._$name = `${name}`;

        /**
         * @type {number}
         * @private
         */
        this._$frame = frame | 0;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class FrameLabel]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class FrameLabel]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.FrameLabel
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.FrameLabel";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object FrameLabel]
     * @method
     * @public
     */
    toString ()
    {
        return "[object FrameLabel]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.FrameLabel
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.FrameLabel";
    }

    /**
     * @description ラベルを含むフレームの番号。
     *              The frame number containing the label.
     *
     * @return  {number}
     * @method
     * @readonly
     * @public
     */
    get frame ()
    {
        return this._$frame;
    }

    /**
     * @description ラベルの名前。
     *              The name of the label.
     *
     * @return  {string}
     * @method
     * @readonly
     * @public
     */
    get name ()
    {
        return this._$name;
    }
}

/**
 * GradientType クラスは、type パラメーター（next2d.display.Graphics クラスの beginGradientFill() メソッドおよび
 * lineGradientStyle() メソッド内のパラメーター）に値を提供します。
 *
 * The GradientType class provides values for the type parameter in the beginGradientFill()
 * and lineGradientStyle() methods of the flash.display.Graphics class.
 *
 * @class
 * @memberOf next2d.display
 */
class GradientType
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class GradientType]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class GradientType]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.GradientType
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.GradientType";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object GradientType]
     * @method
     * @public
     */
    toString ()
    {
        return "[object GradientType]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.GradientType
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.GradientType";
    }

    /**
     * @description 線状グラデーションの塗りを指定する値です。
     *              Value used to specify a linear gradient fill.
     *
     * @return  {string}
     * @default linear
     * @const
     * @static
     */
    static get LINEAR ()
    {
        return "linear";
    }

    /**
     * @description 放射状グラデーションの塗りを指定する値です。
     *              Value used to specify a radial gradient fill.
     *
     * @return  {string}
     * @default radial
     * @const
     * @static
     */
    static get RADIAL ()
    {
        return "radial";
    }
}

/**
 * Graphics クラスには、ベクターシェイプの作成に使用できる一連のメソッドがあります。
 * 描画をサポートする表示オブジェクトには、Sprite および Shape オブジェクトがあります。
 * これらの各クラスには、Graphics オブジェクトである graphics プロパティがあります。
 * 以下は、簡単に使用できるように用意されているヘルパー関数の一例です。
 * drawRect()、drawRoundRect()、drawCircle()、および drawEllipse()。
 *
 * The Graphics class contains a set of methods that you can use to create a vector shape.
 * Display objects that support drawing include Sprite and Shape objects.
 * Each of these classes includes a graphics property that is a Graphics object.
 * The following are among those helper functions provided for ease of use:
 * drawRect(), drawRoundRect(), drawCircle(), and drawEllipse().
 *
 * @class
 * @memberOf next2d.display
 */
class Graphics
{
    /**
     * @param {DisplayObject} src
     *
     * @constructor
     * @public
     */
    constructor (src = null)
    {
        /**
         * @type {DisplayObject}
         * @default null
         * @private
         */
        this._$displayObject = src;

        this.clear();
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Graphics]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Graphics]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.Bitmap
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.Graphics";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Graphics]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Graphics]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.Graphics
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.Graphics";
    }

    /**
     * @return {number}
     * @default 0
     * @const
     * @static
     * @private
     */
    static get MOVE_TO ()
    {
        return 0;
    }

    /**
     * @return {number}
     * @default 1
     * @const
     * @static
     * @private
     */
    static get CURVE_TO ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @default 2
     * @const
     * @static
     * @private
     */
    static get LINE_TO ()
    {
        return 2;
    }

    /**
     * @return {number}
     * @default 3
     * @const
     * @static
     * @private
     */
    static get CUBIC ()
    {
        return 3;
    }

    /**
     * @return {number}
     * @default 4
     * @const
     * @static
     * @private
     */
    static get ARC ()
    {
        return 4;
    }

    /**
     * @return {number}
     * @default 5
     * @const
     * @static
     * @private
     */
    static get FILL_STYLE ()
    {
        return 5;
    }

    /**
     * @return {number}
     * @default 6
     * @const
     * @static
     * @private
     */
    static get STROKE_STYLE ()
    {
        return 6;
    }

    /**
     * @return {number}
     * @default 7
     * @const
     * @static
     * @private
     */
    static get END_FILL ()
    {
        return 7;
    }

    /**
     * @return {number}
     * @default 8
     * @const
     * @static
     * @private
     */
    static get END_STROKE ()
    {
        return 8;
    }

    /**
     * @return {number}
     * @default 9
     * @const
     * @static
     * @private
     */
    static get BEGIN_PATH ()
    {
        return 9;
    }

    /**
     * @return {number}
     * @default 10
     * @const
     * @static
     * @private
     */
    static get GRADIENT_FILL ()
    {
        return 10;
    }

    /**
     * @return {number}
     * @default 11
     * @const
     * @static
     * @private
     */
    static get GRADIENT_STROKE ()
    {
        return 11;
    }

    /**
     * @return {number}
     * @default 12
     * @const
     * @static
     * @private
     */
    static get CLOSE_PATH ()
    {
        return 12;
    }

    /**
     * @return {number}
     * @default 13
     * @const
     * @static
     * @private
     */
    static get BITMAP_FILL ()
    {
        return 13;
    }

    /**
     * @return {number}
     * @default 14
     * @const
     * @static
     * @private
     */
    static get BITMAP_STROKE ()
    {
        return 14;
    }

    /**
     * @description 描画領域をビットマップイメージで塗りつぶします。
     *              Fills a drawing area with a bitmap image.
     *
     * @param  {BitmapData} bitmap_data
     * @param  {Matrix}     [matrix=null]
     * @param  {boolean}    [repeat=true]
     * @param  {boolean}    [smooth=false]
     * @return {Graphics}
     * @method
     * @public
     */
    beginBitmapFill (bitmap_data, matrix = null, repeat = true, smooth = false)
    {
        // end fill
        if (this._$doFill) {
            this.endFill();
        }

        if (!this._$fills) {
            this._$fills = Util.$getArray();
        }

        // start
        this._$maxAlpha = 1;
        this._$doFill   = true;
        this._$canDraw  = true;

        // beginPath
        this._$fills.push(Graphics.BEGIN_PATH);

        this._$fillType   = Graphics.BITMAP_FILL;
        this._$fillBitmap = new GraphicsBitmapFill(
            bitmap_data, matrix, repeat, smooth
        );

        return this;
    }

    /**
     * @description 描画のときに他の Graphics メソッド（lineTo() や drawCircle() など）
     *              に対する今後の呼び出しに使用する単純な一色塗りを指定します。
     *              Specifies a simple one-color fill that subsequent calls
     *              to other Graphics methods (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param  {string|number} [color=0]
     * @param  {number} [alpha=1.0]
     * @return {Graphics}
     * @method
     * @public
     */
    beginFill (color = 0, alpha = 1)
    {
        // end fill
        if (this._$doFill) {
            this.endFill();
        }

        if (!this._$fills) {
            this._$fills = Util.$getArray();
        }

        // valid
        color = Util.$clamp(Util.$toColorInt(color), 0, 0xffffff, 0);
        alpha = Util.$clamp(alpha, 0, 1, 1);

        // setup
        this._$maxAlpha = $Math.max(this._$maxAlpha, alpha);
        this._$doFill   = true;
        this._$canDraw  = true;

        // beginPath
        this._$fills.push(Graphics.BEGIN_PATH);

        // add Fill Style
        const object = Util.$intToRGBA(color, alpha);

        this._$fillType   = Graphics.FILL_STYLE;
        this._$fillStyleR = object.R;
        this._$fillStyleG = object.G;
        this._$fillStyleB = object.B;
        this._$fillStyleA = object.A;

        return this;
    }

    /**
     * @description Graphics の他のメソッド（lineTo()、drawCircle() など）に対する、
     *              オブジェクトの後続の呼び出しに使用するグラデーション塗りを指定します。
     *              Specifies a gradient fill used by subsequent calls
     *              to other Graphics methods (such as lineTo() or drawCircle()) for the object.
     *
     * @param  {string} type
     * @param  {array}  colors
     * @param  {array}  alphas
     * @param  {array}  ratios
     * @param  {Matrix} [matrix=null]
     * @param  {string} [spread_method=SpreadMethod.PAD]
     * @param  {string} [interpolation_method=InterpolationMethod.RGB]
     * @param  {number} [focal_point_ratio=0]
     * @return {Graphics}
     * @method
     * @public
     */
    beginGradientFill (
        type, colors, alphas, ratios, matrix = null,
        spread_method = SpreadMethod.PAD,
        interpolation_method = InterpolationMethod.RGB,
        focal_point_ratio = 0
    ) {

        if (this._$doFill) {
            this.endFill();
        }

        if (!this._$fills) {
            this._$fills = Util.$getArray();
        }

        // setup
        const length = alphas.length;
        for (let idx = 0; idx < length; ++idx) {
            this._$maxAlpha = $Math.max(this._$maxAlpha, alphas[idx]);
        }
        this._$doFill  = true;
        this._$canDraw = true;

        // beginPath
        this._$fills.push(Graphics.BEGIN_PATH);

        this._$fillType     = Graphics.GRADIENT_FILL;
        this._$fillGradient = new GraphicsGradientFill(
            type, colors, alphas, ratios, matrix,
            spread_method, interpolation_method,
            focal_point_ratio
        );

        return this;
    }

    /**
     * @description この Graphics オブジェクトに描画されているグラフィックをクリアし、
     *              塗りと線のスタイルの設定をリセットします。
     *              Clears the graphics that were drawn to this Graphics object,
     *              and resets fill and line style settings.
     *
     * @return {Graphics}
     * @method
     * @public
     */
    clear ()
    {
        // param clear
        this._$maxAlpha      = 0;
        this._$pointerX      = 0;
        this._$pointerY      = 0;
        this._$canDraw       = false;

        // fill
        this._$fillType      = 0;
        this._$fillGradient  = null;
        this._$fillBitmap    = null;
        this._$fillStyleR    = 0;
        this._$fillStyleG    = 0;
        this._$fillStyleB    = 0;
        this._$fillStyleA    = 0;
        this._$doFill        = false;

        // stroke
        this._$lineType      = 0;
        this._$lineGradient  = 0;
        this._$caps          = CapsStyle.NONE;
        this._$joints        = JointStyle.ROUND;
        this._$miterLimit    = 0;
        this._$lineWidth     = 1;
        this._$lineStyleR    = 0;
        this._$lineStyleG    = 0;
        this._$lineStyleB    = 0;
        this._$lineStyleA    = 0;
        this._$doLine        = false;

        // bounds size
        this._$xMin          = $Number.MAX_VALUE;
        this._$xMax          = -$Number.MAX_VALUE;
        this._$yMin          = $Number.MAX_VALUE;
        this._$yMax          = -$Number.MAX_VALUE;

        // init array
        if (this._$recode) {
            Util.$poolArray(this._$recode);
        }
        if (this._$fills) {
            Util.$poolArray(this._$fills);
        }
        if (this._$lines) {
            Util.$poolArray(this._$lines);
        }

        this._$recode = null;
        this._$fills  = null;
        this._$lines  = null;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description すべての描画コマンドをソース Graphics オブジェクトから、呼び出し Graphics オブジェクトにコピーします。
     *              Copies all of drawing commands from the source Graphics object into the calling Graphics object.
     *
     * @return {Graphics}
     * @method
     * @public
     */
    clone ()
    {
        const graphics = new Graphics();
        graphics.copyFrom(this);
        return graphics;
    }

    /**
     * @description すべての描画コマンドをソース Graphics オブジェクトから、呼び出し Graphics オブジェクトにコピーします。
     *              Copies all of drawing commands from the source Graphics object into the calling Graphics object.
     *
     * @param  {Graphics} graphics
     * @return {void}
     * @method
     * @public
     */
    copyFrom (graphics)
    {
        if (!(graphics instanceof Graphics)) {
            return ;
        }

        if (graphics._$fillGradient) {
            this._$fillGradient = graphics._$fillGradient.clone();
        }

        if (graphics._$fillBitmap) {
            this._$fillBitmap = graphics._$fillBitmap.clone();
        }

        // fill
        this._$doFill       = graphics._$doFill;
        this._$fillType     = graphics._$fillType;
        this._$fillStyleR   = graphics._$fillStyleR;
        this._$fillStyleG   = graphics._$fillStyleG;
        this._$fillStyleB   = graphics._$fillStyleB;
        this._$fillStyleA   = graphics._$fillStyleA;

        if (graphics._$lineGradient) {
            this._$lineGradient = graphics._$lineGradient.clone();
        }

        // stroke
        this._$doLine       = graphics._$doLine;
        this._$lineType     = graphics._$lineType;
        this._$caps         = graphics._$caps;
        this._$joints       = graphics._$joints;
        this._$miterLimit   = graphics._$miterLimit;
        this._$lineWidth    = graphics._$lineWidth;
        this._$lineStyleR   = graphics._$lineStyleR;
        this._$lineStyleG   = graphics._$lineStyleG;
        this._$lineStyleB   = graphics._$lineStyleB;
        this._$lineStyleA   = graphics._$lineStyleA;

        // bounds
        this._$xMin         = graphics._$xMin;
        this._$xMax         = graphics._$xMax;
        this._$yMin         = graphics._$yMin;
        this._$yMax         = graphics._$yMax;

        // params
        this._$maxAlpha     = graphics._$maxAlpha;
        this._$pointerX     = graphics._$pointerX;
        this._$pointerY     = graphics._$pointerY;
        this._$canDraw      = graphics._$canDraw;

        // path params
        if (graphics._$fills) {
            this._$fills = graphics._$fills.slice(0);
        }
        if (graphics._$lines) {
            this._$lines = graphics._$lines.slice(0);
        }
        if (graphics._$recode) {
            this._$recode = graphics._$recode.slice(0);
        }
    }

    /**
     * @description 現在の描画位置から指定されたアンカーポイントに 3 次ベジェ曲線を描画します。
     *              Draws a cubic Bezier curve from the current drawing position to the specified anchor point.
     *
     * @param  {number} control_x1
     * @param  {number} control_y1
     * @param  {number} control_x2
     * @param  {number} control_y2
     * @param  {number} anchor_x
     * @param  {number} anchor_y
     * @return {Graphics}
     * @method
     * @public
     */
    cubicCurveTo (
        control_x1, control_y1, control_x2, control_y2,
        anchor_x, anchor_y
    ) {

        anchor_x = +anchor_x || 0;
        anchor_y = +anchor_y || 0;

        if (this._$pointerX === anchor_x && this._$pointerY === anchor_y) {
            return this;
        }

        control_x1 = +control_x1 || 0;
        control_y1 = +control_y1 || 0;
        control_x2 = +control_x2 || 0;
        control_y2 = +control_y2 || 0;

        // set bounds
        this._$setBounds(control_x1, control_y1);
        this._$setBounds(control_x2, control_y2);
        this._$setBounds(anchor_x, anchor_y);

        this._$margePath(Util.$getArray(
            Graphics.CUBIC,
            control_x1, control_y1,
            control_x2, control_y2,
            anchor_x, anchor_y
        ));

        this._$pointerX = anchor_x;
        this._$pointerY = anchor_y;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description (controlX, controlY) で指定されたコントロールポイントを使用し、
     *              現在の描画位置から (anchorX, anchorY) まで、現在の線のスタイルで 2 次ベジェ曲線を描画します。
     *              Draws a quadratic Bezier curve using the current line style from
     *              the current drawing position to (anchorX, anchorY)
     *              and using the control point that (controlX, controlY) specifies.
     *
     * @param  {number} control_x
     * @param  {number} control_y
     * @param  {number} anchor_x
     * @param  {number} anchor_y
     * @return {Graphics}
     * @method
     * @public
     */
    curveTo (control_x, control_y, anchor_x, anchor_y)
    {

        anchor_x = +anchor_x || 0;
        anchor_y = +anchor_y || 0;

        if (this._$pointerX === anchor_x && this._$pointerY === anchor_y) {
            return this;
        }

        control_x = +control_x || 0;
        control_y = +control_y || 0;

        this._$setBounds(control_x, control_y);
        this._$setBounds(anchor_x,  anchor_y);

        this._$margePath(Util.$getArray(
            Graphics.CURVE_TO,
            control_x, control_y,
            anchor_x, anchor_y
        ));

        this._$pointerX = anchor_x;
        this._$pointerY = anchor_y;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description 円を描画します。
     *              Draws a circle.
     *
     * @param  {number} x
     * @param  {number} y
     * @param  {number} radius
     * @return {Graphics}
     * @method
     * @public
     */
    drawCircle (x, y, radius)
    {
        x      = +x || 0;
        y      = +y || 0;
        radius = +radius || 0;

        this._$setBounds(x - radius, y - radius);
        this._$setBounds(x + radius, y + radius);

        this._$margePath(Util.$getArray(
            Graphics.MOVE_TO, x + radius, y,
            Graphics.ARC, x, y, radius
        ));

        this._$pointerX = x;
        this._$pointerY = y;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description 楕円を描画します。
     *              Draws an ellipse.
     *
     * @param  {number} x
     * @param  {number} y
     * @param  {number} width
     * @param  {number} height
     * @return {Graphics}
     * @method
     * @public
     */
    drawEllipse (x, y, width, height)
    {
        x = +x || 0;
        y = +y || 0;
        width  = +width  || 0;
        height = +height || 0;

        const hw = width  / 2; // half width
        const hh = height / 2; // half height
        const x0 = x + hw;
        const y0 = y + hh;
        const x1 = x + width;
        const y1 = y + height;
        const c  = 4 / 3 * ($Math.SQRT2 - 1);
        const cw = c * hw;
        const ch = c * hh;

        return this
            .moveTo(x0, y)
            .cubicCurveTo(x0 + cw, y,       x1,      y0 - ch, x1, y0)
            .cubicCurveTo(x1,      y0 + ch, x0 + cw, y1,      x0, y1)
            .cubicCurveTo(x0 - cw, y1,      x,       y0 + ch, x,  y0)
            .cubicCurveTo(x,       y0 - ch, x0 - cw, y,       x0, y );
    }

    /**
     * @description 矩形を描画します。
     *              Draws a rectangle.
     *
     * @param  {number} x
     * @param  {number} y
     * @param  {number} width
     * @param  {number} height
     * @return {Graphics}
     * @method
     * @public
     */
    drawRect (x, y, width, height)
    {
        // valid
        x = +x || 0;
        y = +y || 0;

        width  = +width  || 0;
        height = +height || 0;

        const xMax = x + width;
        const yMax = y + height;

        return this
            .moveTo(x,    y)
            .lineTo(x,    yMax)
            .lineTo(xMax, yMax)
            .lineTo(xMax, y)
            .lineTo(x,    y);
    }

    /**
     * @description 角丸矩形を描画します。
     *              Draws a rounded rectangle.
     *
     * @param  {number} x
     * @param  {number} y
     * @param  {number} width
     * @param  {number} height
     * @param  {number} ellipse_width
     * @param  {number} [ellipse_height=NaN]
     * @return {Graphics}
     * @method
     * @public
     */
    drawRoundRect (
        x, y, width, height, ellipse_width, ellipse_height = NaN
    ) {

        x = +x || 0;
        y = +y || 0;

        width  = +width  || 0;
        height = +height || 0;

        ellipse_width  = +ellipse_width  || 0;
        ellipse_height = +ellipse_height || ellipse_width;

        const hew = ellipse_width  / 2;
        const heh = ellipse_height / 2;
        const c   = 4 / 3 * ($Math.SQRT2 - 1);
        const cw  = c * hew;
        const ch  = c * heh;

        const dx0 = x   + hew;
        const dx1 = x   + width;
        const dx2 = dx1 - hew;

        const dy0 = y   + heh;
        const dy1 = y   + height;
        const dy2 = dy1 - heh;

        return this
            .moveTo(dx0, y)
            .lineTo(dx2, y)
            .cubicCurveTo(dx2 + cw, y, dx1, dy0 - ch, dx1, dy0)
            .lineTo(dx1, dy2)
            .cubicCurveTo(dx1, dy2 + ch, dx2 + cw, dy1, dx2, dy1)
            .lineTo(dx0, dy1)
            .cubicCurveTo(dx0 - cw, dy1, x, dy2 + ch, x, dy2)
            .lineTo(x, dy0)
            .cubicCurveTo(x, dy0 - ch, dx0 - cw, y, dx0, y);
    }

    /**
     * @description beginFill()、beginGradientFill()、または beginBitmapFill() メソッドへの
     *              最後の呼び出し以降に追加された線と曲線に塗りを適用します。
     *              Applies a fill to the lines and curves that were added since
     *              the last call to the beginFill(), beginGradientFill(),
     *              or beginBitmapFill() method.
     *
     * @return {Graphics}
     * @method
     * @public
     */
    endFill ()
    {
        if (this._$doFill && this._$fills.length > 6) {

            if (!this._$recode) {
                this._$recode = Util.$getArray();
            }

            if (this._$fills[2] !== this._$fills[this._$fills.length - 2]
                || this._$fills[3] !== this._$fills[this._$fills.length - 1]
            ) {
                this._$fills.push(
                    Graphics.LINE_TO,
                    this._$fills[2],
                    this._$fills[3]
                );
            }
            this._$recode.push.apply(this._$recode, this._$fills);

            // fill
            switch (this._$fillType) {

                case Graphics.FILL_STYLE:
                    this._$recode.push(
                        this._$fillType,
                        this._$fillStyleR,
                        this._$fillStyleG,
                        this._$fillStyleB,
                        this._$fillStyleA,
                        Graphics.END_FILL
                    );
                    break;

                case Graphics.GRADIENT_FILL:
                    this._$recode.push(this._$fillType);
                    this._$recode.push.apply(
                        this._$recode, this._$fillGradient.toArray()
                    );
                    break;

                case Graphics.BITMAP_FILL:
                    this._$recode.push(this._$fillType);
                    this._$recode.push.apply(
                        this._$recode, this._$fillBitmap.toArray()
                    );
                    break;

            }

        }

        if (this._$fills) {
            Util.$poolArray(this._$fills);
            this._$fills = null;
        }

        // reset
        this._$fillType     = 0;
        this._$fillGradient = null;
        this._$fillBitmap   = null;
        this._$fillStyleR   = 0;
        this._$fillStyleG   = 0;
        this._$fillStyleB   = 0;
        this._$fillStyleA   = 0;
        this._$doFill       = false;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description lineStyle()、または lineGradientStyle() メソッドへの
     *              最後の呼び出し以降に追加された線と曲線に塗りを適用します。
     *              Applies a fill to the lines and curves that were added since
     *              the last call to the beginFill() or beginGradientFill() method.
     *
     * @return {Graphics}
     * @method
     * @public
     */
    endLine ()
    {
        if (this._$doLine) {

            if (!this._$recode) {
                this._$recode = Util.$getArray();
            }

            this._$recode.push.apply(this._$recode, this._$lines);

            // clear
            Util.$poolArray(this._$lines);
            this._$lines = null;

            // fill
            switch (this._$lineType) {

                case Graphics.STROKE_STYLE:
                    this._$recode.push(
                        this._$lineType,
                        this._$lineWidth,
                        this._$caps,
                        this._$joints,
                        this._$miterLimit,
                        this._$lineStyleR,
                        this._$lineStyleG,
                        this._$lineStyleB,
                        this._$lineStyleA,
                        Graphics.END_STROKE
                    );
                    break;

                case Graphics.GRADIENT_STROKE:
                    this._$recode.push(
                        this._$lineType,
                        this._$lineWidth,
                        this._$caps,
                        this._$joints,
                        this._$miterLimit
                    );
                    this._$recode.push.apply(
                        this._$recode, this._$lineGradient.toArray()
                    );
                    break;

                case Graphics.BITMAP_STROKE:
                    this._$recode.push(
                        this._$lineType,
                        this._$lineWidth,
                        this._$caps,
                        this._$joints,
                        this._$miterLimit
                    );
                    this._$recode.push.apply(
                        this._$recode, this._$fillBitmap.toArray()
                    );
                    break;

            }
        }

        // reset
        this._$lineType     = 0;
        this._$lineWidth    = 0;
        this._$lineGradient = null;
        this._$lineStyleR   = 0;
        this._$lineStyleG   = 0;
        this._$lineStyleB   = 0;
        this._$lineStyleA   = 0;
        this._$caps         = CapsStyle.NONE;
        this._$joints       = JointStyle.ROUND;
        this._$miterLimit   = 0;
        this._$doLine       = false;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description 線の描画で、線として使用するビットマップを指定します。
     *              Specifies a bitmap to use for the line stroke when drawing lines.
     *
     * @param  {BitmapData} bitmap_data
     * @param  {Matrix}     [matrix=null]
     * @param  {boolean}    [repeat=true]
     * @param  {boolean}    [smooth=false]
     * @return {Graphics}
     * @method
     * @public
     */
    lineBitmapStyle (bitmap_data, matrix = null, repeat = true, smooth = false)
    {
        // end fill
        if (this._$doLine) {
            this.endLine();
        }

        if (!this._$lines) {
            this._$lines = Util.$getArray();
        }

        // start
        this._$maxAlpha = 1;
        this._$doLine   = true;
        this._$canDraw  = true;

        // beginPath
        this._$lines.push(Graphics.BEGIN_PATH);

        this._$lineType   = Graphics.BITMAP_STROKE;
        this._$fillBitmap = new GraphicsBitmapFill(
            bitmap_data, matrix, repeat, smooth
        );

        return this;
    }

    /**
     * @description 線の描画で使用するグラデーションを指定します。
     *              Specifies a gradient to use for the stroke when drawing lines.
     *
     * @param  {string} type
     * @param  {array}  colors
     * @param  {array}  alphas
     * @param  {array}  ratios
     * @param  {Matrix} [matrix=null]
     * @param  {string} [spread_method=SpreadMethod.PAD]
     * @param  {string} [interpolation_method=InterpolationMethod.RGB]
     * @param  {number} [focal_point_ratio=0]
     * @return {Graphics}
     * @method
     * @public
     */
    lineGradientStyle (
        type, colors, alphas, ratios, matrix = null,
        spread_method = SpreadMethod.PAD,
        interpolation_method = InterpolationMethod.RGB,
        focal_point_ratio = 0
    ) {

        if (!this._$doLine) {
            return this;
        }

        if (!this._$lines) {
            this._$lines = Util.$getArray();
        }

        // setup
        const length = alphas.length;
        for (let idx = 0; idx < length; ++idx) {
            this._$maxAlpha = $Math.max(this._$maxAlpha, alphas[idx]);
        }

        // beginPath
        this._$lines.push(Graphics.BEGIN_PATH);

        this._$lineType     = Graphics.GRADIENT_STROKE;
        this._$lineGradient = new GraphicsGradientFill(
            type, colors, alphas, ratios, matrix,
            spread_method, interpolation_method,
            focal_point_ratio
        );

        return this;
    }

    /**
     * @description lineTo() メソッドや drawCircle() メソッドなど、
     *              Graphics のメソッドの後続の呼び出しに使用する線スタイルを指定します。
     *              Specifies a line style used for subsequent calls
     *              to Graphics methods such as the lineTo() method
     *              or the drawCircle() method.
     *
     * @param  {number}  [thickness=NaN]
     * @param  {number|string} [color=0]
     * @param  {number}  [alpha=1]
     * @param  {string}  [caps=CapsStyle.NONE]
     * @param  {string}  [joints=JointStyle.ROUND]
     * @param  {number}  [miter_limit=3]
     * @return {Graphics}
     * @method
     * @public
     */
    lineStyle (
        thickness = 1, color = 0, alpha = 1,
        caps = CapsStyle.ROUND, joints = JointStyle.ROUND, miter_limit = 3
    ) {

        if (this._$doLine) {
            this.endLine();
        }

        if (!this._$lines) {
            this._$lines = Util.$getArray();
        }

        color = Util.$clamp(Util.$toColorInt(color), 0, 0xffffff, 0);
        alpha = Util.$clamp(+alpha, 0, 1, 1);

        // setup
        this._$maxAlpha = $Math.max(this._$maxAlpha, alpha);
        this._$doLine   = true;
        this._$canDraw  = true;

        // beginPath
        this._$lines.push(
            Graphics.BEGIN_PATH,
            Graphics.MOVE_TO,
            this._$pointerX,
            this._$pointerY
        );

        // add Fill Style
        const object = Util.$intToRGBA(color, alpha);

        // color
        this._$lineType   = Graphics.STROKE_STYLE;
        this._$lineStyleR = object.R;
        this._$lineStyleG = object.G;
        this._$lineStyleB = object.B;
        this._$lineStyleA = object.A;

        // param
        this._$lineWidth  = thickness;
        this._$caps       = `${caps}`;
        this._$joints     = `${joints}`;

        // set miter limit
        if (this._$joints === JointStyle.MITER) {
            this._$miterLimit = miter_limit;
        }

        return this;
    }

    /**
     * @description 現在の描画位置から (x, y) まで、現在の線のスタイルを使用して線を描画します。
     *              その後で、現在の描画位置は (x, y) に設定されます。
     *              Draws a line using the current line style from the current drawing position to (x, y);
     *              the current drawing position is then set to (x, y).
     *
     * @param   {number} x
     * @param   {number} y
     * @returns {Graphics}
     * @method
     * @public
     */
    lineTo (x, y)
    {
        x = +x || 0;
        y = +y || 0;

        if (this._$pointerX === x && this._$pointerY === y) {
            return this;
        }

        this._$setBounds(x, y);

        this._$margePath(Util.$getArray(Graphics.LINE_TO, x, y));

        this._$pointerX = x;
        this._$pointerY = y;

        // restart
        this._$restart();

        return this;
    }

    /**
     * @description 現在の描画位置を (x, y) に移動します。
     *              Moves the current drawing position to (x, y).
     *
     * @param   {number} x
     * @param   {number} y
     * @returns {Graphics}
     * @method
     * @public
     */
    moveTo (x, y)
    {
        x = +x || 0;
        y = +y || 0;

        this._$pointerX = x;
        this._$pointerY = y;

        this._$setBounds(x, y);

        this._$margePath(Util.$getArray(Graphics.MOVE_TO, x, y));

        // restart
        this._$restart();

        return this;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @return void
     * @private
     */
    _$clip (context, matrix)
    {
        // size
        const baseBounds = this._$getBounds();

        const bounds = Util.$boundsMatrix(baseBounds, matrix);
        let width    = $Math.ceil($Math.abs(bounds.xMax - bounds.xMin));
        let height   = $Math.ceil($Math.abs(bounds.yMax - bounds.yMin));
        Util.$poolBoundsObject(baseBounds);
        Util.$poolBoundsObject(bounds);

        switch (true) {

            case width === 0:
            case height === 0:
            case width === -Util.$Infinity:
            case height === -Util.$Infinity:
            case width === Util.$Infinity:
            case height === Util.$Infinity:
                return;

            default:
                break;

        }

        Util.$resetContext(context);
        context.setTransform(
            matrix[0], matrix[1], matrix[2],
            matrix[3], matrix[4], matrix[5]
        );
        this._$doDraw(context, Util.$COLOR_ARRAY_IDENTITY, true);

        context.clip();
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @param  {string} [blend_mode=BlendMode.NORMAL]
     * @param  {array}  [filters=null]
     * @return {void}
     * @method
     * @private
     */
    _$drawBitmap (
        context, matrix, color_transform,
        blend_mode = BlendMode.NORMAL, filters = null
    ) {

        if (!this._$maxAlpha) {
            return ;
        }

        const alpha = Util.$clamp(
            color_transform[3] + color_transform[7] / 255, 0, 1
        );

        const displayObject = this._$displayObject;

        let multiMatrix = matrix;
        const rawMatrix = displayObject._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        // size
        const baseBounds = this._$getBounds();
        const bounds = Util.$boundsMatrix(baseBounds, multiMatrix);
        const xMax   = bounds.xMax;
        const xMin   = bounds.xMin;
        const yMax   = bounds.yMax;
        const yMin   = bounds.yMin;
        Util.$poolBoundsObject(bounds);
        Util.$poolBoundsObject(baseBounds);

        let width  = $Math.ceil($Math.abs(xMax - xMin));
        let height = $Math.ceil($Math.abs(yMax - yMin));

        switch (true) {

            case width === 0:
            case height === 0:
            case width === -Util.$Infinity:
            case height === -Util.$Infinity:
            case width === Util.$Infinity:
            case height === Util.$Infinity:
                return;

            default:
                break;

        }

        // cache current buffer
        const currentAttachment = context.frameBuffer.currentAttachment;
        if (xMin > currentAttachment.width || yMin > currentAttachment.height) {
            return;
        }

        const xScale = $Math.sqrt(multiMatrix[0] * multiMatrix[0] + multiMatrix[1] * multiMatrix[1]);
        const yScale = $Math.sqrt(multiMatrix[2] * multiMatrix[2] + multiMatrix[3] * multiMatrix[3]);
        if (0 > xMin + width || 0 > yMin + height) {

            if (filters && filters.length
                && displayObject._$canApply(filters)
            ) {

                let rect = new Rectangle(0, 0, width, height);
                for (let idx = 0; idx < filters.length ; ++idx) {
                    rect = filters[idx]._$generateFilterRect(rect, xScale, yScale);
                }

                if (0 > rect.x + rect.width || 0 > rect.y + rect.height) {
                    return;
                }

            } else {
                return;
            }

        }

        // get cache
        const keys = Util.$getArray(
            multiMatrix[0], multiMatrix[1],
            multiMatrix[2], multiMatrix[3]
        );

        const cacheKeys = Util
            .$cacheStore()
            .generateKeys(displayObject._$instanceId, keys, color_transform);

        Util.$poolArray(keys);

        // cache
        let texture = Util.$cacheStore().get(cacheKeys);
        if (!texture) {

            // resize
            const textureScale = context._$textureScale(width, height);
            if (textureScale < 1) {
                width  *= textureScale;
                height *= textureScale;
            }

            // create cache buffer
            const buffer = context
                .frameBuffer
                .createCacheAttachment(width, height, true);
            context._$bind(buffer);

            // reset
            Util.$resetContext(context);

            // plain alpha
            color_transform[3] = 1;

            const hw = width  / 2;
            const hh = height / 2;

            const ratio = Util.$devicePixelRatio;
            const ratioMatrix = Util.$getFloat32Array6(
                1 / ratio, 0, 0, 1 / ratio
            );
            const parentMatrix = Util.$getFloat32Array6(
                matrix[0], matrix[1], matrix[2], matrix[3], 0, 0
            );
            const baseMatrix = Util.$multiplicationMatrix(
                ratioMatrix, parentMatrix
            );
            Util.$poolFloat32Array6(ratioMatrix);
            Util.$poolFloat32Array6(parentMatrix);

            const childMatrix = Util.$getFloat32Array6(
                1, 0, 0, 1, -hw, -hh
            );
            const multiMatrix = Util.$multiplicationMatrix(
                baseMatrix, childMatrix
            );
            Util.$poolFloat32Array6(baseMatrix);
            Util.$poolFloat32Array6(childMatrix);

            Util.$resetContext(context);
            context.setTransform(
                matrix[0], matrix[1], matrix[2], matrix[3],
                multiMatrix[4] + hw,
                multiMatrix[5] + hh
            );
            Util.$poolFloat32Array6(multiMatrix);

            context.beginPath();
            this._$runTransformCommand(context, rawMatrix, color_transform);

            texture = context
                .frameBuffer
                .getTextureFromCurrentAttachment();

            // set cache
            Util.$cacheStore().set(cacheKeys, texture);

            // release buffer
            context
                .frameBuffer
                .releaseAttachment(buffer, false);

            // end draw and reset current buffer
            context._$bind(currentAttachment);

        }
        Util.$poolArray(cacheKeys);

        if (filters && filters.length && displayObject._$canApply(filters)) {

            const filterTexture = displayObject._$drawFilter(
                context, texture, matrix,
                filters, width, height
            );

            // reset
            Util.$resetContext(context);

            // draw
            context._$globalAlpha = alpha;
            context._$imageSmoothingEnabled = true;
            context._$globalCompositeOperation = blend_mode;

            context.setTransform(1, 0, 0, 1,
                xMin - filterTexture._$offsetX,
                yMin - filterTexture._$offsetY
            );
            context.drawImage(filterTexture,
                0, 0, filterTexture.width, filterTexture.height,
                color_transform
            );

        } else {

            // reset
            Util.$resetContext(context);

            // draw
            context._$globalAlpha = alpha;
            context._$imageSmoothingEnabled = true;
            context._$globalCompositeOperation = blend_mode;

            context.setTransform(1, 0, 0, 1, 0, 0);
            context.drawImage(texture,
                xMin, yMin, width, height, color_transform
            );
        }

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @param  {string} [blend_mode=BlendMode.NORMAL]
     * @param  {array}  [filters=null]
     * @return {void}
     * @method
     * @private
     */
    _$draw (
        context, matrix, color_transform,
        blend_mode = BlendMode.NORMAL, filters = null
    ) {

        if (!this._$maxAlpha) {
            return ;
        }

        const alpha = Util.$clamp(
            color_transform[3] + color_transform[7] / 255, 0, 1
        );

        const displayObject = this._$displayObject;

        // set grid data
        let hasGrid = displayObject._$scale9Grid !== null;

        // 9スライスを有効にしたオブジェクトが回転・傾斜成分を含む場合は
        // 9スライスは無効になる
        let parentMatrix = null;
        if (hasGrid) {
            parentMatrix = displayObject._$transform._$rawMatrix();
            hasGrid = hasGrid
                && $Math.abs(parentMatrix[1]) < 0.001
                && $Math.abs(parentMatrix[2]) < 0.0001;
        }

        // size
        const baseBounds = this._$getBounds();
        const bounds = Util.$boundsMatrix(baseBounds, matrix);
        const xMax   = bounds.xMax;
        const xMin   = bounds.xMin;
        const yMax   = bounds.yMax;
        const yMin   = bounds.yMin;
        Util.$poolBoundsObject(bounds);

        let width  = $Math.ceil($Math.abs(xMax - xMin));
        let height = $Math.ceil($Math.abs(yMax - yMin));
        switch (true) {

            case width === 0:
            case height === 0:
            case width === -Util.$Infinity:
            case height === -Util.$Infinity:
            case width === Util.$Infinity:
            case height === Util.$Infinity:
                return;

            default:
                break;

        }

        // cache current buffer
        const currentAttachment = context.frameBuffer.currentAttachment;
        if (xMin > currentAttachment.width || yMin > currentAttachment.height) {
            return;
        }

        let xScale = +$Math.sqrt(
            matrix[0] * matrix[0]
            + matrix[1] * matrix[1]
        );
        if (!$Number.isInteger(xScale)) {
            const value = xScale.toString();
            const index = value.indexOf("e");
            if (index !== -1) {
                xScale = +value.slice(0, index);
            }
            xScale = +xScale.toFixed(4);
        }

        let yScale = +$Math.sqrt(
            matrix[2] * matrix[2]
            + matrix[3] * matrix[3]
        );
        if (!$Number.isInteger(yScale)) {
            const value = yScale.toString();
            const index = value.indexOf("e");
            if (index !== -1) {
                yScale = +value.slice(0, index);
            }
            yScale = +yScale.toFixed(4);
        }

        if (0 > xMin + width || 0 > yMin + height) {

            if (filters && filters.length && displayObject._$canApply(filters)) {

                let rect = new Rectangle(0, 0, width, height);
                for (let idx = 0; idx < filters.length ; ++idx) {
                    rect = filters[idx]._$generateFilterRect(rect, xScale, yScale);
                }

                if (0 > rect.x + rect.width || 0 > rect.y + rect.height) {
                    return;
                }

            } else {
                return;
            }

        }

        // get cache
        const keys = Util.$getArray(xScale, yScale);

        let uniqueId = displayObject._$instanceId;
        if (!hasGrid
            && displayObject._$loaderInfo
            && displayObject._$characterId
        ) {
            uniqueId = `${displayObject._$loaderInfo._$id}@${displayObject._$characterId}`;
        }

        const cacheStore = Util.$cacheStore();
        const cacheKeys  = cacheStore.generateKeys(
            uniqueId, keys, color_transform
        );

        Util.$poolArray(keys);

        // cache
        let texture = cacheStore.get(cacheKeys);
        if (!texture) {

            // resize
            let width  = $Math.ceil($Math.abs(baseBounds.xMax - baseBounds.xMin) * xScale);
            let height = $Math.ceil($Math.abs(baseBounds.yMax - baseBounds.yMin) * yScale);
            const textureScale = context._$textureScale(width, height);
            if (textureScale < 1) {
                width  *= textureScale;
                height *= textureScale;
            }

            // create cache buffer
            const buffer = context
                .frameBuffer
                .createCacheAttachment(width, height, true);
            context._$bind(buffer);

            // reset
            Util.$resetContext(context);
            context.setTransform(
                xScale, 0, 0, yScale,
                -baseBounds.xMin * xScale,
                -baseBounds.yMin * yScale
            );

            if (hasGrid) {

                const player = Util.$currentPlayer();
                const mScale = player._$scale * player._$ratio;
                const baseMatrix = Util.$getFloat32Array6(mScale, 0, 0, mScale, 0, 0);

                const pMatrix = Util.$multiplicationMatrix(
                    baseMatrix, parentMatrix
                );

                Util.$poolFloat32Array6(baseMatrix);

                const aMatrixBase = displayObject
                    ._$parent
                    ._$transform
                    .concatenatedMatrix
                    ._$matrix;

                const aMatrix = Util.$getFloat32Array6(
                    aMatrixBase[0], aMatrixBase[1], aMatrixBase[2], aMatrixBase[3],
                    aMatrixBase[4] * mScale - xMin,
                    aMatrixBase[5] * mScale - yMin
                );

                const apMatrix = Util.$multiplicationMatrix(aMatrix, pMatrix);
                const aOffsetX = apMatrix[4] - (matrix[4] - xMin);
                const aOffsetY = apMatrix[5] - (matrix[5] - yMin);
                Util.$poolFloat32Array6(apMatrix);

                const parentBounds = Util.$boundsMatrix(baseBounds, pMatrix);
                const parentXMax   = +parentBounds.xMax;
                const parentXMin   = +parentBounds.xMin;
                const parentYMax   = +parentBounds.yMax;
                const parentYMin   = +parentBounds.yMin;
                const parentWidth  = $Math.ceil($Math.abs(parentXMax - parentXMin));
                const parentHeight = $Math.ceil($Math.abs(parentYMax - parentYMin));

                Util.$poolBoundsObject(parentBounds);

                context.grid.enable(
                    parentXMin, parentYMin, parentWidth, parentHeight,
                    baseBounds, displayObject._$scale9Grid,
                    pMatrix[0], pMatrix[1], pMatrix[2], pMatrix[3], pMatrix[4], pMatrix[5],
                    aMatrix[0], aMatrix[1], aMatrix[2], aMatrix[3], aMatrix[4] - aOffsetX, aMatrix[5] - aOffsetY
                );

                Util.$poolFloat32Array6(pMatrix);
                Util.$poolFloat32Array6(aMatrix);
            }

            // plain alpha
            color_transform[3] = 1;
            this._$doDraw(context, color_transform, false);

            if (hasGrid) {
                context.grid.disable();
            }

            texture = context
                .frameBuffer
                .getTextureFromCurrentAttachment();

            // set cache
            cacheStore.set(cacheKeys, texture);

            // release buffer
            context
                .frameBuffer
                .releaseAttachment(buffer, false);

            // end draw and reset current buffer
            context._$bind(currentAttachment);
        }

        // pool
        Util.$poolArray(cacheKeys);
        Util.$poolBoundsObject(baseBounds);

        if (filters && filters.length) {

            const canApply = displayObject._$canApply(filters);
            if (canApply) {

                const filterTexture = displayObject._$drawFilter(
                    context, texture, matrix,
                    filters, width, height
                );

                // reset
                Util.$resetContext(context);

                // draw
                context._$globalAlpha = alpha;
                context._$imageSmoothingEnabled = true;
                context._$globalCompositeOperation = blend_mode;

                context.setTransform(1, 0, 0, 1,
                    xMin - filterTexture._$offsetX,
                    yMin - filterTexture._$offsetY
                );
                context.drawImage(filterTexture,
                    0, 0, filterTexture.width, filterTexture.height,
                    color_transform
                );

                return ;
            }
        }

        // reset
        Util.$resetContext(context);

        // draw
        context._$globalAlpha = alpha;
        context._$imageSmoothingEnabled = true;
        context._$globalCompositeOperation = blend_mode;

        const radianX = $Math.atan2(matrix[1], matrix[0]);
        const radianY = $Math.atan2(-matrix[2], matrix[3]);
        if (radianX || radianY) {

            const tx = baseBounds.xMin * xScale;
            const ty = baseBounds.yMin * yScale;

            context.setTransform(
                $Math.cos(radianX),
                $Math.sin(radianX),
                -$Math.sin(radianY),
                $Math.cos(radianY),
                tx * $Math.cos(radianX) - ty * $Math.sin(radianY) + matrix[4],
                tx * $Math.sin(radianX) + ty * $Math.cos(radianY) + matrix[5]
            );

        } else {

            context.setTransform(1, 0, 0, 1, xMin, yMin);

        }

        context.drawImage(texture,
            0, 0, texture.width, texture.height, color_transform
        );
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array}         color_transform
     * @param  {boolean}              [is_clip=false]
     * @return {void}
     * @method
     * @private
     */
    _$doDraw (context, color_transform, is_clip = false)
    {
        // draw
        Util.$resetContext(context);

        context.beginPath();
        this._$runCommand(context, color_transform, is_clip);
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object}  options
     * @param  {boolean} [is_clip=false]
     * @return {boolean}
     * @method
     * @private
     */
    _$hit (context, matrix, options, is_clip = false)
    {
        context.beginPath();
        context.setTransform(
            matrix[0], matrix[1], matrix[2],
            matrix[3], matrix[4], matrix[5]
        );
        return this._$runCommand(context, null, is_clip, options);
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$getBounds ()
    {
        const displayObject = this._$displayObject;
        if (displayObject && displayObject._$bounds) {
            return Util.$getBoundsObject(
                displayObject._$bounds.xMin, displayObject._$bounds.xMax,
                displayObject._$bounds.yMin, displayObject._$bounds.yMax
            );
        }

        return Util.$getBoundsObject(
            this._$xMin, this._$xMax,
            this._$yMin, this._$yMax
        );
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$restart ()
    {
        if (this._$displayObject
            && !this._$displayObject._$isUpdated()
        ) {

            this._$displayObject._$doChanged();
            Util.$isUpdated = true;

            Util
                .$cacheStore()
                .removeCache(this._$displayObject._$instanceId);

            if (this._$displayObject._$characterId) {
                Util
                    .$cacheStore()
                    .removeCache(this._$displayObject._$characterId);
            }
        }
    }

    /**
     * @param  {number} [x=0]
     * @param  {number} [y=0]
     * @return {void}
     * @method
     * @private
     */
    _$setBounds (x = 0, y = 0)
    {
        this._$setFillBounds(x, y);
        if (this._$doLine) {
            this._$setLineBounds(x, y);
        }
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @method
     * @private
     */
    _$setFillBounds (x, y)
    {
        this._$xMin = $Math.min(this._$xMin, x);
        this._$xMax = $Math.max(this._$xMax, x);
        this._$yMin = $Math.min(this._$yMin, y);
        this._$yMax = $Math.max(this._$yMax, y);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {void}
     * @method
     * @private
     */
    _$setLineBounds (x, y)
    {
        this._$xMin = $Math.min(this._$xMin, $Math.min(x, this._$pointerX));
        this._$xMax = $Math.max(this._$xMax, $Math.max(x, this._$pointerX));
        this._$yMin = $Math.min(this._$yMin, $Math.min(y, this._$pointerY));
        this._$yMax = $Math.max(this._$yMax, $Math.max(y, this._$pointerY));

        // correction
        const half     = this._$lineWidth / 2;
        const radian90 = 0.5 * $Math.PI;
        const radian1  = $Math.atan2(y - this._$pointerY, x - this._$pointerX); // to end point
        const radian2  = $Math.atan2(this._$pointerY - y, this._$pointerX - x); // to start point
        const radian3  = radian1 + radian90;
        const radian4  = radian1 - radian90;
        const radian5  = radian2 + radian90;
        const radian6  = radian2 - radian90;

        // init
        let x1 = x + half;
        let x2 = -half + x;
        let x3 = this._$pointerX + half;
        let x4 = -half + this._$pointerX;
        let y1 = y + half;
        let y2 = -half + y;
        let y3 = this._$pointerY + half;
        let y4 = -half + this._$pointerY;

        this._$xMin = $Math.min(this._$xMin, $Math.min(x1, $Math.min(x2, $Math.min(x3, x4))));
        this._$xMax = $Math.max(this._$xMax, $Math.max(x1, $Math.max(x2, $Math.max(x3, x4))));
        this._$yMin = $Math.min(this._$yMin, $Math.min(y1, $Math.min(y2, $Math.min(y3, y4))));
        this._$yMax = $Math.max(this._$yMax, $Math.max(y1, $Math.max(y2, $Math.max(y3, y4))));

        // pointer x
        if ($Math.abs(radian3) % radian90 !== 0) {
            x1 = x + $Math.cos(radian3) * half;
        }

        if ($Math.abs(radian4) % radian90 !== 0) {
            x2 = x + $Math.cos(radian4) * half;
        }

        if ($Math.abs(radian5) % radian90 !== 0) {
            x3 = this._$pointerX + $Math.cos(radian5) * half;
        }

        if ($Math.abs(radian6) % radian90 !== 0) {
            x4 = this._$pointerX + $Math.cos(radian6) * half;
        }

        // pointer y
        if (radian3 && $Math.abs(radian3) % $Math.PI !== 0) {
            y1 = y + $Math.sin(radian3) * half;
        }

        if (radian4 && $Math.abs(radian4) % $Math.PI !== 0) {
            y2 = y + $Math.sin(radian4) * half;
        }

        if (radian5 && $Math.abs(radian5) % $Math.PI !== 0) {
            y3 = this._$pointerY + $Math.sin(radian5) * half;
        }

        if (radian6 && $Math.abs(radian6) % $Math.PI !== 0) {
            y4 = this._$pointerY + $Math.sin(radian6) * half;
        }

        this._$xMin = $Math.min(this._$xMin, $Math.min(x1, $Math.min(x2, $Math.min(x3, x4))));
        this._$xMax = $Math.max(this._$xMax, $Math.max(x1, $Math.max(x2, $Math.max(x3, x4))));
        this._$yMin = $Math.min(this._$yMin, $Math.min(y1, $Math.min(y2, $Math.min(y3, y4))));
        this._$yMax = $Math.max(this._$yMax, $Math.max(y1, $Math.max(y2, $Math.max(y3, y4))));

        // case
        let rx1 = 0;
        let ry1 = 0;
        let rx2 = 0;
        let ry2 = 0;
        let rx3 = 0;
        let ry3 = 0;
        let rx4 = 0;
        let ry4 = 0;
        switch (this._$caps) {

            case CapsStyle.ROUND:

                if ($Math.abs(radian1) % radian90 !== 0) {
                    rx1 = x + $Math.cos(radian1) * half;
                }

                if (radian1 && $Math.abs(radian1) % $Math.PI !== 0) {
                    ry1 = y + $Math.sin(radian1) * half;
                }

                if ($Math.abs(radian2) % radian90 !== 0) {
                    rx2 = this._$pointerX + $Math.cos(radian2) * half;
                }

                if (radian2 && $Math.abs(radian2) % $Math.PI !== 0) {
                    ry2 = this._$pointerY + $Math.sin(radian2) * half;
                }

                this._$xMin = $Math.min(this._$xMin, $Math.min(rx1, rx2));
                this._$xMax = $Math.max(this._$xMax, $Math.max(rx1, rx2));
                this._$yMin = $Math.min(this._$yMin, $Math.min(ry1, ry2));
                this._$yMax = $Math.max(this._$yMax, $Math.max(ry1, ry2));

                break;

            case CapsStyle.SQUARE:

                if ($Math.abs(radian1) % radian90 !== 0) {
                    const r1cos = $Math.cos(radian1) * half;
                    rx1 = x1 + r1cos;
                    rx2 = x2 + r1cos;
                }

                if ($Math.abs(radian2) % radian90 !== 0) {
                    const r2cos = $Math.cos(radian2) * half;
                    rx3 = x3 + r2cos;
                    rx4 = x4 + r2cos;
                }

                if (radian1 && $Math.abs(radian1) % $Math.PI !== 0) {
                    const r1sin = $Math.sin(radian1) * half;
                    ry1 = y1 + r1sin;
                    ry2 = y2 + r1sin;
                }

                if (radian2 && $Math.abs(radian2) % $Math.PI !== 0) {
                    const r2sin = $Math.sin(radian2) * half;
                    ry3 = y3 + r2sin;
                    ry4 = y4 + r2sin;
                }

                this._$xMin = $Math.min(this._$xMin, $Math.min(rx1, $Math.min(rx2, $Math.min(rx3, rx4))));
                this._$xMax = $Math.max(this._$xMax, $Math.max(rx1, $Math.max(rx2, $Math.max(rx3, rx4))));
                this._$yMin = $Math.min(this._$yMin, $Math.min(ry1, $Math.min(ry2, $Math.min(ry3, ry4))));
                this._$yMax = $Math.max(this._$yMax, $Math.max(ry1, $Math.max(ry2, $Math.max(ry3, ry4))));

                break;

            default:
                break;

        }
    }

    /**
     * @param {array} data
     * @method
     * @private
     */
    _$margePath (data)
    {
        if (this._$doFill) {
            this._$fills.push.apply(this._$fills, data);
        }

        if (this._$doLine) {
            this._$lines.push.apply(this._$lines, data);
        }

        Util.$poolArray(data);
    }

    /**
     * @param  {CanvasToWebGLContext|CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} [color_transform=null]
     * @return {boolean}
     * @method
     * @private
     */
    _$runTransformCommand (context, matrix, color_transform = null)
    {

        // fixed logic
        if (this._$doLine) {
            this.endLine();
        }

        // fixed logic
        if (this._$doFill) {
            this.endFill();
        }

        if (!this._$recode) {
            return false;
        }

        let xMin =  Number.MAX_VALUE;
        let xMax = -Number.MAX_VALUE;
        let yMin =  Number.MAX_VALUE;
        let yMax = -Number.MAX_VALUE;

        const recode = this._$recode;
        const length = recode.length;
        for (let idx = 0; idx < length; ) {

            switch (recode[idx++]) {

                case Graphics.BEGIN_PATH:
                    context.beginPath();
                    break;

                case Graphics.MOVE_TO:
                    {
                        const x = recode[idx++];
                        const y = recode[idx++];

                        const tx = x * matrix[0] + y * matrix[2];
                        const ty = x * matrix[1] + y * matrix[3];

                        xMin = $Math.min(tx, xMin);
                        xMax = $Math.max(tx, xMax);
                        yMin = $Math.min(ty, yMin);
                        yMax = $Math.max(ty, yMax);

                        context.moveTo(tx, ty);
                    }
                    break;

                case Graphics.LINE_TO:
                    {
                        const x = recode[idx++];
                        const y = recode[idx++];

                        const tx = x * matrix[0] + y * matrix[2];
                        const ty = x * matrix[1] + y * matrix[3];

                        xMin = $Math.min(tx, xMin);
                        xMax = $Math.max(tx, xMax);
                        yMin = $Math.min(ty, yMin);
                        yMax = $Math.max(ty, yMax);

                        context.lineTo(tx, ty);
                    }
                    break;

                case Graphics.CURVE_TO:
                    {
                        const cx = recode[idx++];
                        const cy = recode[idx++];
                        const x  = recode[idx++];
                        const y  = recode[idx++];

                        const ctx = cx * matrix[0] + cy * matrix[2];
                        const cty = cx * matrix[1] + cy * matrix[3];
                        const tx  = x  * matrix[0] + y  * matrix[2];
                        const ty  = x  * matrix[1] + y  * matrix[3];

                        xMin = $Math.min(ctx, xMin);
                        xMax = $Math.max(ctx, xMax);
                        yMin = $Math.min(cty, yMin);
                        yMax = $Math.max(cty, yMax);

                        xMin = $Math.min(tx, xMin);
                        xMax = $Math.max(tx, xMax);
                        yMin = $Math.min(ty, yMin);
                        yMax = $Math.max(ty, yMax);

                        context.quadraticCurveTo(ctx, cty, tx, ty);
                    }
                    break;

                case Graphics.CLOSE_PATH:
                    context.closePath();
                    break;

                case Graphics.CUBIC:
                    {
                        const cp1x = recode[idx++];
                        const cp1y = recode[idx++];
                        const cp2x = recode[idx++];
                        const cp2y = recode[idx++];
                        const x    = recode[idx++];
                        const y    = recode[idx++];

                        const cp1tx = cp1x * matrix[0] + cp1y * matrix[2];
                        const cp1ty = cp1x * matrix[1] + cp1y * matrix[3];
                        const cp2tx = cp2x * matrix[0] + cp2y * matrix[2];
                        const cp2ty = cp2x * matrix[1] + cp2y * matrix[3];
                        const tx    = x * matrix[0] + y * matrix[2];
                        const ty    = x * matrix[1] + y * matrix[3];

                        xMin = $Math.min(cp1tx, xMin);
                        xMax = $Math.max(cp1tx, xMax);
                        yMin = $Math.min(cp1ty, yMin);
                        yMax = $Math.max(cp1ty, yMax);

                        xMin = $Math.min(cp2tx, xMin);
                        xMax = $Math.max(cp2tx, xMax);
                        yMin = $Math.min(cp2ty, yMin);
                        yMax = $Math.max(cp2ty, yMax);

                        xMin = $Math.min(tx, xMin);
                        xMax = $Math.max(tx, xMax);
                        yMin = $Math.min(ty, yMin);
                        yMax = $Math.max(ty, yMax);

                        context.bezierCurveTo(cp1tx, cp1ty, cp2tx, cp2ty, tx, ty);
                    }
                    break;

                case Graphics.ARC:
                    {
                        const x = recode[idx++];
                        const y = recode[idx++];
                        const radius = recode[idx++];

                        const tx = x * matrix[0] + y * matrix[2];
                        const ty = x * matrix[1] + y * matrix[3];

                        xMin = $Math.min(tx, xMin);
                        xMax = $Math.max(tx, xMax);
                        yMin = $Math.min(ty, yMin);
                        yMax = $Math.max(ty, yMax);

                        context.arc(tx, ty, radius, 0, 2 * $Math.PI);
                    }
                    break;

                case Graphics.BITMAP_FILL:
                    {

                        context._$matrix[6] -= xMin * context._$matrix[0] + yMin * context._$matrix[3];
                        context._$matrix[7] -= xMin * context._$matrix[1] + yMin * context._$matrix[4];

                        context.save();

                        const bitmapData = recode[idx++];
                        const matrix     = recode[idx++];
                        const repeat     = recode[idx++];
                        const smooth     = recode[idx++];

                        context.fillStyle = context
                            .createPattern(bitmapData._$texture, repeat, color_transform);

                        if (matrix) {
                            context.transform(
                                matrix[0], matrix[1], matrix[2],
                                matrix[3], matrix[4], matrix[5]
                            );
                        }

                        context._$imageSmoothingEnabled = smooth;
                        context.fill();

                        // restore
                        context.restore();
                        context._$imageSmoothingEnabled = false;

                    }
                    break;

                default:
                    break;

            }

        }

        return false;
    }

    /**
     * @param  {CanvasToWebGLContext|CanvasRenderingContext2D} context
     * @param  {Float32Array} [color_transform=null]
     * @param  {boolean}      [is_clip=false]
     * @param  {object}       [options=null]
     * @return {boolean}
     * @method
     * @private
     */
    _$runCommand (context, color_transform = null, is_clip = false, options = null)
    {
        // fixed logic
        if (this._$doLine) {
            this.endLine();
        }

        // fixed logic
        if (this._$doFill) {
            this.endFill();
        }

        if (!this._$recode) {
            return false;
        }

        const recode = this._$recode;
        const length = recode.length;
        for (let idx = 0; idx < length; ) {

            switch (recode[idx++]) {

                case Graphics.BEGIN_PATH:
                    context.beginPath();
                    break;

                case Graphics.MOVE_TO:
                    context.moveTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.LINE_TO:
                    context.lineTo(recode[idx++], recode[idx++]);
                    break;

                case Graphics.CURVE_TO:
                    context.quadraticCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.FILL_STYLE:
                    {
                        if (is_clip || options) {
                            idx += 4;
                            continue;
                        }

                        const fillStyle = context._$contextStyle;

                        fillStyle._$fillStyle[0] = recode[idx++] / 255;
                        fillStyle._$fillStyle[1] = recode[idx++] / 255;
                        fillStyle._$fillStyle[2] = recode[idx++] / 255;
                        fillStyle._$fillStyle[3] = color_transform[3] !== 1 || color_transform[7] !== 0
                            ? $Math.max(0, $Math.min(recode[idx++] * color_transform[3] + color_transform[7], 255)) / 255
                            : recode[idx++] / 255;

                        context._$style = fillStyle;
                    }
                    break;

                case Graphics.END_FILL:

                    if (options) {

                        if (context.isPointInPath(options.x, options.y)) {
                            return true;
                        }

                        continue;
                    }

                    if (!is_clip) {
                        context.fill();
                    }

                    break;

                case Graphics.STROKE_STYLE:
                    {
                        if (is_clip || options) {
                            idx += 8;
                            continue;
                        }

                        context.lineWidth  = recode[idx++];
                        context.lineCap    = recode[idx++];
                        context.lineJoin   = recode[idx++];
                        context.miterLimit = recode[idx++];

                        const strokeStyle = context._$contextStyle;

                        strokeStyle._$strokeStyle[0] = recode[idx++] / 255;
                        strokeStyle._$strokeStyle[1] = recode[idx++] / 255;
                        strokeStyle._$strokeStyle[2] = recode[idx++] / 255;
                        strokeStyle._$strokeStyle[3] = color_transform[3] !== 1 || color_transform[7] !== 0
                            ? $Math.max(0, $Math.min(recode[idx++] * color_transform[3] + color_transform[7], 255)) / 255
                            : recode[idx++] / 255;

                        context._$style = strokeStyle;
                    }
                    break;

                case Graphics.END_STROKE:

                    if (options) {

                        if (context.isPointInStroke(options.x, options.y)) {
                            return true;
                        }

                        continue;
                    }

                    if (!is_clip) {
                        context.stroke();
                    }
                    break;

                case Graphics.CLOSE_PATH:
                    context.closePath();
                    break;

                case Graphics.CUBIC:
                    context.bezierCurveTo(
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++],
                        recode[idx++], recode[idx++]
                    );
                    break;

                case Graphics.ARC:
                    {
                        const arcX   = recode[idx++];
                        const arcY   = recode[idx++];
                        const radius = recode[idx++];
                        context.arc(arcX, arcY, radius, 0, 2 * $Math.PI);
                    }
                    break;

                case Graphics.GRADIENT_FILL:
                    {
                        if (options) {

                            if (context.isPointInPath(options.x, options.y)) {
                                return true;
                            }

                            idx += 6;
                            continue;
                        }

                        if (is_clip) {
                            idx += 6;
                            continue;
                        }

                        const type          = recode[idx++];
                        const stops         = recode[idx++];
                        const matrix        = recode[idx++];
                        const spread        = recode[idx++];
                        const interpolation = recode[idx++];
                        const focal         = recode[idx++];

                        let css = null;
                        if (type === GradientType.LINEAR) {

                            const xy = Util.$linearGradientXY(matrix);
                            css = context.createLinearGradient(
                                xy[0], xy[1], xy[2], xy[3],
                                interpolation, spread
                            );

                        } else {

                            context.save();
                            context.transform(
                                matrix[0], matrix[1], matrix[2],
                                matrix[3], matrix[4], matrix[5]
                            );

                            css = context.createRadialGradient(
                                0, 0, 0, 0, 0, 819.2,
                                interpolation, spread, focal
                            );

                        }

                        const length = stops.length;
                        for (let idx = 0; idx < length; ++idx) {

                            const color = stops[idx];

                            css.addColorStop(color.ratio, Util.$getFloat32Array4(
                                $Math.max(0, $Math.min(color.R * color_transform[0] + color_transform[4], 255)) | 0,
                                $Math.max(0, $Math.min(color.G * color_transform[1] + color_transform[5], 255)) | 0,
                                $Math.max(0, $Math.min(color.B * color_transform[2] + color_transform[6], 255)) | 0,
                                $Math.max(0, $Math.min(color.A * color_transform[3] + color_transform[7], 255)) | 0
                            ));

                        }

                        context.fillStyle = css;
                        context.fill();

                        if (type === GradientType.RADIAL) {
                            context.restore();
                        }
                    }
                    break;

                case Graphics.GRADIENT_STROKE:
                    {
                        if (options) {

                            if (context.isPointInStroke(options.x, options.y)) {
                                return true;
                            }

                            idx += 12;
                            continue;
                        }

                        if (is_clip) {
                            idx += 12;
                            continue;
                        }

                        const lineWidth     = recode[idx++];
                        const caps          = recode[idx++];
                        const joints        = recode[idx++];
                        const miterLimit    = recode[idx++];
                        const type          = recode[idx++];
                        const stops         = recode[idx++];
                        const matrix        = recode[idx++];
                        const spread        = recode[idx++];
                        const interpolation = recode[idx++];
                        const focal         = recode[idx++];

                        let css = null;
                        if (type === GradientType.LINEAR) {

                            const xy = Util.$linearGradientXY(matrix);
                            css = context.createLinearGradient(
                                xy[0], xy[1], xy[2], xy[3],
                                interpolation, spread
                            );

                        } else {

                            context.save();
                            context.transform(
                                matrix[0], matrix[1], matrix[2],
                                matrix[3], matrix[4], matrix[5]
                            );

                            css = context.createRadialGradient(
                                0, 0, 0, 0, 0, 819.2,
                                interpolation, spread, focal
                            );

                        }

                        const length = stops.length;
                        for (let idx = 0; idx < length; ++idx) {

                            const color = stops[idx];

                            css.addColorStop(color.ratio, Util.$getFloat32Array4(
                                $Math.max(0, $Math.min(color.R * color_transform[0] + color_transform[4], 255)) | 0,
                                $Math.max(0, $Math.min(color.G * color_transform[1] + color_transform[5], 255)) | 0,
                                $Math.max(0, $Math.min(color.B * color_transform[2] + color_transform[6], 255)) | 0,
                                $Math.max(0, $Math.min(color.A * color_transform[3] + color_transform[7], 255)) | 0
                            ));

                        }

                        context.strokeStyle = css;
                        context.lineWidth   = lineWidth;
                        context.lineCap     = caps;
                        context.lineJoin    = joints;
                        context.miterLimit  = miterLimit;
                        context.stroke();

                        if (type === GradientType.RADIAL) {
                            context.restore();
                        }

                    }
                    break;

                case Graphics.BITMAP_FILL:
                    {
                        if (options) {

                            if (context.isPointInPath(options.x, options.y)) {
                                return true;
                            }

                            idx += 6;
                            continue;
                        }

                        if (is_clip) {
                            idx += 6;
                            continue;
                        }

                        context.save();

                        const bitmapData = recode[idx++];
                        const matrix     = recode[idx++];
                        const repeat     = recode[idx++];
                        const smooth     = recode[idx++];

                        if (matrix) {
                            context.transform(
                                matrix[0], matrix[1], matrix[2],
                                matrix[3], matrix[4], matrix[5]
                            );
                        }

                        if (repeat === "no-repeat"
                            && bitmapData.width  === this._$xMax - this._$xMin
                            && bitmapData.height === this._$yMax - this._$yMin
                        ) {

                            context.drawImage(bitmapData._$texture,
                                0, 0, bitmapData.width, bitmapData.height
                            );

                        } else {

                            context.fillStyle = context.createPattern(
                                bitmapData._$texture, repeat, color_transform
                            );

                            context._$imageSmoothingEnabled = smooth;
                            context.fill();

                        }

                        // restore
                        context.restore();
                        context._$imageSmoothingEnabled = false;

                    }
                    break;

                case Graphics.BITMAP_STROKE:
                    {
                        if (options) {

                            if (context.isPointInStroke(options.x, options.y)) {
                                return true;
                            }

                            idx += 9;
                            continue;
                        }

                        if (is_clip) {
                            idx += 9;
                            continue;
                        }

                        context.save();

                        const lineWidth  = recode[idx++];
                        const caps       = recode[idx++];
                        const joints     = recode[idx++];
                        const miterLimit = recode[idx++];
                        const bitmapData = recode[idx++];
                        const matrix     = recode[idx++];
                        const repeat     = recode[idx++];
                        const smooth     = recode[idx++];

                        if (matrix) {
                            context.transform(
                                matrix[0], matrix[1], matrix[2],
                                matrix[3], matrix[4], matrix[5]
                            );
                        }

                        context.lineWidth   = lineWidth;
                        context.lineCap     = caps;
                        context.lineJoin    = joints;
                        context.miterLimit  = miterLimit;
                        context.strokeStyle = context.createPattern(
                            bitmapData._$texture, repeat, color_transform
                        );

                        context._$imageSmoothingEnabled = smooth;
                        context.stroke();

                        // restore
                        context.restore();
                        context._$imageSmoothingEnabled = false;

                    }
                    break;

                default:
                    break;

            }

        }

        return false;
    }
}

/**
 * ビットマップ塗りを定義します。ビットマップは、スムージング、繰り返し、
 * またはタイリング表示して領域を塗りつぶしたり、変換マトリックスを使用して操作できます。
 *
 * Defines a bitmap fill. The bitmap can be smoothed,
 * repeated or tiled to fill the area; or manipulated using a transformation matrix.
 *
 * @class
 * @memberOf next2d.display
 * @private
 */
class GraphicsBitmapFill
{
    /**
     * @param {BitmapData} bitmap_data
     * @param {Matrix}     [matrix=null]
     * @param {boolean}    [repeat=true]
     * @param {boolean}    [smooth=false]
     *
     * @constructor
     * @private
     */
    constructor (bitmap_data, matrix = null, repeat = true, smooth = false)
    {
        /**
         * @description 透明または不透明なビットマップイメージです。
         *              A transparent or opaque bitmap image.
         *
         * @type {BitmapData}
         * @private
         */
        this._$bitmapData = bitmap_data;

        /**
         * @description ビットマップ上の変形を定義する、
         *              （next2d.geom.Matrix クラスの）マトリックスオブジェクトです。
         *              A matrix object (of the next2d.geom.Matrix class)
         *              that defines transformations on the bitmap.
         *
         * @type {Matrix}
         * @default null
         * @private
         */
        this._$matrix = matrix;

        /**
         * @description ビットマップイメージを一定のパターンでタイル状に表示するかどうかを指定します。
         *              Specifies whether to repeat the bitmap image in a tiled pattern.
         *
         * @type {boolean}
         * @default true
         * @private
         */
        this._$repeat = !!repeat;

        /**
         * @description ビットマップイメージにスムージングアルゴリズムを適用するかどうかを指定します。
         *              Specifies whether to apply a smoothing algorithm to the bitmap image.
         *
         * @type {boolean}
         * @default false
         * @private
         */
        this._$smooth = !!smooth;
    }

    /**
     * @description 新しいオブジェクトとして、このクラスのクローンを返します。
     *              含まれるオブジェクトはまったく同じコピーになります。
     *              Returns a clone of this class as a new object,
     *              with an exact copy of the contained object.
     *
     * @return {GraphicsBitmapFill}
     * @method
     * @public
     */
    clone ()
    {
        return new GraphicsBitmapFill(
            this._$bitmapData.clone(),
            this._$matrix ? this._$matrix.clone() : null,
            this._$repeat,
            this._$smooth
        );
    }

    /**
     * @description このクラスのもつパラメーターをArrayで返却する
     *              Return the parameters of this class as an Array.
     *
     * @return {array}
     * @method
     * @public
     */
    toArray ()
    {
        return Util.$getArray(
            this._$bitmapData,
            this._$matrix,
            this._$repeat ? "repeat" : "no-repeat",
            this._$smooth
        );
    }
}
/**
 * グラデーション塗りを定義します。
 * Defines a gradient fill.
 *
 * @class
 * @memberOf next2d.display
 * @private
 */
class GraphicsGradientFill
{
    /**
     * @param  {string} [type=GradientType.LINEAR]
     * @param  {array}  [colors=null]
     * @param  {array}  [alphas=null]
     * @param  {array}  [ratios=null]
     * @param  {Matrix} [matrix=null]
     * @param  {string} [spread_method=SpreadMethod.PAD]
     * @param  {string} [interpolation_method=InterpolationMethod.RGB]
     * @param  {number} [focal_point_ratio=0]
     *
     * @constructor
     * @private
     */
    constructor(
        type = GradientType.LINEAR, colors = null, alphas = null, ratios = null,
        matrix = null, spread_method = SpreadMethod.PAD,
        interpolation_method = InterpolationMethod.RGB,
        focal_point_ratio = 0
    ) {

        /**
         * @description 使用するグラデーションのタイプを指定する GradientType クラスの値です。
         *              A value from the GradientType class that specifies which gradient type to use.
         *
         * @type {string}
         * @default GradientType.LINEAR
         * @private
         */
        this._$type = GradientType.RADIAL === type
            ? type
            : GradientType.LINEAR;

        /**
         * @description グラデーションで使用する RGB 16 進数カラー値の配列です。
         *              An array of RGB hexadecimal color values to use in the gradient.
         *
         * @type {array}
         * @default null
         * @private
         */
        this._$colors =  Util.$isArray(colors)
            ? this._$toColorInt(colors)
            : null;

        /**
         * @description colors 配列内の各色に対応するアルファ値の配列です。
         *              An array of alpha values for the corresponding colors in the colors array.
         *
         * @type {array}
         * @default null
         * @private
         */
        this._$alphas = Util.$isArray(alphas)
            ? this._$toColorInt(alphas)
            : null;

        /**
         * @description 色分布の比率の配列です。
         *              An array of color distribution ratios.
         *
         * @type {array}
         * @default null
         * @private
         */
        this._$ratios = null;
        if (Util.$isArray(ratios)) {
            for (let idx = 0; idx < ratios.length; ++idx) {
                ratios[idx] = Util.$clamp(ratios[idx], 0, 255, 0);
            }
            this._$ratios = ratios;
        }

        /**
         * @description Matrix クラスで定義される変換マトリックスです。
         *              A transformation matrix as defined by the Matrix class.
         *
         * @type {Matrix}
         * @default null
         * @private
         */
        this._$matrix = matrix;

        /**
         * @description 使用する spread メソッドを指定する SpreadMethod クラスの値です。
         *              A value from the SpreadMethod class that specifies which spread method to use.
         *
         * @type {string}
         * @default SpreadMethod.PAD
         * @private
         */
        switch (spread_method) {

            case SpreadMethod.REFLECT:
            case SpreadMethod.REPEAT:
                this._$spreadMethod = spread_method;
                break;

            default:
                this._$spreadMethod = SpreadMethod.PAD;
                break;
        }

        /**
         * @description 使用する値を指定する InterpolationMethod クラスの値です。
         *              A value from the InterpolationMethod class that specifies which value to use.
         *
         * @type {string}
         * @default InterpolationMethod.RGB
         * @private
         */
        this._$interpolationMethod = interpolation_method === InterpolationMethod.LINEAR_RGB
            ? interpolation_method
            : InterpolationMethod.RGB;

        /**
         * @description グラデーションの焦点の位置を制御する数値です。
         *              A number that controls the location
         *              of the focal point of the gradient.
         *
         * @type {number}
         * @default null
         * @private
         */
        this._$focalPointRatio = +focal_point_ratio || 0;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$colorStops = null;
    }

    /**
     * @description 分配された色の情報を統合して配列で返却
     *              Integrate the distributed color information and return it in an array.
     *
     * @member  {array}
     * @default null
     * @readonly
     * @public
     */
    get colorStops ()
    {
        if (!this._$colorStops) {

            this._$colorStops = Util.$getArray();

            const length = $Math.min(
                $Math.min(this._$alphas.length, this._$colors.length),
                this._$ratios.length
            );

            for (let idx = 0; idx < length; ++idx) {

                const object = Util.$intToRGBA(
                    this._$colors[idx], this._$alphas[idx]
                );

                this._$colorStops[idx] = {
                    "ratio": this._$ratios[idx] / 255,
                    "R": object.R,
                    "G": object.G,
                    "B": object.B,
                    "A": object.A
                };

            }
        }

        return this._$colorStops;
    }

    /**
     * @description カラー設定値をINTに変換
     *              Convert color setting value to INT.
     *
     * @return {array}
     * @method
     * @private
     */
    _$toColorInt (colors)
    {
        const length = colors.length;
        for (let idx = 0; idx < length; ++idx) {
            colors[idx] = Util.$clamp(
                Util.$toColorInt(colors[idx]), 0, 0xffffff, 0xffffff
            );
        }
        return colors;
    }

    /**
     * @description このクラスのもつパラメーターをArrayで返却する
     *              Return the parameters of this class as an Array.
     *
     * @return {array}
     * @method
     * @public
     */
    toArray ()
    {
        return Util.$getArray(
            this._$type,
            this.colorStops,
            this._$matrix
                ? this._$matrix._$matrix
                : Util.$MATRIX_ARRAY_RATIO_0_0_RATIO_0_0,
            this._$spreadMethod,
            this._$interpolationMethod,
            this._$focalPointRatio
        );
    }
}
/**
 * InterpolationMethod クラスは、interpolationMethod パラメーター（Graphics.beginGradientFill()
 * および Graphics.lineGradientStyle() メソッドのパラメーター）の値を提供します。
 * このパラメーターは、グラデーションをレンダリングするときに使用する RGB スペースを決定します。
 *
 * The InterpolationMethod class provides values for the interpolationMethod parameter
 * in the Graphics.beginGradientFill() and Graphics.lineGradientStyle() methods.
 * This parameter determines the RGB space to use when rendering the gradient.
 *
 * @class
 * @memberOf next2d.display
 */
class InterpolationMethod
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class InterpolationMethod]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class InterpolationMethod]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.InterpolationMethod
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.InterpolationMethod";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object InterpolationMethod]
     * @method
     * @public
     */
    toString ()
    {
        return "[object InterpolationMethod]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.InterpolationMethod
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.InterpolationMethod";
    }

    /**
     * @description 線形 RGB 補間メソッドを使用することを指定します。
     *              Specifies that the linear RGB interpolation method should be used.
     *
     * @return  {string}
     * @default linearRGB
     * @const
     * @static
     */
    static get LINEAR_RGB ()
    {
        return "linearRGB";
    }

    /**
     * @description RGB 補間メソッドを使用することを指定します。
     *              Specifies that the RGB interpolation method should be used.
     *
     * @return  {string}
     * @default rgb
     * @const
     * @static
     */
    static get RGB ()
    {
        return "rgb";
    }
}

/**
 * JointStyle クラスは、線の描画で使用される結合スタイルを指定する定数値の列挙です。
 * これらの定数は、joints パラメーター（next2d.display.Graphics.lineStyle() メソッドのパラメーター）の値として使用されます。
 * このメソッドは、マイター、ラウンド、ベベルの 3 種類の結合をサポートします。
 *
 * The JointStyle class is an enumeration of constant values that specify the joint style to use in drawing lines.
 * These constants are provided for use as values in the joints parameter of the next2d.display.Graphics.lineStyle() method.
 * The method supports three types of joints: miter, round, and bevel, as the following
 *
 * @class
 * @memberOf next2d.display
 */
class JointStyle
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class JointStyle]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class JointStyle]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.JointStyle
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.JointStyle";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object JointStyle]
     * @method
     * @public
     */
    toString ()
    {
        return "[object JointStyle]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.JointStyle
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.JointStyle";
    }

    /**
     * @description next2d.display.Graphics.lineStyle() メソッドの joints パラメーターでベベル結合を指定します。
     *              Specifies beveled joints in the joints parameter of
     *              the next2d.display.Graphics.lineStyle() method.
     *
     * @return  {string}
     * @default bevel
     * @const
     * @static
     */
    static get BEVEL ()
    {
        return "bevel";
    }

    /**
     * @description next2d.display.Graphics.lineStyle() メソッドの joints パラメーターでマイター結合を指定します。
     *              Specifies mitered joints in the joints parameter of
     *              the next2d.display.Graphics.lineStyle() method.
     *
     * @return  {string}
     * @default miter
     * @const
     * @static
     */
    static get MITER ()
    {
        return "miter";
    }

    /**
     * @description next2d.display.Graphics.lineStyle() メソッドの joints パラメーターでラウンド結合を指定します。
     *              Specifies round joints in the joints parameter of
     *              the next2d.display.Graphics.lineStyle() method.
     *
     * @return  {string}
     * @default round
     * @const
     * @static
     */
    static get ROUND ()
    {
        return "round";
    }
}

/**
 * Loader クラスは、JSON ファイルまたはイメージ（JPEG、PNG、または GIF）ファイルを読み込むために使用します。
 * 読み込みを開始するには load() メソッドを使用します。
 * 読み込まれた表示オブジェクトは Loader オブジェクトの子として追加されます。
 *
 * The Loader class is used to load JSON files or image (JPEG, PNG, or GIF) files.
 * Use the load() method to initiate loading.
 * The loaded display object is added as a child of the Loader object.
 *
 * @class
 * @memberOf next2d.display
 * @extends  DisplayObjectContainer
 */
class Loader extends DisplayObjectContainer
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {LoaderInfo}
         * @default null
         * @private
         */
        this._$loaderInfo = new LoaderInfo();
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Loader]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Loader]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.Loader
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.Loader";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Loader]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Loader]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.Loader
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.Loader";
    }

    /**
     * @description load() または loadImage() メソッドを使用して読み込まれた JSON または
     *              イメージ（JPEG、PNG、または GIF）ファイルのルート表示オブジェクトが含まれます。
     *              Contains the root display object of a JSON or image (JPEG, PNG, or GIF) file
     *              that was loaded using the load() or loadImage() methods.
     *
     * @member {DisplayObject}
     * @readonly
     * @public
     */
    get content ()
    {
        return this._$loaderInfo._$content;
    }

    /**
     * @description 読み込まれているオブジェクトに対応する LoaderInfo オブジェクトを返します。
     *              Returns a LoaderInfo object corresponding to the object being loaded.
     *
     * @member {LoaderInfo}
     * @readonly
     * @public
     */
    get contentLoaderInfo ()
    {
        return this._$loaderInfo;
    }

    /**
     * @description JSONファイルを、この Loader オブジェクトの子であるcontentプロパティにロードします。
     *              JPEG、GIF、PNGなどの画像データは loadImage で同様にcontentプロパティにロードします。
     *              Load the JSON file into the content property, which is a child of this Loader object.
     *              Image data such as JPEG, GIF, PNG, etc.
     *              are loaded into the content property in the same way with loadImage.
     *
     * @param   {URLRequest} request
     * @returns {void}
     * @method
     * @public
     */
    load (request)
    {
        if (!request || !(request instanceof URLRequest)) {
            return ;
        }

        const loaderInfo = this.contentLoaderInfo;
        switch (request.responseDataFormat) {

            case URLLoaderDataFormat.JSON:
            case URLLoaderDataFormat.ARRAY_BUFFER:
                break;

            default:
                if (loaderInfo.willTrigger(IOErrorEvent.IO_ERROR)) {
                    loaderInfo.dispatchEvent(new IOErrorEvent(
                        IOErrorEvent.IO_ERROR, false, false,
                        "data format is json or arrayBuffer only."
                    ));
                }
                return ;
        }

        loaderInfo._$url    = request.url;
        loaderInfo._$format = request.responseDataFormat;

        Util.$ajax({
            "format": request.responseDataFormat,
            "url": request.url,
            "method": request.method,
            "data": request.data,
            "headers": request.headers,
            "credentials": request.withCredentials,
            "event": {
                "loadstart": function (event)
                {
                    const loaderInfo = this.contentLoaderInfo;

                    loaderInfo._$bytesLoaded = event.loaded;
                    loaderInfo._$bytesTotal  = event.total;

                    if (loaderInfo.willTrigger(Event.OPEN)) {
                        loaderInfo.dispatchEvent(new Event(Event.OPEN));
                    }
                    if (loaderInfo.willTrigger(ProgressEvent.PROGRESS)) {
                        loaderInfo.dispatchEvent(new ProgressEvent(
                            ProgressEvent.PROGRESS,
                            false, false, event.loaded, event.total
                        ));
                    }

                }.bind(this),
                "progress": function (event)
                {
                    const loaderInfo = this.contentLoaderInfo;

                    // set
                    loaderInfo._$bytesLoaded = event.loaded;
                    loaderInfo._$bytesTotal  = event.total;

                    // progress event
                    if (loaderInfo.willTrigger(ProgressEvent.PROGRESS)) {
                        loaderInfo.dispatchEvent(new ProgressEvent(
                            ProgressEvent.PROGRESS,
                            false, false, event.loaded, event.total
                        ));
                    }

                }.bind(this),
                "loadend": function (event)
                {
                    const loaderInfo = this.contentLoaderInfo;

                    // set
                    loaderInfo._$bytesLoaded = event.loaded;
                    loaderInfo._$bytesTotal  = event.total;

                    // progress event
                    if (loaderInfo.willTrigger(ProgressEvent.PROGRESS)) {
                        loaderInfo.dispatchEvent(new ProgressEvent(
                            ProgressEvent.PROGRESS,
                            false, false, event.loaded, event.total
                        ));
                    }

                    // http status event
                    const responseHeaders = Util.$getArray();

                    const headers = Util.$headerToArray(
                        event.target.getAllResponseHeaders()
                    );

                    const length  = headers.length;
                    for (let idx = 0; idx < length; ++idx) {

                        const obj = headers[idx];

                        responseHeaders.push(new URLRequestHeader(obj.name, obj.value));

                    }

                    if (loaderInfo.willTrigger(HTTPStatusEvent.HTTP_STATUS)) {
                        const httpStatusEvent = new HTTPStatusEvent(
                            HTTPStatusEvent.HTTP_STATUS, false, false,
                            event.target.status
                        );

                        httpStatusEvent._$responseURL     = event.target.responseURL;
                        httpStatusEvent._$responseHeaders = responseHeaders;

                        loaderInfo.dispatchEvent(httpStatusEvent);
                    }

                    if (199 < event.target.status && 400 > event.target.status) {

                        switch (loaderInfo.format) {

                            case URLLoaderDataFormat.JSON:
                                {
                                    const json = JSON.parse(
                                        event.target.responseText
                                    );

                                    if (json.type === "zlib") {

                                        if (Util.$unzipWorkerActive) {

                                            Util.$unzipQueues.push({
                                                "json": json,
                                                "scope": this
                                            });

                                            return ;
                                        }

                                        Util.$unzipWorkerActive = true;

                                        if (!Util.$unzipWorker) {
                                            Util.$unzipWorker = new Worker(Util.$unzipURL);
                                        }

                                        const buffer = new Uint8Array(json.buffer);
                                        Util.$unzipWorker.onmessage = Util.$unzipHandler.bind(this);
                                        Util.$unzipWorker.postMessage(buffer, [buffer.buffer]);

                                    } else {

                                        this._$build(json);

                                    }

                                }
                                break;

                            case URLLoaderDataFormat.ARRAY_BUFFER:
                                this._$imageDecode(
                                    new Uint8Array(event.target.response)
                                );
                                break;

                            default:
                                break;

                        }

                    } else {

                        if (loaderInfo.willTrigger(IOErrorEvent.IO_ERROR)) {
                            loaderInfo.dispatchEvent(new IOErrorEvent(
                                IOErrorEvent.IO_ERROR, false, false,
                                event.target.statusText
                            ));
                        }

                    }

                }.bind(this)
            }
        });
    }

    /**
     * @description JPEG、GIFファイルを、この Loader オブジェクトの子であるcontentプロパティにロードします。
     *              Load a JPEG or GIF file into the content property, which is a child of this Loader object.
     *
     * @param   {URLRequest} request
     * @returns {void}
     * @method
     * @public
     */
    loadImage (request)
    {
        request.responseDataFormat = URLLoaderDataFormat.ARRAY_BUFFER;
        this.load(request);
    }

    /**
     * @param   {Uint8Array} buffer
     * @return  {void}
     * @method
     * @private
     */
    _$imageDecode (buffer)
    {
        const target = {
            "image": new Util.$Image(),
            "scope": this
        };

        target.image.decoding = "async";
        target.image.src = Util.$URL.createObjectURL(
            new Util.$Blob([buffer], {
                "type": `image/${Util.$getImageType(buffer)}`
            })
        );

        if (Util.$imageWorkerActive) {
            Util.$imageQueues.push(target);
            return ;
        }

        Util.$imageWorkerActive = true;

        target.image.decode()
            .then(Util.$decodeImage.bind(target))
            .catch(() =>
            {
                throw new Error("image encoding error");
            });

    }

    /**
     * @param  {object} object
     * @private
     */
    _$build (object)
    {
        const loaderInfo = this.contentLoaderInfo;

        let rootSymbol = null;
        const symbols = Util.$getMap();
        if (object.symbols.length) {
            for (let idx = 0; idx < object.symbols.length; ++idx) {

                const values = object.symbols[idx];

                if (values[1] === 0) {
                    rootSymbol = values[0];
                }

                symbols.set(values[0], values[1]);
            }
        }

        loaderInfo._$data = {
            "stage": object.stage,
            "characters": object.characters,
            "symbols": symbols
        };

        // setup
        if (rootSymbol) {

            const SymbolClass = Util.$getClass(rootSymbol) || MovieClip;
            loaderInfo._$content = new SymbolClass();

        } else {

            loaderInfo._$content = new MovieClip();

        }

        // build root
        const root = object.characters[0];
        loaderInfo._$content._$build({
            "characterId": 0,
            "clipDepth": 0,
            "depth": 0,
            "endFrame": root.controller.length,
            "startFrame": 1
        }, this);

        // fixed logic
        loaderInfo._$content._$parent = null;
        this.addChild(loaderInfo._$content);

        // fixed logic
        loaderInfo._$content._$added      = false;
        loaderInfo._$content._$addedStage = false;

        const player = Util.$currentPlayer();

        // to event
        player._$loaders.push(loaderInfo);

        // next
        if (player._$loadStatus === Player.LOAD_START) {
            player._$loadStatus = Player.LOAD_END;
        }
    }
}

/**
 * LoaderInfo クラスは、読み込まれる JSON ファイルやイメージファイル（JPEG、GIF、PNG ファイルなど）に関する情報を提供します。
 * LoaderInfo オブジェクトは、すべての表示オブジェクトで使用できます。
 * 提供される情報には、読み込みの進行状況、読み込む側と読み込まれたコンテンツの URL、メディアの総バイト数、メディアの規格高さと幅などが含まれます。
 *
 * The LoaderInfo class provides information about a loaded JSON file or a loaded image file (JPEG, GIF, or PNG).
 * LoaderInfo objects are available for any display object.
 * The information provided includes load progress, the URLs of the loader and loaded content,
 * the number of bytes total for the media, and the nominal height and width of the media.
 *
 * @class
 * @memberOf next2d.display
 * @extends  EventDispatcher
 */
class LoaderInfo extends EventDispatcher
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {number}
         * @private
         */
        this._$id = loaderInfoId++;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesLoaded = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesTotal = 0;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$url = "";

        /**
         * @type {DisplayObject}
         * @default null
         * @private
         */
        this._$content = null;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$data = null;

        /**
         * @type {string}
         * @default URLLoaderDataFormat.STRING
         * @private
         */
        this._$format = URLLoaderDataFormat.STRING;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class LoaderInfo]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class LoaderInfo]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.LoaderInfo
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.LoaderInfo";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object LoaderInfo]
     * @method
     * @public
     */
    toString ()
    {
        return "[object LoaderInfo]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.LoaderInfo
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.LoaderInfo";
    }

    /**
     * @description そのメディアのロード済みのバイト数です。
     *              The uint of bytes that are loaded for the media.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesLoaded ()
    {
        return this._$bytesLoaded;
    }

    /**
     * @description メディアファイル全体のバイト数です。
     *              The number of bytes in the entire media file.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesTotal ()
    {
        return this._$bytesTotal;
    }

    /**
     * @description LoaderInfo オブジェクトに関係したロードされたオブジェクトです。
     *              The loaded object associated with this LoaderInfo object.
     *
     * @member {DisplayObject}
     * @readonly
     * @public
     */
    get content ()
    {
        return this._$content;
    }

    /**
     * @description 読み込まれるメディアの URL です。
     *              The URL of the media being loaded.
     *
     * @member {string}
     * @default ""
     * @readonly
     * @public
     */
    get url ()
    {
        return this._$url;
    }

    /**
     * @description 読み込まれるメディアの データフォーマット です。
     *              The data format of the media being loaded.
     *
     * @member {string}
     * @default URLLoaderDataFormat.STRING
     * @public
     */
    get format ()
    {
        return this._$format;
    }
    set format (format)
    {
        this._$format = format;
    }
}

/**
 * LoopConfig クラスで、MovieClipのフレームヘッダーの移動方法を指定できます。
 * 一度限りの再生や逆再生、フレーム固定などのアニメーションのループバリエーションを設定できます。
 *
 * The LoopConfig class allows you to specify how the frame headers of a MovieClip are moved.
 * You can set up looping variations of the animation, such as one-time playback,
 * reverse playback, or fixed frame.
 *
 * @class
 * @memberOf next2d.display
 */
class LoopConfig
{
    /**
     * @param {number} [type=0]
     * @param {number} [start=1]
     * @param {number} [end=0]
     *
     * @constructor
     * @public
     */
    constructor (type = 0, start = 1, end = 0)
    {
        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$type = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$start = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$end = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$frame = 1;

        // setup
        this.type  = type;
        this.start = start;
        this.end   = end;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class LoopConfig]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class LoopConfig]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.LoopConfig
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.LoopConfig";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object LoopConfig]
     * @method
     * @public
     */
    toString ()
    {
        return "[object LoopConfig]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.LoopConfig
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.LoopConfig";
    }

    /**
     * @description ループ設定の適用を開始するフレームの値、自動で設定されます。
     *              The value of the frame at which to start applying the loop setting, set automatically.
     *
     * @return  {number}
     * @default 1
     * @readonly
     * @public
     */
    get frame ()
    {
        return this._$frame;
    }

    /**
     * @description LoopTypeクラスの固定値を利用して、ループのタイプを設定できます。
     *              You can set the type of loop by using a fixed value in the LoopType class.
     *
     * @return  {number}
     * @default 0
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        this._$type = Util.$clamp(
            type | 0, LoopType.REPEAT, LoopType.REPEAT_REVERSAL
        );
    }

    /**
     * @description フレーム移動の開始値を設定します。逆再生時はここで設定した値が終了フレームとなります。
     *              Sets the start value for frame shift. For reverse playback,
     *              the value set here is the end frame.
     *
     * @return  {number}
     * @default 1
     * @public
     */
    get start ()
    {
        return this._$start;
    }
    set start (start)
    {
        this._$start = Util.$clamp(start | 0, 1, 0xffffff);
    }

    /**
     * @description フレーム移動の終了値を設定します。逆再生時はここで設定した値が開始フレームとなります。
     *              Sets the end value of frame shift. For reverse playback,
     *              the value set here is the start frame.
     *
     * @return  {number}
     * @default 0
     * @public
     */
    get end ()
    {
        return this._$end;
    }
    set end (end)
    {
        this._$end = Util.$clamp(end | 0, 0, 0xffffff);
    }
}

/**
 * LoopType クラスは、MovieClipのフレームヘッダーの移動方法を指定する定数値の列挙です。
 * これらの定数は、LoopConfigで利用されます。
 *
 * The LoopType class is an enumeration of constant values
 * that specify how to move the frame header of a MovieClip,
 * These constants are used by LoopConfig.
 *
 * @class
 * @memberOf next2d.display
 */
class LoopType
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class LoopType]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class LoopType]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.LoopType
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.LoopType";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object LoopType]
     * @method
     * @public
     */
    toString ()
    {
        return "[object LoopType]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.LoopType
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.LoopType";
    }

    /**
     * @description ループ設定でリピート再生を使用することを指定します。
     *              Specifies that repeat playback should be used in the loop settings.
     *
     * @return  {number}
     * @default 0
     * @const
     * @static
     */
    static get REPEAT ()
    {
        return 0;
    }

    /**
     * @description ループ設定で再生ヘッダーが指定した最終フレームに到達するとフレームを固定する設定を指定します。
     *              Specifies the setting to fix frames when the playback header reaches the specified final frame in the loop settings.
     *
     * @return  {number}
     * @default 1
     * @const
     * @static
     */
    static get NO_REPEAT ()
    {
        return 1;
    }

    /**
     * @description ループ設定でフレームを固定する設定を指定します。
     *              Specifies the setting for fixing frames in the loop setting.
     *
     * @return  {number}
     * @default 2
     * @const
     * @static
     */
    static get FIXED ()
    {
        return 2;
    }

    /**
     * @description ループ設定で再生ヘッダーが逆再生し、指定した開始フレームに到達するとフレームを固定する設定を指定します。
     *              Specifies the setting where the playback header plays backwards in the loop setting
     *              and fixes the frame when the specified start frame is reached.
     *
     * @return  {number}
     * @default 3
     * @const
     * @static
     */
    static get NO_REPEAT_REVERSAL ()
    {
        return 3;
    }

    /**
     * @description ループ設定でリピート逆再生を使用することを指定します。
     *              Specifies the use of repeat reverse playback in the loop settings.
     *
     * @return  {number}
     * @default 4
     * @const
     * @static
     */
    static get REPEAT_REVERSAL ()
    {
        return 4;
    }
}

/**
 * Shape クラスには、Graphics クラスからメソッドにアクセスできる graphics プロパティがあります。
 *
 * The Shape class includes a graphics property,
 * which lets you access methods from the Graphics class.
 *
 * @class
 * @memberOf next2d.display
 * @extends  DisplayObject
 */
class Shape extends DisplayObject
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {Graphics}
         * @default null
         * @private
         */
        this._$graphics = null;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$bounds = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bitmapId = 0;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Shape]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Shape]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.Shape
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.Shape";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Shape]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Shape]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.Shape
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.Shape";
    }

    /**
     * @description ベクターの描画コマンドが発生するこのスプライトに属する Graphics オブジェクトを指定します。
     *              Specifies the Graphics object that belongs to this sprite
     *              where vector drawing commands can occur.
     *
     * @member  {Graphics}
     * @readonly
     * @public
     */
    get graphics ()
    {
        if (!this._$graphics) {
            this._$graphics = new Graphics(this);
        }
        return this._$graphics;
    }

    /**
     * @param  {object} character
     * @param  {LoaderInfo} loaderInfo
     * @return {void}
     * @method
     * @private
     */
    _$buildCharacter (character, loaderInfo)
    {
        const graphics = this.graphics;

        if (character.recodes) {

            switch (true) {

                case character.bitmapId > 0:
                    {
                        this._$bitmapId = character.bitmapId;

                        const bitmap = loaderInfo._$data.characters[character.bitmapId];

                        const width  = $Math.abs(bitmap.bounds.xMax - bitmap.bounds.xMin);
                        const height = $Math.abs(bitmap.bounds.yMax - bitmap.bounds.yMin);

                        const bitmapData = new BitmapData(width, height, true, 0);
                        if (!bitmap._$buffer) {
                            bitmap._$buffer = new Uint8Array(bitmap.buffer);
                            Util.$poolArray(bitmap.buffer);
                            bitmap.buffer = null;
                        }
                        bitmapData._$buffer = bitmap._$buffer.slice();

                        // setup
                        graphics._$recode = Util.$getArray();

                        // clone
                        const recodes = character.recodes;
                        if (recodes[recodes.length - 1] === Graphics.END_FILL) {

                            const length  = recodes.length - 6;
                            for (let idx = 0; idx < length; ++idx) {
                                graphics._$recode.push(recodes[idx]);
                            }

                            // add Bitmap Fill
                            graphics._$recode.push(
                                Graphics.BITMAP_FILL,
                                bitmapData,
                                null,
                                "repeat",
                                false
                            );

                        } else {

                            const width      = recodes[recodes.length - 9];
                            const caps       = recodes[recodes.length - 8];
                            const joints     = recodes[recodes.length - 7];
                            const miterLimit = recodes[recodes.length - 6];

                            const length  = recodes.length - 10;
                            for (let idx = 0; idx < length; ++idx) {
                                graphics._$recode.push(recodes[idx]);
                            }

                            graphics._$recode.push(
                                Graphics.BITMAP_STROKE,
                                width,
                                caps,
                                joints,
                                miterLimit,
                                bitmapData,
                                new $Float32Array([1, 0, 0, 1, character.bounds.xMin, character.bounds.yMin]),
                                "repeat",
                                false
                            );
                        }
                    }
                    break;

                case character.inBitmap:
                    {
                        // setup
                        graphics._$recode = Util.$getArray();

                        const recodes = character.recodes;
                        for (let idx = 0; idx < recodes.length; ++idx) {
                            const value = recodes[idx];
                            graphics._$recode[idx] = value;

                            if (typeof value !== "object") {
                                continue;
                            }

                            if (!value.buffer) {
                                continue;
                            }

                            const bitmapData = new BitmapData(
                                value.width, value.height, true, 0
                            );
                            bitmapData._$buffer = new Uint8Array(value.buffer);
                            graphics._$recode[idx++] = bitmapData;

                            const matrix = recodes[idx];
                            graphics._$recode[idx] = Util.$getFloat32Array6(
                                matrix[0], matrix[1], matrix[2],
                                matrix[3], matrix[4], matrix[5]
                            );
                        }
                    }
                    break;

                default:
                    graphics._$recode = character.recodes.slice(0);
                    break;

            }

        } else {

            const width  = $Math.abs(character.bounds.xMax - character.bounds.xMin);
            const height = $Math.abs(character.bounds.yMax - character.bounds.yMin);

            const bitmapData = new BitmapData(width, height, true, 0);
            if (!character._$buffer) {
                character._$buffer = new Uint8Array(character.buffer);
                Util.$poolArray(character.buffer);
                character.buffer = null;
            }
            bitmapData._$buffer = character._$buffer.slice(0);

            graphics
                .beginBitmapFill(bitmapData, null, false)
                .drawRect(0, 0, width, height);

        }

        graphics._$maxAlpha = 1;
        graphics._$canDraw  = true;

        graphics._$xMin = character.bounds.xMin;
        graphics._$xMax = character.bounds.xMax;
        graphics._$yMin = character.bounds.yMin;
        graphics._$yMax = character.bounds.yMax;

        // 9-scale
        if (character.grid) {
            this._$scale9Grid = new Rectangle(
                character.grid.x, character.grid.y,
                character.grid.w, character.grid.h
            );
        }
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$sync ()
    {
        const character = super._$sync();

        if (character) {
            this._$buildCharacter(character, this._$loaderInfo);
        }

        return character;
    }

    /**
     * @param  {object} tag
     * @param  {DisplayObjectContainer} parent
     * @return {object}
     * @method
     * @private
     */
    _$build (tag, parent)
    {
        const character = super._$build(tag, parent);

        this._$buildCharacter(character, parent._$loaderInfo);

        return character;
    }

    /**
     * @param   {Float32Array} [matrix=null]
     * @returns {object}
     * @method
     * @private
     */
    _$getBounds (matrix = null)
    {
        if (!this._$graphics) {
            return Util.$getBoundsObject(0, 0, 0, 0);
        }

        const bounds = this._$graphics._$getBounds();
        if (matrix) {

            const tMatrix = Util.$multiplicationMatrix(
                matrix, this._$transform._$rawMatrix()
            );

            const result = Util.$boundsMatrix(bounds, tMatrix);
            Util.$poolBoundsObject(bounds);

            return result;
        }

        return bounds;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @return {void}
     * @method
     * @private
     */
    _$draw (context, matrix, color_transform)
    {
        if (!this._$visible) {
            return ;
        }

        if (!this._$graphics || !this._$graphics._$canDraw) {
            return ;
        }

        let multiColor = color_transform;
        const rawColor = this._$transform._$rawColorTransform();
        if (rawColor !== Util.$COLOR_ARRAY_IDENTITY) {
            multiColor = Util.$multiplicationColor(color_transform, rawColor);
        }

        const alpha = Util.$clamp(multiColor[3] + multiColor[7] / 255, 0, 1, 0);
        if (!alpha) {
            if (multiColor !== color_transform) {
                Util.$poolFloat32Array8(multiColor);
            }
            return ;
        }

        const filters   = this._$filters   || this.filters;
        const blendMode = this._$blendMode || this.blendMode;
        if (!this._$bitmapId) {

            let multiMatrix = matrix;
            const rawMatrix = this._$transform._$rawMatrix();
            if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
                multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
            }

            this
                ._$graphics
                ._$draw(context, multiMatrix, multiColor, blendMode, filters);

            if (multiMatrix !== matrix) {
                Util.$poolFloat32Array6(multiMatrix);
            }

        } else {

            this
                ._$graphics
                ._$drawBitmap(context, matrix, multiColor, blendMode, filters);

        }

        if (multiColor !== color_transform) {
            Util.$poolFloat32Array8(multiColor);
        }

    }

    /**
     * @param   {CanvasToWebGLContext} context
     * @param   {Float32Array} matrix
     * @returns {void}
     * @method
     * @private
     */
    _$clip (context, matrix)
    {
        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        this._$graphics._$clip(context, multiMatrix);

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object}  options
     * @return {boolean}
     * @method
     * @private
     */
    _$mouseHit (context, matrix, options)
    {
        if (!this._$visible) {
            return false;
        }

        return this._$hit(context, matrix, options);
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object}  options
     * @param  {boolean} [is_clip=false]
     * @return {boolean}
     * @method
     * @private
     */
    _$hit (context, matrix, options, is_clip)
    {
        let hit = false;

        if (this._$graphics
            && this._$graphics._$canDraw
            && this._$graphics._$getBounds()
        ) {

            let multiMatrix = matrix;
            const rawMatrix = this._$transform._$rawMatrix();
            if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
                multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
            }

            hit = this
                ._$graphics
                ._$hit(context, multiMatrix, options, is_clip);

            if (multiMatrix !== matrix) {
                Util.$poolFloat32Array6(multiMatrix);
            }

        }

        return hit;
    }
}

/**
 * SpreadMethod クラスは、spreadMethod パラメーター（Graphics クラスの beginGradientFill() メソッド
 * および lineGradientStyle() メソッドのパラメーター）の値を提供します。
 *
 * The SpreadMethod class provides values for the spreadMethod parameter
 * in the beginGradientFill() and lineGradientStyle() methods of the Graphics class.
 *
 * @class
 * @memberOf next2d.display
 */
class SpreadMethod
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class SpreadMethod]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class SpreadMethod]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.SpreadMethod
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.SpreadMethod";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object SpreadMethod]
     * @method
     * @public
     */
    toString ()
    {
        return "[object SpreadMethod]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.SpreadMethod
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.SpreadMethod";
    }

    /**
     * @description グラデーションで spread メソッド pad を使用することを指定します。
     *              Specifies that the gradient use the pad spread method.
     *
     * @return  {string}
     * @default pad
     * @const
     * @static
     */
    static get PAD ()
    {
        return "pad";
    }

    /**
     * @description グラデーションで spread メソッド reflect を使用することを指定します。
     *              Specifies that the gradient use the reflect spread method.
     *
     * @return  {string}
     * @default reflect
     * @const
     * @static
     */
    static get REFLECT ()
    {
        return "reflect";
    }

    /**
     * @description グラデーションで spread メソッド repeat を使用することを指定します。
     *              Specifies that the gradient use the repeat spread method.
     *
     * @return  {string}
     * @default repeat
     * @const
     * @static
     */
    static get REPEAT ()
    {
        return "repeat";
    }
}

/**
 * Stage クラスはメイン描画領域を表します。
 * The Stage class represents the main drawing area.
 *
 * @class
 * @memberOf next2d.display
 * @extends  DisplayObjectContainer
 */
class Stage extends DisplayObjectContainer
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {Player}
         * @default null
         * @private
         */
        this._$player = null;

        /**
         * @type {Stage}
         * @private
         */
        this._$root = this;

        /**
         * @type {Stage}
         * @private
         */
        this._$stage = this;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$invalidate = true;

        /**
         * @type {number}
         * @default 0xffffffff
         * @private
         */
        this._$color = 0xffffffff;

        /**
         * @type {number}
         * @default 60
         * @private
         */
        this._$frameRate = 60;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Stage]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Stage]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.Stage
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.Stage";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Stage]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Stage]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.Stage
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.Stage";
    }

    /**
     * @description 背景色です。
     *              background color.
     *
     * @member {number}
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        this._$color = Util.$clamp(Util.$toColorInt(color), 0, 0xffffff, 0xffffff);
        const player = this._$player;
        if (player) {
            const rgba = Util.$uintToRGBA(this._$color);
            player
                ._$context
                ._$setColor(
                    rgba.R / 255,
                    rgba.G / 255,
                    rgba.B / 255,
                    rgba.A / 255
                );
        }
    }

    /**
     * @description ステージのフレームレートを取得または設定します。
     *              Gets and sets the frame rate of the stage.
     *
     * @member {number}
     * @public
     */
    get frameRate ()
    {
        return this._$frameRate;
    }
    set frameRate (frame_rate)
    {
        this._$frameRate = Util.$clamp(+frame_rate, 1, 60, 60);
        if (this._$player && !this._$player._$stopFlag) {
            this._$player.stop();
            this._$player.play();
        }
    }

    /**
     * @description Player オブジェクトを返します。
     *              Returns a Player object.
     *
     * @member {Player}
     * @readonly
     * @public
     */
    get player ()
    {
        return this._$player;
    }

    /**
     * @description 現在のCanvasの高さをピクセル単位で指定します。
     *              Specifies the height of the current Canvas in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get canvasHeight ()
    {
        return this._$player
            ? this._$player._$height / Util.$devicePixelRatio
            : 0;
    }

    /**
     * @description 現在のCanvasの幅をピクセル単位で指定します。
     *              Specifies the width of the current Canvas in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get canvasWidth ()
    {
        return this._$player
            ? this._$player._$width / Util.$devicePixelRatio
            : 0;
    }

    /**
     * @description 現在のStageの高さをピクセル単位で指定します。
     *              Specifies the height of the current Stage in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get currentStageHeight ()
    {
        return this._$player
            ? this._$player._$baseHeight * this._$player._$scale
            : 0;
    }

    /**
     * @description 現在のStageの幅をピクセル単位で指定します。
     *              Specifies the width of the current Stage in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get currentStageWidth ()
    {
        return this._$player
            ? this._$player._$baseWidth * this._$player._$scale
            : 0;
    }

    /**
     * @description 初期設定したステージの高さをピクセル単位で指定します。
     *              Specifies the height of the initially set stage in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get stageHeight ()
    {
        return this._$player ? this._$player._$baseHeight : 0;
    }

    /**
     * @description 初期設定したステージの幅をピクセル単位で指定します。
     *              Specifies the width of the initially set stage in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get stageWidth ()
    {
        return this._$player ? this._$player._$baseWidth : 0;
    }

    /**
     * @description 表示リストをレンダリングする必要のある次の機会に、
     *              表示オブジェクトに警告するようランタイムに通知します。
     *              (例えば、再生ヘッドを新しいフレームに進める場合などです。)
     *              Calling the invalidate() method signals runtimes
     *              to alert display objects on the next opportunity
     *              it has to render the display list.
     *              (for example, when the playhead advances to a new frame)
     *
     * @return {void}
     * @method
     * @public
     */
    invalidate ()
    {
        this._$invalidate = true;
    }
}

/**
 * StageQuality クラスでは、Stage.quality パラメーターの値を定義します。
 * デバイスフォントは quality プロパティの影響を受けません。
 *
 * The StageQuality class defines the value of the Stage.quality parameter.
 * which are therefore unaffected by the quality property.
 *
 * @class
 * @memberOf next2d.display
 */
class StageQuality
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class StageQuality]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class StageQuality]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.display.StageQuality
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.display.StageQuality";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object StageQuality]
     * @method
     * @public
     */
    toString ()
    {
        return "[object StageQuality]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.display.StageQuality
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.display.StageQuality";
    }

    /**
     * @description 高いレンダリング品質を指定します。
     *              Specifies high rendering quality.
     *
     * @return  {string}
     * @default high
     * @method
     * @static
     */
    static get HIGH ()
    {
        return "high";
    }

    /**
     * @description 低いレンダリング品質を指定します。
     *              Specifies low rendering quality.
     *
     * @return  {string}
     * @default low
     * @method
     * @static
     */
    static get LOW ()
    {
        return "low";
    }

    /**
     * @description 中程度のレンダリング品質を指定します。
     *              Specifies medium rendering quality.
     *
     * @return  {string}
     * @default medium
     * @method
     * @static
     */
    static get MEDIUM ()
    {
        return "medium";
    }
}

/**
 * BitmapFilter クラスは、すべてのイメージフィルター効果の基本クラスです。
 * BevelFilter、BlurFilter、ColorMatrixFilter、ConvolutionFilter、DisplacementMapFilter、DropShadowFilter、GlowFilter、GradientBevelFilter、
 * および GradientGlowFilter クラスはすべて、BitmapFilter クラスを継承します。
 * このフィルター効果は、あらゆる表示オブジェクトに適用できます。
 *
 * The BitmapFilter class is the base class for all image filter effects.
 * The BevelFilter, BlurFilter, ColorMatrixFilter, ConvolutionFilter, DisplacementMapFilter, DropShadowFilter, GlowFilter, GradientBevelFilter,
 * and GradientGlowFilter classes all extend the BitmapFilter class.
 * You can apply these filter effects to any display object.
 * You can neither directly instantiate nor extend BitmapFilter.
 *
 * @class
 * @memberOf next2d.filters
 */
class BitmapFilter
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$updated = true;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BitmapFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BitmapFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.BitmapFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.BitmapFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BitmapFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BitmapFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.BitmapFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.BitmapFilter";
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$isUpdated ()
    {
        return this._$updated;
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$doChanged ()
    {
        this._$updated  = true;
        Util.$isUpdated = true;
    }
}

/**
 * BitmapFilterType クラスには、BitmapFilter の型を設定する値が含まれます。
 * The BitmapFilterType class contains values to set the type of a BitmapFilter.
 *
 * @class
 * @memberOf next2d.filters
 */
class BitmapFilterType
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BitmapFilterType]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BitmapFilterType]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.BitmapFilterType
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.BitmapFilterType";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BitmapFilterType]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BitmapFilterType]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.BitmapFilterType
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.BitmapFilterType";
    }

    /**
     * @description オブジェクトの領域全体にフィルターを適用する設定を定義します。
     *              Defines the setting that applies a filter to the entire area of an object.
     *
     * @return  {string}
     * @default full
     * @const
     * @static
     */
    static get FULL ()
    {
        return "full";
    }

    /**
     * @description オブジェクトの内側の領域にフィルターを適用する設定を定義します。
     *              Defines the setting that applies a filter to the inner area of an object.
     *
     * @return  {string}
     * @default inner
     * @const
     * @static
     */
    static get INNER ()
    {
        return "inner";
    }

    /**
     * @description オブジェクトの外側の領域にフィルターを適用する設定を定義します。
     *              Defines the setting that applies a filter to the outer area of an object.
     *
     * @return  {string}
     * @default outer
     * @const
     * @static
     */
    static get OUTER ()
    {
        return "outer";
    }
}

/**
 * BitmapFilterQuality クラスには、BitmapFilter オブジェクトのレンダリング品質を設定する値が含まれます。
 * The BitmapFilterQuality class contains values to set the rendering quality of a BitmapFilter object.
 *
 * @class
 * @memberOf next2d.filters
 */
class BitmapFilterQuality
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BitmapFilterQuality]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BitmapFilterQuality]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.BitmapFilterQuality
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.BitmapFilterQuality";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BitmapFilterQuality]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BitmapFilterQuality]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.BitmapFilterQuality
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.BitmapFilterQuality";
    }

    /**
     * @description 低品質のフィルター設定を定義します。
     *              Defines the low quality filter setting.
     *
     * @return  {number}
     * @default 1
     * @const
     * @static
     */
    static get LOW ()
    {
        return 1;
    }

    /**
     * @description 標準品質のフィルター設定を定義します。
     *              Defines the medium quality filter setting.
     *
     * @return  {number}
     * @default 2
     * @const
     * @static
     */
    static get MEDIUM ()
    {
        return 2;
    }

    /**
     * @description 高品質のフィルター設定を定義します。
     *              Defines the high quality filter setting.
     *
     * @return  {number}
     * @default 3
     * @const
     * @static
     */
    static get HIGH ()
    {
        return 3;
    }
}

/**
 * DisplacementMapFilterMode クラスは DisplacementMapFilter クラスの mode プロパティの値を提供します。
 * The DisplacementMapFilterMode class provides values for the mode property of the DisplacementMapFilter class.
 *
 * @class
 * @memberOf next2d.filters
 */
class DisplacementMapFilterMode
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class DisplacementMapFilterMode]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class DisplacementMapFilterMode]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.DisplacementMapFilterMode
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.DisplacementMapFilterMode";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object DisplacementMapFilterMode]
     * @method
     * @public
     */
    toString ()
    {
        return "[object DisplacementMapFilterMode]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.DisplacementMapFilterMode
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.DisplacementMapFilterMode";
    }

    /**
     * @description 置き換え値をソースイメージのエッジに固定します。
     *              Clamps the displacement value to the edge of the source image.
     *
     * @return  {string}
     * @default clamp
     * @const
     * @static
     */
    static get CLAMP ()
    {
        return "clamp";
    }

    /**
     * @description 置き換え値がイメージの外にある場合、color プロパティと
     *              alpha プロパティの値を置き換えます。
     *              If the displacement value is outside the image,
     *              substitutes the values in the color and alpha properties.
     *
     * @return  {string}
     * @default color
     * @const
     * @static
     */
    static get COLOR ()
    {
        return "color";
    }

    /**
     * @description 置き換え値が範囲外である場合、その置き換えを無視して、
     *              ソースピクセルを使用します。
     *              If the displacement value is out of range,
     *              ignores the displacement and uses the source pixel.
     *
     * @return  {string}
     * @default ignore
     * @const
     * @static
     */
    static get IGNORE ()
    {
        return "ignore";
    }

    /**
     * @description 置き換え値をソースイメージの反対側で折り返します。
     *              Wraps the displacement value to the other side of the source image.
     *
     * @return  {string}
     * @default wrap
     * @const
     * @static
     */
    static get WRAP ()
    {
        return "wrap";
    }
}

/**
 * BlurFilter クラスを使用すると、表示オブジェクトにぼかし効果を適用できます。
 * ぼかし効果は、イメージの細部をぼかします。ソフトフォーカスがかかっているように見えるぼかしから、
 * 半透明ガラスを通してイメージを見るようにかすんで見えるガウスぼかしまで作成できます。
 * このフィルターの quality プロパティを低く設定すると、ソフトフォーカスがかかっているように見えるぼかしになります。
 * quality プロパティを高く設定すると、ガウスぼかしフィルターに似たものになります。
 *
 * The BlurFilter class lets you apply a blur visual effect to display objects.
 * A blur effect softens the details of an image.
 * You can produce blurs that range from a softly unfocused look to a Gaussian blur,
 * a hazy appearance like viewing an image through semi-opaque glass.
 * When the quality property of this filter is set to low, the result is a softly unfocused look.
 * When the quality property is set to high, it approximates a Gaussian blur filter.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class BlurFilter extends BitmapFilter
{
    /**
     * @param {number}  [blur_x=4]
     * @param {number}  [blur_y=4]
     * @param {int}     [quality=1]
     *
     * @constructor
     * @public
     */
    constructor (blur_x = 4, blur_y = 4, quality = 1)
    {
        super();

        /**
         * @type {number}
         * @default 4
         * @private
         */
        this._$blurX = 4;

        /**
         * @type {number}
         * @default 4
         * @private
         */
        this._$blurY = 4;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$quality = 1;

        // setup
        this.blurX   = blur_x;
        this.blurY   = blur_y;
        this.quality = quality;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BlurFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BlurFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.BlurFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.BlurFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BlurFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BlurFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.BlurFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.BlurFilter";
    }

    /**
     * @return {array}
     * @private
     */
    static get STEP ()
    {
        return [0.5, 1.05, 1.4, 1.55, 1.75, 1.9, 2, 2.15, 2.2, 2.3, 2.5, 3, 3, 3.5, 3.5];
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurX;
    }
    set blurX (blur_x)
    {
        blur_x = Util.$clamp(+blur_x, 0, 255, 0);
        if (blur_x !== this._$blurX) {
            this._$doChanged(true);
        }
        this._$blurX = blur_x;
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurY;
    }
    set blurY (blur_y)
    {
        blur_y = Util.$clamp(+blur_y, 0, 255, 0);
        if (blur_y !== this._$blurY) {
            this._$doChanged(true);
        }
        this._$blurY = blur_y;
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$quality;
    }
    set quality (quality)
    {
        quality = Util.$clamp(quality | 0, 0, 15, BitmapFilterQuality.LOW);
        if (quality !== this._$quality) {
            this._$doChanged(true);
        }
        this._$quality = quality;
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {BlurFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new BlurFilter(this._$blurX, this._$blurY, this._$quality);
    }

    /**
     * @param  {Rectangle} rect
     * @param  {number}    [x_scale=null]
     * @param  {number}    [y_scale=null]
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect, x_scale = null, y_scale = null)
    {
        const clone = rect.clone();

        if (!this._$quality) {
            return clone;
        }

        const step = BlurFilter.STEP[this._$quality - 1];

        let dx = 0 >= this._$blurX ? 1 : this._$blurX * step;
        let dy = 0 >= this._$blurY ? 1 : this._$blurY * step;

        switch (true) {

            case typeof x_scale === "number":
            case typeof y_scale === "number":
                dx *= x_scale;
                dy *= y_scale;
                break;

            default:
                dx = $Math.round(dx);
                dy = $Math.round(dy);
                break;

        }

        clone.x      -= dx;
        clone.width  += dx * 2;
        clone.y      -= dy;
        clone.height += dy * 2;

        return clone;
    }

    /**
     * @param  {BlurFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        return this._$quality === filter._$quality
            && this._$blurX === filter._$blurX
            && this._$blurY === filter._$blurY;
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$quality && this._$blurX && this._$blurY;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {boolean} [removed=true]
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context, matrix, removed = true)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        const baseTexture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();

        if (!this._$canApply()) {
            if (removed) {
                return baseTexture;
            }
            return context
                .frameBuffer
                .createTextureFromCurrentAttachment();

        }

        // matrix to scale
        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        // after size
        const baseRect = new Rectangle(0, 0, baseTexture.width, baseTexture.height);
        const rect = this._$generateFilterRect(baseRect, xScale, yScale);

        const width   = $Math.ceil(rect.width) | 0;
        const height  = $Math.ceil(rect.height) | 0;
        const offsetX = $Math.ceil($Math.abs(rect.x) + $Math.abs(width  - rect.width)  * 0.5);
        const offsetY = $Math.ceil($Math.abs(rect.y) + $Math.abs(height - rect.height) * 0.5);

        // set offset xy
        context._$offsetX = +(offsetX + context._$offsetX);
        context._$offsetY = +(offsetY + context._$offsetY);

        const baseBlurX = this._$blurX * xScale;
        const baseBlurY = this._$blurY * yScale;

        let bufferScaleX = 1;
        let bufferScaleY = 1;

        if (baseBlurX > 128) {
            bufferScaleX = 0.0625;
        } else if (baseBlurX > 64) {
            bufferScaleX = 0.125;
        } else if (baseBlurX > 32) {
            bufferScaleX = 0.25;
        } else if (baseBlurX > 16) {
            bufferScaleX = 0.5;
        }

        if (baseBlurY > 128) {
            bufferScaleY = 0.0625;
        } else if (baseBlurY > 64) {
            bufferScaleY = 0.125;
        } else if (baseBlurY > 32) {
            bufferScaleY = 0.25;
        } else if (baseBlurY > 16) {
            bufferScaleY = 0.5;
        }

        const bufferBlurX = baseBlurX * bufferScaleX;
        const bufferBlurY = baseBlurY * bufferScaleY;

        let bufferWidth  = $Math.ceil(width  * bufferScaleX);
        let bufferHeight = $Math.ceil(height * bufferScaleY);

        const attachment0 = context
            .frameBuffer
            .createTextureAttachment(bufferWidth, bufferHeight);

        const attachment1 = context
            .frameBuffer
            .createTextureAttachment(bufferWidth, bufferHeight);

        const attachments = [attachment0, attachment1];
        let attachmentIndex = 0;

        context._$bind(attachment0);

        // draw
        Util.$resetContext(context);
        context.setTransform(bufferScaleX, 0, 0, bufferScaleY, 0, 0);
        context.drawImage(
            baseTexture, offsetX, offsetY,
            baseTexture.width, baseTexture.height
        );

        // set alpha
        context.blend.toOneZero();

        // execute
        let targetTexture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();

        for (let q = 0; q < this._$quality; ++q) {

            // draw blur x
            if (this._$blurX > 0) {

                attachmentIndex = (attachmentIndex + 1) % 2;

                const xTexture = attachments[attachmentIndex];
                context._$bind(xTexture);

                context._$applyBlurFilter(targetTexture, true, bufferBlurX);

                targetTexture = context
                    .frameBuffer
                    .getTextureFromCurrentAttachment();
            }

            // draw blur y
            if (this._$blurY > 0) {

                attachmentIndex = (attachmentIndex + 1) % 2;

                const yTexture = attachments[attachmentIndex];
                context._$bind(yTexture);

                context._$applyBlurFilter(targetTexture, false, bufferBlurY);

                targetTexture = context
                    .frameBuffer
                    .getTextureFromCurrentAttachment();
            }
        }

        // reset alpha
        context.blend.reset();

        if (bufferScaleX !== 1 || bufferScaleY !== 1) {

            const resultAttachment = context
                .frameBuffer
                .createTextureAttachment(width, height);
            context._$bind(resultAttachment);

            Util.$resetContext(context);
            context.imageSmoothingEnabled = true;
            context.setTransform(1 / bufferScaleX, 0, 0, 1 / bufferScaleY, 0, 0);
            context.drawImage(targetTexture, 0, 0, bufferWidth, bufferHeight);

            targetTexture = context
                .frameBuffer
                .getTextureFromCurrentAttachment();

            Util.$resetContext(context);
            context.setTransform(1, 0, 0, 1, 0, 0);

            context
                .frameBuffer
                .releaseAttachment(attachments[0], true);

            context
                .frameBuffer
                .releaseAttachment(attachments[1], true);

            if (removed) {
                context
                    .frameBuffer
                    .releaseAttachment(currentAttachment, true);
            } else {
                context
                    .frameBuffer
                    .releaseAttachment(resultAttachment, false);
            }

        } else {

            // 最終結果ではない方のAttachmentを解放する
            context
                .frameBuffer
                .releaseAttachment(attachments[(attachmentIndex + 1) % 2], true);

            if (removed) {
                // 適用前のAttachmentを解放する
                context
                    .frameBuffer
                    .releaseAttachment(currentAttachment, true);
            } else {
                // 適用後のAttachmentを解放する
                context
                    .frameBuffer
                    .releaseAttachment(attachments[attachmentIndex], false);
            }
        }

        return targetTexture;
    }
}

/**
 * BevelFilter クラスを使用すると、表示オブジェクトにベベル効果を追加できます。
 * ボタンなどのオブジェクトにベベル効果を適用すると 3 次元的に表現されます。
 * 異なるハイライトカラー、シャドウカラー、ベベルのぼかし量、ベベルの角度、ベベルの配置、
 * ノックアウト効果を使用して、ベベルの外観をカスタマイズできます。
 *
 * The BevelFilter class lets you add a bevel effect to display objects.
 * A bevel effect gives objects such as buttons a three-dimensional look.
 * You can customize the look of the bevel with different highlight and shadow colors,
 * the amount of blur on the bevel, the angle of the bevel, the placement of the bevel,
 * and a knockout effect.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class BevelFilter extends BitmapFilter
{
    /**
     * @param {number}  [distance=4]
     * @param {number}  [angle=45]
     * @param {uint}    [highlight_color=0xffffff]
     * @param {number}  [highlight_alpha=1]
     * @param {uint}    [shadow_color=0x000000]
     * @param {number}  [shadow_alpha=1]
     * @param {number}  [blur_x=4]
     * @param {number}  [blur_y=4]
     * @param {number}  [strength=1]
     * @param {int}     [quality=1]
     * @param {string}  [type=BitmapFilterType.INNER]
     * @param {boolean} [knockout=false]
     *
     * @constructor
     * @public
     */
    constructor (
        distance = 4, angle = 45, highlight_color = 0xffffff, highlight_alpha = 1,
        shadow_color = 0, shadow_alpha = 1, blur_x = 4, blur_y = 4,
        strength = 1, quality = 1, type = "inner", knockout = false
    ) {

        super();

        /**
         * @type {BlurFilter}
         * @default BlurFilter
         * @private
         */
        this._$blurFilter = new BlurFilter(blur_x, blur_y, quality);

        /**
         * @type {number}
         * @default 4
         * @private
         */
        this._$distance = 4;

        /**
         * @type {number}
         * @default 45
         * @private
         */
        this._$angle = 45;

        /**
         * @type {number}
         * @default 0xffffff
         * @private
         */
        this._$highlightColor = 0xffffff;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$highlightAlpha = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$shadowColor = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$shadowAlpha = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$strength = 1;

        /**
         * @type {string}
         * @default BitmapFilterType.INNER
         * @private
         */
        this._$type = BitmapFilterType.INNER;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$knockout = false;

        // setup
        this.distance       = distance;
        this.angle          = angle;
        this.highlightColor = highlight_color;
        this.highlightAlpha = highlight_alpha;
        this.shadowColor    = shadow_color;
        this.shadowAlpha    = shadow_alpha;
        this.strength       = strength;
        this.type           = type;
        this.knockout       = !!knockout;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class BevelFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class BevelFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.BevelFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.BevelFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object BevelFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object BevelFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.BevelFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.BevelFilter";
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        angle %= 360;
        if (angle !== this._$angle) {
            this._$doChanged(true);
        }
        this._$angle = Util.$clamp(angle, -360, 360, 45);
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurFilter._$blurX;
    }
    set blurX (blur_x)
    {
        this._$blurFilter.blurX = blur_x;
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurFilter._$blurY;
    }
    set blurY (blur_y)
    {
        this._$blurFilter.blurY = blur_y;
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        distance = Util.$clamp(+distance, -255, 255, 4);
        if (distance !== this._$distance) {
            this._$doChanged(true);
        }
        this._$distance = distance;
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get highlightAlpha ()
    {
        return this._$highlightAlpha;
    }
    set highlightAlpha (highlight_alpha)
    {
        highlight_alpha = Util.$clamp(+highlight_alpha, 0, 1, 0);
        if (highlight_alpha !== this._$highlightAlpha) {
            this._$doChanged(true);
        }
        this._$highlightAlpha = highlight_alpha;
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 0xffffff
     * @public
     */
    get highlightColor ()
    {
        return this._$highlightColor;
    }
    set highlightColor (highlight_color)
    {
        highlight_color = Util.$clamp(
            Util.$toColorInt(highlight_color), 0, 0xffffff, 0xffffff
        );
        if (highlight_color !== this._$highlightColor) {
            this._$doChanged(true);
        }

        this._$highlightColor = highlight_color;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        knockout = !!knockout;
        if (knockout !== this._$knockout) {
            this._$doChanged(true);
        }
        this._$knockout = knockout;
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$blurFilter._$quality;
    }
    set quality (quality)
    {
        this._$blurFilter.quality = quality;
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get shadowAlpha ()
    {
        return this._$shadowAlpha;
    }
    set shadowAlpha (shadow_alpha)
    {
        shadow_alpha = Util.$clamp(+shadow_alpha, 0, 1, 0);
        if (shadow_alpha !== this._$shadowAlpha) {
            this._$doChanged(true);
        }
        this._$shadowAlpha = shadow_alpha;
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get shadowColor ()
    {
        return this._$shadowColor;
    }
    set shadowColor (shadow_color)
    {
        shadow_color = Util.$clamp(
            Util.$toColorInt(shadow_color), 0, 0xffffff, 0
        );

        if (shadow_color !== this._$shadowColor) {
            this._$doChanged(true);
        }

        this._$shadowColor = shadow_color;
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        strength = Util.$clamp(strength | 0, 0, 255, 0);
        if (strength !== this._$strength) {
            this._$doChanged(true);
        }
        this._$strength = strength;
    }

    /**
     * @description オブジェクトでのベベルの配置
     *              The placement of the bevel on the object.
     *
     * @member  {string}
     * @default BitmapFilterType.INNER
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type += "";
        if (type !== this._$type) {
            this._$doChanged(true);
        }

        switch (type) {

            case BitmapFilterType.OUTER:
            case BitmapFilterType.INNER:
                this._$type = type;
                break;

            default:
                this._$type = BitmapFilterType.FULL;
                break;

        }
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {BevelFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new BevelFilter(
            this._$distance, this._$angle, this._$highlightColor, this._$highlightAlpha,
            this._$shadowColor, this._$shadowAlpha, this._$blurFilter._$blurX, this._$blurFilter._$blurY,
            this._$strength, this._$blurFilter._$quality, this._$type, this._$knockout
        );
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$isUpdated ()
    {
        return this._$updated || this._$blurFilter._$isUpdated();
    }

    /**
     * @param  {Rectangle} rect
     * @param  {number}    [x_scale=null]
     * @param  {number}    [y_scale=null]
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect, x_scale = null, y_scale = null)
    {
        let clone = rect.clone();
        if (!this._$canApply()) {
            return clone;
        }

        clone = this._$blurFilter._$generateFilterRect(clone, x_scale, y_scale);

        const radian = this._$angle * Util.$Deg2Rad;
        const x      = $Math.abs($Math.cos(radian) * this._$distance);
        const y      = $Math.abs($Math.sin(radian) * this._$distance);

        clone.x      += -x;
        clone.width  += x;
        clone.y      += -y;
        clone.height += y * 2;

        return clone;
    }

    /**
     * @param  {BevelFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$highlightColor !== filter._$highlightColor) {
            return false;
        }

        if (this._$highlightAlpha !== filter._$highlightAlpha) {
            return false;
        }

        if (this._$shadowColor !== filter._$shadowColor) {
            return false;
        }

        if (this._$shadowAlpha !== filter._$shadowAlpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return this._$blurFilter._$isSame(filter._$blurFilter);
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$strength && this._$distance && this._$blurFilter._$canApply();
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array}  matrix
     * @return {WebGLTexture}
     * @private
     */
    _$applyFilter (context, matrix)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        const baseTexture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();
        if (!this._$canApply()) {
            return baseTexture;
        }

        const baseWidth   = currentAttachment.width;
        const baseHeight  = currentAttachment.height;
        const baseOffsetX = context._$offsetX;
        const baseOffsetY = context._$offsetY;

        // matrix to scale
        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        // pointer
        const radian = +(this._$angle * Util.$Deg2Rad);
        const x = +($Math.cos(radian) * this._$distance * xScale);
        const y = +($Math.sin(radian) * this._$distance * yScale);

        // highlight buffer
        let highlightTextureBaseAttachment = context
            .frameBuffer
            .createTextureAttachment(baseWidth, baseHeight);
        context._$bind(highlightTextureBaseAttachment);

        Util.$resetContext(context);
        context.drawImage(baseTexture, 0, 0, baseWidth, baseHeight);

        context.globalCompositeOperation = BlendMode.ERASE;
        context.drawImage(baseTexture, x * 2, y * 2, baseWidth, baseHeight);

        const highlightTextureBase = this
            ._$blurFilter
            ._$applyFilter(context, matrix, false);

        const blurWidth   = highlightTextureBase.width;
        const blurHeight  = highlightTextureBase.height;
        const bevelWidth  = $Math.ceil(blurWidth  + $Math.abs(x) * 2);
        const bevelHeight = $Math.ceil(blurHeight + $Math.abs(y) * 2);

        // bevel filter buffer
        const isInner = this._$type === BitmapFilterType.INNER;
        const width   = isInner ? baseWidth  : bevelWidth;
        const height  = isInner ? baseHeight : bevelHeight;

        const absX = $Math.abs(x);
        const absY = $Math.abs(y);
        const blurOffsetX = (blurWidth  - baseWidth)  / 2;
        const blurOffsetY = (blurHeight - baseHeight) / 2;

        let baseTextureX, baseTextureY, blurTextureX, blurTextureY;
        if (isInner) {
            baseTextureX = 0;
            baseTextureY = 0;
            blurTextureX = -blurOffsetX - x;
            blurTextureY = -blurOffsetY - y;
        } else {
            baseTextureX = absX + blurOffsetX;
            baseTextureY = absY + blurOffsetY;
            blurTextureX = absX - x;
            blurTextureY = absY - y;
        }

        context._$bind(currentAttachment);
        context._$applyBitmapFilter(
            highlightTextureBase, width, height,
            baseWidth, baseHeight, baseTextureX, baseTextureY,
            blurWidth, blurHeight, blurTextureX, blurTextureY,
            false, this._$type, this._$knockout,
            this._$strength, null, null, null,
            Util.$intToR(this._$highlightColor, this._$highlightAlpha, true),
            Util.$intToG(this._$highlightColor, this._$highlightAlpha, true),
            Util.$intToB(this._$highlightColor, this._$highlightAlpha, true),
            this._$highlightAlpha,
            Util.$intToR(this._$shadowColor, this._$shadowAlpha, true),
            Util.$intToG(this._$shadowColor, this._$shadowAlpha, true),
            Util.$intToB(this._$shadowColor, this._$shadowAlpha, true),
            this._$shadowAlpha
        );

        context._$offsetX = baseOffsetX + baseTextureX;
        context._$offsetY = baseOffsetY + baseTextureY;

        context
            .frameBuffer
            .releaseTexture(highlightTextureBase);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * ColorMatrixFilter クラスを使用すると、表示オブジェクトにぼかし効果を適用できます。
 * ぼかし効果は、イメージの細部をぼかします。ソフトフォーカスがかかっているように見えるぼかしから、
 * 半透明ガラスを通してイメージを見るようにかすんで見えるガウスぼかしまで作成できます。
 * このフィルターの quality プロパティを低く設定すると、ソフトフォーカスがかかっているように見えるぼかしになります。
 * quality プロパティを高く設定すると、ガウスぼかしフィルターに似たものになります。
 *
 * The ColorMatrixFilter class lets you apply a blur visual effect to display objects.
 * A blur effect softens the details of an image.
 * You can produce blurs that range from a softly unfocused look to a Gaussian blur,
 * a hazy appearance like viewing an image through semi-opaque glass.
 * When the quality property of this filter is set to low, the result is a softly unfocused look.
 * When the quality property is set to high, it approximates a Gaussian blur filter.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class ColorMatrixFilter extends BitmapFilter
{
    /**
     * @param {array} [matrix=null]
     *
     * @constructor
     * @public
     */
    constructor (matrix = null)
    {
        super();

        /**
         * @type {array}
         * @default {array}
         * @private
         */
        this._$matrix = [
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
        ];

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$doApply = false;

        // setup
        this.matrix = matrix;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class ColorMatrixFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class ColorMatrixFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.ColorMatrixFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.ColorMatrixFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object ColorMatrixFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object ColorMatrixFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.ColorMatrixFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.ColorMatrixFilter";
    }

    /**
     * @description 4×5 カラー変換用の20個のアイテムの配列
     *              An array of 20 items for 4x5 color transform.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get matrix ()
    {
        return this._$matrix;
    }
    set matrix (matrix)
    {
        if (!Util.$isArray(matrix) || matrix.length !== 20) {
            return ;
        }

        if (this._$matrix) {

            const length = matrix.length;
            for (let idx = 0; idx < length; ++idx) {

                if (matrix[idx] === this._$matrix[idx]) {
                    continue;
                }

                this._$doChanged(true);
                this._$doApply = true;
                break;
            }

        }

        this._$matrix = matrix;
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {ColorMatrixFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new ColorMatrixFilter(this._$matrix);
    }

    /**
     * @param  {Rectangle} rect
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect)
    {
        return rect;
    }

    /**
     * @param  {ColorMatrixFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        const length = this._$matrix.length;
        for (let idx = 0; idx < length; ++idx) {
            if (this._$matrix[idx] !== filter._$matrix[idx]) {
                return false;
            }
        }
        return true;
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$doApply;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        const texture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();

        const width   = texture.width;
        const height  = texture.height;

        // new buffer
        const targetTextureAttachment = context
            .frameBuffer
            .createTextureAttachment(width, height);
        context._$bind(targetTextureAttachment);

        // apply
        Util.$resetContext(context);
        context._$applyColorMatrixFilter(texture, this._$matrix);

        // reset
        context
            .frameBuffer
            .releaseAttachment(currentAttachment, true);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();

    }
}

/**
 * ConvolutionFilter クラスを使用すると、マトリックス畳み込みフィルター効果を適用できます。
 * 畳み込みでは、入力イメージ内のピクセルを、隣接するピクセルと組み合わせて、イメージを作成します。
 * 畳み込みを使用すると、ぼかし、エッジ検出、シャープ、エンボス、ベベルなど、幅広いイメージ効果を実現できます。
 *
 * The ConvolutionFilter class applies a matrix convolution filter effect.
 * A convolution combines pixels in the input image with neighboring pixels to produce an image.
 * A wide variety of image effects can be achieved through convolutions, including blurring,
 * edge detection, sharpening, embossing, and beveling.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class ConvolutionFilter extends BitmapFilter
{
    /**
     * @param {number}  [matrix_x=0]
     * @param {number}  [matrix_y=0]
     * @param {array}   [matrix=null]
     * @param {number}  [divisor=1.0]
     * @param {number}  [bias=0.0]
     * @param {boolean} [preserve_alpha=true]
     * @param {boolean} [clamp=true]
     * @param {number}  [color=0]
     * @param {number}  [alpha=0.0]
     *
     * @constructor
     * @public
     */
    constructor (
        matrix_x = 0, matrix_y = 0, matrix = null, divisor = 1,
        bias = 0, preserve_alpha = true, clamp = true, color = 0, alpha = 0
    ) {

        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$matrixX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$matrixY = 0;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$matrix = null;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$divisor = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bias = 0;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$preserveAlpha = true;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$clamp = true;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$color = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$alpha = 0;

        // setup
        this.matrixX       = matrix_x;
        this.matrixY       = matrix_y;
        this.matrix        = matrix;
        this.divisor       = divisor;
        this.bias          = bias;
        this.preserveAlpha = preserve_alpha;
        this.clamp         = clamp;
        this.color         = color;
        this.alpha         = alpha;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class ConvolutionFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class ConvolutionFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.ConvolutionFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.ConvolutionFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object ConvolutionFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object ConvolutionFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.ConvolutionFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.ConvolutionFilter";
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }
    set alpha (alpha)
    {
        alpha = Util.$clamp(+alpha, 0, 1, 0);
        if (alpha !== this._$alpha) {
            this._$doChanged(true);
        }
        this._$alpha = alpha;
    }

    /**
     * @description マトリックス変換の結果に加算するバイアス量です。
     *              The amount of bias to add to the result of the matrix transformation.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get bias ()
    {
        return this._$bias;
    }
    set bias (bias)
    {
        bias = +bias;
        if (bias !== this._$bias) {
            this._$doChanged(true);
        }
        this._$bias = bias;
    }

    /**
     * @description イメージをクランプする必要があるかどうかを示します。
     *              Indicates whether the image should be clamped.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get clamp ()
    {
        return this._$clamp;
    }
    set clamp (clamp)
    {
        clamp = !!clamp;
        if (clamp !== this._$clamp) {
            this._$doChanged(true);
        }
        this._$clamp = clamp;
    }

    /**
     * @description ソースイメージの外にあるピクセルを置換する 16 進数のカラー値です。
     *              The hexadecimal color to substitute for pixels that are off the source image.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        color = Util.$clamp(
            Util.$toColorInt(color), 0, 0xffffff, 0
        );

        if (color !== this._$color) {
            this._$doChanged(true);
        }

        this._$color = color;
    }

    /**
     * @description マトリックス変換中に使用する除数です。
     *              The divisor used during matrix transformation.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get divisor ()
    {
        return this._$divisor;
    }
    set divisor (divisor)
    {
        divisor = +divisor;
        if (divisor !== this._$divisor) {
            this._$doChanged(true);
        }
        this._$divisor = divisor;
    }

    /**
     * @description マトリックス変換に使用する値の配列です。
     *              An array of values used for matrix transformation.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get matrix ()
    {
        return this._$matrix;
    }
    set matrix (matrix)
    {
        this._$doChanged(true);

        if (this._$matrix) {
            Util.$poolArray(this._$matrix);
        }

        // default
        this._$matrix = Util.$getArray();

        if (Util.$isArray(matrix)) {
            this._$matrix = matrix.slice(0);
        }
    }

    /**
     * @description マトリックスの x 次元 (マトリックスの列数) です。
     *              The x dimension of the matrix (the number of columns in the matrix).
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get matrixX ()
    {
        return this._$matrixX;
    }
    set matrixX (matrix_x)
    {
        matrix_x = Util.$clamp(matrix_x | 0, 0, 15, 0) | 0;
        if (matrix_x !== this._$matrixX) {
            this._$doChanged(true);
        }
        this._$matrixX = matrix_x;
    }

    /**
     * @description マトリックスの y 次元（マトリックスの行数）です。
     *              The y dimension of the matrix (the number of rows in the matrix).
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get matrixY ()
    {
        return this._$matrixY;
    }
    set matrixY (matrix_y)
    {
        matrix_y = Util.$clamp(matrix_y | 0, 0, 15, 0) | 0;
        if (matrix_y !== this._$matrixY) {
            this._$doChanged(true);
        }
        this._$matrixY = matrix_y;
    }

    /**
     * @description アルファチャンネルがフィルター効果なしで維持されるかどうか、またはカラーチャンネルだけではなく
     *              アルファチャンネルにも畳み込みフィルターが適用されるかどうかを示します。
     *              Indicates if the alpha channel is preserved without the filter effect or
     *              if the convolution filter is applied to the alpha channel as well as the color channels.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get preserveAlpha ()
    {
        return this._$preserveAlpha;
    }
    set preserveAlpha (preserve_alpha)
    {
        preserve_alpha = !!preserve_alpha;
        if (preserve_alpha !== this._$preserveAlpha) {
            this._$doChanged(true);
        }
        this._$preserveAlpha = preserve_alpha;
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {ConvolutionFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new ConvolutionFilter(
            this._$matrixX, this._$matrixY, this._$matrix,
            this._$divisor, this._$bias, this._$preserveAlpha,
            this._$clamp, this._$color, this._$alpha
        );
    }

    /**
     * @param  {Rectangle} rect
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect)
    {
        return rect;
    }

    /**
     * @param  {ConvolutionFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$matrixX !== filter._$matrixX) {
            return false;
        }

        if (this._$matrixY !== filter._$matrixY) {
            return false;
        }

        if (this._$divisor !== filter._$divisor) {
            return false;
        }

        if (this._$bias !== filter._$bias) {
            return false;
        }

        if (this._$preserveAlpha !== filter._$preserveAlpha) {
            return false;
        }

        if (this._$clamp !== filter._$clamp) {
            return false;
        }

        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        const length = this._$matrix.length;
        for (let idx = 0; idx < length; ++idx) {
            if (this._$matrix[idx] !== filter._$matrix[idx]) {
                return false;
            }
        }

        return true;
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$matrixX * this._$matrixY === this._$matrix.length;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        const texture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();
        if (!this._$canApply()) {
            return texture;
        }

        context._$applyConvolutionFilter(
            texture,
            this._$matrixX,
            this._$matrixY,
            this._$matrix,
            this._$divisor,
            this._$bias,
            this._$preserveAlpha,
            this._$clamp,
            Util.$intToR(this._$color, this._$alpha, false),
            Util.$intToG(this._$color, this._$alpha, false),
            Util.$intToB(this._$color, this._$alpha, false),
            this._$alpha
        );

        context
            .frameBuffer
            .releaseAttachment(currentAttachment, true);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * DisplacementMapFilter クラスは、指定された BitmapData オブジェクト（置き換えマップイメージと言います）
 * のピクセル値を使用して、オブジェクトの置き換え（変位）を実行します。
 *
 * The DisplacementMapFilter class uses the pixel values from the specified
 * BitmapData object (called the displacement map image) to perform a displacement of an object.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class DisplacementMapFilter extends BitmapFilter
{
    /**
     * @param {BitmapData} [map_bitmap = null]
     * @param {Point}      [map_point = null]
     * @param {number}     [component_x = 0]
     * @param {number}     [component_y = 0]
     * @param {number}     [scale_x = 0.0]
     * @param {number}     [scale_y = 0.0]
     * @param {string}     [mode = DisplacementMapFilterMode.WRAP]
     * @param {number}     [color = 0]
     * @param {number}     [alpha = 0.0]
     *
     * @constructor
     * @public
     */
    constructor (
        map_bitmap = null, map_point = null, component_x = 0, component_y = 0,
        scale_x = 0, scale_y = 0, mode = "wrap", color = 0, alpha = 0
    ) {

        super();

        /**
         * @type {BitmapData}
         * @default null
         * @private
         */
        this._$mapBitmap = null;

        /**
         * @type {Point}
         * @default null
         * @private
         */
        this._$mapPoint = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$componentX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$componentY = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scaleX = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scaleY = 0;

        /**
         * @type {string}
         * @default DisplacementMapFilterMode.WRAP
         * @private
         */
        this._$mode = DisplacementMapFilterMode.WRAP;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$color = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$alpha = 0;

        // setup
        this.mapBitmap  = map_bitmap;
        this.mapPoint   = map_point;
        this.componentX = component_x;
        this.componentY = component_y;
        this.scaleX     = scale_x;
        this.scaleY     = scale_y;
        this.mode       = mode;
        this.color      = color;
        this.alpha      = alpha;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class DisplacementMapFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class DisplacementMapFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.DisplacementMapFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.DisplacementMapFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object DisplacementMapFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object DisplacementMapFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.DisplacementMapFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.DisplacementMapFilter";
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }
    set alpha (alpha)
    {
        alpha = Util.$clamp(+alpha, 0, 1, 0);
        if (alpha !== this._$alpha) {
            this._$doChanged(true);
        }
        this._$alpha = alpha;
    }

    /**
     * @description 範囲外置き換えの場合に使用する色を指定します。
     *              Specifies what color to use for out-of-bounds displacements.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        color = Util.$clamp(
            Util.$toColorInt(color),0 ,0xffffff, 0
        );

        if (color !== this._$color) {
            this._$doChanged(true);
        }

        this._$color = color;
    }

    /**
     * @description x の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。
     *              Describes which color channel to use in the map image to displace the x result.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get componentX ()
    {
        return this._$componentX;
    }
    set componentX (component_x)
    {
        component_x |= 0;
        if (component_x !== this._$componentX) {
            this._$doChanged(true);
        }

        this._$componentX = 0;
        switch (component_x) {

            case BitmapDataChannel.ALPHA:
            case BitmapDataChannel.BLUE:
            case BitmapDataChannel.GREEN:
            case BitmapDataChannel.RED:
                this._$componentX = component_x;
                break;

            default:
                break;

        }
    }

    /**
     * @description y の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。
     *              Describes which color channel to use in the map image to displace the y result.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get componentY ()
    {
        return this._$componentY;
    }
    set componentY (component_y)
    {
        component_y |= 0;
        if (component_y !== this._$componentY) {
            this._$doChanged(true);
        }

        this._$componentY = 0;
        switch (component_y) {

            case BitmapDataChannel.ALPHA:
            case BitmapDataChannel.BLUE:
            case BitmapDataChannel.GREEN:
            case BitmapDataChannel.RED:
                this._$componentY = component_y;
                break;

            default:
                break;

        }
    }

    /**
     * @description 置き換えマップデータが含まれる BitmapData オブジェクトです。
     *              A BitmapData object containing the displacement map data.
     *
     * @member  {BitmapData}
     * @default null
     * @public
     */
    get mapBitmap ()
    {
        return this._$mapBitmap;
    }
    set mapBitmap (map_bitmap)
    {
        if (map_bitmap !== this._$mapBitmap) {
            this._$doChanged(true);
        }

        // default
        this._$mapBitmap = null;
        if (map_bitmap instanceof BitmapData) {
            this._$mapBitmap = map_bitmap;
        }
    }

    /**
     * @description マップイメージの左上隅を基準としたターゲット表示オブジェクトの
     *              左上隅のオフセットが含まれる値です。
     *              A value that contains the offset of the upper-left corner
     *              of the target display object from the upper-left corner of the map image.
     *
     * @member  {Point}
     * @default null
     * @public
     */
    get mapPoint ()
    {
        return this._$mapPoint;
    }
    set mapPoint (map_point)
    {
        if (map_point !== this._$mapPoint) {
            this._$doChanged(true);
        }

        // default
        this._$mapPoint = null;

        if (map_point instanceof Point) {
            this._$mapPoint = map_point;
        }
    }

    /**
     * @description フィルターのモードです。
     *              The mode for the filter.
     *
     * @member  {string}
     * @default DisplacementMapFilterMode.WRAP
     * @public
     */
    get mode ()
    {
        return this._$mode;
    }
    set mode (mode)
    {
        mode += "";
        if (mode !== this._$mode) {
            this._$doChanged(true);
        }

        this._$mode = DisplacementMapFilterMode.WRAP;
        switch (mode) {

            case DisplacementMapFilterMode.CLAMP:
            case DisplacementMapFilterMode.COLOR:
            case DisplacementMapFilterMode.IGNORE:
                this._$mode = mode;
                break;

            default:
                break;

        }
    }

    /**
     * @description マップ計算の x 置き換え結果を拡大 / 縮小する場合に使用する乗数です。
     *              The multiplier to use to scale the x displacement result from the map calculation.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get scaleX ()
    {
        return this._$scaleX;
    }
    set scaleX (scale_x)
    {
        scale_x = Util.$clamp(+scale_x, -0xffff, 0xffff, 0);
        if (scale_x !== this._$scaleX) {
            this._$doChanged(true);
        }
        this._$scaleX = scale_x;
    }

    /**
     * @description マップ計算の y 置き換え結果を拡大 / 縮小する場合に使用する乗数です。
     *              The multiplier to use to scale the y displacement result from the map calculation.
     *
     * @member  {number}
     * @default 0
     * @public
     */
    get scaleY ()
    {
        return this._$scaleY;
    }
    set scaleY (scale_y)
    {
        scale_y = Util.$clamp(+scale_y, -0xffff, 0xffff, 0);
        if (scale_y !== this._$scaleY) {
            this._$doChanged(true);
        }
        this._$scaleY = scale_y;
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {DisplacementMapFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new DisplacementMapFilter(
            this._$mapBitmap, this._$mapPoint, this._$componentX, this._$componentY,
            this._$scaleX, this._$scaleY, this._$mode, this._$color, this._$alpha
        );
    }

    /**
     * @param  {Rectangle} rect
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect)
    {
        return rect;
    }

    /**
     * @param  {DisplacementMapFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$mapBitmap !== filter._$mapBitmap) {
            return false;
        }

        if (this._$mapPoint.x !== filter._$mapPoint.x) {
            return false;
        }

        if (this._$mapPoint.y !== filter._$mapPoint.y) {
            return false;
        }

        if (this._$componentX !== filter._$componentX) {
            return false;
        }

        if (this._$componentY !== filter._$componentY) {
            return false;
        }

        if (this._$scaleX !== filter._$scaleX) {
            return false;
        }

        if (this._$scaleY !== filter._$scaleY) {
            return false;
        }

        if (this._$mode !== filter._$mode) {
            return false;
        }

        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        return true;
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$mapBitmap
            && this._$componentX && this._$componentY
            && this._$scaleX && this._$scaleY;
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array}  matrix
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context, matrix)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        const texture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();
        if (!this._$canApply()) {
            return texture;
        }

        // matrix to scale
        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        context._$applyDisplacementMapFilter(
            texture,
            this._$mapBitmap._$texture,
            texture.width  / xScale,
            texture.height / yScale,
            this._$mapPoint,
            this._$componentX,
            this._$componentY,
            this._$scaleX,
            this._$scaleY,
            this._$mode,
            Util.$intToR(this._$color, this._$alpha, true),
            Util.$intToG(this._$color, this._$alpha, true),
            Util.$intToB(this._$color, this._$alpha, true),
            this._$alpha
        );

        context
            .frameBuffer
            .releaseAttachment(currentAttachment, true);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * DropShadowFilter クラスは、ドロップシャドウを表示オブジェクトに追加します。
 * シャドウアルゴリズムは、ぼかしフィルターで使用するのと同じボックスフィルターに基づいています。
 * ドロップシャドウのスタイルには複数のオプションがあり、内側シャドウ、外側シャドウ、ノックアウトモードなどがあります。
 *
 * The DropShadowFilter class lets you add a drop shadow to display objects.
 * The shadow algorithm is based on the same box filter that the blur filter uses.
 * You have several options for the style of the drop shadow, including inner
 * or outer shadow and knockout mode.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class DropShadowFilter extends BitmapFilter
{
    /**
     * @param   {number}  [distance=4]
     * @param   {number}  [angle=45]
     * @param   {number}  [color=0]
     * @param   {number}  [alpha=1]
     * @param   {number}  [blur_x=4]
     * @param   {number}  [blur_y=4]
     * @param   {number}  [strength=1]
     * @param   {number}  [quality=1]
     * @param   {boolean} [inner=false]
     * @param   {boolean} [knockout=false]
     * @param   {boolean} [hide_object=false]
     *
     * @constructor
     * @public
     */
    constructor (
        distance = 4, angle = 45, color = 0, alpha = 1, blur_x = 4, blur_y = 4,
        strength = 1, quality = 1, inner = false, knockout = false, hide_object = false
    ) {

        super();

        /**
         * @type {BlurFilter}
         * @default BlurFilter
         * @private
         */
        this._$blurFilter = new BlurFilter(blur_x, blur_y, quality);

        /**
         * @type {number}
         * @default 4
         * @private
         */
        this._$distance = 4;

        /**
         * @type {number}
         * @default 45
         * @private
         */
        this._$angle = 45;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$color = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$alpha = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$strength = 1;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$inner = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$knockout = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$hideObject = false;

        // setup
        this.distance   = distance;
        this.angle      = angle;
        this.color      = color;
        this.alpha      = alpha;
        this.strength   = strength;
        this.inner      = inner;
        this.knockout   = knockout;
        this.hideObject = hide_object;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class DropShadowFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class DropShadowFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.DropShadowFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.DropShadowFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object DropShadowFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object DropShadowFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.DropShadowFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.DropShadowFilter";
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }
    set alpha (alpha)
    {
        alpha = Util.$clamp(+alpha, 0, 1, 0);
        if (alpha !== this._$alpha) {
            this._$doChanged(true);
        }
        this._$alpha = alpha;
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        angle %= 360;
        if (angle !== this._$angle) {
            this._$doChanged(true);
        }
        this._$angle = Util.$clamp(angle, -360, 360, 45);
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurFilter._$blurX;
    }
    set blurX (blur_x)
    {
        this._$blurFilter.blurX = blur_x;
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurFilter._$blurY;
    }
    set blurY (blur_y)
    {
        this._$blurFilter.blurY = blur_y;
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        color = Util.$clamp(
            Util.$toColorInt(color), 0, 0xffffff, 0
        );

        if (color !== this._$color) {
            this._$doChanged(true);
        }

        this._$color = color;
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        distance = Util.$clamp(+distance, -255, 255, 4);
        if (distance !== this._$distance) {
            this._$doChanged(true);
        }
        this._$distance = distance;
    }

    /**
     * @description オブジェクトが非表示であるかどうかを示します。
     *              Indicates whether or not the object is hidden.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get hideObject ()
    {
        return this._$hideObject;
    }
    set hideObject (hide_object)
    {
        hide_object = !!hide_object;
        if (hide_object !== this._$hideObject) {
            this._$doChanged(true);
        }
        this._$hideObject = hide_object;
    }

    /**
     * @description グローが内側グローであるかどうか
     *              Specifies whether the glow is an inner glow.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }
    set inner (inner)
    {
        inner = !!inner;
        if (inner !== this._$inner) {
            this._$doChanged(true);
        }
        this._$inner = inner;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        knockout = !!knockout;
        if (knockout !== this._$knockout) {
            this._$doChanged(true);
        }
        this._$knockout = knockout;
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$blurFilter._$quality;
    }
    set quality (quality)
    {
        this._$blurFilter.quality = quality;
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        strength = Util.$clamp(strength | 0, 0, 255, 0);
        if (strength !== this._$strength) {
            this._$doChanged(true);
        }
        this._$strength = strength;
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {DropShadowFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new DropShadowFilter(
            this._$distance, this._$angle, this._$color, this._$alpha,
            this._$blurFilter._$blurX, this._$blurFilter._$blurY, this._$strength,
            this._$blurFilter._$quality, this._$inner, this._$knockout, this._$hideObject
        );
    }

    /**
     * @return {boolean}
     * @method
     * @public
     */
    _$isUpdated ()
    {
        return this._$updated || this._$blurFilter._$isUpdated();
    }

    /**
     * @param  {Rectangle} rect
     * @param  {number}    [x_scale=null]
     * @param  {number}    [y_scale=null]
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect, x_scale = null, y_scale = null)
    {
        let clone = rect.clone();
        if (!this._$canApply()) {
            return clone;
        }

        clone = this
            ._$blurFilter
            ._$generateFilterRect(clone, x_scale, y_scale);

        const radian = this._$angle * Util.$Deg2Rad;
        const x      = $Math.cos(radian) * this._$distance * 2;
        const y      = $Math.sin(radian) * this._$distance * 2;

        clone.x      = $Math.min(clone.x, x);
        clone.width  += $Math.abs(x);
        clone.y      = $Math.min(clone.y, y);
        clone.height += $Math.abs(y);

        return clone;
    }

    /**
     * @param  {DropShadowFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        if (this._$hideObject !== filter._$hideObject) {
            return false;
        }

        return this._$blurFilter._$isSame(filter._$blurFilter);
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$alpha && this._$strength && this._$blurFilter._$canApply();
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array}  matrix
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context, matrix)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        if (!this._$canApply()) {
            return context
                .frameBuffer
                .getTextureFromCurrentAttachment();
        }

        const baseWidth   = currentAttachment.width;
        const baseHeight  = currentAttachment.height;
        const baseOffsetX = context._$offsetX;
        const baseOffsetY = context._$offsetY;

        const blurTexture = this
            ._$blurFilter
            ._$applyFilter(context, matrix, false);

        const blurWidth   = blurTexture.width;
        const blurHeight  = blurTexture.height;
        const blurOffsetX = context._$offsetX;
        const blurOffsetY = context._$offsetY;

        const offsetDiffX = blurOffsetX - baseOffsetX;
        const offsetDiffY = blurOffsetY - baseOffsetY;

        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        // shadow point
        const radian = this._$angle * Util.$Deg2Rad;
        const x = $Math.cos(radian) * this._$distance * 2 * xScale / Util.$devicePixelRatio;
        const y = $Math.sin(radian) * this._$distance * 2 * yScale / Util.$devicePixelRatio;

        // dropShadow canvas
        const w = this._$inner ? baseWidth  : blurWidth  + $Math.max(0, $Math.abs(x) - offsetDiffX);
        const h = this._$inner ? baseHeight : blurHeight + $Math.max(0, $Math.abs(y) - offsetDiffY);
        const width  = $Math.ceil(w);
        const height = $Math.ceil(h);
        const fractionX = (width  - w) / 2;
        const fractionY = (height - h) / 2;

        let baseTextureX, baseTextureY, blurTextureX, blurTextureY;
        if (this._$inner) {
            baseTextureX = 0;
            baseTextureY = 0;
            blurTextureX = x - blurOffsetX;
            blurTextureY = y - blurOffsetY;
        } else {
            baseTextureX = $Math.max(0, offsetDiffX - x) + fractionX;
            baseTextureY = $Math.max(0, offsetDiffY - y) + fractionY;
            blurTextureX = (x > 0 ? $Math.max(0, x - offsetDiffX) : 0) + fractionX;
            blurTextureY = (y > 0 ? $Math.max(0, y - offsetDiffY) : 0) + fractionY;
        }

        let type, knockout;
        if (this._$inner) {
            type = BitmapFilterType.INNER;
            knockout = this._$knockout || this._$hideObject;
        } else if (!this._$knockout && this._$hideObject) {
            type = BitmapFilterType.FULL;
            knockout = true;
        } else {
            type = BitmapFilterType.OUTER;
            knockout = this._$knockout;
        }

        context._$bind(currentAttachment);
        context._$applyBitmapFilter(
            blurTexture, width, height,
            baseWidth, baseHeight, baseTextureX, baseTextureY,
            blurWidth, blurHeight, blurTextureX, blurTextureY,
            true, type, knockout,
            this._$strength, null, null, null,
            Util.$intToR(this._$color, this._$alpha, true),
            Util.$intToG(this._$color, this._$alpha, true),
            Util.$intToB(this._$color, this._$alpha, true),
            this._$alpha,
            0, 0, 0, 0
        );

        context._$offsetX = baseOffsetX + baseTextureX;
        context._$offsetY = baseOffsetY + baseTextureY;

        context
            .frameBuffer
            .releaseTexture(blurTexture);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * GlowFilter クラスを使用すると、表示オブジェクトにグロー効果を適用できます。
 * グローのスタイルには複数のオプションがあり、内側グロー、外側グロー、ノックアウトモードなどがあります。
 * グローフィルターは、distance プロパティと angle プロパティを 0 に設定したドロップシャドウフィルターによく似ています。
 *
 * The GlowFilter class lets you apply a glow effect to display objects.
 * You have several options for the style of the glow, including inner or outer glow and knockout mode.
 * The glow filter is similar to the drop shadow filter with the distance
 * and angle properties of the drop shadow filter set to 0.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class GlowFilter extends BitmapFilter
{
    /**
     * @param   {number}  [color=0xFF0000]
     * @param   {number}  [alpha=1]
     * @param   {number}  [blur_x=6]
     * @param   {number}  [blur_y=6]
     * @param   {number}  [strength=2]
     * @param   {int}     [quality=1]
     * @param   {boolean} [inner=false]
     * @param   {boolean} [knockout=false]
     *
     * @constructor
     * @public
     */
    constructor (
        color = 0, alpha = 1, blur_x = 4, blur_y = 4,
        strength = 1, quality = 1, inner = false, knockout = false
    ) {

        super();

        /**
         * @type {BlurFilter}
         * @default BlurFilter
         * @private
         */
        this._$blurFilter = new BlurFilter(blur_x, blur_y, quality);

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$color = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$alpha = 1;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$strength = 1;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$inner = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$knockout = false;

        // setup
        this.color    = color;
        this.alpha    = alpha;
        this.strength = strength;
        this.inner    = inner;
        this.knockout = knockout;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class GlowFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class GlowFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.GlowFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.GlowFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object GlowFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object GlowFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.GlowFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.GlowFilter";
    }

    /**
     * @description アルファ透明度の値です。
     *              The alpha transparency value for the color.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get alpha ()
    {
        return this._$alpha;
    }
    set alpha (alpha)
    {
        alpha = Util.$clamp(+alpha, 0, 1, 0);
        if (alpha !== this._$alpha) {
            this._$doChanged(true);
        }
        this._$alpha = alpha;
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurFilter._$blurX;
    }
    set blurX (blur_x)
    {
        this._$blurFilter.blurX = blur_x;
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurFilter._$blurY;
    }
    set blurY (blur_y)
    {
        this._$blurFilter.blurY = blur_y;
    }

    /**
     * @description グローのカラー
     *              The color of the glow.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        color = Util.$clamp(
            Util.$toColorInt(color), 0, 0xffffff, 4
        );

        if (color !== this._$color) {
            this._$doChanged(true);
        }

        this._$color = color;
    }

    /**
     * @description グローが内側グローであるかどうか
     *              Specifies whether the glow is an inner glow.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get inner ()
    {
        return this._$inner;
    }
    set inner (inner)
    {
        inner = !!inner;
        if (inner !== this._$inner) {
            this._$doChanged(true);
        }
        this._$inner = inner;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default true
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        knockout = !!knockout;
        if (knockout !== this._$knockout) {
            this._$doChanged(true);
        }
        this._$knockout = knockout;
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$blurFilter._$quality;
    }
    set quality (quality)
    {
        this._$blurFilter.quality = quality;
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        strength = Util.$clamp(strength | 0, 0, 255, 0);
        if (strength !== this._$strength) {
            this._$doChanged(true);
        }
        this._$strength = strength;
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {GlowFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new GlowFilter(
            this._$color, this._$alpha, this._$blurFilter._$blurX, this._$blurFilter._$blurY,
            this._$strength, this._$blurFilter._$quality, this._$inner, this._$knockout
        );
    }

    /**
     * @return {boolean}
     * @method
     * @public
     */
    _$isUpdated ()
    {
        return this._$updated || this._$blurFilter._$isUpdated();
    }

    /**
     * @param  {Rectangle} rect
     * @param  {number}    [x_scale=null]
     * @param  {number}    [y_scale=null]
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect, x_scale = null, y_scale = null)
    {
        const clone = rect.clone();
        if (!this._$canApply()) {
            return clone;
        }

        return this
            ._$blurFilter
            ._$generateFilterRect(clone, x_scale, y_scale);
    }

    /**
     * @param  {GlowFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$color !== filter._$color) {
            return false;
        }

        if (this._$alpha !== filter._$alpha) {
            return false;
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$inner !== filter._$inner) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return this._$blurFilter._$isSame(filter._$blurFilter);
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$alpha && this._$strength && this._$blurFilter._$canApply();
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array}  matrix
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context, matrix)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        if (!this._$canApply()) {
            return context
                .frameBuffer
                .getTextureFromCurrentAttachment();
        }

        const baseWidth   = currentAttachment.width;
        const baseHeight  = currentAttachment.height;
        const baseOffsetX = context._$offsetX;
        const baseOffsetY = context._$offsetY;

        const blurTexture = this
            ._$blurFilter
            ._$applyFilter(context, matrix, false);

        const blurWidth   = blurTexture.width;
        const blurHeight  = blurTexture.height;
        const blurOffsetX = context._$offsetX;
        const blurOffsetY = context._$offsetY;

        const width  = this._$inner ? baseWidth  : blurWidth;
        const height = this._$inner ? baseHeight : blurHeight;

        let baseTextureX, baseTextureY, blurTextureX, blurTextureY;
        if (this._$inner) {
            baseTextureX = 0;
            baseTextureY = 0;
            blurTextureX = -blurOffsetX;
            blurTextureY = -blurOffsetY;
        } else {
            baseTextureX = blurOffsetX - baseOffsetX;
            baseTextureY = blurOffsetY - baseOffsetY;
            blurTextureX = 0;
            blurTextureY = 0;
        }

        const type = this._$inner
            ? BitmapFilterType.INNER
            : BitmapFilterType.OUTER;

        context._$bind(currentAttachment);
        context._$applyBitmapFilter(
            blurTexture, width, height,
            baseWidth, baseHeight, baseTextureX, baseTextureY,
            blurWidth, blurHeight, blurTextureX, blurTextureY,
            true, type, this._$knockout,
            this._$strength, null, null, null,
            Util.$intToR(this._$color, this._$alpha, true),
            Util.$intToG(this._$color, this._$alpha, true),
            Util.$intToB(this._$color, this._$alpha, true),
            this._$alpha,
            0, 0, 0, 0
        );

        context._$offsetX = baseOffsetX + baseTextureX;
        context._$offsetY = baseOffsetY + baseTextureY;

        context
            .frameBuffer
            .releaseTexture(blurTexture);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * GradientBevelFilter クラスを使用すると、オブジェクトにグラデーションベベル効果を適用し、表示できます。
 * グラデーションベベルは、オブジェクトの外側、内側、または上側が斜めになったエッジであり、グラデーションカラーで強調されます。
 * 斜めのエッジによってオブジェクトが 3 次元に見えます。
 *
 * The GradientBevelFilter class lets you apply a gradient bevel effect to display objects.
 * A gradient bevel is a beveled edge, enhanced with gradient color,
 * on the outside, inside, or top of an object.
 * Beveled edges make objects look three-dimensional.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class GradientBevelFilter  extends BitmapFilter
{
    /**
     * @param {number}  [distance=4.0]
     * @param {number}  [angle=45]
     * @param {array}   [colors=null]
     * @param {array}   [alphas=null]
     * @param {array}   [ratios=null]
     * @param {number}  [blur_x=4.0]
     * @param {number}  [blur_y=4.0]
     * @param {number}  [strength=1]
     * @param {number}  [quality=1]
     * @param {string}  [type=BitmapFilterType.INNER]
     * @param {boolean} [knockout=false]
     *
     * @constructor
     * @public
     */
    constructor (
        distance = 4, angle = 45, colors = null, alphas = null,
        ratios = null, blur_x = 4, blur_y = 4, strength = 1,
        quality = 1, type = "inner", knockout = false
    ) {

        super();

        /**
         * @type {BlurFilter}
         * @default BlurFilter
         * @private
         */
        this._$blurFilter = new BlurFilter(blur_x, blur_y, quality);

        /**
         * @type {number}
         * @default 4
         * @private
         */
        this._$distance = 4;

        /**
         * @type {number}
         * @default 45
         * @private
         */
        this._$angle = 45;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$colors = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$alphas = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$ratios = null;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$strength = 1;

        /**
         * @type {string}
         * @default BitmapFilterType.INNER
         * @private
         */
        this._$type = BitmapFilterType.INNER;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$knockout = false;

        // setup
        this.distance = distance;
        this.angle    = angle;
        this.colors   = colors;
        this.alphas   = alphas;
        this.ratios   = ratios;
        this.strength = strength;
        this.type     = type;
        this.knockout = knockout;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class GradientBevelFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class GradientBevelFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.GradientBevelFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.GradientBevelFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object GradientBevelFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object GradientBevelFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.GradientBevelFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.GradientBevelFilter";
    }

    /**
     * @description カラー配列内の各色に対応するアルファ透明度の値の配列です。
     *              An array of alpha transparency values
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get alphas ()
    {
        return !this._$colors || !this._$ratios ? null : this._$alphas;
    }
    set alphas (alphas)
    {
        this._$alphas = null;
        if (Util.$isArray(alphas)) {

            this._$doChanged(true);

            const length = alphas.length;
            for (let idx = 0; idx < length; ++idx) {
                const alpha = +alphas[idx];
                alphas[idx] = Util.$clamp(alpha, 0, 1, 0);
            }

            this._$alphas = alphas.slice(0);
        }
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        angle %= 360;
        if (angle !== this._$angle) {
            this._$doChanged(true);
        }
        this._$angle = Util.$clamp(angle, -360, 360, 45);
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurFilter._$blurX;
    }
    set blurX (blur_x)
    {
        this._$blurFilter.blurX = blur_x;
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurFilter._$blurY;
    }
    set blurY (blur_y)
    {
        this._$blurFilter.blurY = blur_y;
    }

    /**
     * @description グラデーションで使用する RGB 16 進数カラー値の配列です。
     *              An array of RGB hexadecimal color values to use in the gradient.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get colors ()
    {
        return !this._$alphas || !this._$ratios ? null : this._$colors;
    }
    set colors (colors)
    {
        this._$colors = null;
        if (Util.$isArray(colors)) {

            this._$doChanged(true);

            const length = colors.length;
            for (let idx = 0; idx < length; ++idx) {

                let color = Util.$toColorInt(colors[idx]) | 0;

                if (color < 0) {
                    color = 0x1000000 - $Math.abs(color) % 0x1000000;
                }

                if (color > 0xffffff) {
                    color = color % 0x1000000;
                }

                colors[idx] = Util.$clamp($Math.abs(color), 0, 0xffffff);
            }

            this._$colors = colors.slice(0);
        }
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        distance = Util.$clamp(+distance, -255, 255, 4);
        if (distance !== this._$distance) {
            this._$doChanged(true);
        }
        this._$distance = distance;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        knockout = !!knockout;
        if (knockout !== this._$knockout) {
            this._$doChanged(true);
        }
        this._$knockout = knockout;
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$blurFilter._$quality;
    }
    set quality (quality)
    {
        this._$blurFilter.quality = quality;
    }

    /**
     * @description カラー配列内の対応するカラーの色分布比率の配列です。
     *              An array of color distribution ratios
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get ratios ()
    {
        return !this._$alphas || !this._$colors ? null : this._$ratios;
    }
    set ratios (ratios)
    {
        this._$ratios = null;
        if (Util.$isArray(ratios)) {

            this._$doChanged(true);

            const length = ratios.length;
            for (let idx = 0; idx < length; ++idx) {
                ratios[idx] = Util.$clamp(+ratios[idx], 0, 255, 0);
            }

            this._$ratios = ratios.slice(0);
        }
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        strength = Util.$clamp(strength | 0, 0, 255, 0);
        if (strength !== this._$strength) {
            this._$doChanged(true);
        }
        this._$strength = strength;
    }

    /**
     * @description オブジェクトでのベベルの配置
     *              The placement of the bevel on the object.
     *
     * @member  {string}
     * @default BitmapFilterType.INNER
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type += "";
        if (type !== this._$type) {
            this._$doChanged(true);
        }

        switch (type) {

            case BitmapFilterType.OUTER:
            case BitmapFilterType.FULL:
                this._$type = type;
                break;

            default:
                this._$type = BitmapFilterType.INNER;
                break;

        }
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {GradientBevelFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new GradientBevelFilter(
            this._$distance, this._$angle, this._$colors, this._$alphas, this._$ratios,
            this._$blurFilter._$blurX, this._$blurFilter._$blurY, this._$strength,
            this._$blurFilter._$quality, this._$type, this._$knockout
        );
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$isUpdated ()
    {
        return this._$updated || this._$blurFilter._$isUpdated();
    }
    /**
     * @param  {Rectangle} rect
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect)
    {
        let clone = rect.clone();
        if (!this._$canApply()) {
            return clone;
        }

        clone = this._$blurFilter._$generateFilterRect(clone);

        const radian = this._$angle * Util.$Deg2Rad;
        const x      = $Math.abs($Math.cos(radian) * this._$distance);
        const y      = $Math.abs($Math.sin(radian) * this._$distance);

        clone.x      += -x;
        clone.width  += x;
        clone.y      += -y;
        clone.height += y * 2;

        return clone;
    }

    /**
     * @param  {GradientBevelFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return this
            ._$blurFilter
            ._$isSame(filter._$blurFilter);
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$strength && this._$distance
            && this._$alphas && this._$ratios && this._$colors
            && this._$blurFilter._$canApply();
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array}  matrix
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context, matrix)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        const baseTexture = context
            .frameBuffer
            .getTextureFromCurrentAttachment();

        if (!this._$canApply()) {
            return baseTexture;
        }

        const baseWidth   = currentAttachment.width;
        const baseHeight  = currentAttachment.height;
        const baseOffsetX = context._$offsetX;
        const baseOffsetY = context._$offsetY;

        // matrix to scale
        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        // pointer
        const radian = +(this._$angle * Util.$Deg2Rad);
        const x = +($Math.cos(radian) * this._$distance * xScale);
        const y = +($Math.sin(radian) * this._$distance * yScale);

        // highlight buffer
        let highlightTextureBaseAttachment = context
            .frameBuffer
            .createTextureAttachment(baseWidth, baseHeight);
        context._$bind(highlightTextureBaseAttachment);

        Util.$resetContext(context);
        context.drawImage(baseTexture, 0, 0, baseWidth, baseHeight);

        context.globalCompositeOperation = BlendMode.ERASE;
        context.drawImage(baseTexture, x * 2, y * 2, baseWidth, baseHeight);

        const highlightTextureBase = this
            ._$blurFilter
            ._$applyFilter(context, matrix, false);

        const blurWidth   = highlightTextureBase.width;
        const blurHeight  = highlightTextureBase.height;
        const bevelWidth  = $Math.ceil(blurWidth  + $Math.abs(x) * 2);
        const bevelHeight = $Math.ceil(blurHeight + $Math.abs(y) * 2);

        // bevel filter buffer
        const isInner = this._$type === BitmapFilterType.INNER;
        const width   = isInner ? baseWidth  : bevelWidth;
        const height  = isInner ? baseHeight : bevelHeight;

        const absX = $Math.abs(x);
        const absY = $Math.abs(y);
        const blurOffsetX = (blurWidth  - baseWidth)  / 2;
        const blurOffsetY = (blurHeight - baseHeight) / 2;

        let baseTextureX, baseTextureY, blurTextureX, blurTextureY;
        if (isInner) {
            baseTextureX = 0;
            baseTextureY = 0;
            blurTextureX = -blurOffsetX - x;
            blurTextureY = -blurOffsetY - y;
        } else {
            baseTextureX = absX + blurOffsetX;
            baseTextureY = absY + blurOffsetY;
            blurTextureX = absX - x;
            blurTextureY = absY - y;
        }

        context._$bind(currentAttachment);
        context._$applyBitmapFilter(
            highlightTextureBase, width, height,
            baseWidth, baseHeight, baseTextureX, baseTextureY,
            blurWidth, blurHeight, blurTextureX, blurTextureY,
            false, this._$type, this._$knockout,
            this._$strength, this._$ratios, this._$colors, this._$alphas,
            0, 0, 0, 0, 0, 0, 0, 0
        );

        context._$offsetX = baseOffsetX + baseTextureX;
        context._$offsetY = baseOffsetY + baseTextureY;

        context
            .frameBuffer
            .releaseTexture(highlightTextureBase);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * GradientGlowFilter クラスを使用すると、表示オブジェクトにグラデーショングロー効果を適用できます。
 * グラデーショングローとは、制御可能なカラーグラデーションによるリアルな輝きです。
 * グラデーショングローは、オブジェクトの内側エッジや外側エッジの周囲、またはオブジェクトの上に適用できます。
 *
 * The GradientGlowFilter class lets you apply a gradient glow effect to display objects.
 * A gradient glow is a realistic-looking glow with a color gradient that you can control.
 * You can apply a gradient glow around the inner or outer edge of an object or on top of an object.
 *
 * @class
 * @memberOf next2d.filters
 * @extends  BitmapFilter
 */
class GradientGlowFilter  extends BitmapFilter
{
    /**
     * @param {number}  [distance=4.0]
     * @param {number}  [angle=45]
     * @param {array}   [colors=null]
     * @param {array}   [alphas=null]
     * @param {array}   [ratios=null]
     * @param {number}  [blur_x=4.0]
     * @param {number}  [blur_y=4.0]
     * @param {number}  [strength=1]
     * @param {number}  [quality=1]
     * @param {string}  [type=BitmapFilterType.INNER]
     * @param {boolean} [knockout=false]
     *
     * @constructor
     * @public
     */
    constructor (
        distance = 4, angle = 45, colors = null, alphas = null,
        ratios = null, blur_x = 4, blur_y = 4, strength = 1,
        quality = 1, type = "inner", knockout = false
    ) {

        super();

        /**
         * @type {BlurFilter}
         * @default BlurFilter
         * @private
         */
        this._$blurFilter = new BlurFilter(blur_x, blur_y, quality);

        /**
         * @type {number}
         * @default 4
         * @private
         */
        this._$distance = 4;

        /**
         * @type {number}
         * @default 45
         * @private
         */
        this._$angle = 45;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$colors = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$alphas = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$ratios = null;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$strength = 1;

        /**
         * @type {string}
         * @default BitmapFilterType.INNER
         * @private
         */
        this._$type = BitmapFilterType.INNER;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$knockout = false;

        // setup
        this.distance = distance;
        this.angle    = angle;
        this.colors   = colors;
        this.alphas   = alphas;
        this.ratios   = ratios;
        this.strength = strength;
        this.type     = type;
        this.knockout = knockout;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class GradientGlowFilter]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class GradientGlowFilter]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.filters.GradientGlowFilter
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.filters.GradientGlowFilter";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object GradientGlowFilter]
     * @method
     * @public
     */
    toString ()
    {
        return "[object GradientGlowFilter]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.filters.GradientGlowFilter
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.filters.GradientGlowFilter";
    }

    /**
     * @description カラー配列内の各色に対応するアルファ透明度の値の配列です。
     *              An array of alpha transparency values
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get alphas ()
    {
        return !this._$colors || !this._$ratios ? null : this._$alphas;
    }
    set alphas (alphas)
    {
        this._$alphas = null;
        if (Util.$isArray(alphas)) {

            this._$doChanged(true);

            const length = alphas.length;
            for (let idx = 0; idx < length; ++idx) {
                const alpha = +alphas[idx];
                alphas[idx] = Util.$clamp(alpha, 0, 1, 0);
            }

            this._$alphas = alphas.slice(0);
        }
    }

    /**
     * @description シャドウの角度
     *              The angle of the shadow.
     *
     * @member  {number}
     * @default 45
     * @public
     */
    get angle ()
    {
        return this._$angle;
    }
    set angle (angle)
    {
        angle %= 360;
        if (angle !== this._$angle) {
            this._$doChanged(true);
        }
        this._$angle = Util.$clamp(angle, -360, 360, 45);
    }

    /**
     * @description 水平方向のぼかし量。
     *              The amount of horizontal blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurX ()
    {
        return this._$blurFilter._$blurX;
    }
    set blurX (blur_x)
    {
        this._$blurFilter.blurX = blur_x;
    }

    /**
     * @description 垂直方向のぼかし量。
     *              The amount of vertical blur.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get blurY ()
    {
        return this._$blurFilter._$blurY;
    }
    set blurY (blur_y)
    {
        this._$blurFilter.blurY = blur_y;
    }

    /**
     * @description グラデーションで使用する RGB 16 進数カラー値の配列です。
     *              An array of RGB hexadecimal color values to use in the gradient.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get colors ()
    {
        return !this._$alphas || !this._$ratios ? null : this._$colors;
    }
    set colors (colors)
    {
        this._$colors = null;
        if (Util.$isArray(colors)) {

            this._$doChanged(true);

            const length = colors.length;
            for (let idx = 0; idx < length; ++idx) {

                let color = Util.$toColorInt(colors[idx]) | 0;

                if (color < 0) {
                    color = 0x1000000 - $Math.abs(color) % 0x1000000;
                }

                if (color > 0xffffff) {
                    color = color % 0x1000000;
                }

                colors[idx] = Util.$clamp($Math.abs(color), 0, 0xffffff);
            }

            this._$colors = colors.slice(0);
        }
    }

    /**
     * @description シャドウのオフセット距離です。
     *              The offset distance for the shadow, in pixels.
     *
     * @member  {number}
     * @default 4
     * @public
     */
    get distance ()
    {
        return this._$distance;
    }
    set distance (distance)
    {
        distance = Util.$clamp(+distance, -255, 255, 4);
        if (distance !== this._$distance) {
            this._$doChanged(true);
        }
        this._$distance = distance;
    }

    /**
     * @description オブジェクトにノックアウト効果を適用するかどうか
     *              Specifies whether the object has a knockout effect.
     *
     * @member  {boolean}
     * @default false
     * @public
     */
    get knockout ()
    {
        return this._$knockout;
    }
    set knockout (knockout)
    {
        knockout = !!knockout;
        if (knockout !== this._$knockout) {
            this._$doChanged(true);
        }
        this._$knockout = knockout;
    }

    /**
     * @description ぼかしの実行回数です。
     *              The number of times to perform the blur.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get quality ()
    {
        return this._$blurFilter._$quality;
    }
    set quality (quality)
    {
        this._$blurFilter.quality = quality;
    }

    /**
     * @description カラー配列内の対応するカラーの色分布比率の配列です。
     *              An array of color distribution ratios
     *              for the corresponding colors in the colors array.
     *
     * @member  {array}
     * @default null
     * @public
     */
    get ratios ()
    {
        return !this._$alphas || !this._$colors ? null : this._$ratios;
    }
    set ratios (ratios)
    {
        this._$ratios = null;
        if (Util.$isArray(ratios)) {

            this._$doChanged(true);

            const length = ratios.length;
            for (let idx = 0; idx < length; ++idx) {
                const ratio = Util.$clamp(+ratios[idx], 0, 255, 0);
                ratios[idx] = ratio;
            }

            this._$ratios = ratios.slice(0);
        }
    }

    /**
     * @description インプリントの強さまたは広がりです。
     *              The strength of the imprint or spread.
     *
     * @member  {number}
     * @default 1
     * @public
     */
    get strength ()
    {
        return this._$strength;
    }
    set strength (strength)
    {
        strength = Util.$clamp(strength | 0, 0, 255, 0);
        if (strength !== this._$strength) {
            this._$doChanged(true);
        }
        this._$strength = strength;
    }

    /**
     * @description オブジェクトでのベベルの配置
     *              The placement of the bevel on the object.
     *
     * @member  {string}
     * @default BitmapFilterType.INNER
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type += "";
        if (type !== this._$type) {
            this._$doChanged(true);
        }

        switch (type) {

            case BitmapFilterType.OUTER:
            case BitmapFilterType.FULL:
                this._$type = type;
                break;

            default:
                this._$type = BitmapFilterType.INNER;
                break;

        }
    }

    /**
     * @description オブジェクトのコピーを返します。
     *              Returns a copy of this filter object.
     *
     * @return {GradientGlowFilter}
     * @method
     * @public
     */
    clone ()
    {
        return new GradientGlowFilter(
            this._$distance, this._$angle, this._$colors, this._$alphas, this._$ratios,
            this._$blurFilter._$blurX, this._$blurFilter._$blurY, this._$strength,
            this._$blurFilter._$quality, this._$type, this._$knockout
        );
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$isUpdated ()
    {
        return this._$updated || this._$blurFilter._$isUpdated();
    }

    /**
     * @param  {Rectangle} rect
     * @param  {number}    [x_scale=null]
     * @param  {number}    [y_scale=null]
     * @return {Rectangle}
     * @method
     * @private
     */
    _$generateFilterRect (rect, x_scale = null, y_scale = null)
    {
        let clone = rect.clone();
        if (!this._$canApply()) {
            return clone;
        }

        clone = this
            ._$blurFilter
            ._$generateFilterRect(clone, x_scale, y_scale);

        const radian = this._$angle * Util.$Deg2Rad;
        const x      = $Math.cos(radian) * this._$distance;
        const y      = $Math.sin(radian) * this._$distance;

        clone.x      = $Math.min(clone.x, x);
        clone.width  += $Math.abs(x);
        clone.y      = $Math.min(clone.y, y);
        clone.height += $Math.abs(y);

        return clone;
    }

    /**
     * @return {boolean}
     * @method
     * @private
     */
    _$canApply ()
    {
        return this._$strength
            && this._$alphas && this._$ratios && this._$colors
            && this._$blurFilter._$canApply();
    }

    /**
     * @param  {GradientGlowFilter} filter
     * @return {boolean}
     * @method
     * @private
     */
    _$isSame (filter)
    {
        if (this._$distance !== filter._$distance) {
            return false;
        }

        if (this._$angle !== filter._$angle) {
            return false;
        }

        for (let idx = 0; idx < this._$colors.length; ++idx) {
            if (this._$colors[idx] !== filter._$colors[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$alphas.length; ++idx) {
            if (this._$alphas[idx] !== filter._$alphas[idx]) {
                return false;
            }
        }

        for (let idx = 0; idx < this._$ratios.length; ++idx) {
            if (this._$ratios[idx] !== filter._$ratios[idx]) {
                return false;
            }
        }

        if (this._$strength !== filter._$strength) {
            return false;
        }

        if (this._$type !== filter._$type) {
            return false;
        }

        if (this._$knockout !== filter._$knockout) {
            return false;
        }

        return this._$blurFilter._$isSame(filter._$blurFilter);
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {array}  matrix
     * @return {WebGLTexture}
     * @method
     * @private
     */
    _$applyFilter (context, matrix)
    {
        this._$doChanged(false);

        const currentAttachment = context
            .frameBuffer
            .currentAttachment;

        // reset
        context.setTransform(1, 0, 0, 1, 0, 0);

        if (!this._$canApply()) {
            return context
                .frameBuffer
                .getTextureFromCurrentAttachment();
        }

        const baseWidth   = currentAttachment.width;
        const baseHeight  = currentAttachment.height;
        const baseOffsetX = context._$offsetX;
        const baseOffsetY = context._$offsetY;

        const blurTexture = this
            ._$blurFilter
            ._$applyFilter(context, matrix, false);

        const blurWidth   = blurTexture.width;
        const blurHeight  = blurTexture.height;
        const blurOffsetX = context._$offsetX;
        const blurOffsetY = context._$offsetY;

        const offsetDiffX = blurOffsetX - baseOffsetX;
        const offsetDiffY = blurOffsetY - baseOffsetY;

        // matrix to scale
        const xScale = $Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]);
        const yScale = $Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3]);

        // shadow point
        const radian = +(this._$angle * Util.$Deg2Rad);
        const x = +($Math.cos(radian) * this._$distance * xScale);
        const y = +($Math.sin(radian) * this._$distance * yScale);

        const isInner = this.type === BitmapFilterType.INNER;
        const w = isInner ? baseWidth  : blurWidth  + $Math.max(0, $Math.abs(x) - offsetDiffX);
        const h = isInner ? baseHeight : blurHeight + $Math.max(0, $Math.abs(y) - offsetDiffY);
        const width  = $Math.ceil(w);
        const height = $Math.ceil(h);
        const fractionX = (width  - w) / 2;
        const fractionY = (height - h) / 2;

        let baseTextureX, baseTextureY, blurTextureX, blurTextureY;
        if (isInner) {
            baseTextureX = 0;
            baseTextureY = 0;
            blurTextureX = x - blurOffsetX;
            blurTextureY = y - blurOffsetY;
        } else {
            baseTextureX = $Math.max(0, offsetDiffX - x) + fractionX;
            baseTextureY = $Math.max(0, offsetDiffY - y) + fractionY;
            blurTextureX = (x > 0 ? $Math.max(0, x - offsetDiffX) : 0) + fractionX;
            blurTextureY = (y > 0 ? $Math.max(0, y - offsetDiffY) : 0) + fractionY;
        }

        context._$bind(currentAttachment);
        context._$applyBitmapFilter(
            blurTexture, width, height,
            baseWidth, baseHeight, baseTextureX, baseTextureY,
            blurWidth, blurHeight, blurTextureX, blurTextureY,
            true, this.type, this.knockout,
            this._$strength, this.ratios, this.colors, this.alphas,
            0, 0, 0, 0, 0, 0, 0, 0
        );

        context._$offsetX = baseOffsetX + baseTextureX;
        context._$offsetY = baseOffsetY + baseTextureY;

        context
            .frameBuffer
            .releaseTexture(blurTexture);

        return context
            .frameBuffer
            .getTextureFromCurrentAttachment();
    }
}

/**
 * TextFormatAlign クラスは、TextFormat クラスのテキストの行揃えの値を提供します。
 * The TextFormatAlign class provides values for text alignment in the TextFormat class.
 *
 * @class
 * @memberOf next2d.text
 */
class TextFormatAlign
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class TextFormatAlign]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class TextFormatAlign]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.text.TextFormatAlign
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.text.TextFormatAlign";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object TextFormatAlign]
     * @method
     * @public
     */
    toString ()
    {
        return "[object TextFormatAlign]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.text.TextFormatAlign
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.text.TextFormatAlign";
    }

    /**
     * @description テキストをテキストフィールドの中央に配置します。
     *              centers the text in the text field.
     *
     * @return  {string}
     * @default center
     * @const
     * @static
     */
    static get CENTER ()
    {
        return "center";
    }

    /**
     * @description テキストをテキストフィールド内で左に行揃えします。
     *              aligns text to the left within the text field.
     *
     * @return  {string}
     * @default left
     * @const
     * @static
     */
    static get LEFT ()
    {
        return "left";
    }

    /**
     * @description テキストをテキストフィールド内で右に行揃えします。
     *              aligns text to the right within the text field.
     *
     * @return  {string}
     * @default right
     * @const
     * @static
     */
    static get RIGHT ()
    {
        return "right";
    }
}

/**
 * TextFieldAutoSize クラスは、TextField クラスの autoSize プロパティの設定で使用される定数値の列挙です。
 * TThe TextFieldAutoSize class is an enumeration of constant values used in setting the autoSize property of the TextField class.
 *
 * @class
 * @memberOf next2d.text
 */
class TextFieldAutoSize
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class TextFieldAutoSize]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class TextFieldAutoSize]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.text.TextFieldAutoSize
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.text.TextFieldAutoSize";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object TextFieldAutoSize]
     * @method
     * @public
     */
    toString ()
    {
        return "[object TextFieldAutoSize]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.text.TextFieldAutoSize
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.text.TextFieldAutoSize";
    }

    /**
     * @description テキストが中央揃えテキストとして扱われることを指定します。
     *              Specifies that the text is to be treated as center-justified text.
     *
     * @return  {string}
     * @default center
     * @const
     * @static
     */
    static get CENTER ()
    {
        return "center";
    }

    /**
     * @description テキストが左揃えテキストとして扱われることを指定します。つまり、テキストフィールドの
     *              左側が固定され、テキストフィールドの単一行の右側のみが伸縮します。
     *              Specifies that the text is to be treated as left-justified text, meaning
     *              that the left side of the text field remains fixed and any resizing
     *              of a single line is on the right side.
     *
     * @return  {string}
     * @default left
     * @const
     * @static
     */
    static get LEFT ()
    {
        return "left";
    }

    /**
     * @description サイズ変更が発生しないことを指定します。
     *              Specifies that no resizing is to occur.
     *
     * @return  {string}
     * @default none
     * @const
     * @static
     */
    static get NONE ()
    {
        return "none";
    }

    /**
     * @description テキストが右揃えテキストとして扱われることを指定します。つまり、テキストフィールドの
     *              右側が固定され、テキストフィールドの単一行の左側のみが伸縮します。
     *              Specifies that the text is to be treated as right-justified text,
     *              meaning that the right side of the text field remains fixed
     *              and any resizing of a single line is on the left side.
     *
     * @return  {string}
     * @default right
     * @const
     * @static
     */
    static get RIGHT ()
    {
        return "right";
    }
}

/**
 * TextField クラスは、テキストの表示と入力用の表示オブジェクトを作成するために使用されます。
 * プロパティインスペクターを使用して、テキストフィールドにインスタンス名を付けることができます。
 * また、TextField クラスのメソッドとプロパティを使用して、JavaScript でテキストフィールドを操作できます。
 *
 * The TextField class is used to create display objects for text display and input.
 * You can give a text field an instance name in the Property inspector
 * and use the methods and properties of the TextField class to manipulate it with JavaScript.
 *
 * @class
 * @memberOf next2d.text
 * @extends  InteractiveObject
 */
class TextField extends InteractiveObject
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        super();

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$background = false;

        /**
         * @type {number}
         * @default 0xffffff
         * @private
         */
        this._$backgroundColor = 0xffffff;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$border = false;

        /**
         * @type {number}
         * @default 0x000000
         * @private
         */
        this._$borderColor = 0x000000;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$htmlText = "";

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$multiline = false;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$text = "";

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$wordWrap = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$scrollH = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$scrollV = 1;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$maxScrollV = null;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$maxScrollH = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$maxChars = 0;

        // TextFormat
        const textFormat = new TextFormat();
        textFormat._$setDefault(this);

        /**
         * @type {TextFormat}
         * @private
         */
        this._$defaultTextFormat = textFormat;

        /**
         * @type {TextFormat}
         * @private
         */
        this._$decisionTextFormat = textFormat;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$rawHtmlText = "";

        /**
         * @type {object}
         * @private
         */
        this._$bounds = {
            "xMin": 0 ,
            "xMax": 100,
            "yMin": 0 ,
            "yMax": 100
        };

        /**
         * @type {object}
         * @private
         */
        this._$originBounds = {
            "xMin": 0 ,
            "xMax": 100,
            "yMin": 0 ,
            "yMax": 100
        };

        /**
         * @type {string}
         * @default null
         * @private
         */
        this._$restrict = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$isHTML = false;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$textData = null;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$renew = true;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$textHeight = null;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$textWidth = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$widthTable = null;

        /**
         * @type {HTMLTextAreaElement}
         * @default null
         * @private
         */
        this._$textarea = null;

        /**
         * @type {string}
         * @default TextFieldAutoSize.NONE
         * @private
         */
        this._$autoSize = TextFieldAutoSize.NONE;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$autoFontSize = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$textAppending = false;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$heightTable = null;

        /**
         * @type {array}
         * @default array
         * @private
         */
        this._$textFormatTable = [];

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$textAreaActive = false;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$totalWidth = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$objectTable = null;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$imageData = null;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$scrollEnabled = true;

        /**
         * @type {Sprite}
         * @default null
         * @private
         */
        this._$scrollSprite = null;

        /**
         * @type {string}
         * @default null
         * @private
         */
        this._$type = TextFieldType.STATIC;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$textHeightTable = null;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$focus = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$isComposing = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$thickness = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$thicknessColor = 0;

        /**
         * @type {string}
         * @default TextFormatVerticalAlign.TOP
         * @private
         */
        this._$verticalAlign = TextFormatVerticalAlign.TOP;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class TextField]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class TextField]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.text.TextField
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.text.TextField";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object TextField]
     * @method
     * @public
     */
    toString ()
    {
        return "[object TextField]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.text.TextField
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.text.TextField";
    }

    /**
     * @return  {string}
     * @default text
     * @const
     * @static
     * @private
     */
    static get TEXT ()
    {
        return "text";
    }

    /**
     * @return  {string}
     * @default text
     * @const
     * @static
     * @private
     */
    static get BREAK ()
    {
        return "break";
    }

    /**
     * @return  {string}
     * @default text
     * @const
     * @static
     * @private
     */
    static get WRAP ()
    {
        return "wrap";
    }

    /**
     * @return  {string}
     * @default text
     * @const
     * @static
     * @private
     */
    static get IMAGE ()
    {
        return "image";
    }

    /**
     * @description テキストサイズの自動的な拡大 / 縮小および整列を制御します。
     *              Controls automatic sizing and alignment of text size.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get autoFontSize ()
    {
        return this._$autoFontSize;
    }
    set autoFontSize (auto_font_size)
    {
        this._$autoFontSize = !!auto_font_size;
    }

    /**
     * @description テキストフィールドの自動的な拡大 / 縮小および整列を制御します。
     *              Controls automatic sizing and alignment of text fields.
     *
     * @member {string}
     * @default TextFieldAutoSize.NONE
     * @public
     */
    get autoSize ()
    {
        return this._$autoSize;
    }
    set autoSize (auto_size)
    {
        switch (auto_size) {

            case TextFieldAutoSize.CENTER:
            case TextFieldAutoSize.LEFT:
            case TextFieldAutoSize.RIGHT:
                this._$autoSize = auto_size;
                break;

            default:
                this._$autoSize = TextFieldAutoSize.NONE;
                break;

        }

        this._$reload();
    }

    /**
     * @description テキストフィールドに背景の塗りつぶしがあるかどうかを指定します。
     *              Specifies whether the text field has a background fill.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get background ()
    {
        return this._$background;
    }
    set background (background)
    {
        this._$background = !!background;
        this._$reset();
    }

    /**
     * @description テキストフィールドの背景の色です。
     *              The color of the text field background.
     *
     * @member {number}
     * @default 0xffffff
     * @public
     */
    get backgroundColor ()
    {
        return this._$backgroundColor;
    }
    set backgroundColor (background_color)
    {
        this._$backgroundColor = Util.$clamp(
            Util.$toColorInt(background_color), 0, 0xffffff, 0xffffff
        );
        this._$reset();
    }

    /**
     * @description テキストフィールドに境界線があるかどうかを指定します。
     *              Specifies whether the text field has a border.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get border ()
    {
        return this._$border;
    }
    set border (border)
    {
        this._$border = !!border;
        this._$reset();
    }

    /**
     * @description テキストフィールドの境界線の色です。
     *              The color of the text field border.
     *
     * @member {number}
     * @default 0x000000
     * @public
     */
    get borderColor ()
    {
        return this._$borderColor;
    }
    set borderColor (border_color)
    {
        this._$borderColor = Util.$clamp(
            Util.$toColorInt(border_color), 0, 0xffffff, 0
        );
        this._$reset();
    }

    /**
     * @description テキストに適用するフォーマットを指定します。
     *              Specifies the formatting to be applied to the text.
     *
     * @member {TextFormat}
     * @public
     */
    get defaultTextFormat ()
    {
        return this._$defaultTextFormat;
    }
    set defaultTextFormat (text_format)
    {
        if (text_format instanceof TextFormat) {

            text_format._$merge(this._$defaultTextFormat);
            text_format._$textField = this;

            this._$defaultTextFormat = text_format;
        }
    }

    /**
     * @description このオブジェクトでマウスまたはその他のユーザー入力メッセージを
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get focus ()
    {
        return this._$focus;
    }
    set focus (focus)
    {
        if (this._$focus === !!focus) {
            return ;
        }

        this._$focus = !!focus;
        if (this._$focus) {

            if (this._$type === TextFieldType.INPUT) {

                const player = Util.$currentPlayer();

                const div = Util.$document.getElementById(player.contentElementId);
                if (!div) {
                    return;
                }

                this._$createTextAreaElement(player._$scale);

                // setup
                const element = this._$textarea;
                const matrix  = this._$transform.concatenatedMatrix;
                const bounds  = this._$getBounds(null);

                const color = Util.$intToRGBA(
                    this._$defaultTextFormat._$color, 100
                );

                element.style.color  = `rgb(${color.R},${color.G},${color.B})`;
                element.style.left   = `${(matrix.tx + bounds.xMin + player._$tx / player._$scale / Util.$devicePixelRatio) * player._$scale}px`;
                element.style.top    = `${(matrix.ty + bounds.yMin + player._$ty / player._$scale / Util.$devicePixelRatio) * player._$scale}px`;
                element.style.width  = `${$Math.ceil((this.width  - 1) * player._$scale)}px`;
                element.style.height = `${$Math.ceil((this.height - 1) * player._$scale)}px`;

                // set text
                element.value = this.text;

                div.appendChild(element);

                const timer = Util.$requestAnimationFrame;
                timer(() => { element.focus() });

                this._$textAreaActive = true;

                // focus in event
                if (this.willTrigger(FocusEvent.FOCUS_IN)) {
                    this.dispatchEvent(new FocusEvent(FocusEvent.FOCUS_IN));
                }

                this._$doChanged();
                Util.$isUpdated = true;
            }

        } else {

            // execute
            if (this._$textarea) {

                this._$textarea.dispatchEvent(
                    new Util.$window.Event(`${Util.$PREFIX}_blur`)
                );

                if (this.willTrigger(FocusEvent.FOCUS_OUT)) {
                    this.dispatchEvent(new FocusEvent(FocusEvent.FOCUS_OUT));
                }

                this._$doChanged();
                Util.$isUpdated = true;

                this._$textarea.remove();
            }

        }
    }

    /**
     * @description テキストフィールドの内容を HTML で表します。
     *              Contains the HTML representation of the text field contents.
     *
     * @member {string}
     * @default ""
     * @public
     */
    get htmlText ()
    {
        return this._$htmlText;
    }
    set htmlText (html_text)
    {
        if (this._$htmlText !== html_text) {
            this._$htmlText        = `${html_text}`;
            this._$rawHtmlText     = "";
            this._$text            = "";
            this._$isHTML          = true;
            this._$textFormatTable = [];
            this._$reload();
        }
    }

    /**
     * @description テキストフィールド内の文字数です。
     *              The int of characters in a text field.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get length ()
    {
        return this.text.length;
    }

    /**
     * @description ユーザーが入力するときに、テキストフィールドに入力できる最大の文字数です。
     *              The maximum number of characters that the text field can contain,
     *              as entered by a user.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get maxChars ()
    {
        return this._$maxChars;
    }
    set maxChars (max_chars)
    {
        this._$maxChars = max_chars | 0;
    }

    /**
     * TODO
     * @description scrollH の最大値です。
     *              The maximum value of scrollH.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get maxScrollH ()
    {
        // TODO
        if (this._$maxScrollH === null) {
            this._$maxScrollH = 0;
        }
        return this._$maxScrollH;
    }

    /**
     * @description scrollV の最大値です。
     *              The maximum value of scrollV.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get maxScrollV ()
    {
        if (this._$maxScrollV === null) {

            this._$maxScrollV = 1;

            this._$getTextData();

            const length    = this._$textHeightTable.length;
            const maxHeight = this.height;

            if (maxHeight > this.textHeight) {
                return this._$maxScrollV;
            }

            let textHeight = 0;

            let idx = 0;
            while (length > idx) {

                textHeight += this._$textHeightTable[idx];
                if (textHeight > maxHeight) {
                    break;
                }

                this._$maxScrollV++;
            }
        }
        return this._$maxScrollV;
    }

    /**
     * @description フィールドが複数行テキストフィールドであるかどうかを示します。
     *              Indicates whether field is a multiline text field.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get multiline ()
    {
        return this._$multiline;
    }
    set multiline (multiline)
    {
        this._$multiline = !!multiline;
        this._$reset();
    }

    /**
     * @description フィールドが複数行テキストフィールドであるかどうかを示します。
     *              Indicates whether field is a multiline text field.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get numLines ()
    {
        if (this._$textData === null) {
            this._$getTextData();
        }
        return this._$objectTable.length;
    }

    /**
     * @description ユーザーがテキストフィールドに入力できる文字のセットを指定します。
     *              Indicates the set of characters that a user can enter into the text field.
     *
     * @member {string}
     * @default null
     * @public
     */
    get restrict ()
    {
        return this._$restrict;
    }
    set restrict (restrict)
    {
        this._$restrict = `${restrict}`;
    }

    /**
     * @description スクロール機能のON/OFFの制御。
     *              Control ON/OFF of the scroll function.
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get scrollEnabled ()
    {
        return this._$scrollEnabled;
    }
    set scrollEnabled (scroll_enabled)
    {
        this._$scrollEnabled = !!scroll_enabled;
    }

    /**
     * TODO
     * @description 現在の水平スクロール位置です。
     *              The current horizontal scrolling position.
     *
     * @member {number}
     * @public
     */
    get scrollH ()
    {
        return this._$scrollH;
    }
    set scrollH (scroll_h)
    {
        scroll_h = Util.$clamp(scroll_h | 0, 0, this.maxScrollH);

        if (this._$scrollH !== scroll_h) {

            this._$scrollH = scroll_h;

            this._$reset();

            if (this.willTrigger(Event.SCROLL)) {
                this.dispatchEvent(new Event(Event.SCROLL, true));
            }
        }
    }

    /**
     * @description テキストフィールドのテキストの垂直位置です。
     *              The vertical position of text in a text field.
     *
     * @member {number}
     * @public
     */
    get scrollV ()
    {
        return this._$scrollV;
    }
    set scrollV (scroll_v)
    {
        scroll_v = Util.$clamp(scroll_v | 0, 1, this.maxScrollV);

        if (this._$scrollV !== scroll_v) {

            this._$scrollV = $Math.max(1, scroll_v);

            this._$reset();

            if (this.textHeight > this.height) {
                this._$scrollSprite.height = this.height * this.height / this.textHeight - 1;

                const parent = this._$parent;
                if (parent) {
                    // view start
                    this._$scrollSprite.alpha = 1;

                    // set position
                    this._$scrollSprite.x = this.x + this.width - this._$scrollSprite.width - 0.5;
                    this._$scrollSprite.y = this.y + 0.5
                        + (this.height - 1 - this._$scrollSprite.height)
                        / (this.maxScrollV - 1)
                        * (this._$scrollV - 1);

                    // added sprite
                    parent.addChildAt(
                        this._$scrollSprite,
                        parent.getChildIndex(this) + 1
                    );

                    // start animation
                    if (this._$scrollSprite.hasLocalVariable("job")) {
                        this._$scrollSprite.getLocalVariable("job").stop();
                    }

                    const job = Tween.add(this._$scrollSprite,
                        { "alpha" : 1 },
                        { "alpha" : 0 },
                        1
                    );

                    job.addEventListener(Event.COMPLETE, (event) =>
                    {
                        const sprite = event.target.target;
                        sprite.deleteLocalVariable("job");
                        if (sprite.parent) {
                            sprite.parent.removeChild(sprite);
                        }
                    });
                    job.start();

                    this._$scrollSprite.setLocalVariable("job", job);
                }
            }

            if (this.willTrigger(Event.SCROLL)) {
                this.dispatchEvent(new Event(Event.SCROLL, true));
            }
        }
    }

    /**
     * @description テキストフィールド内の現在のテキストであるストリングです。
     *              A string that is the current text in the text field.
     *
     * @member {string}
     * @default ""
     * @public
     */
    get text ()
    {
        if (!this._$isHTML) {
            return this._$text;
        }

        if (this._$rawHtmlText) {
            return this._$rawHtmlText;
        }

        let text = "";
        const textData = this._$getTextData();
        const length   = textData.length | 0;
        for (let idx = 1; idx < length; ++idx) {

            const object = textData[idx];
            switch (object.mode) {

                case TextField.TEXT:
                    text += object.text;
                    break;

                case TextField.BREAK:
                    text += "\r";
                    break;

            }
        }

        if (!this._$isHTML && this._$initText) {
            text += "\r";
        }

        this._$rawHtmlText = text;

        return text;
    }
    set text (text)
    {
        if (text === null) {
            text = "";
        }

        text = `${text}`;
        if (text !== this._$text) {
            this._$text            = text;
            this._$htmlText        = "";
            this._$cacheText       = "";
            this._$isHTML          = false;

            if (!this._$textAppending) {
                this._$textFormatTable = [];
            }

            this._$reload();
        }
    }

    /**
     * @description テキストフィールドのテキストの色です（16 進数形式）。
     *              The color of the text in a text field, in hexadecimal format.
     *
     * @member {number}
     * @public
     */
    get textColor ()
    {
        return this._$defaultTextFormat.color;
    }
    set textColor (text_color)
    {
        this._$defaultTextFormat.color = text_color;
        this._$reload();
    }

    /**
     * @description テキストの高さです（ピクセル単位）。
     *              The height of the text in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get textHeight ()
    {
        if (this.text === "") {
            return 0;
        }

        if (this._$textHeight === null) {

            // setup
            this._$textHeight = 2;
            this._$getTextData();

            let leading  = this._$decisionTextFormat._$leading | 0;
            const length = this._$textHeightTable.length;
            if (length === 1) {
                this._$textHeight += leading;
            }

            for (let idx = 0; idx < length; ++idx) {
                this._$textHeight += this._$textHeightTable[idx];
            }

        }

        return this._$textHeight;
    }

    /**
     * @description テキストの幅です（ピクセル単位）。
     *              The width of the text in pixels.
     *
     * @member {number}
     * @readonly
     * @public
     */
    get textWidth ()
    {
        if (this._$textWidth === null) {

            // setup
            this._$textWidth = 0;
            this._$getTextData();

            for (let idx = 0; idx < this._$widthTable.length; ++idx) {
                this._$textWidth = $Math.max(this._$textWidth, this._$widthTable[idx]);
            }

        }

        return this._$textWidth;
    }

    /**
     * @description 輪郭のテキスト幅です。0(デフォルト値)で無効にできます。
     *              The text width of the outline, which can be disabled with 0 (the default value).
     *
     * @member {number}
     * @default 0
     * @public
     */
    get thickness ()
    {
        return this._$thickness;
    }
    set thickness (thickness)
    {
        this._$thickness = thickness | 0;
        this._$reset();
    }

    /**
     * @description 輪郭のテキストの色です（16 進数形式）。
     *              The color of the outline text. (Hexadecimal format)
     *
     * @member {number}
     * @default 0
     * @public
     */
    get thicknessColor ()
    {
        return this._$thicknessColor;
    }
    set thicknessColor (thickness_color)
    {
        this._$thicknessColor = Util.$clamp(
            Util.$toColorInt(thickness_color), 0, 0xffffff, 0xffffff
        );
        this._$reset();
    }

    /**
     * @description テキストフィールドのタイプです。
     *              The type of the text field.
     *
     * @member {string}
     * @default TextFieldType.STATIC
     * @public
     */
    get type ()
    {
        return this._$type;
    }
    set type (type)
    {
        type += "";
        if (type === TextFieldType.STATIC) {
            this._$type     = type;
            this._$textarea = null;
        } else {
            this._$type = TextFieldType.INPUT;
        }
    }

    /**
     * @description 縦方向の揃え位置を指定するプロパティです。
     *              This property specifies the vertical alignment position.
     *
     * @member {string}
     * @default extFormatVerticalAlign.TOP
     * @public
     */
    get verticalAlign ()
    {
        return this._$verticalAlign;
    }
    set verticalAlign (vertical_align)
    {
        switch (vertical_align) {

            case TextFormatVerticalAlign.MIDDLE:
            case TextFormatVerticalAlign.BOTTOM:
                this._$verticalAlign = vertical_align;
                break;

            default:
                this._$verticalAlign = TextFormatVerticalAlign.TOP;
                break;
        }
    }

    /**
     * @description テキストフィールドのテキストを折り返すかどうかを示すブール値です。
     *              A Boolean value that indicates whether the text field has word wrap.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get wordWrap ()
    {
        return this._$wordWrap;
    }
    set wordWrap (word_wrap)
    {
        this._$wordWrap = !!word_wrap;
    }

    /**
     * @description 表示オブジェクトの幅を示します（ピクセル単位）。
     *              Indicates the width of the display object, in pixels.
     *
     * @member {number}
     * @public
     */
    get width ()
    {
        return super.width;
    }
    set width (width)
    {
        width = +width;
        if (!Util.$isNaN(width) && width > -1) {
            const bounds = this._$getBounds(null);

            const xMin = $Math.abs(bounds.xMin);
            this._$originBounds.xMax = width + xMin;
            this._$originBounds.xMin = xMin;
            this._$bounds.xMax = this._$originBounds.xMax;
            this._$bounds.xMin = this._$originBounds.xMin;

            super.width = width;

            this._$reload();
        }
    }

    /**
     * @description 表示オブジェクトの高さを示します（ピクセル単位）。
     *              Indicates the height of the display object, in pixels.
     *
     * @member {number}
     * @public
     */
    get height ()
    {
        return super.height;
    }
    set height (height)
    {
        height = +height;
        if (!Util.$isNaN(height) && height > -1) {
            const bounds = this._$getBounds(null);

            const yMin = $Math.abs(bounds.yMin);
            this._$originBounds.yMax = height + yMin;
            this._$bounds.yMax = this._$originBounds.yMax;
            this._$bounds.yMin = this._$originBounds.yMin;
            super.height = height;

            this._$reload();
        }
    }

    /**
     * @description 親 DisplayObjectContainer のローカル座標を基準にした
     *              DisplayObject インスタンスの x 座標を示します。
     *              Indicates the x coordinate
     *              of the DisplayObject instance relative to the local coordinates
     *              of the parent DisplayObjectContainer.
     *
     * @member {number}
     * @public
     */
    get x ()
    {
        const matrix = this._$transform.matrix;
        const bounds = this._$getBounds(null);
        return matrix._$matrix[4] + bounds.xMin;
    }
    set x (x)
    {
        const bounds = this._$getBounds(null);
        super.x = x - bounds.xMin;
    }

    /**
     * @description 親 DisplayObjectContainer のローカル座標を基準にした
     *              DisplayObject インスタンスの y 座標を示します。
     *              Indicates the y coordinate
     *              of the DisplayObject instance relative to the local coordinates
     *              of the parent DisplayObjectContainer.
     *
     * @member {number}
     * @public
     */
    get y ()
    {
        const matrix = this._$transform.matrix;
        const bounds = this._$getBounds(null);
        return matrix._$matrix[5] + bounds.yMin;
    }
    set y (y)
    {
        const bounds = this._$getBounds(null);
        super.y = y - bounds.yMin;
    }

    /**
     * @description newText パラメーターで指定されたストリングを、
     *              テキストフィールドのテキストの最後に付加します。
     *              Appends the string specified by the newText parameter
     *              to the end of the text of the text field.
     *
     * @param  {string} text
     * @return void
     * @method
     * @public
     */
    appendText (text)
    {
        const currentText = this.text;
        this._$textAppending = true;
        this.text = currentText + `${text}`;
        this._$textAppending = false;
    }

    /**
     * @description beginIndex パラメーターと endIndex パラメーターで指定された範囲の
     *              テキストのフォーマット情報を含む TextFormat オブジェクトを返します。
     *              Returns a TextFormat object that contains formatting information
     *              for the range of text that the beginIndex and endIndex parameters specify.
     *
     * @param  {int} [begin_index=-1]
     * @param  {int} [end_index=-1]
     * @return {TextFormat}
     * @method
     * @public
     */
    getTextFormat (begin_index = -1, end_index = -1)
    {
        begin_index |= 0;
        end_index   |= 0;

        const data   = this._$getTextData();
        const length = end_index > -1 ? end_index : data.length;

        let init = false;
        let textFormat = new TextFormat();
        let idx = begin_index > -1 ? begin_index : 0;
        for ( ; idx < length; ++idx) {

            if (data[idx].mode === TextField.BREAK) {
                continue;
            }

            const tf = data[idx].textFormat;
            if (!init) {
                init = true;
                textFormat = tf._$clone();
                continue;
            }

            textFormat._$align         = textFormat._$align         !== tf._$align         ? null : tf._$align;
            textFormat._$blockIndent   = textFormat._$blockIndent   !== tf._$blockIndent   ? null : tf._$blockIndent;
            textFormat._$bold          = textFormat._$bold          !== tf._$bold          ? null : tf._$bold;
            textFormat._$color         = textFormat._$color         !== tf._$color         ? null : tf._$color;
            textFormat._$font          = textFormat._$font          !== tf._$font          ? null : tf._$font;
            textFormat._$indent        = textFormat._$indent        !== tf._$indent        ? null : tf._$indent;
            textFormat._$italic        = textFormat._$italic        !== tf._$italic        ? null : tf._$italic;
            textFormat._$leading       = textFormat._$leading       !== tf._$leading       ? null : tf._$leading;
            textFormat._$leftMargin    = textFormat._$leftMargin    !== tf._$leftMargin    ? null : tf._$leftMargin;
            textFormat._$letterSpacing = textFormat._$letterSpacing !== tf._$letterSpacing ? null : tf._$letterSpacing;
            textFormat._$rightMargin   = textFormat._$rightMargin   !== tf._$rightMargin   ? null : tf._$rightMargin;
            textFormat._$size          = textFormat._$size          !== tf._$size          ? null : tf._$size;
            textFormat._$underline     = textFormat._$underline     !== tf._$underline     ? null : tf._$underline;

        }

        return textFormat;
    }

    /**
     * @description lineIndex パラメーターで指定された行のテキストを返します。
     *              Returns the text of the line specified by the lineIndex parameter.
     *
     * @param  {number} line_index
     * @return {string}
     * @public
     */
    getLineText (line_index)
    {
        if (!this._$text && !this._$htmlText) {
            return "";
        }

        line_index |= 0;
        let lineText = "";
        const textData = this._$getTextData();
        for (let idx = 0; idx < textData.length; idx++) {

            const obj = textData[idx];

            if (obj.yIndex > line_index) {
                break;
            }

            if (obj.yIndex !== line_index) {
                continue;
            }

            if (obj.mode !== TextField.TEXT) {
                continue;
            }

            lineText += obj.text;
        }

        return lineText;
    }

    /**
     * @description beginIndex パラメーターと endIndex パラメーターで指定された文字範囲を、
     *              newText パラメーターの内容に置き換えます。
     *              Replaces the range of characters that the beginIndex
     *              and endIndex parameters specify with the contents of the newText parameter.
     *
     * @param  {number} begin_index
     * @param  {number} end_index
     * @param  {string} new_text
     * @return {void}
     * @method
     * @public
     */
    replaceText (begin_index, end_index, new_text)
    {
        begin_index |= 0;
        end_index   |= 0;
        if (begin_index > -1 && end_index > -1 && end_index >= begin_index) {

            const text = this.text;

            if (begin_index >= text.length) {

                if (end_index >= text.length && end_index >= begin_index) {
                    this.text = text + `${new_text}`;
                }

            } else {

                this.text = text.substr(0, begin_index)
                    + `${new_text}`
                    + text.substr(end_index, text.length);

            }
        }
    }

    /**
     * @description format パラメーターで指定したテキストフォーマットを、
     *              テキストフィールド内の指定されたテキストに適用します。
     *              Applies the text formatting that the format parameter specifies
     *              to the specified text in a text field.
     *
     * @param  {TextFormat} text_format
     * @param  {number}     [begin_index=-1]
     * @param  {number}     [end_index=-1]
     * @return {void}
     * @method
     * @public
     */
    setTextFormat (text_format, begin_index = -1, end_index = -1)
    {
        // setup
        begin_index |= 0;
        end_index   |= 0;

        const textData = this._$getTextData();

        this._$reset();

        switch (true) {

            case begin_index === -1 && end_index === -1:
                {
                    const length = textData.length;
                    for (let idx = 0; idx < length; ++idx) {
                        this._$textFormatTable[idx] = text_format._$clone();
                    }
                }
                break;

            case begin_index > -1 && end_index === -1:
                {
                    let idx = begin_index + 1;
                    let obj = textData[idx];
                    if (obj.mode === TextField.WRAP) {
                        obj = textData[++idx];
                    }
                    this._$textFormatTable[idx] = text_format._$clone();
                }
                break;

            case begin_index > -1 && end_index > -1 && end_index > begin_index:
                {
                    let offset = 0;
                    for (let idx = begin_index; idx < end_index; ++idx) {

                        const obj = textData[idx];
                        if (!obj) {
                            continue;
                        }

                        if (obj.mode === TextField.WRAP
                            || obj.mode === TextField.BREAK
                        ) {
                            ++end_index;
                            --offset;
                            continue;
                        }

                        this._$textFormatTable[idx + offset] = text_format._$clone();

                    }
                }
                break;

        }

        this._$getTextData();
        this._$resize();
    }

    /**
     * @return {array}
     * @method
     * @private
     */
    _$getTextData ()
    {
        if (this._$textData === null) {

            // reset
            this._$textData        = [];
            this._$imageData       = [];
            this._$heightTable     = [];
            this._$textHeightTable = [];
            this._$objectTable     = [];
            this._$widthTable      = [];
            this._$heightCache     = Util.$getMap();

            let tfCopyOffset = -1;
            if (this._$isHTML) {

                // html text
                let htmlText = this._$htmlText;

                const index = htmlText.search(/(< .*>|<>)/g);
                if (index > -1) {
                    htmlText = htmlText.slice(0, index);
                }

                htmlText = htmlText.replace(/\r\n/g, "\r\r");
                if (Util.$P_TAG.innerHTML !== htmlText) {
                    Util.$P_TAG.textContent = "";
                    Util.$P_TAG.insertAdjacentHTML("afterbegin", htmlText);
                }

                // setup
                let tf = this._$decisionTextFormat;
                if (this._$textData.length in this._$textFormatTable) {
                    const tft = this._$textFormatTable[this._$textData.length]._$clone();
                    tft._$merge(tf);
                    tf = tft;
                }

                // init
                this._$totalWidth         = 0;
                this._$heightTable[0]     = 0;
                this._$textHeightTable[0] = this._$getTextHeight(tf);
                this._$widthTable[0]      = 0;

                const obj = {
                    "mode"      : TextField.BREAK,
                    "x"         : 0,
                    "yIndex"    : 0,
                    "textFormat": tf._$clone()
                };

                this._$objectTable[0] = obj;
                this._$textData[0]    = obj;

                this._$parseTag(Util.$P_TAG, tf._$clone(), tfCopyOffset);

            } else {

                // plain text
                const texts = this._$multiline
                    ? this._$text.split("\n")
                    : [this._$text.replace("\n", "")];

                const length = texts.length;
                for (let idx = 0; idx < length; ++idx) {

                    // reset
                    this._$totalWidth = 0;

                    let tf = this.defaultTextFormat;

                    const yIndex = this._$wordWrap || this._$multiline
                        ? this._$heightTable.length
                        : 0;

                    this._$heightTable[yIndex]     = 0;
                    this._$textHeightTable[yIndex] = this._$getTextHeight(tf);
                    this._$widthTable[yIndex]      = 0;

                    if (yIndex) {
                        this._$heightTable[yIndex]     = this._$heightTable[yIndex - 1];
                        this._$textHeightTable[yIndex] = this._$textHeightTable[yIndex - 1];
                    }

                    if (this._$textData.length in this._$textFormatTable) {
                        const tft = this._$textFormatTable[this._$textData.length]._$clone();
                        tft._$merge(tf);
                        tf = tft;
                    }

                    const obj = {
                        "mode"      : TextField.BREAK,
                        "x"         : 0,
                        "yIndex"    : yIndex,
                        "textFormat": tf._$clone()
                    };

                    tf = this.defaultTextFormat;

                    this._$objectTable[yIndex] = obj;
                    this._$textData[this._$textData.length] = obj;

                    // parse text data
                    const text = texts[idx];
                    if (text) {
                        tfCopyOffset = this._$parseText(text, tf, tfCopyOffset);
                    }
                }
            }

            // clear
            Util.$poolMap(this._$heightCache);
            this._$heightCache = null;
        }

        return this._$textData;
    }

    /**
     * @param  {Element}    tag
     * @param  {TextFormat} text_format
     * @param  {number}     tf_copy_offset
     * @return {void}
     * @private
     */
    _$parseTag (tag, text_format, tf_copy_offset)
    {
        const childNodes = tag.childNodes;
        const length     = childNodes.length;
        for (let idx = 0; idx < length; ++idx) {

            let tf = text_format._$clone();

            const node = childNodes[idx];
            if (node.nodeType === 3) {

                tf_copy_offset = this._$parseText(node.nodeValue, tf);

                continue;

            }

            switch (node.nodeName) {

                case "P":
                    {
                        if (node.hasAttribute("align")) {
                            tf._$align = node.getAttribute("align").toLowerCase();
                            if (this._$textData.length === 1) {
                                this._$textData[0].textFormat._$align = tf._$align;
                            }
                        }

                        this._$parseTag(node, tf, tf_copy_offset);

                        if (!this._$multiline) {
                            break;
                        }

                        // reset
                        this._$totalWidth = this._$getImageOffsetX();

                        const yIndex = this._$heightTable.length;

                        this._$heightTable[yIndex]     = 0;
                        this._$textHeightTable[yIndex] = 0;
                        this._$widthTable[yIndex]      = 0;

                        if (yIndex) {
                            this._$heightTable[yIndex]     = this._$heightTable[yIndex - 1];
                            this._$textHeightTable[yIndex] = this._$textHeightTable[yIndex - 1];
                        }

                        if (this._$textData.length in this._$textFormatTable) {
                            const tft = this._$textFormatTable[this._$textData.length]._$clone();
                            tft._$merge(tf);
                            tf = tft;
                        }

                        const obj = {
                            "mode"      : TextField.BREAK,
                            "x"         : 0,
                            "yIndex"    : yIndex,
                            "textFormat": tf
                        };

                        this._$objectTable[yIndex] = obj;
                        this._$textData.push(obj);
                    }
                    break;

                case "B": // bold
                    tf._$bold = true;
                    this._$parseTag(node, tf, tf_copy_offset);
                    break;

                case "I": // italic
                    tf._$italic = true;
                    this._$parseTag(node, tf, tf_copy_offset);
                    break;

                case "U": // underline
                    tf._$underline = true;
                    this._$parseTag(node, tf, tf_copy_offset);
                    break;

                case "FONT": // FONT
                    if (node.hasAttribute("face")) {
                        tf._$font = node.getAttribute("face");
                    }

                    if (node.hasAttribute("size")) {
                        tf._$size = node.getAttribute("size") | 0;
                    }

                    if (node.hasAttribute("color")) {
                        tf._$color = Util.$toColorInt(node.getAttribute("color"));
                    }

                    if (node.hasAttribute("letterSpacing")) {
                        tf.letterSpacing = node.getAttribute("letterSpacing") | 0;
                    }

                    this._$parseTag(node, tf, tf_copy_offset);
                    break;

                case "TEXTFORMAT": // TEXTFORMAT

                    if (node.hasAttribute("blockindent")) {
                        tf._$blockIndent = node.getAttribute("blockindent") | 0;
                    }

                    if (node.hasAttribute("indent")) {
                        tf._$indent = node.getAttribute("indent") | 0;
                    }

                    if (node.hasAttribute("leading")) {
                        tf._$leading = node.getAttribute("leading") | 0;
                    }

                    if (node.hasAttribute("leftmargin")) {
                        tf._$leftMargin = node.getAttribute("leftmargin") | 0;
                    }

                    if (node.hasAttribute("rightmargin")) {
                        tf._$rightMargin = node.getAttribute("rightmargin") | 0;
                    }

                    this._$parseTag(node, tf, tf_copy_offset);
                    break;

                case "BR": // br
                    {
                        if (!this._$multiline) {
                            break;
                        }

                        // add y index
                        const yIndex = this._$heightTable.length;

                        this._$heightTable[yIndex]     = this._$heightTable[yIndex - 1];
                        this._$textHeightTable[yIndex] = this._$textHeightTable[yIndex - 1];
                        this._$widthTable[yIndex]      = 0;

                        // reset
                        this._$totalWidth = this._$getImageOffsetX();

                        // new clone
                        tf._$indent = 0;

                        // set x offset
                        const obj = {
                            "mode"      : TextField.BREAK,
                            "x"         : 0,
                            "yIndex"    : yIndex,
                            "textFormat": tf
                        };

                        this._$objectTable[yIndex]              = obj;
                        this._$textData[this._$textData.length] = obj;
                    }
                    break;

                case "IMG":
                    {
                        let src = "";
                        if (node.hasAttribute("src")) {
                            src = node.getAttribute("src");
                        }

                        let obj = null;
                        if (!Util.$loadedImages.has(src)) {

                            const width  = node.getAttribute("width") || 0;
                            const height = node.getAttribute("height") || 0;
                            const vspace = node.getAttribute("vspace") || 8;
                            const hspace = node.getAttribute("hspace") || 8;

                            let totalTextHeight = 0;
                            for (let idx = 0; idx < this._$textHeightTable.length; idx++) {
                                totalTextHeight += this._$textHeightTable[idx];
                            }

                            obj = {
                                "mode"      : TextField.IMAGE,
                                "src"       : src,
                                "loaded"    : false,
                                "x"         : 0,
                                "y"         : totalTextHeight,
                                "width"     : width | 0,
                                "height"    : height | 0,
                                "hspace"    : hspace | 0,
                                "vspace"    : vspace | 0,
                                "textFormat": tf._$clone()
                            };

                            if (this._$imageData.length > 0) {
                                const prevImage   = this._$imageData[this._$imageData.length - 1];
                                const imageBottom = prevImage.y + prevImage.height + prevImage.vspace * 2;

                                obj.y = $Math.max(totalTextHeight, imageBottom);
                            }

                            this._$loadImage(obj);
                            Util.$loadedImages.set(src, obj);

                        } else {

                            obj = Util.$loadedImages.get(src);

                        }

                        this._$textData[this._$textData.length]   = obj;
                        this._$imageData[this._$imageData.length] = obj;
                    }
                    break;

                default:
                    this._$parseTag(node, tf, tf_copy_offset);
                    break;

            }
        }
    }

    /**
     * @param  {Object} obj
     * @return void
     * @private
     */
    _$loadImage (obj)
    {
        obj.scope = this;
        obj.image = new Util.$Image();

        obj.image.crossOrigin = "anonymous";
        obj.image.addEventListener("load", function ()
        {
            this.loaded = true;

            // set size
            if (!this.width) {
                this.width = this.image.width | 0;
            }
            if (!this.height) {
                this.height = this.image.height | 0;
            }

            const scope = this.scope;
            this.scope  = null;

            Util.$loadedImages.set(this.src, this);
            scope._$reload();

        }.bind(obj), false);

        obj.image.src = obj.src;
    }

    /**
     * @param   {string} text
     * @param   {TextFormat} text_format
     * @param   {number} tf_copy_offset
     * @returns {number}
     * @method
     * @private
     */
    _$parseText (text, text_format, tf_copy_offset)
    {

        let yIndex = this._$heightTable.length - 1 | 0;

        // new format
        let tf = text_format._$clone();

        const matrix = this._$transform.concatenatedMatrix._$matrix;

        const boundsWidth = (this._$originBounds.xMax - this._$originBounds.xMin)
            * (matrix[0] / matrix[3]);

        Util.$poolFloat32Array6(matrix);

        const maxWidth = boundsWidth - tf._$widthMargin() - 4;
        for (let idx = 0; idx < text.length; ++idx) {

            tf = text_format._$clone();
            if (this._$textData.length + tf_copy_offset in this._$textFormatTable) {
                const tft = this._$textFormatTable[this._$textData.length + tf_copy_offset]._$clone();
                tft._$merge(tf);
                tf = tft;
            }

            // reset object
            const obj = {
                "mode"      : TextField.TEXT,
                "text"      : text[idx],
                "x"         : 0,
                "width"     : 0,
                "fontScale" : 0,
                "yIndex"    : yIndex,
                "textFormat": tf
            };

            let breakCode = null;
            if (this._$multiline) {
                breakCode = obj.text === "\n" || obj.text === "\r" || obj.text === "\n\r";
            }

            let leading    = yIndex ? tf._$leading : 0;
            let width      = 0;
            let height     = 0;
            let textHeight = 0;
            let wrapObj    = null;

            Util.$textContext.font = tf._$generateFontStyle();
            width = Util.$textContext.measureText(obj.text).width + tf._$letterSpacing;

            height     = this._$getTextHeight(tf);
            textHeight = height + leading;
            obj.height = height;

            if (breakCode ||
                this._$wordWrap && this._$totalWidth + width > maxWidth
            ) {

                // add y index
                this._$widthTable[++yIndex] = 0;

                obj.yIndex = yIndex;

                this._$heightTable[yIndex]     = this._$heightTable[yIndex - 1];
                this._$textHeightTable[yIndex] = this._$textHeightTable[yIndex - 1];

                // reset
                this._$totalWidth = this._$getImageOffsetX();

                // new clone
                tf = tf._$clone();
                tf._$indent = 0;

                // set x offset
                const mode = breakCode ? TextField.BREAK : TextField.WRAP;
                wrapObj = {
                    "mode"      : mode,
                    "x"         : 0,
                    "yIndex"    : yIndex,
                    "textFormat": tf
                };

                this._$objectTable[yIndex] = wrapObj;

                if (!breakCode) {
                    --tf_copy_offset;
                }

                let text        = obj.text;
                let chunkLength = 0;
                let isSeparated = true;
                const pattern   = /[0-9a-zA-Z?!;:.,？！。、；：〜]/g;

                while (text.match(pattern)) {
                    ++chunkLength;
                    const prevObj = this._$textData[this._$textData.length - chunkLength];

                    if (prevObj.mode !== TextField.TEXT) {
                        isSeparated = false;
                        break;
                    }

                    text = prevObj.text;
                }

                if (chunkLength > 1 && this._$textData[this._$textData.length - chunkLength + 1].text.match(/[0-9a-zA-Z]/g)) {
                    --chunkLength;
                }

                if (chunkLength > 0 && isSeparated) {

                    const insertIdx = this._$textData.length - chunkLength;
                    this._$textData.splice(insertIdx, 0, wrapObj);

                    // prev line
                    let offset    = 1;
                    let targetObj = this._$textData[insertIdx - offset];

                    this._$widthTable[yIndex - 1]      = 0;
                    this._$heightTable[yIndex - 1]     = 0;
                    this._$textHeightTable[yIndex - 1] = 0;

                    while (targetObj.mode === TextField.TEXT) {

                        height     = this._$getTextHeight(targetObj.textFormat);
                        textHeight = height + leading;

                        this._$widthTable[yIndex - 1]     += targetObj.width;
                        this._$heightTable[yIndex - 1]     = $Math.max(this._$heightTable[yIndex - 1], height);
                        this._$textHeightTable[yIndex - 1] = $Math.max(this._$textHeightTable[yIndex - 1], textHeight);

                        ++offset;
                        targetObj = this._$textData[insertIdx - offset];
                    }

                    // new line
                    offset = 1;
                    while (this._$textData.length > insertIdx + offset) {
                        targetObj = this._$textData[insertIdx + offset];
                        ++offset;

                        height     = this._$getTextHeight(targetObj.textFormat);
                        textHeight = height + leading;

                        this._$heightTable[yIndex]     = $Math.max(this._$heightTable[yIndex], height);
                        this._$textHeightTable[yIndex] = $Math.max(this._$textHeightTable[yIndex], textHeight);

                        targetObj.x      = this._$totalWidth;
                        targetObj.yIndex = yIndex;

                        this._$totalWidth += targetObj.width;
                    }

                } else {
                    this._$textData[this._$textData.length] = wrapObj;
                }
            }

            if (!breakCode) {

                // width data
                obj.width          = width;
                obj.x              = this._$totalWidth;
                this._$totalWidth += width;

                this._$widthTable[yIndex] = $Math.max(this._$widthTable[yIndex], this._$totalWidth);

                // height data
                this._$heightTable[yIndex]     = $Math.max(this._$heightTable[yIndex], height);
                this._$textHeightTable[yIndex] = $Math.max(this._$textHeightTable[yIndex], textHeight);

                this._$textData[this._$textData.length] = obj;

            }

        }

        return tf_copy_offset;
    }

    /**
     * @param  {TextFormat} text_format
     * @return {number}
     * @private
     */
    _$getTextHeight (text_format)
    {
        if (!Util.$DIV) {

            const div = Util.$document.createElement("div");

            div.innerHTML             = "a";
            div.style.display         = "block";
            div.style.position        = "absolute";
            div.style.top             = "-9999px";
            div.style.left            = "-9999px";
            div.style.padding         = "0";
            div.style.margin          = "0";
            div.style.padding         = "0";
            div.style.border          = "0";
            div.style.outline         = "0";
            div.style.verticalAlign   = "bottom";
            div.style.lineHeight      = "100%";

            Util.$DIV = div;
            Util.$document.body.appendChild(Util.$DIV);

        }

        const size   = text_format._$size;
        const font   = text_format._$font;
        const weight = text_format._$bold ? "bold" : "normal";

        // use cache
        const key = `${size}_${font}_${weight}`;
        if (this._$heightCache.has(key)) {
            return this._$heightCache.get(key);
        }

        // update dom data
        const style = Util.$DIV.style;

        const fontSize = `${size}px`;
        if (style.fontSize !== fontSize) {
            style.fontSize = fontSize;
        }
        if (style.fontFamily !== font) {
            style.fontFamily = font;
        }
        if (style.fontWeight !== weight) {
            style.fontWeight = weight;
        }

        const height = 10 > size
            ? Util.$DIV.clientHeight * size * 0.1
            : Util.$DIV.clientHeight;

        // cache
        this._$heightCache.set(key, height);
        return height;
    }

    /**
     * @return {number}
     * @private
     */
    _$getImageOffsetX ()
    {
        if (!this._$imageData.length) {
            return 0;
        }

        let totalTextHeight = 0;
        for (let idx = 0; idx < this._$textHeightTable.length; ++idx) {
            totalTextHeight += this._$textHeightTable[idx];
        }

        for (let idx = 0; idx < this._$imageData.length; ++idx) {

            const image = this._$imageData[idx];

            const imageHeight = image.height + image.vspace * 2;

            if (image.y <= totalTextHeight
                && totalTextHeight < image.y + imageHeight
            ) {
                return image.width + image.hspace * 2;
            }
        }

        return 0;
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$reset ()
    {
        this._$renew           = true;
        this._$textData        = null;
        this._$imageData       = null;
        this._$textHeight      = null;
        this._$textWidth       = null;
        this._$heightTable     = null;
        this._$textHeightTable = null;
        this._$widthTable      = null;
        this._$objectTable     = null;
        this._$totalWidth      = null;
        this._$maxScrollH      = null;
        this._$maxScrollV      = null;

        this._$doChanged();
        Util.$isUpdated = true;

        // cache clear
        Util.$cacheStore().removeCache(this._$instanceId);
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$reload ()
    {
        this._$reset();
        this._$getTextData();

        if (this._$autoSize === TextFieldAutoSize.NONE && this._$autoFontSize) {

            const fontSize = this.defaultTextFormat.size;
            if (this.width && this.textWidth
                && this.textWidth > this.width
            ) {

                while (this.textWidth > this.width) {

                    this.defaultTextFormat.size--;
                    if (1 > this.defaultTextFormat.size) {
                        this.defaultTextFormat.size = 1;
                        break;
                    }

                    this._$reset();
                    this._$getTextData();
                }

            }

            if (this.height && this.textHeight
                && this.textHeight > this.height
            ) {

                while (this.textHeight > this.height) {

                    this.defaultTextFormat.size--;
                    if (1 > this.defaultTextFormat.size) {
                        this.defaultTextFormat.size = 1;
                        break;
                    }

                    this._$reset();
                    this._$getTextData();
                }

            }

            // restore
            this.defaultTextFormat.size = fontSize;
        }

        this._$resize();
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$resize ()
    {
        // update bounds
        if (this._$autoSize !== TextFieldAutoSize.NONE) {

            const tf = this._$defaultTextFormat;
            const width = this.textWidth + 4
                + tf._$leftMargin + tf._$rightMargin;

            if (this._$wordWrap) {

                this._$bounds.xMax = this._$originBounds.xMax;
                this._$bounds.xMin = this._$originBounds.xMin;

            } else {

                switch (this._$autoSize) {

                    case TextFieldAutoSize.LEFT:
                        this._$bounds.xMax = width + this._$bounds.xMin;
                        break;

                    case TextFieldAutoSize.CENTER:
                        this._$bounds.xMax = width + this._$bounds.xMin;
                        break;

                    case TextFieldAutoSize.RIGHT:
                        this._$bounds.xMax = this._$originBounds.xMax
                            - (this._$originBounds.xMax - this._$originBounds.xMin
                                - (width - this._$originBounds.xMin));
                        break;

                    default:
                        break;

                }

            }

            // set height
            this._$bounds.yMax = this.textHeight
                + 4 + this._$originBounds.yMin;

        } else {

            if (this._$scrollEnabled && !this._$scrollSprite) {
                this._$scrollSprite = new Sprite();
                this._$scrollSprite
                    .graphics
                    .beginFill("#000", 0.3)
                    .drawRoundRect(0, 0, 3, 3, 3);
                this._$scrollSprite._$scale9Grid = new Rectangle(1.5, 1.5, 0.1, 0.1);
            }
        }
    }

    /**
     * @param  {object} obj
     * @param  {number} width
     * @return {number}
     * @private
     */
    _$getAlignOffset (obj, width)
    {

        // default
        const totalWidth = this._$widthTable[obj.yIndex];
        const textFormat = obj.textFormat;
        const indent     = textFormat._$blockIndent + textFormat._$leftMargin > 0
            ? textFormat._$blockIndent + textFormat._$leftMargin
            : 0;

        switch (true) {

            // wordWrap case
            case this._$wordWrap === false && totalWidth > width:
                return $Math.max(0, indent);

            case textFormat._$align === TextFormatAlign.CENTER: // format CENTER
            case this._$autoSize === TextFieldAutoSize.CENTER: // autoSize CENTER
                return $Math.max(0, width / 2 - indent - textFormat._$rightMargin - totalWidth / 2);

            case textFormat._$align === TextFormatAlign.RIGHT: // format RIGHT
            case this._$autoSize === TextFieldAutoSize.RIGHT: // autoSize RIGHT
                return $Math.max(0, width - indent - totalWidth - textFormat._$rightMargin - 2);

            // autoSize LEFT
            // format LEFT
            default:
                return $Math.max(0, indent + 2);

        }
    }

    /**
     * @param   {Float32Array} [matrix=null]
     * @returns {object}
     * @private
     */
    _$getBounds (matrix = null)
    {
        if (matrix) {

            const multiMatrix = Util.$multiplicationMatrix(
                matrix, this._$correctMatrix(this._$transform._$rawMatrix())
            );

            return Util.$boundsMatrix(this._$bounds, multiMatrix);
        }

        return Util.$boundsMatrix(
            this._$bounds, this._$correctMatrix(Util.$MATRIX_ARRAY_IDENTITY)
        );
    }

    /**
     * @param  {Float32Array} matrix
     * @return {Float32Array}
     * @private
     */
    _$correctMatrix (matrix)
    {
        switch (this._$autoSize) {

            case TextFieldAutoSize.CENTER:
            {
                const textWidth = this.textWidth + 4;

                const xOffset = (this._$originBounds.xMax - this._$originBounds.xMin) / 2
                        - textWidth / 2;

                return Util.$getFloat32Array6(
                    matrix[0], matrix[1], matrix[2],
                    matrix[3], matrix[4] + xOffset, matrix[5]
                );
            }

            case TextFieldAutoSize.RIGHT:
            {
                const textWidth = this.textWidth + 4;

                const xOffset = this._$originBounds.xMax - this._$originBounds.xMin
                        - (textWidth - this._$originBounds.xMin);

                return Util.$getFloat32Array6(
                    matrix[0], matrix[1], matrix[2],
                    matrix[3], matrix[4] + xOffset, matrix[5]
                );
            }

            default:
                return matrix;

        }
    }

    /**
     * @param  {object} character
     * @return {void}
     * @method
     * @private
     */
    _$buildCharacter (character)
    {
        const textFormat = this.defaultTextFormat;

        textFormat.font          = character.font;
        textFormat.size          = character.size | 0;
        textFormat.align         = character.align;
        textFormat.color         = character.color | 0;
        textFormat.leading       = character.leading;
        textFormat.letterSpacing = character.letterSpacing;
        textFormat.leftMargin    = character.leftMargin;
        textFormat.rightMargin   = character.rightMargin;

        switch (character.fontType) {

            case 1:
                textFormat.bold = true;
                break;

            case 2:
                textFormat.italic = true;
                break;

            case 3:
                textFormat.bold   = true;
                textFormat.italic = true;
                break;

        }

        // setup
        this._$type           = character.inputType;
        this._$multiline      = !!character.multiline;
        this._$wordWrap       = !!character.wordWrap;
        this._$border         = !!character.border;
        this._$scrollEnabled  = !!character.scroll;
        this._$thickness      = character.thickness | 0;
        this._$thicknessColor = character.thicknessColor | 0;

        // bounds
        this._$bounds.xMin       = character.originBounds.xMin;
        this._$bounds.xMax       = character.originBounds.xMax;
        this._$bounds.yMin       = character.originBounds.yMin;
        this._$bounds.yMax       = character.originBounds.yMax;
        this._$originBounds.xMin = character.originBounds.xMin;
        this._$originBounds.xMax = character.originBounds.xMax;
        this._$originBounds.yMin = character.originBounds.yMin;
        this._$originBounds.yMax = character.originBounds.yMax;

        switch (character.autoSize) {

            case 1:
                this.autoSize = character.align;
                break;

            case 2:
                this.autoFontSize = true;
                break;

        }

        this.text = character.text;
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$sync ()
    {
        const character = super._$sync();

        if (character) {
            this._$buildCharacter(character);
        }

        return character;
    }

    /**
     * @param  {object} tag
     * @param  {DisplayObjectContainer} parent
     * @return {object}
     * @method
     * @private
     */
    _$build (tag, parent)
    {
        const character = super._$build(tag, parent);

        this._$buildCharacter(character);

        return character;
    }

    /**
     * @param   {CanvasToWebGLContext} context
     * @param   {Float32Array} matrix
     * @returns {void}
     * @method
     * @private
     */
    _$clip (context, matrix)
    {
        // size
        const bounds = this._$getBounds();
        const xMax   = bounds.xMax;
        const xMin   = bounds.xMin;
        const yMax   = bounds.yMax;
        const yMin   = bounds.yMin;
        Util.$poolBoundsObject(bounds);

        let width  = $Math.ceil($Math.abs(xMax - xMin));
        let height = $Math.ceil($Math.abs(yMax - yMin));
        if (!width || !height) {
            return;
        }

        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        Util.$resetContext(context);
        context.setTransform(
            multiMatrix[0], multiMatrix[1], multiMatrix[2],
            multiMatrix[3], multiMatrix[4], multiMatrix[5]
        );
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(width, 0);
        context.lineTo(width, height);
        context.lineTo(0, height);
        context.lineTo(0, 0);
        context.clip(true);

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @return {void}
     * @method
     * @private
     */
    _$draw (context, matrix, color_transform)
    {
        if (!this._$visible || this._$textAreaActive) {
            return ;
        }

        if (!this._$background && !this._$border && !this.text) {
            return;
        }

        let multiColor = color_transform;
        const rawColor = this._$transform._$rawColorTransform();
        if (rawColor !== Util.$COLOR_ARRAY_IDENTITY) {
            multiColor = Util.$multiplicationColor(color_transform, rawColor);
        }

        const alpha = Util.$clamp(multiColor[3] + multiColor[7] / 255, 0 ,1);
        if (!alpha) {
            return ;
        }

        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        const baseBounds = this._$getBounds(null);
        baseBounds.xMin -= this._$thickness;
        baseBounds.xMax += this._$thickness;
        baseBounds.yMin -= this._$thickness;
        baseBounds.yMax += this._$thickness;

        // local cache
        const baseXMin = baseBounds.xMin;
        const baseYMin = baseBounds.yMin;

        const bounds = Util.$boundsMatrix(baseBounds, multiMatrix);
        const xMax   = +bounds.xMax;
        const xMin   = +bounds.xMin;
        const yMax   = +bounds.yMax;
        const yMin   = +bounds.yMin;
        Util.$poolBoundsObject(bounds);

        let width  = $Math.ceil($Math.abs(xMax - xMin));
        let height = $Math.ceil($Math.abs(yMax - yMin));
        switch (true) {

            case width === 0:
            case height === 0:
            case width === -Util.$Infinity:
            case height === -Util.$Infinity:
            case width === Util.$Infinity:
            case height === Util.$Infinity:
                return;

            default:
                break;

        }

        if (0 > xMin + width || 0 > yMin + height) {
            return;
        }

        // cache current buffer
        const currentAttachment = context.frameBuffer.currentAttachment;
        if (xMin > currentAttachment.width || yMin > currentAttachment.height) {
            return;
        }

        let xScale = +$Math.sqrt(
            multiMatrix[0] * multiMatrix[0]
            + multiMatrix[1] * multiMatrix[1]
        );
        if (!$Number.isInteger(xScale)) {
            const value = xScale.toString();
            const index = value.indexOf("e");
            if (index !== -1) {
                xScale = +value.slice(0, index);
            }
            xScale = +xScale.toFixed(4);
        }

        let yScale = +$Math.sqrt(
            multiMatrix[2] * multiMatrix[2]
            + multiMatrix[3] * multiMatrix[3]
        );
        if (!$Number.isInteger(yScale)) {
            const value = yScale.toString();
            const index = value.indexOf("e");
            if (index !== -1) {
                yScale = +value.slice(0, index);
            }
            yScale = +yScale.toFixed(4);
        }

        const filters = this._$filters || this.filters;
        if (0 > xMin + width || 0 > yMin + height) {

            if (filters && filters.length && this._$canApply(filters)) {

                let rect = new Rectangle(0, 0, width, height);
                for (let idx = 0; idx < filters.length ; ++idx) {
                    rect = filters[idx]._$generateFilterRect(rect, xScale, yScale);
                }

                if (0 > rect.x + rect.width || 0 > rect.y + rect.height) {
                    return;
                }

            } else {
                return;
            }

        }

        // get cache
        const keys = Util.$getArray(xScale, yScale);
        const cacheStore = Util.$cacheStore();
        const cacheKeys  = cacheStore.generateKeys(this._$instanceId, keys, multiColor);
        let texture      = cacheStore.get(cacheKeys);
        Util.$poolArray(keys);

        // texture is small or renew
        if (texture && (this._$renew || this._$isUpdated())) {
            cacheStore.removeCache(this._$instanceId);
            texture = null;
        }

        if (!texture) {

            // resize
            const lineWidth  = $Math.min(1, $Math.max(xScale, yScale));
            const baseWidth  = $Math.ceil($Math.abs(baseBounds.xMax - baseBounds.xMin) * xScale);
            const baseHeight = $Math.ceil($Math.abs(baseBounds.yMax - baseBounds.yMin) * yScale);

            this._$renew = false;

            // alpha reset
            multiColor[3] = 1;

            // new canvas
            const canvas  = cacheStore.getCanvas();
            canvas.width  = baseWidth  + lineWidth * 2;
            canvas.height = baseHeight + lineWidth * 2;
            const ctx     = canvas.getContext("2d");

            // border and background
            if (this._$background || this._$border) {

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(baseWidth, 0);
                ctx.lineTo(baseWidth, baseHeight);
                ctx.lineTo(0, baseHeight);
                ctx.lineTo(0, 0);

                if (this._$background) {

                    const rgb   = Util.$intToRGBA(this._$backgroundColor);
                    const alpha = $Math.max(0, $Math.min(
                        rgb.A * 255 * multiColor[3] + multiColor[7], 255)
                    ) / 255;

                    ctx.fillStyle = `rgba(${rgb.R},${rgb.G},${rgb.B},${alpha})`;
                    ctx.fill();
                }

                if (this._$border) {

                    const rgb   = Util.$intToRGBA(this._$borderColor);
                    const alpha = $Math.max(0, $Math.min(
                        rgb.A * 255 * multiColor[3] + multiColor[7], 255)
                    ) / 255;

                    ctx.lineWidth   = lineWidth;
                    ctx.strokeStyle = `rgba(${rgb.R},${rgb.G},${rgb.B},${alpha})`;
                    ctx.stroke();

                }

            }

            // mask start
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(2, 2);
            ctx.lineTo(baseWidth - 2, 2);
            ctx.lineTo(baseWidth - 2, baseHeight - 2);
            ctx.lineTo(2, baseHeight - 2);
            ctx.lineTo(2, 2);
            ctx.clip();

            ctx.beginPath();
            ctx.setTransform(xScale, 0, 0, yScale, 0, 0);
            this._$doDraw(ctx, matrix, multiColor, baseWidth / matrix[0]);
            ctx.restore();

            texture = context
                .frameBuffer
                .createTextureFromCanvas(ctx.canvas);

            // set cache
            cacheStore.set(cacheKeys, texture);

            // destroy cache
            cacheStore.destroy(ctx);

        }
        Util.$poolArray(cacheKeys);
        Util.$poolBoundsObject(baseBounds);

        const blendMode = this._$blendMode || this.blendMode;
        if (filters && filters.length) {

            const canApply = this._$canApply(filters);
            if (canApply) {

                const filterTexture = this._$drawFilter(
                    context, texture, multiMatrix,
                    filters, width, height
                );

                // reset
                Util.$resetContext(context);

                // draw
                context._$globalAlpha = alpha;
                context._$globalCompositeOperation = blendMode;

                context.setTransform(1, 0, 0, 1,
                    xMin - filterTexture._$offsetX,
                    yMin - filterTexture._$offsetY
                );
                context.drawImage(filterTexture,
                    0, 0, filterTexture.width, filterTexture.height,
                    multiColor
                );

                if (multiMatrix !== matrix) {
                    Util.$poolFloat32Array6(multiMatrix);
                }

                if (multiColor !== color_transform) {
                    Util.$poolFloat32Array8(multiColor);
                }

                return ;

            }

        }

        // reset
        Util.$resetContext(context);

        // draw
        context._$globalAlpha = alpha;
        context._$globalCompositeOperation = blendMode;

        const radianX = $Math.atan2(multiMatrix[1], multiMatrix[0]);
        const radianY = $Math.atan2(-multiMatrix[2], multiMatrix[3]);
        if (radianX || radianY) {

            const tx = baseXMin * xScale;
            const ty = baseYMin * yScale;

            context.setTransform(
                $Math.cos(radianX),
                $Math.sin(radianX),
                -$Math.sin(radianY),
                $Math.cos(radianY),
                tx * $Math.cos(radianX) - ty * $Math.sin(radianY) + multiMatrix[4],
                tx * $Math.sin(radianX) + ty * $Math.cos(radianY) + multiMatrix[5]
            );

        } else {

            context.setTransform(1, 0, 0, 1, xMin, yMin);

        }

        context.drawImage(texture,
            0, 0, texture.width, texture.height, multiColor
        );

        // pool
        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        if (multiColor !== color_transform) {
            Util.$poolFloat32Array8(multiColor);
        }
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @param  {number} width
     * @return {void}
     * @method
     * @private
     */
    _$doDraw (context, matrix, color_transform, width)
    {
        // init
        const textData = this._$getTextData();

        const limitWidth  = this.width;
        const limitHeight = this.height;

        // setup
        let xOffset      = 0;
        let offsetHeight = 0;
        let currentV     = 0;

        let yOffset = 0;
        if (this._$verticalAlign !== TextFormatVerticalAlign.TOP
            && this.height > this.textHeight
        ) {

            switch (this._$verticalAlign) {

                case TextFormatVerticalAlign.MIDDLE:
                    yOffset = (this.height - this.textHeight + 2) / 2;
                    break;

                case TextFormatVerticalAlign.BOTTOM:
                    yOffset = this.height - this.textHeight + 2;
                    break;

            }

        }

        const length = textData.length;
        for (let idx = 0; idx < length; ++idx) {

            let obj = textData[idx];
            if (obj.width === 0) {
                continue;
            }

            // check
            const offsetWidth = xOffset + obj.x;
            if (this._$autoSize === TextFieldAutoSize.NONE
                && (offsetHeight > limitHeight || offsetWidth > limitWidth)
            ) {
                continue;
            }

            let tf = obj.textFormat;

            // color
            const rgb   = Util.$intToRGBA(obj.textFormat._$color);
            const alpha = $Math.max(0, $Math.min(
                rgb.A * 255 * color_transform[3] + color_transform[7], 255)
            ) / 255;

            context.fillStyle = `rgba(${rgb.R},${rgb.G},${rgb.B},${alpha})`;

            if (this._$thickness) {
                const rgb   = Util.$intToRGBA(this._$thicknessColor);
                const alpha = $Math.max(0, $Math.min(
                    rgb.A * 255 * color_transform[3] + color_transform[7], 255)
                ) / 255;
                context.lineWidth   = this._$thickness;
                context.strokeStyle = `rgba(${rgb.R},${rgb.G},${rgb.B},${alpha})`;
            }

            const yIndex = obj.yIndex | 0;
            switch (obj.mode) {

                case TextField.BREAK:
                case TextField.WRAP:

                    currentV++;

                    if (this.scrollV > currentV) {
                        continue;
                    }

                    offsetHeight += this._$textHeightTable[yIndex];

                    xOffset = this._$getAlignOffset(this._$objectTable[yIndex], width);
                    if (tf._$underline) {

                        const offset = obj.textFormat._$size / 12;

                        const rgb   = Util.$intToRGBA(tf._$color);
                        const alpha = $Math.max(0, $Math.min(
                            rgb.A * 255 * color_transform[3] + color_transform[7], 255)
                        ) / 255;

                        context.lineWidth   = $Math.max(1, 1 / $Math.min(matrix[0], matrix[3]));
                        context.strokeStyle = `rgba(${rgb.R},${rgb.G},${rgb.B},${alpha})`;

                        context.beginPath();
                        context.moveTo(xOffset, yOffset + offsetHeight - offset);
                        context.lineTo(xOffset + this._$widthTable[yIndex], yOffset + offsetHeight - offset);
                        context.stroke();

                    }

                    break;

                case TextField.TEXT:
                    {
                        if (this.scrollV > currentV) {
                            continue;
                        }

                        let offsetY = offsetHeight - this._$heightTable[0];
                        if (!Util.$isSafari) {
                            offsetY += 2 * (obj.textFormat._$size / 12);
                        }

                        context.beginPath();
                        context.textBaseline = "top";
                        context.font = tf._$generateFontStyle();

                        if (this._$thickness) {
                            context.strokeText(obj.text, offsetWidth, yOffset + offsetY);
                        }
                        context.fillText(obj.text, offsetWidth, yOffset + offsetY);

                    }
                    break;

                case TextField.IMAGE:

                    if (!obj.loaded) {
                        continue;
                    }

                    context.beginPath();
                    context.drawImage(obj.image,
                        obj.hspace, yOffset + obj.y,
                        obj.width, obj.height
                    );

                    break;

            }
        }
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object}  options
     * @return {boolean}
     * @method
     * @private
     */
    _$mouseHit (context, matrix, options)
    {
        if (!this._$visible) {
            return false;
        }

        return this._$hit(context, matrix, options);
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object} options
     * @return {boolean}
     * @method
     * @private
     */
    _$hit (context, matrix, options)
    {
        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        const baseBounds = this._$getBounds(null);

        const bounds = Util.$boundsMatrix(baseBounds, multiMatrix);
        const xMax   = +bounds.xMax;
        const xMin   = +bounds.xMin;
        const yMax   = +bounds.yMax;
        const yMin   = +bounds.yMin;
        Util.$poolBoundsObject(bounds);
        Util.$poolBoundsObject(baseBounds);

        const width  = $Math.ceil($Math.abs(xMax - xMin));
        const height = $Math.ceil($Math.abs(yMax - yMin));

        context.setTransform(1, 0, 0, 1, xMin, yMin);
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(width, 0);
        context.lineTo(width, height);
        context.lineTo(0, height);
        context.lineTo(0, 0);

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        return context.isPointInPath(options.x, options.y);
    }

    /**
     * @param  {number} scale
     * @return {void}
     * @method
     * @private
     */
    _$createTextAreaElement (scale)
    {
        // new text area
        if (!this._$textarea) {

            this._$textarea       = Util.$document.createElement("textarea");
            this._$textarea.value = this.text;
            this._$textarea.id    = `${Util.$PREFIX}_TextField_${this._$instanceId}`;

            if (!this._$wordWrap) {
                this._$textarea.wrap = "off";
            }

            const textFormat = this.defaultTextFormat;

            // setup
            this._$textarea.style.position         = "absolute";
            this._$textarea.style.outline          = "0";
            this._$textarea.style.padding          = `2px 2px 2px ${$Math.max(3, textFormat.leftMargin | 0)}px`;
            this._$textarea.style.margin           = "0";
            this._$textarea.style.appearance       = "none";
            this._$textarea.style.resize           = "none";
            this._$textarea.style.border           = this._$border ? `solid 1px #${this.borderColor.toString(16)}` : "none";
            this._$textarea.style.overflow         = "hidden";
            this._$textarea.style.zIndex           = 0x7fffffff;
            this._$textarea.style.verticalAlign    = "top";
            this._$textarea.style.backgroundColor  = this._$border || this._$background
                ? `#${this.backgroundColor.toString(16)}`
                : "transparent";

            // add blur event
            this._$textarea.addEventListener(`${Util.$PREFIX}_blur`, function (event)
            {
                // set new text
                let value = event.target.value ? event.target.value : "";
                if (value && this._$restrict) {

                    let pattern = this._$restrict;

                    if (pattern[0] !== "[") {
                        pattern = "[" + pattern;
                    }

                    if (pattern[pattern.length - 1] !== "]") {
                        pattern += "]";
                    }

                    const found = value.match(new $RegExp(pattern, "gm"));
                    value = found ? found.join("") : "";
                }

                this.text = value;

                const div = Util
                    .$document
                    .getElementById(Util.$currentPlayer().contentElementId);

                if (div) {

                    const element = Util
                        .$document
                        .getElementById(`${Util.$PREFIX}_TextField_${this._$instanceId}`);

                    if (element) {
                        element.remove();
                        this._$focus = false;
                        this._$textAreaActive = false;

                        Util.$isUpdated = true;
                        this._$doChanged();
                    }
                }

            }.bind(this));

            // input event
            this._$textarea.addEventListener("input", function (event)
            {
                // set new text
                let value = event.target.value ? event.target.value : "";

                // SafariではInputEvent.isComposingがundefined
                if (this._$restrict && !this._$isComposing && value) {
                    let pattern = this._$restrict;

                    if (pattern[0] !== "[") {
                        pattern = "[" + pattern;
                    }

                    if (pattern[pattern.length - 1] !== "]") {
                        pattern += "]";
                    }

                    const found = value.match(new $RegExp(pattern, "gm"));
                    value = found ? found.join("") : "";
                }

                if (!this._$isComposing && this.text !== value) {

                    // update
                    this.text = value;
                    event.target.value = value;

                    if (this.willTrigger(Event.CHANGE)) {
                        this.dispatchEvent(new Event(Event.CHANGE, true));
                    }

                    const player = Util.$currentPlayer();

                    // setup
                    const element = this._$textarea;
                    const matrix  = this._$transform.concatenatedMatrix;
                    const bounds  = this._$getBounds(null);

                    element.style.left   = `${$Math.floor((matrix.tx + bounds.xMin + player._$tx / player._$scale / Util.$devicePixelRatio) * player._$scale)}px`;
                    element.style.top    = `${$Math.floor((matrix.ty + bounds.yMin + player._$ty / player._$scale / Util.$devicePixelRatio) * player._$scale)}px`;
                    element.style.width  = `${$Math.ceil((this.width  - 1) * player._$scale)}px`;
                    element.style.height = `${$Math.ceil((this.height - 1) * player._$scale)}px`;
                }

            }.bind(this));

            // IME入力開始時のevent
            this._$textarea.addEventListener("compositionstart", function ()
            {
                this._$isComposing = true;
            }.bind(this));

            // IME入力確定時のevent
            this._$textarea.addEventListener("compositionend", function (event)
            {
                this._$isComposing = false;
                let value = event.target.value ? event.target.value : "";

                if (!this._$restrict || !value) {
                    return;
                }

                let pattern = this._$restrict;

                if (pattern[0] !== "[") {
                    pattern = "[" + pattern;
                }

                if (pattern[pattern.length - 1] !== "]") {
                    pattern += "]";
                }

                const found = value.match(new $RegExp(pattern, "gm"));
                value = found ? found.join("") : "";

                // update
                this.text = value;
                event.target.value = value;
            }.bind(this));

            // add click event
            this._$textarea.addEventListener("click", function ()
            {
                if (this.willTrigger(MouseEvent.CLICK)) {
                    this.dispatchEvent(new MouseEvent(MouseEvent.CLICK));
                }
            }.bind(this));

            // add mousewheel event
            this._$textarea.addEventListener(Util.$MOUSE_WHEEL, function (event)
            {
                this.scrollV += event.deltaY;
            }.bind(this));

            // add scroll event
            this._$textarea.addEventListener(Util.$SCROLL, function ()
            {
                if (this._$scrollEventLock) {
                    this._$scrollEventLock = false;
                    return;
                }

                const height = parseFloat(this._$textarea.style.height);
                this.scrollV = this._$textarea.scrollTop / (this._$textarea.scrollHeight - height) * this.maxScrollV + 1;
            }.bind(this));

            switch (true) {

                case Util.$isTouch:
                    // down event
                    this._$textarea.addEventListener(Util.$TOUCH_START, function ()
                    {
                        const player = Util.$currentPlayer();
                        if (player) {
                            player._$state  = "down";
                        }
                    });

                    // up event
                    this._$textarea.addEventListener(Util.$TOUCH_END, function ()
                    {
                        const player = Util.$currentPlayer();
                        if (player) {
                            player._$state  = "up";
                        }
                    });
                    break;

                default:
                    // down event
                    this._$textarea.addEventListener(Util.$MOUSE_DOWN, function ()
                    {
                        const player = Util.$currentPlayer();
                        if (player) {
                            player._$state  = "down";
                        }
                    });

                    // up event
                    this._$textarea.addEventListener(Util.$MOUSE_UP, function ()
                    {
                        const player = Util.$currentPlayer();
                        if (player) {
                            player._$state  = "up";
                        }
                    });

                    break;

            }

        }

        // change style
        const tf = this.defaultTextFormat;
        const fontSize = $Math.ceil(tf.size * scale * this._$transform.concatenatedMatrix.d);
        this._$textarea.style.fontSize   = `${fontSize}px`;
        this._$textarea.style.fontFamily = tf.font;
        this._$textarea.style.lineHeight = `${(fontSize + $Math.max(0, tf.leading | 0)) / fontSize}em`;

        if (this._$autoSize !== TextFieldAutoSize.NONE) {
            this._$textarea.style.textAlign = TextFieldAutoSize.CENTER;
        } else {
            this._$textarea.style.textAlign = tf.align;
        }

        if (!this._$textarea.onkeydown) {
            this._$textarea.onkeydown = function (event)
            {

                // set new text
                let value = event.target.value ? event.target.value : "";

                // SafariではInputEvent.isComposingがundefined
                if (this._$restrict && !this._$isComposing && value) {
                    let pattern = this._$restrict;

                    if (pattern[0] !== "[") {
                        pattern = "[" + pattern;
                    }

                    if (pattern[pattern.length - 1] !== "]") {
                        pattern += "]";
                    }

                    const found = value.match(new $RegExp(pattern, "gm"));
                    value = found ? found.join("") : "";
                }

                // update
                if (!this._$isComposing) {
                    this.text = value;
                    event.target.value = value;
                }

                // enter off
                if (event.keyCode === 13 && !this._$multiline) {
                    return false;
                }

            }.bind(this);
        }

        //reset
        this._$textarea.maxLength = 0x7fffffff;
        if (this._$maxChars) {
            this._$textarea.maxLength = this._$maxChars;
        }

    }
}

/**
 * TextFieldType クラスは、TextField クラスの type プロパティの設定で使用される定数値の列挙です。
 * The TextFieldType class is an enumeration of constant values used in setting
 * the type property of the TextField class.
 *
 * @class
 * @memberOf next2d.text
 */
class TextFieldType
{

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class TextFieldType]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class TextFieldType]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.text.TextFieldType
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.text.TextFieldType";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object TextFieldType]
     * @method
     * @public
     */
    toString ()
    {
        return "[object TextFieldType]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.text.TextFieldType
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.text.TextFieldType";
    }

    /**
     * @description input TextField を指定するために使用されます。
     *              Used to specify an input TextField.
     *
     * @return  {string}
     * @default input
     * @const
     * @static
     */
    static get INPUT ()
    {
        return "input";
    }

    /**
     * @description 静的な TextField を指定するために使用されます。
     *              Used to specify an static TextField.
     *
     * @return  {string}
     * @default static
     * @const
     * @static
     */
    static get STATIC ()
    {
        return "static";
    }
}

/**
 * TextFormat クラスは、文字フォーマット情報を表します。
 * TextFormat クラスを使用して、テキストフィールドに特定のテキストフォーマットを作成します。
 *
 * The TextFormat class represents character formatting information.
 * Use the TextFormat class to create specific text formatting for text fields.
 *
 * @class
 * @memberOf next2d.text
 */
class TextFormat
{
    /**
     * @param {string}  [font=null]
     * @param {number}  [size=null]
     * @param {number}  [color=null]
     * @param {boolean} [bold=null]
     * @param {boolean} [italic=null]
     * @param {boolean} [underline=null]
     * @param {string}  [align=null]
     * @param {number}  [left_margin=null]
     * @param {number}  [right_margin=null]
     * @param {number}  [indent=null]
     * @param {number}  [leading=null]
     * @param {number}  [block_indent=null]
     *
     * @constructor
     * @public
     */
    constructor(
        font = null, size = null, color = null, bold = null, italic = null,
        underline = null, align = null, left_margin = null, right_margin = null,
        indent = null, leading = null, block_indent = null
    ) {

        /**
         * @type {string}
         * @default null
         * @private
         */
        this._$font = font;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$size = size;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$color = color === null
            ? null
            : Util.$clamp(
                Util.$toColorInt(color), 0, 0xffffff, 0xffffff
            );

        /**
         * @type {boolean}
         * @default null
         * @private
         */
        this._$bold = bold;

        /**
         * @type {boolean}
         * @default null
         * @private
         */
        this._$italic = italic;

        /**
         * @type {boolean}
         * @default null
         * @private
         */
        this._$underline = underline;

        /**
         * @type {string}
         * @default null
         * @private
         */
        this._$align = align;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$leftMargin  = left_margin;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$rightMargin = right_margin;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$indent = indent;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$leading = leading;

        /**
         * @type {number}
         * @default null
         * @private
         */
        this._$blockIndent   = block_indent;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$letterSpacing = 0;

        /**
         * @type {TextField}
         * @default null
         * @private
         */
        this._$textField = null;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class TextFormat]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class TextFormat]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.text.TextFormat
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.text.TextFormat";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object TextFormat]
     * @method
     * @public
     */
    toString ()
    {
        return "[object TextFormat]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.text.TextFormat
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.text.TextFormat";
    }

    /**
     * @description 段落の行揃えの設定を示します。
     *              Indicates the alignment of the paragraph.
     *
     * @member {string}
     * @default null
     * @public
     */
    get align ()
    {
        return this._$align;
    }
    set align (align)
    {
        switch (align) {

            case TextFormatAlign.CENTER:
            case TextFormatAlign.RIGHT:
            case TextFormatAlign.LEFT:
                this._$align = align;
                break;

            default:
                this._$align = null;
                break;

        }

        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description ブロックのインデントをピクセル単位で示します。
     *              Indicates the block indentation in pixels.
     *
     * @member {number}
     * @default null
     * @public
     */
    get blockIndent ()
    {
        return this._$blockIndent;
    }
    set blockIndent (block_indent)
    {
        this._$blockIndent = block_indent;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description テキストをボールドにするかどうかを指定します。
     *              Specifies whether the text is boldface.
     *
     * @member {boolean}
     * @default null
     * @public
     */
    get bold ()
    {
        return this._$bold;
    }
    set bold (bold)
    {
        this._$bold = !!bold;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description テキストの色を示します。
     *              Indicates the color of the text.
     *
     * @member {number}
     * @default null
     * @public
     */
    get color ()
    {
        return this._$color;
    }
    set color (color)
    {
        this._$color = Util.$clamp(
            Util.$toColorInt(color), 0, 0xffffff, 0
        );
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description このテキストフォーマットでのテキストフォント名を示すストリングです。
     *              The name of the font for text in this text format, as a string.
     *
     * @member {string}
     * @default null
     * @public
     */
    get font ()
    {
        return this._$font;
    }
    set font (font)
    {
        this._$font = `${font}`;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description 左インデントから段落の先頭文字までのインデントを示します。
     *              Indicates the indentation from the left margin
     *              to the first character in the paragraph.
     *
     * @member {number}
     * @default null
     * @public
     */
    get indent ()
    {
        return this._$indent;
    }
    set indent (indent)
    {
        this._$indent = indent;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description このテキストフォーマットのテキストをイタリックにするかどうかを示します。
     *              Indicates whether text in this text format is italicized.
     *
     * @member {boolean}
     * @default null
     * @public
     */
    get italic ()
    {
        return this._$italic;
    }
    set italic (italic)
    {
        this._$italic = !!italic;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description 行間の垂直の行送りを示す整数です。
     *              An integer representing the amount
     *              of vertical space (called leading) between lines.
     *
     * @member {number}
     * @default null
     * @public
     */
    get leading ()
    {
        return this._$leading;
    }
    set leading (leading)
    {
        this._$leading = leading;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description 段落の左インデントをピクセル単位で示します。
     *              The left margin of the paragraph, in pixels.
     *
     * @member {number}
     * @default null
     * @public
     */
    get leftMargin ()
    {
        return this._$leftMargin;
    }
    set leftMargin (left_margin)
    {
        this._$leftMargin = left_margin;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description すべての文字の間に均等に配分されるスペースの量を表す数値です。
     *              A object representing the amount
     *              of space that is uniformly distributed between all characters.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get letterSpacing ()
    {
        return this._$letterSpacing;
    }
    set letterSpacing (letter_spacing)
    {
        this._$letterSpacing = letter_spacing;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description 段落の右インデントをピクセル単位で示します。
     *              The right margin of the paragraph, in pixels.
     *
     * @member {number}
     * @default null
     * @public
     */
    get rightMargin ()
    {
        return this._$rightMargin;
    }
    set rightMargin (right_margin)
    {
        this._$rightMargin = right_margin;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description このテキストフォーマットのテキストのサイズ（ピクセル単位）です。
     *              The size in pixels of text in this text format.
     *
     * @member {number}
     * @default null
     * @public
     */
    get size ()
    {
        return this._$size;
    }
    set size (size)
    {
        this._$size = size | 0;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @description このテキストフォーマットを使用するテキストに
     *              アンダーラインを表示する（true）か、表示しない（false）かを示します。
     *              Indicates whether the text that uses this text format
     *              is underlined (true) or not (false).
     *
     * @member {boolean}
     * @default null
     * @public
     */
    get underline ()
    {
        return this._$underline;
    }
    set underline (underline)
    {
        this._$underline = !!underline;
        if (this._$textField) {
            this._$textField._$renew = true;
        }
    }

    /**
     * @return {next2d.text.TextFormat}
     * @private
     */
    _$clone ()
    {
        const textFormat = new TextFormat(
            this._$font, this._$size, this._$color, this._$bold,
            this._$italic, this._$underline, this._$align,
            this._$leftMargin, this._$rightMargin,
            this._$indent, this._$leading, this._$blockIndent
        );

        textFormat._$letterSpacing = this._$letterSpacing;
        textFormat._$textField     = this._$textField;

        return textFormat;
    }

    /**
     * @param  {TextField} text_field
     * @return {void}
     * @private
     */
    _$setDefault (text_field = null)
    {
        this._$align         = TextFormatAlign.LEFT;
        this._$blockIndent   = 0;
        this._$bold          = false;
        this._$color         = 0;
        this._$font          = "Times New Roman";
        this._$indent        = 0;
        this._$italic        = false;
        this._$leading       = 0;
        this._$leftMargin    = 0;
        this._$letterSpacing = 0;
        this._$rightMargin   = 0;
        this._$size          = 12;
        this._$underline     = false;
        this._$textField     = text_field;
    }

    /**
     * @param  {TextFormat} text_format
     * @return {void}
     * @private
     */
    _$merge (text_format)
    {
        if (this._$align === null) {
            this._$align = text_format._$align;
        }

        if (this._$blockIndent === null) {
            this._$blockIndent = text_format._$blockIndent;
        }

        if (this._$bold === null) {
            this._$bold = text_format._$bold;
        }

        if (this._$color === null) {
            this._$color = text_format.color;
        }

        if (this._$font === null) {
            this._$font = text_format._$font;
        }

        if (this._$indent === null) {
            this._$indent = text_format._$indent;
        }

        if (this._$italic === null) {
            this._$italic = text_format._$italic;
        }

        if (this._$leading === null) {
            this._$leading = text_format._$leading;
        }

        if (this._$leftMargin === null) {
            this._$leftMargin = text_format._$leftMargin;
        }

        if (this._$letterSpacing === null) {
            this._$letterSpacing = text_format._$letterSpacing;
        }

        if (this._$rightMargin === null) {
            this._$rightMargin = text_format._$rightMargin;
        }

        if (this._$size === null) {
            this._$size = text_format._$size;
        }

        if (this._$underline === null) {
            this._$underline = text_format._$underline;
        }
    }

    /**
     * @return {number}
     * @method
     * @private
     */
    _$widthMargin ()
    {
        return this._$indent + this._$leftMargin + this._$rightMargin;
    }

    /**
     * @return {string}
     * @method
     * @private
     */
    _$generateFontStyle ()
    {
        let fontStyle = "";
        if (this._$italic) {
            fontStyle = "italic ";
        }
        if (this._$bold) {
            fontStyle += "bold ";
        }

        return `${fontStyle}${this._$size}px '${this._$font}','sans-serif'`;
    }
}

/**
 * TextFormatVerticalAlign クラスは、縦方向の揃え位置を指定するプロパティです。
 * The TextFormatVerticalAlign class is a property that specifies the vertical alignment position.
 *
 * @class
 * @memberOf next2d.text
 */
class TextFormatVerticalAlign
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class TextFormatVerticalAlign]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class TextFormatVerticalAlign]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.text.TextFormatVerticalAlign
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.text.TextFormatVerticalAlign";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object TextFormatVerticalAlign]
     * @method
     * @public
     */
    toString ()
    {
        return "[object TextFormatVerticalAlign]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.text.TextFormatVerticalAlign
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.text.TextFormatVerticalAlign";
    }

    /**
     * @description テキストをテキストフィールド内で上揃えに配置します。
     *              Aligns the text with the top of the text field.
     *
     * @return  {string}
     * @default top
     * @const
     * @static
     */
    static get TOP ()
    {
        return "top";
    }

    /**
     * @description テキストをテキストフィールド内で中央揃えに配置します。
     *              Center the text in the text field.
     *
     * @return  {string}
     * @default middle
     * @const
     * @static
     */
    static get MIDDLE ()
    {
        return "middle";
    }

    /**
     * @description テキストをテキストフィールド内で下揃えに配置します。
     *              Aligns the text to the bottom within the text field.
     *
     * @return  {string}
     * @default bottom
     * @const
     * @static
     */
    static get BOTTOM ()
    {
        return "bottom";
    }
}

/**
 * Sound クラスを使用すると、アプリケーション内のサウンドを処理することができます。
 * Sound クラスを使用すると、Sound オブジェクトの作成や、外部 MP3 ファイルのオブジェクトへのロードと再生ができます。
 *
 * The Sound class lets you work with sound in an application.
 * The Sound class lets you create a Sound object,
 * load and play an external MP3 file into that object.
 *
 * @class
 * @memberOf next2d.media
 * @extends  EventDispatcher
 */
class Sound extends EventDispatcher
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {

        super();

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesLoaded = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesTotal  = 0;

        /**
         * @type {Uint8Array}
         * @default null
         * @private
         */
        this._$buffer = null;

        /**
         * @type {Uint8Array}
         * @default null
         * @private
         */
        this._$audioBuffer = null;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$character = null;

        /**
         * @type {array}
         * @private
         */
        this._$sources = Util.$getArray();

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$volume = 1;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$currentCount = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$loopCount = 0;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$stopFlag = true;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Sound]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Sound]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.media.Sound
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.media.Sound";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Sound]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Sound]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.media.Sound
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.media.Sound";
    }

    /**
     * @description 既にアプリケーションにロードされているデータのバイト数です。
     *              The number of bytes of data that have been loaded into the application.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesLoaded ()
    {
        return this._$bytesLoaded;
    }

    /**
     * @description アプリケーションにロードされるファイルの総バイト数。
     *              The total size in bytes of the file being loaded into the application.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesTotal ()
    {
        return this._$bytesTotal;
    }

    /**
     * @description ループ回数の設定
     *              Loop count setting.
     *
     * @member {number}
     * @default 0
     * @public
     */
    get loopCount ()
    {
        return this._$loopCount;
    }
    set loopCount (loop_count)
    {
        this._$loopCount = loop_count;
    }

    /**
     * @description ボリュームです。範囲は 0（無音）～ 1（フルボリューム）です。
     *              The volume, ranging from 0 (silent) to 1 (full volume).
     *
     * @member {number}
     * @default 1
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }
    set volume (volume)
    {
        this._$volume = $Math.min(
            SoundMixer.volume,
            Util.$clamp(volume, 0, 1, 1)
        );

        const length = this._$sources.length;
        if (length && Util.$audioContext) {
            for (let idx = 0; idx < length; ++idx) {

                const source = this._$sources[idx];

                source._$gainNode.gain.value = this._$volume;
                source._$volume = this._$volume;
            }
        }
    }

    /**
     * @description Sound クラスを複製します。
     *              Duplicate the Sound class.
     *
     * @return {Sound}
     * @method
     * @public
     */
    clone ()
    {
        const sound  = new Sound();
        sound.volume = this.volume;
        sound.loop   = this.loop;

        if (this._$character) {
            sound._$character = this._$character;
        } else {
            sound._$audioBuffer = this._$audioBuffer;
        }

        return sound;
    }

    /**
     * @description 指定した URL から外部 MP3 ファイルのロードを開始します。
     *              Initiates loading of an external MP3 file from the specified URL.
     *
     * @param {URLRequest} request
     * @return {void}
     * @method
     * @public
     */
    load (request)
    {
        Util.$ajax({
            "format": URLLoaderDataFormat.ARRAY_BUFFER,
            "url": request.url,
            "method": request.method,
            "data": request.data,
            "headers": request.headers,
            "credentials": request.withCredentials,
            "event": {
                "loadstart": function (event)
                {
                    this._$bytesLoaded = event.loaded;
                    this._$bytesTotal  = event.total;

                    if (this.willTrigger(Event.OPEN)) {
                        this.dispatchEvent(new Event(Event.OPEN));
                    }
                    if (this.willTrigger(ProgressEvent.PROGRESS)) {
                        this.dispatchEvent(new ProgressEvent(
                            ProgressEvent.PROGRESS, false, false,
                            event.loaded, event.total
                        ));
                    }

                }.bind(this),
                "progress": function (event)
                {
                    this._$bytesLoaded = event.loaded;
                    this._$bytesTotal  = event.total;

                    if (this.willTrigger(ProgressEvent.PROGRESS)) {
                        this.dispatchEvent(new ProgressEvent(
                            ProgressEvent.PROGRESS, false, false,
                            event.loaded, event.total
                        ));
                    }
                }.bind(this),
                "loadend": function (event)
                {
                    this._$bytesLoaded = event.loaded;
                    this._$bytesTotal  = event.total;

                    if (this.willTrigger(ProgressEvent.PROGRESS)) {
                        this.dispatchEvent(new ProgressEvent(
                            ProgressEvent.PROGRESS, false, false,
                            event.loaded, event.total
                        ));
                    }

                    if (199 < event.target.status && 400 > event.target.status) {

                        this._$buffer = new Uint8Array(event.target.response);

                        if (Util.$audioContext) {
                            Util.$decodeAudioData(this);
                        } else {
                            Util.$audios.push(this);
                        }

                        // load complete
                        Util.$currentPlayer()._$loaders.push(this);

                    } else {

                        if (this.willTrigger(IOErrorEvent.IO_ERROR)) {
                            this.dispatchEvent(new IOErrorEvent(
                                IOErrorEvent.IO_ERROR, false, false,
                                event.target.statusText,
                                event.target.status
                            ));
                        }

                    }

                }.bind(this)
            }
        });
    }

    /**
     * @description サウンドを再生します。
     *              Play a sound.
     *
     * @param   {number} [start_time=0]
     * @return  {void}
     * @method
     * @public
     */
    play (start_time = 0)
    {
        const buffer = this._$character
            ? this._$character.audioBuffer
            : this._$audioBuffer;

        // execute
        if (!Util.$audioContext || !buffer) {

            const wait = function (now, start_time = 0)
            {
                const buffer = this._$character
                    ? this._$character.audioBuffer
                    : this._$audioBuffer;

                if (buffer !== null && Util.$audioContext !== null) {
                    const offset = (Util.$performance.now() - now) / 1000;
                    this._$createBufferSource(start_time, offset);
                    return ;
                }

                const timer = Util.$requestAnimationFrame;
                timer(wait);

            }.bind(this, Util.$performance.now(), start_time);

            const timer = Util.$requestAnimationFrame;
            timer(wait);

        } else {

            this._$createBufferSource(start_time);

        }
    }

    /**
     * @description チャンネルで再生しているサウンドを停止します。
     *              Stops the sound playing in the channel.
     *
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        this._$stopFlag = true;
        const length = this._$sources.length;
        if (length) {

            const player = Util.$currentPlayer();
            if (Util.$audioContext) {

                for (let idx = 0; idx < length; ++idx) {

                    const source = this._$sources[idx];

                    if (source._$gainNode) {
                        source._$gainNode.gain.value = 0;
                        source._$gainNode.disconnect();
                        source._$gainNode = null;
                    }

                    source.onended = null;
                    source.disconnect();
                }
            }

            player._$sources.splice(
                player._$sources.indexOf(this), 1
            );

            this._$currentCount   = 0;
            this._$sources.length = 0;
        }
    }

    /**
     * @param  {object} tag
     * @param  {MovieClip} parent
     * @return {void}
     * @method
     * @private
     */
    _$build(tag, parent)
    {
        this._$character = parent
            ._$loaderInfo
            ._$data.characters[tag.characterId];

        if (!this._$character.init) {

            this._$character.init   = true;
            this._$character.buffer = new Uint8Array(this._$character.buffer);

            if (Util.$audioContext) {
                Util.$decodeAudioData(this);
            } else {
                Util.$audios.push(this);
            }
        }

        this._$loopCount = tag.loopCount | 0;
        this._$volume = $Math.min(SoundMixer.volume, tag.volume);
    }

    /**
     * @param  {number}  [start_time=0]
     * @param  {number}  [offset=0]
     * @return {void}
     * @method
     * @private
     */
    _$createBufferSource (start_time = 0, offset = 0)
    {
        // setup
        const source = Util.$audioContext.createBufferSource();
        source._$startTime = start_time;

        source.onended = this._$endEventHandler.bind(this);

        // main
        source.buffer = this._$character
            ? this._$character.audioBuffer
            : this._$audioBuffer;

        source._$gainNode = Util.$audioContext.createGain();
        source._$gainNode.connect(Util.$audioContext.destination);

        const volume = $Math.min(SoundMixer.volume, this._$volume);

        source._$gainNode.gain.value = volume;
        source._$volume = volume;

        source.connect(source._$gainNode);
        source.start(start_time | 0, offset);

        const player = Util.$currentPlayer();
        if (player._$sources.indexOf(this) === -1) {
            player._$sources.push(this);
        }

        this._$sources.push(source);

        this._$stopFlag = false;
    }

    /**
     * @param  {Event} event
     * @return {void}
     * @method
     * @private
     */
    _$endEventHandler (event)
    {
        const source = event.target;

        this._$sources.splice(
            this._$sources.indexOf(source), 1
        );

        if (!this._$stopFlag && this._$loopCount > this._$currentCount) {

            this._$createBufferSource();

            this._$currentCount++;

        } else {

            this._$currentCount = 0;

            if (Util.$audioContext) {

                if (source._$gainNode) {
                    source._$gainNode.gain.value = 0;
                    source._$gainNode.disconnect();
                    source._$gainNode = null;
                }

                // Firefoxにて、disconnectした時にonendedが呼び出されるのを回避
                source.onended = null;
                source.disconnect();
            }

            if (!this._$sources.length) {
                const player = Util.$currentPlayer();
                player._$sources.splice(
                    player._$sources.indexOf(this), 1
                );
            }

            if (this.willTrigger(Event.SOUND_COMPLETE)) {
                this.dispatchEvent(new Event(Event.SOUND_COMPLETE));
            }

        }
    }
}

/**
 * SoundMixer クラスには、静的プロパティやアプリケーションのグローバルサウンドコントロールのメソッドが含まれます。
 * SoundMixer クラスは、アプリケーションの埋め込みおよびストリーミングサウンド、及び、Video クラスの音声を制御します。
 *
 * @class
 * @memberOf next2d.media
 */
class SoundMixer
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class SoundMixer]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class SoundMixer]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.media.SoundMixer
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.media.SoundMixer";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object SoundMixer]
     * @method
     * @public
     */
    toString ()
    {
        return "[object SoundMixer]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.media.SoundMixer
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.media.SoundMixer";
    }

    /**
     * @description ボリュームです。範囲は 0（無音）～ 1（フルボリューム）です。
     *              The volume, ranging from 0 (silent) to 1 (full volume).
     *
     * @member {number}
     * @default 1
     * @static
     */
    static get volume ()
    {
        return Util.$soundMixerVolume;
    }
    static set volume (volume)
    {
        Util.$soundMixerVolume = Util.$clamp(volume, 0, 1, 1);

        const sources = Util.$currentPlayer()._$sources;
        for (let idx = 0; idx < sources.length; ++idx) {
            const source = sources[idx];
            source._$gainNode.gain.value = $Math.min(
                Util.$soundMixerVolume,
                source._$volume
            );
        }

        const videos = Util.$currentPlayer()._$videos;
        for (let idx = 0; idx < videos.length; ++idx) {
            const video  = videos[idx];
            video._$video.volume = $Math.min(video.volume, Util.$soundMixerVolume);
        }

    }

    /**
     * @description 再生中のサウンドをすべて停止します。
     *              Stops all sounds currently playing.
     *
     * @return {void}
     * @method
     * @static
     */
    static stopAll ()
    {
        const player = Util.$currentPlayer();

        // sounds
        const sources = player._$sources;
        while (sources.length) {
            sources[0].stop();
        }

        const videos = player._$videos;
        for (let idx = 0; idx < videos.length; ++idx) {
            videos[idx].pause();
        }
    }
}

/**
 * SoundTransform クラスにはボリュームとループのプロパティが含まれます。
 *
 * The SoundTransform class contains properties for volume and loop.
 *
 * @class
 * @memberOf next2d.media
 */
class SoundTransform
{
    /**
     * @param {number}  [volume=1]
     * @param {boolean} [loop=false]
     *
     * @constructor
     * @public
     */
    constructor (volume = 1, loop = false)
    {
        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$volume = 1;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$loop = false;

        // setup
        this.volume = volume;
        this.loop   = loop;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class SoundTransform]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class SoundTransform]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.media.SoundTransform
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.media.SoundTransform";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object SoundTransform]
     * @method
     * @public
     */
    toString ()
    {
        return "[object SoundTransform]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.media.SoundTransform
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.media.SoundTransform";
    }

    /**
     * @description ループ設定です。
     *              loop setting.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get loop ()
    {
        return this._$loop;
    }
    set loop (loop)
    {
        this._$loop = !!loop;
    }

    /**
     * @description ボリュームです。範囲は 0（無音）～ 1（フルボリューム）です。
     *              The volume, ranging from 0 (silent) to 1 (full volume).
     *
     * @member {number}
     * @default 1
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }
    set volume (volume)
    {
        this._$volume = Util.$clamp(+volume, 0, 1, 0);
    }
}

/**
 * サーバーまたはローカルに保存された録画済みビデオファイルを再生する Video オブジェクトです。
 * ビデオストリームを再生するには、attachNetStream() を使用して、ビデオを Video オブジェクトに関連付けます。
 * 次に、addChild() を使用して、Video オブジェクトを表示リストに追加します。
 *
 * A Video object that plays a recorded video file stored on a server or locally.
 * To play a video stream, use attachNetStream() to attach the video to the Video object.
 * Then, add the Video object to the display list using addChild().
 *
 * @class
 * @memberOf next2d.media
 * @extends  DisplayObject
 */
class Video extends DisplayObject
{
    /**
     * @param {number} [width = 320]
     * @param {number} [height = 240]
     *
     * @constructor
     * @public
     */
    constructor(width = 320, height = 240)
    {
        super();

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$smoothing = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$loop = false;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$autoPlay = true;

        /**
         * @type {object}
         * @private
         */
        this._$bounds = Util.$getBoundsObject(0, width, 0, height);

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesLoaded = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$bytesTotal = 0;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$timerId = -1;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$start = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$update = null;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$sound = null;

        /**
         * @type {HTMLVideoElement}
         * @default null
         * @private
         */
        this._$video = null;

        /**
         * @type {WebGLTexture}
         * @default null
         * @private
         */
        this._$texture = null;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$stop = true;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$wait = false;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$volume = 1;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Video]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Video]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.media.Video
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.media.Video";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Video]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Video]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.media.Video
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.media.Video";
    }

    /**
     * @description 既にアプリケーションにロードされているデータのバイト数です。
     *              The number of bytes of data that have been loaded into the application.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesLoaded ()
    {
        return this._$bytesLoaded;
    }

    /**
     * @description アプリケーションにロードされるファイルの総バイト数。
     *              The total size in bytes of the file being loaded into the application.
     *
     * @member {number}
     * @default 0
     * @readonly
     * @public
     */
    get bytesTotal ()
    {
        return this._$bytesTotal;
    }

    /**
     * @description 現在のキーフレーム
     *              Current keyframe
     *
     *
     * @member {number}
     * @readonly
     * @public
     */
    get currentTime ()
    {
        return this._$video ? this._$video.currentTime : 0;
    }

    /**
     * @description キーフレーム総数
     *              Total number of keyframes
     *
     * @member {number}
     * @readonly
     * @public
     */
    get duration ()
    {
        return this._$video ? this._$video.duration : 0;
    }

    /**
     * @description ビデオをループ生成するかどうかを指定します。
     *              Specifies whether or not to generate a video loop.
     *
     * @member {boolean}
     * @default false
     * @public
     */
    get loop ()
    {
        return this._$loop;
    }
    set loop (loop)
    {
        this._$loop = loop;
    }

    /**
     * @description ビデオを自動再生するかどうかを指定します。
     *              Specifies whether or not to auto-play the video.
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get autoPlay ()
    {
        return this._$autoPlay;
    }
    set autoPlay (auto_play)
    {
        this._$autoPlay = auto_play;
    }

    /**
     * @description ビデオを拡大 / 縮小する際にスムージング（補間）するかどうかを指定します。
     *              Specifies whether the video should be smoothed (interpolated)
     *              when it is scaled.
     *
     * @member {boolean}
     * @default true
     * @public
     */
    get smoothing ()
    {
        return this._$smoothing;
    }
    set smoothing (smoothing)
    {
        this._$smoothing = !!smoothing;
    }

    /**
     * @description 映像コンテンツへの URL を指定します。
     *              Specifies the URL to the video content.
     *
     * @member {string}
     * @default ""
     * @public
     */
    get src ()
    {
        return this._$video ? this._$video.src : "";
    }
    set src (src)
    {
        if (!this._$video) {

            this._$initializeVideo();

        } else {

            this._$video.removeEventListener("canplaythrough", this._$start);
            this._$video.addEventListener("canplaythrough", this._$start);

        }

        this._$video.src = src;
        this._$video.load();
    }

    /**
     * @description ビデオストリームの高さをピクセル単位で指定する整数です。
     *              An integer specifying the height of the video stream, in pixels.
     *
     * @member {number}
     * @default 320
     * @readonly
     * @public
     */
    get videoHeight ()
    {
        return this._$video ? this._$video.videoHeight : this._$bounds.yMax;
    }

    /**
     * @description ビデオストリームの幅をピクセル単位で指定する整数です。
     *              An integer specifying the width of the video stream, in pixels.
     *
     * @member {number}
     * @default 240
     * @readonly
     * @public
     */
    get videoWidth ()
    {
        return this._$video ? this._$video.videoWidth : this._$bounds.xMax;
    }

    /**
     * @description ボリュームです。範囲は 0（無音）～ 1（フルボリューム）です。
     *              The volume, ranging from 0 (silent) to 1 (full volume).
     *
     * @member {number}
     * @default 1
     * @public
     */
    get volume ()
    {
        return this._$volume;
    }
    set volume (volume)
    {
        this._$volume = $Math.min(
            SoundMixer.volume,
            Util.$clamp(volume, 0, 1, 1)
        );

        if (this._$video) {
            this._$video.volume = this._$volume;
        }
    }

    /**
     * @description Video オブジェクトに現在表示されているイメージ（ビデオストリームではない）をクリアします。
     *              Clears the image currently displayed
     *              in the Video object (not the video stream).
     *
     * @return {void}
     * @method
     * @public
     */
    clear ()
    {
        if (this._$texture) {
            Util.$currentPlayer()
                ._$context
                .frameBuffer
                .releaseTexture(this._$texture);
        }

        if (this._$video) {
            this._$video.pause();
        }

        // reset
        this._$start       = null;
        this._$update      = null;
        this._$sound       = null;
        this._$video       = null;
        this._$texture     = null;
        this._$bounds.xMax = 0;
        this._$bounds.yMax = 0;

        this._$doChanged();
    }

    /**
     * @description ビデオストリームの再生を一時停止します。
     *              Pauses playback of a video stream.
     *
     * @return {void}
     * @method
     * @public
     */
    pause ()
    {
        if (this._$video && !this._$stop) {

            this._$stop = true;
            this._$video.pause();

            const cancelTimer = Util.$cancelAnimationFrame;
            cancelTimer(this._$timerId);
            this._$timerId = -1;

            if (this._$texture) {
                Util.$currentPlayer()
                    ._$context
                    .frameBuffer
                    .releaseTexture(this._$texture);

                this._$texture = null;
            }

            this.dispatchEvent(
                new VideoEvent(VideoEvent.PAUSE), false, false,
                this._$bytesLoaded, this._$bytesTotal
            );

            const player = Util.$currentPlayer();
            player._$videos.splice(
                player._$videos.indexOf(this), 1
            );
        }
    }

    /**
     * @description ローカルディレクトリまたは Web サーバーからメディアファイルを再生します。
     *              Plays a media file from a local directory or a web server;
     *
     * @returns {void}
     * @method
     * @public
     */
    play ()
    {
        if (this._$video && this._$stop) {

            this._$stop = false;

            this._$video.volume = $Math.min(this._$volume, SoundMixer.volume);
            this._$video.play();

            const timer = Util.$requestAnimationFrame;
            this._$timerId = timer(this._$update);

            this.dispatchEvent(
                new VideoEvent(VideoEvent.PLAY), false, false,
                this._$bytesLoaded, this._$bytesTotal
            );

            const player = Util.$currentPlayer();
            if (player._$videos.indexOf(this) === -1) {
                player._$videos.push(this);
            }
        }
    }

    /**
     * @description 指定された位置に最も近いキーフレームをシークします。
     *              Seeks the keyframe closest to the specified location.
     *
     * @param  {number} offset
     * @return {void}
     * @method
     * @public
     */
    seek (offset)
    {
        if (this._$video) {
            this._$video.currentTime = offset;

            this.dispatchEvent(
                new VideoEvent(VideoEvent.SEEK), false, false,
                this._$bytesLoaded, this._$bytesTotal
            );
        }
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$initializeVideo ()
    {
        this._$video = Util.$document.createElement("video");

        this._$update = function ()
        {
            const player = Util.$currentPlayer();
            if (!this._$stage) {

                this._$video.pause();

                const cancelTimer = Util.$cancelAnimationFrame;
                cancelTimer(this._$timerId);
                this._$timerId = -1;

                if (this._$texture) {
                    player._$context
                        .frameBuffer
                        .releaseTexture(this._$texture);

                    this._$texture = null;
                }

                player._$videos.splice(
                    player._$videos.indexOf(this), 1
                );

                return ;
            }

            // update
            player._$draw(0);
            this._$bytesLoaded = this._$video.currentTime;

            if (this._$video.currentTime) {

                this._$texture = player._$context
                    .frameBuffer
                    .createTextureFromVideo(
                        this._$video, this._$smoothing, this._$texture
                    );

                this.dispatchEvent(
                    new VideoEvent(VideoEvent.PROGRESS), false, false,
                    this._$bytesLoaded, this._$bytesTotal
                );

                this._$doChanged();
            }

            const timer = Util.$requestAnimationFrame;
            this._$timerId = timer(this._$update);

        }.bind(this);

        this._$sound = function ()
        {
            const name = Util.$isTouch ? Util.$TOUCH_END : Util.$MOUSE_UP;
            Util.$currentPlayer()
                ._$canvas
                .removeEventListener(name, this._$sound);

            this._$video.muted = false;

        }.bind(this);

        this._$video.muted       = true;
        this._$video.autoplay    = false;
        this._$video.crossOrigin = "anonymous";
        this._$video.type        = "video/mp4";

        if (Util.$isTouch) {
            this._$video.setAttribute("playsinline", "");
        }

        this._$start = function ()
        {
            this._$bounds.xMax = this._$video.videoWidth;
            this._$bounds.yMax = this._$video.videoHeight;
            this._$bytesTotal  = this._$video.duration;

            if (!Util.$audioContext) {

                const name = Util.$isTouch ? Util.$TOUCH_END : Util.$MOUSE_UP;
                Util
                    .$currentPlayer()
                    ._$canvas
                    .addEventListener(name, this._$sound);

            } else {

                this._$video.muted = false;

            }

            if (this._$autoPlay) {

                const player = Util.$currentPlayer();
                if (player._$videos.indexOf(this) === -1) {
                    player._$videos.push(this);
                }

                this._$wait = true;
                this._$doChanged();
            }

        }.bind(this);
        this._$video.addEventListener("canplaythrough", this._$start);

        this._$video.addEventListener("ended", function ()
        {
            if (this._$loop) {
                this._$video.currentTime = 0;
                return ;
            }

            this.dispatchEvent(
                new VideoEvent(VideoEvent.PLAY_END), false, false,
                this._$bytesLoaded, this._$bytesTotal
            );

            const cancelTimer = Util.$cancelAnimationFrame;
            cancelTimer(this._$timerId);

            this._$timerId = -1;

        }.bind(this));
    }

    /**
     * @param  {object} character
     * @return {void}
     * @method
     * @private
     */
    _$buildCharacter (character)
    {
        this._$loop     = character.loop;
        this._$autoPlay = character.autoPlay;
        this._$bounds   = character.bounds;

        if (!this._$video) {
            this._$initializeVideo();
        }

        this._$video.src = URL.createObjectURL(new Blob(
            [new Uint8Array(character.buffer)],
            { "type": "video/mp4" }
        ));

        // setup
        this._$video.volume = $Math.min(character.volume, SoundMixer.volume);
        this._$video.load();
    }

    /**
     * @return {object}
     * @method
     * @private
     */
    _$sync ()
    {
        const character = super._$sync();

        if (character) {
            this._$buildCharacter(character);
        }

        return character;
    }

    /**
     * @param  {object} tag
     * @param  {DisplayObjectContainer} parent
     * @return {object}
     * @method
     * @private
     */
    _$build (tag, parent)
    {
        const character = super._$build(tag, parent);

        this._$buildCharacter(character);

        return character;
    }

    /**
     * @param   {CanvasToWebGLContext} context
     * @param   {Float32Array} matrix
     * @returns {void}
     * @method
     * @private
     */
    _$clip (context, matrix)
    {
        let width  = this._$bounds.xMax;
        let height = this._$bounds.yMax;
        if (!width || !height) {
            return;
        }

        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        Util.$resetContext(context);
        context.setTransform(
            multiMatrix[0], multiMatrix[1], multiMatrix[2],
            multiMatrix[3], multiMatrix[4], multiMatrix[5]
        );
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(width, 0);
        context.lineTo(width, height);
        context.lineTo(0, height);
        context.lineTo(0, 0);
        context.clip(true);

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }
    }

    /**
     * @param  {CanvasToWebGLContext} context
     * @param  {Float32Array} matrix
     * @param  {Float32Array} color_transform
     * @return void
     * @method
     * @private
     */
    _$draw (context, matrix, color_transform)
    {
        if (!this._$visible) {
            return ;
        }

        if (this._$wait) {

            this._$stop = false;
            this._$video.play();

            this.dispatchEvent(
                new VideoEvent(VideoEvent.PLAY_START), false, false,
                this._$bytesLoaded, this._$bytesTotal
            );

            const timer = Util.$requestAnimationFrame;
            this._$timerId = timer(this._$update);

            this._$wait = false;
        }

        if (!this._$texture) {
            return ;
        }

        let multiColor = color_transform;
        const rawColor = this._$transform._$rawColorTransform();
        if (rawColor !== Util.$COLOR_ARRAY_IDENTITY) {
            multiColor = Util.$multiplicationColor(color_transform, rawColor);
        }

        const alpha = Util.$clamp(multiColor[3] + multiColor[7] / 255, 0, 1, 0);
        if (!alpha) {
            if (multiColor !== color_transform) {
                Util.$poolFloat32Array8(multiColor);
            }
            return ;
        }

        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        // default bounds
        const bounds = Util.$boundsMatrix(this._$bounds, multiMatrix);
        const xMax   = +bounds.xMax;
        const xMin   = +bounds.xMin;
        const yMax   = +bounds.yMax;
        const yMin   = +bounds.yMin;
        Util.$poolBoundsObject(bounds);

        let width  = $Math.ceil($Math.abs(xMax - xMin));
        let height = $Math.ceil($Math.abs(yMax - yMin));
        switch (true) {

            case width === 0:
            case height === 0:
            case width === -Util.$Infinity:
            case height === -Util.$Infinity:
            case width === Util.$Infinity:
            case height === Util.$Infinity:
                return;

            default:
                break;

        }

        // cache current buffer
        const currentAttachment = context.frameBuffer.currentAttachment;
        if (xMin > currentAttachment.width || yMin > currentAttachment.height) {
            return;
        }

        let xScale = +$Math.sqrt(
            multiMatrix[0] * multiMatrix[0]
            + multiMatrix[1] * multiMatrix[1]
        );

        let yScale = +$Math.sqrt(
            multiMatrix[2] * multiMatrix[2]
            + multiMatrix[3] * multiMatrix[3]
        );

        const filters = this._$filters   || this.filters;
        if (0 > xMin + width || 0 > yMin + height) {

            if (filters && filters.length && this._$canApply(filters)) {

                let rect = new Rectangle(0, 0, width, height);
                for (let idx = 0; idx < filters.length ; ++idx) {
                    rect = filters[idx]._$generateFilterRect(rect, xScale, yScale);
                }

                if (0 > rect.x + rect.width || 0 > rect.y + rect.height) {
                    return;
                }

            } else {
                return;
            }

        }

        let texture = this._$texture;
        const blendMode = this._$blendMode || this.blendMode;
        if (filters && filters.length && this._$canApply(filters)) {

            let targetTexture = this._$texture;
            if (xScale !== 1 || yScale !== 1) {

                const currentAttachment = context
                    .frameBuffer
                    .currentAttachment;

                const attachment = context
                    .frameBuffer
                    .createCacheAttachment(
                        targetTexture.width  * xScale,
                        targetTexture.height * yScale
                    );

                context._$bind(attachment);

                // reset
                Util.$resetContext(context);
                context.setTransform(xScale, 0, 0, yScale, 0, 0);
                context.drawImage(this._$texture,
                    0, 0, this._$texture.width, this._$texture.height
                );

                // execute
                targetTexture = context
                    .frameBuffer
                    .getTextureFromCurrentAttachment();

                context._$bind(currentAttachment);
                context
                    .frameBuffer
                    .releaseAttachment(attachment, false);

            }

            // draw filter
            texture = this._$drawFilter(
                context, targetTexture, multiMatrix,
                filters, width, height
            );

            // reset
            Util.$resetContext(context);

            // draw
            context._$globalAlpha = alpha;
            context._$imageSmoothingEnabled = this._$smoothing;
            context._$globalCompositeOperation = blendMode;

            // size
            const bounds = Util.$boundsMatrix(this._$bounds, multiMatrix);
            context.setTransform(1, 0, 0, 1,
                bounds.xMin - texture._$offsetX,
                bounds.yMin - texture._$offsetY
            );
            context.drawImage(texture,
                0, 0, texture.width, texture.height,
                multiColor
            );

            // pool
            Util.$poolBoundsObject(bounds);

        } else {

            // reset
            Util.$resetContext(context);

            // draw
            context._$globalAlpha = alpha;
            context._$imageSmoothingEnabled = this._$smoothing;
            context._$globalCompositeOperation = blendMode;

            context.setTransform(
                multiMatrix[0], multiMatrix[1], multiMatrix[2],
                multiMatrix[3], multiMatrix[4], multiMatrix[5]
            );

            context.drawImage(
                texture, 0, 0,
                texture.width, texture.height, multiColor
            );
        }

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        if (multiColor !== color_transform) {
            Util.$poolFloat32Array8(multiColor);
        }
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {Float32Array} matrix
     * @param  {object} options
     * @return {boolean}
     * @method
     * @private
     */
    _$mouseHit (context, matrix, options)
    {
        if (!this._$visible) {
            return false;
        }

        return this._$hit(context, matrix, options);
    }

    /**
     * @param  {CanvasRenderingContext2D} context
     * @param  {array}   matrix
     * @param  {object}  options
     * @return {boolean}
     * @method
     * @private
     */
    _$hit (context, matrix, options)
    {
        let multiMatrix = matrix;
        const rawMatrix = this._$transform._$rawMatrix();
        if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
            multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
        }

        const baseBounds = this._$getBounds(null);

        const bounds = Util.$boundsMatrix(baseBounds, multiMatrix);
        const xMax   = +bounds.xMax;
        const xMin   = +bounds.xMin;
        const yMax   = +bounds.yMax;
        const yMin   = +bounds.yMin;
        Util.$poolBoundsObject(bounds);
        Util.$poolBoundsObject(baseBounds);

        const width  = $Math.ceil($Math.abs(xMax - xMin));
        const height = $Math.ceil($Math.abs(yMax - yMin));

        context.setTransform(1, 0, 0, 1, xMin, yMin);
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(width, 0);
        context.lineTo(width, height);
        context.lineTo(0, height);
        context.lineTo(0, 0);

        if (multiMatrix !== matrix) {
            Util.$poolFloat32Array6(multiMatrix);
        }

        return context.isPointInPath(options.x, options.y);
    }

    /**
     * @param  {Float32Array} [matrix=null]
     * @return {object}
     * @method
     * @private
     */
    _$getBounds (matrix = null)
    {
        if (matrix) {

            let multiMatrix = matrix;
            const rawMatrix = this._$transform._$rawMatrix();
            if (rawMatrix !== Util.$MATRIX_ARRAY_IDENTITY) {
                multiMatrix = Util.$multiplicationMatrix(matrix, rawMatrix);
            }

            const bounds = Util.$boundsMatrix(this._$bounds, multiMatrix);

            if (multiMatrix !== matrix) {
                Util.$poolFloat32Array6(multiMatrix);
            }

            return bounds;
        }

        return Util.$getBoundsObject(
            this._$bounds.xMin, this._$bounds.xMax,
            this._$bounds.yMin, this._$bounds.yMax
        );
    }
}

/**
 * URLLoaderDataFormat クラスは、ダウンロードされるデータの受信方法を指定する値を提供します。
 *
 * The URLLoaderDataFormat class provides values that specify how downloaded data is received.
 *
 * @class
 * @memberOf next2d.net
 */
class URLLoaderDataFormat
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class URLLoaderDataFormat]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class URLLoaderDataFormat]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.net.URLLoaderDataFormat
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.net.URLLoaderDataFormat";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object URLLoaderDataFormat]
     * @method
     * @public
     */
    toString ()
    {
        return "[object URLLoaderDataFormat]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.net.URLLoaderDataFormat
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.net.URLLoaderDataFormat";
    }

    /**
     * @description ダウンロードされるデータを生のバイナリデータとして受信することを指定します。
     *              Specifies that downloaded data is received as raw binary data.
     *
     * @return  {string}
     * @default arraybuffer
     * @const
     * @static
     */
    static get ARRAY_BUFFER ()
    {
        return "arraybuffer";
    }

    /**
     * @description ダウンロードされるデータをJSONとして受信することを指定します。
     *              Specifies that downloaded data is received as string.
     *
     * @return  {string}
     * @default json
     * @const
     * @static
     */
    static get JSON ()
    {
        return "json";
    }
}

/**
 * URLRequest クラスは、すべての情報を 1 つの HTTP 要求にキャプチャします
 *
 * The URLRequest class captures all of the information in a single HTTP request.
 *
 * @class
 * @memberOf next2d.net
 */
class URLRequest
{
    /**
     * @param {string} [url=""]
     *
     * @constructor
     * @public
     */
    constructor (url = "")
    {
        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$url = url;

        /**
         * @type {string}
         * @default application/json
         * @private
         */
        this._$contentType = "application/json";

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$data = null;

        /**
         * @type {string}
         * @default URLRequestMethod.GET
         * @private
         */
        this._$method = URLRequestMethod.GET;

        /**
         * @type {array}
         * @private
         */
        this._$requestHeaders  = Util.$getArray();

        /**
         * @type {string}
         * @default navigator.userAgent
         * @private
         */
        this._$userAgent = Util.$navigator.userAgent;

        /**
         * @type {string}
         * @default URLLoaderDataFormat.JSON
         * @private
         */
        this._$responseDataFormat = URLLoaderDataFormat.JSON;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$withCredentials = false;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class URLRequest]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class URLRequest]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.net.URLRequest
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.net.URLRequest";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object URLRequest]
     * @method
     * @public
     */
    toString ()
    {
        return "[object URLRequest]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.net.URLRequest
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.net.URLRequest";
    }

    /**
     * @description data プロパティのコンテンツの MIME コンテンツタイプです。
     *              The MIME content type of the content in the the data property.
     *
     * @member {string}
     * @default application/json
     * @public
     */
    get contentType ()
    {
        return this._$contentType;
    }
    set contentType (content_type)
    {
        this._$contentType = `${content_type}`;
    }

    /**
     * @description URL リクエストで送信されるデータを含むオブジェクトです。
     *              An object containing data to be transmitted with the URL request.
     *
     * @member {string|object}
     * @public
     */
    get data ()
    {
        return this._$data;
    }
    set data (data)
    {
        this._$data = data;
    }

    /**
     * @description HTTP フォーム送信メソッドを制御します。
     *              Controls the HTTP form submission method.
     *
     * @member  {string}
     * @default URLRequestMethod.GET
     * @public
     */
    get method ()
    {
        return this._$method;
    }
    set method (method)
    {
        method += "";
        switch (method.toUpperCase()) {

            case URLRequestMethod.DELETE:
            case URLRequestMethod.HEAD:
            case URLRequestMethod.OPTIONS:
            case URLRequestMethod.POST:
            case URLRequestMethod.PUT:
                this._$method = method;
                break;

            default:
                this._$method = URLRequestMethod.GET;
                break;
        }
    }

    /**
     * @description HTTP リクエストヘッダーの配列が HTTP リクエストに追加されます。
     *              The array of HTTP request headers to be appended to the HTTP request.
     *
     * @member {URLRequestHeader[]}
     * @public
     */
    get requestHeaders ()
    {
        return this._$requestHeaders;
    }
    set requestHeaders (request_headers)
    {
        if (Util.$isArray(request_headers)) {
            this._$requestHeaders = request_headers;
        }
    }

    /**
     * @description リクエストされる URL です。
     *              The URL to be requested.
     *
     * @member {string}
     * @public
     */
    get url ()
    {
        if (this._$url && this._$url.indexOf("//") === -1) {

            const urls = this._$url.split("/");
            if (urls[0] === "" || urls[0] === ".") {
                urls.shift();
            }

            const player = Util.$currentPlayer();
            if (player) {
                return `${player.base}${urls.join("/")}`;
            }
        }

        return this._$url;
    }
    set url (url)
    {
        this._$url = `${url}`;
    }

    /**
     * @description HTTP 要求で使用されるユーザーエージェントストリングを指定します。
     *              Specifies the user-agent string to be used in the HTTP request.
     *
     * @member {string}
     * @readonly
     * @public
     */
    get userAgent ()
    {
        return this._$userAgent;
    }

    /**
     * @description レスポンスのデータフォーマットを指定します。
     *              Specifies the data format of the response.
     *
     * @member {string}
     * @default URLLoaderDataFormat.JSON
     * @public
     */
    get responseDataFormat ()
    {
        return this._$responseDataFormat;
    }
    set responseDataFormat (format)
    {
        this._$responseDataFormat = `${format}`;
    }

    /**
     * @description HTTP 要求で使用されるユーザーエージェントストリングを指定します。
     *              Specifies the user-agent string to be used in the HTTP request.
     *
     * @member {boolean}
     * @default false
     * @readonly
     * @public
     */
    get withCredentials ()
    {
        return this._$withCredentials;
    }

    /**
     * @description リクエストされる Header Object
     *              Header Object to be requested.
     *
     * @member {Map}
     * @readonly
     * @public
     */
    get headers ()
    {
        const headers = Util.$getMap();
        headers.set("Content-Type", `${this._$contentType}`);

        const length = this._$requestHeaders.length;
        for (let idx = 0; idx < length; ++idx) {

            const urlRequestHeader = this._$requestHeaders[idx];

            if (urlRequestHeader instanceof URLRequestHeader) {
                headers.set(urlRequestHeader.name, urlRequestHeader.value);
            }
        }

        return headers;
    }
}

/**
 * URLRequestHeader オブジェクトは 1 つの HTTP のリクエストヘッダーをカプセル化し、名前と値のペアを構成します。
 * URLRequestHeader オブジェクトは URLRequest クラスの requestHeaders プロパティで使用されます。
 *
 * A URLRequestHeader object encapsulates a single HTTP request header and consists of a name/value pair.
 * URLRequestHeader objects are used in the requestHeaders property of the URLRequest class.
 *
 * @class
 * @memberOf next2d.net
 */
class URLRequestHeader
{
    /**
     * @param {string} [name=""]
     * @param {string} [value=""]
     *
     * @constructor
     * @public
     */
    constructor (name = "", value = "")
    {
        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$name = `${name}`;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$value = `${value}`;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class URLRequestHeader]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class URLRequestHeader]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.net.URLRequestHeader
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.net.URLRequestHeader";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object URLRequestHeader]
     * @method
     * @public
     */
    toString ()
    {
        return "[object URLRequestHeader]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.net.URLRequestHeader
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.net.URLRequestHeader";
    }

    /**
     * @description HTTP リクエストヘッダー名（Content-Type や SOAPAction など）です。
     *              An HTTP request header name (such as Content-Type or SOAPAction).
     *
     * @member {string}
     * @default ""
     * @readonly
     * @public
     */
    get name ()
    {
        return this._$name;
    }

    /**
     * @description name プロパティに関連付けられた値（text/plain など）です。
     *              The value associated with the name property (such as text/plain).
     *
     * @member {string}
     * @default ""
     * @readonly
     * @public
     */
    get value ()
    {
        return this._$value;
    }
}

/**
 * URLRequestMethod クラスは、URLRequest オブジェクトがデータをサーバーに送信するときに
 * POST または GET のどちらのメソッドを使用するかを指定する値を提供します。
 *
 * The URLRequestMethod class provides values that specify whether the URLRequest object should use the
 * POST method or the GET method when sending data to a server.
 *
 * @class
 * @memberOf next2d.net
 */
class URLRequestMethod
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class URLRequestMethod]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class URLRequestMethod]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.net.URLRequestMethod
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.net.URLRequestMethod";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object URLRequestMethod]
     * @method
     * @public
     */
    toString ()
    {
        return "[object URLRequestMethod]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.net.URLRequestMethod
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.net.URLRequestMethod";
    }

    /**
     * @description URLRequest オブジェクトが DELETE であることを指定します。
     *              Specifies that the URLRequest object is a DELETE.
     *
     * @return  {string}
     * @default DELETE
     * @const
     * @static
     */
    static get DELETE ()
    {
        return "DELETE";
    }

    /**
     * @description URLRequest オブジェクトが GET であることを指定します。
     *              Specifies that the URLRequest object is a GET.
     *
     * @return  {string}
     * @default GET
     * @const
     * @static
     */
    static get GET ()
    {
        return "GET";
    }

    /**
     * @description URLRequest オブジェクトが HEAD であることを指定します。
     *              Specifies that the URLRequest object is a HEAD.
     *
     * @return  {string}
     * @default HEAD
     * @const
     * @static
     */
    static get HEAD ()
    {
        return "HEAD";
    }

    /**
     * @description URLRequest オブジェクトが OPTIONS であることを指定します。
     *              Specifies that the URLRequest object is OPTIONS.
     *
     * @return  {string}
     * @default OPTIONS
     * @const
     * @static
     */
    static get OPTIONS ()
    {
        return "OPTIONS";
    }

    /**
     * @description URLRequest オブジェクトが POST であることを指定します。
     *              Specifies that the URLRequest object is a POST.
     *
     * @return  {string}
     * @default POST
     * @const
     * @static
     */
    static get POST ()
    {
        return "POST";
    }

    /**
     * @description URLRequest オブジェクトが PUT であることを指定します。
     *              Specifies that the URLRequest object is a PUT.
     *
     * @return  {string}
     * @default PUT
     * @const
     * @static
     */
    static get PUT ()
    {
        return "PUT";
    }
}

/**
 * Easeクラスは、イージング機能の関数を提供します。
 * The Ease class provides a collection of easing functions
 *
 * @class
 * @memberOf next2d.ui
 */
class Easing
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Easing]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Easing]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.ui.Easing
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.ui.Easing";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Easing]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Easing]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.ui.Easing
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.ui.Easing";
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static linear (t, b, c, d)
    {
        return t / d * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inQuad (t, b, c, d)
    {
        return (t /= d) * t * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outQuad (t, b, c, d)
    {
        return -(t /= d) * (t - 2) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutQuad (t, b, c, d)
    {
        return (t /= d / 2) < 1
            ? t * t * c / 2 + b
            : -((t -= 1) * (t - 2) - 1) * c / 2 + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inCubic (t, b, c, d)
    {
        return (t /= d) * t * t * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outCubic (t, b, c, d)
    {
        t /= d;
        return (--t * t * t + 1) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutCubic (t, b, c, d)
    {
        return (t /= d / 2) < 1
            ? t * t * t * c / 2 + b
            : ((t -= 2) * t * t + 2) * c / 2 + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inQuart (t, b, c, d)
    {
        return (t /= d) * t * t * t * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outQuart (t, b, c, d)
    {
        t /= d;
        return (--t * t * t * t - 1) * -c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutQuart (t, b, c, d)
    {
        return (t /= d / 2) < 1
            ? t * t * t * t * c / 2 + b
            : ((t -= 2) * t * t * t - 2) * -c / 2 + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inQuint (t, b, c, d)
    {
        return (t /= d) * t * t * t * t * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outQuint (t, b, c, d)
    {
        t /= d;
        return (--t * t * t * t * t + 1) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutQuint (t, b, c, d)
    {
        return (t /= d / 2) < 1
            ? t * t * t * t * t * c / 2 + b
            : ((t -= 2) * t * t * t * t + 2) * c / 2 + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inSine (t, b, c, d)
    {
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outSine (t, b, c, d)
    {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutSine (t, b, c, d)
    {
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inExpo (t, b, c, d)
    {
        return c * Math.pow(2, 10 * (t / d - 1) ) + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outExpo (t, b, c, d)
    {
        return c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutExpo (t, b, c, d)
    {
        return (t /= d / 2) < 1
            ? c / 2 * Math.pow(2, 10 * (t - 1)) + b
            : c / 2 * (-Math.pow(2, -10 * (t - 1)) + 2) + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inCirc (t, b, c, d)
    {
        return (1 - Math.sqrt(1 - (t /= d) * t)) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outCirc (t, b, c, d)
    {
        t /= d;
        return Math.sqrt(1 - --t * t) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutCirc (t, b, c, d)
    {
        return (t /= d * 2) < 1
            ? (Math.sqrt(1 - t * t) - 1) / -2 * c + b
            : (Math.sqrt(1 - (t -= 2) * t) + 1) / 2 * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inBack (t, b, c, d)
    {
        return (2.70158 * (t /= d) * t * t - 1.70158 * t * t) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outBack (t, b, c, d)
    {
        return (1 + 2.70158 * Math.pow((t /= d) - 1, 3) + 1.70158 * Math.pow(t - 1, 2)) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutBack (t, b, c, d)
    {
        let s = 1.70158;
        if ((t /= d / 2) < 1) {
            return t * t * (((s *= 1.525) + 1) * t - s) * c / 2 + b;
        }
        return ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) * c / 2 + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inElastic (t, b, c, d)
    {
        return (t /= d) === 0
            ? b
            : t === 1
                ? c + b
                : -Math.pow(2, (t *= 10) - 10) * Math.sin((t - 10.75) * (2 * Math.PI / 3)) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outElastic (t, b, c, d)
    {
        return (t /= d) === 0
            ? b
            : t === 1
                ? c + b
                : (Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI / 3)) + 1) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutElastic (t, b, c, d)
    {
        return (t /= d) === 0
            ? b
            : t === 1
                ? c + b
                : t < 0.5
                    ? -(Math.pow(2, 20  * t - 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI / 4.5))) / 2    * c + b
                    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI / 4.5)) / 2 + 1) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static outBounce (t, b, c, d)
    {
        if ((t /= d) < 1 / 2.75) {
            return 7.5625 * t * t * c + b;
        }
        if (t < 2 / 2.75) {
            return (7.5625 * (t -= 1.5 / 2.75)   * t + 0.75) * c + b;
        }
        if (t < 2.5 / 2.75) {
            return (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) * c + b;
        }
        return (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) * c + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inBounce (t, b, c, d)
    {
        return c - Easing.outBounce(d - t, 0, c, d) + b;
    }

    /**
     * @param  {number} t
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @return {number}
     * @method
     * @static
     */
    static inOutBounce (t, b, c, d)
    {
        return t < d / 2
            ? Easing.inBounce(t * 2, b, c / 2, d)
            : Easing.outBounce(t * 2 - d, b + c / 2, c / 2, d);
    }
}

/**
 * @class
 * @memberOf next2d.ui
 * @extends  EventDispatcher
 */
class Job extends EventDispatcher
{
    /**
     * @param {object}   target
     * @param {object}   [from=null]
     * @param {object}   [to=null]
     * @param {number}   [delay=0]
     * @param {number}   [duration=1]
     * @param {function} [ease=null]
     *
     * @constructor
     * @public
     */
    constructor (target, from = null, to = null, delay = 0, duration = 1, ease = null)
    {
        super();

        /**
         * @type {object}
         * @private
         */
        this._$target = target;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$delay = delay;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$duration = duration;

        /**
         * @type {function}
         * @default Easing.linear
         * @private
         */
        this._$ease = ease || Easing.linear;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$from = from;

        /**
         * @type {array}
         * @default null
         * @private
         */
        this._$names = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$startTime = 0;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$stopFlag = false;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$forceStop = false;

        /**
         * @type {object}
         * @default null
         * @private
         */
        this._$to = to;

        /**
         * @type {function}
         * @default null
         * @private
         */
        this._$update = null;
    }

    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Job]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Job]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.ui.Job
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.ui.Job";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Job]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Job]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.ui.Job
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.ui.Job";
    }

    /**
     * @member {function}
     * @default Easing.linear
     * @public
     */
    get ease ()
    {
        return this._$ease;
    }
    set ease (ease)
    {
        if (typeof ease === "function") {
            this._$ease = ease;
        }
    }

    /**
     * @member {number}
     * @default 0
     * @public
     */
    get delay ()
    {
        return this._$delay;
    }
    set delay (delay)
    {
        this._$delay = delay;
    }

    /**
     * @member {number}
     * @default 1
     * @public
     */
    get duration ()
    {
        return this._$duration;
    }
    set duration (duration)
    {
        this._$duration = duration;
    }

    /**
     * @member {object}
     * @default null
     * @public
     */
    get from ()
    {
        return this._$from;
    }
    set from (from)
    {
        this._$from = from;
    }

    /**
     * @member {object}
     * @default null
     * @public
     */
    get to ()
    {
        return this._$to;
    }
    set to (to)
    {
        this._$to = to;
    }

    /**
     * @member {object}
     * @readonly
     * @public
     */
    get target ()
    {
        return this._$target;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    initialize ()
    {
        if (this._$forceStop) {
            return ;
        }
        // setup
        this._$stopFlag  = false;
        this._$startTime = Util.$performance.now();
        this._$update    = this.update.bind(this);

        this._$names = this.entries(this._$from);

        // add event
        this.addEventListener(Event.ENTER_FRAME, this._$update);
    }

    /**
     * @param  {object} object
     * @return {array}
     * @method
     * @public
     */
    entries (object)
    {
        const entries = Object.entries(object);

        for (let idx = 0; idx < entries.length; ++idx) {

            const values = entries[idx];

            const value = values[1];
            if (value && typeof value === "object") {
                values[1] = this.entries(value);
            }
        }

        return entries;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    start ()
    {
        if (this._$delay) {

            const timer = Util.$setTimeout;
            timer(function ()
            {
                this.initialize();
            }.bind(this), this._$delay * 1000);

            return ;
        }

        this.initialize();
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        this._$forceStop = true;
        this._$stopFlag  = true;

        this.removeEventListener(Event.ENTER_FRAME, this._$update);

        if (this.hasEventListener(Event.STOP)) {
            this.dispatchEvent(new Event(Event.STOP));
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    update ()
    {
        if (this._$stopFlag) {
            this.removeEventListener(Event.ENTER_FRAME, this._$update);
            return ;
        }

        this._$currentTime = (Util.$performance.now() - this._$startTime) * 0.001;

        this.updateProperty(
            this._$target, this._$from, this._$to, this._$names
        );

        if (this.hasEventListener(Event.UPDATE)) {
            this.dispatchEvent(new Event(Event.UPDATE));
        }

        if (this._$currentTime >= this._$duration) {

            this.removeEventListener(Event.ENTER_FRAME, this._$update);

            if (this.hasEventListener(Event.COMPLETE)) {
                this.dispatchEvent(new Event(Event.COMPLETE));
            }
        }
    }

    /**
     * @param  {object} target
     * @param  {object} from
     * @param  {object} to
     * @param  {array}  names
     * @return {void}
     * @method
     * @public
     */
    updateProperty (target, from, to, names)
    {
        for (let idx = 0; idx < names.length; ++idx) {

            const values = names[idx];

            const name  = values[0];
            const value = values[1];

            if (value && typeof value === "object") {
                this.updateProperty(target[name], from[name], to[name], value);
                continue;
            }

            // update
            const fromValue = from[name];
            if (this._$duration > this._$currentTime) {

                target[name] = this._$ease(
                    this._$currentTime,
                    fromValue, to[name] - fromValue,
                    this._$duration
                );

            } else {

                target[name] = to[name];

            }
        }
    }
}

/**
 * @class
 * @memberOf next2d.ui
 */
class Tween
{
    /**
     * @description 指定されたクラスのストリングを返します。
     *              Returns the string representation of the specified class.
     *
     * @return  {string}
     * @default [class Tween]
     * @method
     * @static
     */
    static toString ()
    {
        return "[class Tween]";
    }

    /**
     * @description 指定されたクラスの空間名を返します。
     *              Returns the space name of the specified class.
     *
     * @return  {string}
     * @default next2d.ui.Tween
     * @const
     * @static
     */
    static get namespace ()
    {
        return "next2d.ui.Tween";
    }

    /**
     * @description 指定されたオブジェクトのストリングを返します。
     *              Returns the string representation of the specified object.
     *
     * @return  {string}
     * @default [object Tween]
     * @method
     * @public
     */
    toString ()
    {
        return "[object Tween]";
    }

    /**
     * @description 指定されたオブジェクトの空間名を返します。
     *              Returns the space name of the specified object.
     *
     * @return  {string}
     * @default next2d.ui.Tween
     * @const
     * @public
     */
    get namespace ()
    {
        return "next2d.ui.Tween";
    }

    /**
     * @description 新しいJobクラスを追加します
     *              Add a new Job class
     *
     * @param  {object}   target
     * @param  {object}   from
     * @param  {object}   to
     * @param  {number}   [delay=0]
     * @param  {number}   [duration=1]
     * @param  {function} [ease=null]
     * @return {Job}
     * @method
     * @static
     */
    static add (target, from, to, delay = 0, duration = 1, ease = null)
    {
        return new Job(target, from, to, delay, duration, ease);
    }
}

/**
 * @class
 */
class CacheStore
{
    /**
     * @constructor
     */
    constructor ()
    {
        /**
         * @type {array}
         * @private
         */
        this._$pool = Util.$getArray();

        /**
         * @type {Map}
         * @private
         */
        this._$store = Util.$getMap();

        /**
         * @type {number}
         * @default 2
         * @private
         */
        this._$lifeCount = 2;

        /**
         * @type {function}
         * @private
         */
        this._$delayLifeCheck = this.lifeCheck.bind(this);

        /**
         * @type {function}
         * @private
         */
        this._$delayBitmapLifeCheck = this.bitmapLifeCheck.bind(this);
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    reset ()
    {
        const store = this._$store.values();
        for (const data of store) {

            const values = data.values();
            for (const value of values) {
                this.destroy(value);
            }

            Util.$poolMap(data);
        }

        this._$store.clear();
    }

    /**
     * @param  {CanvasRenderingContext2D|WebGLTexture} object
     * @return {void}
     * @method
     * @public
     */
    destroy (object)
    {
        if (!object) {
            return ;
        }

        switch (object.constructor) {

            case Util.$WebGLTexture:
                {
                    const timer = Util.$requestAnimationFrame;
                    timer(() =>
                    {
                        const player = Util.$currentPlayer();
                        if (player._$context) {

                            const bitmapData = object._$bitmapData;
                            if (bitmapData) {

                                bitmapData._$getPixelsAsync(
                                    0, 0, bitmapData.width, bitmapData.height, "RGBA"
                                );

                                object._$bitmapData = false;

                                // delay delete
                                const timer = Util.$setTimeout;
                                timer(this._$delayBitmapLifeCheck, 2000, bitmapData);
                            }

                            player
                                ._$context
                                .frameBuffer
                                .releaseTexture(object);
                        }
                    });
                }
                break;

            case Util.$CanvasRenderingContext2D:
                {
                    const canvas = object.canvas;
                    const width  = canvas.width;
                    const height = canvas.height;

                    object.clearRect(0, 0, width + 1, height + 1);

                    // canvas reset
                    canvas.width = canvas.height = 1;

                    // pool
                    this._$pool.push(canvas);
                }
                break;

            default:
                break;

        }
    }

    /**
     * @return {HTMLCanvasElement}
     * @method
     * @public
     */
    getCanvas ()
    {
        return this._$pool.pop() || Util.$document.createElement("canvas");
    }

    /**
     * @param   {string|number} id
     * @returns {void}
     * @method
     * @public
     */
    removeCache (id)
    {
        id = `${id}`;
        if (this._$store.has(id)) {

            const data = this._$store.get(id);

            const values = data.values();
            for (const value of values) {
                this.destroy(value);
            }

            Util.$poolMap(data);
            this._$store.delete(id);
        }
    }

    /**
     * @param  {*} id
     * @param  {*} type
     * @return {string}
     * @method
     * @public
     */
    generateLifeKey (id, type)
    {
        return `${id}:${type}`;
    }

    /**
     * @param  {array} keys
     * @return {*}
     * @method
     * @public
     */
    get (keys)
    {
        const id   = `${keys[0]}`;
        const type = `${keys[1]}`;

        if (this._$store.has(id)) {

            const data = this._$store.get(id);

            if (data.has(type)) {

                const key = `life_${type}`;

                // reset
                if (data.has(key) === 1) {
                    data.set(key, this._$lifeCount);
                }

                return data.get(type);
            }

        }

        return null;
    }

    /**
     * @param  {array} keys
     * @param  {*} value
     * @return {void}
     * @method
     * @public
     */
    set (keys, value = null)
    {
        const id   = `${keys[0]}`;
        const type = `${keys[1]}`;

        // init
        if (!this._$store.has(id)) {
            this._$store.set(id, Util.$getMap());
        }

        const data = this._$store.get(id);
        if (!value) {

            data.delete(type);
            data.delete(`life_${type}`);

            if (!data.size) {
                Util.$poolMap(data);
                this._$store.delete(id);
            }

            return ;

        }
        const oldValue = data.get(type);
        if (oldValue && oldValue !== value) {
            this.destroy(oldValue);
        }

        // set cache
        data.set(type, value);
        data.set(`life_${type}`, this._$lifeCount);

        // lifeCheck
        const timer = Util.$setTimeout;
        timer(this._$delayLifeCheck, 5000, id, type);
    }

    /**
     * @param  {BitmapData} bitmap_data
     * @return {void}
     * @method
     * @public
     */
    bitmapLifeCheck (bitmap_data)
    {
        if (!bitmap_data._$pixelBuffer) {
            return ;
        }
        const context = Util.$currentPlayer()._$context;

        bitmap_data._$buffer = context
            .pbo
            .getBufferSubDataAsync(bitmap_data._$pixelBuffer);

        // reset
        bitmap_data._$pixelBuffer = null;
    }

    /**
     * @param  {*} id
     * @param  {string} type
     * @return {void}
     * @method
     * @public
     */
    lifeCheck (id, type)
    {
        if (!this._$store.has(id)) {
            return ;
        }
        const data = this._$store.get(id);
        const key  = `life_${type}`;

        const lifeCount = data.get(key) - 1;
        if (!lifeCount) {

            // destroy
            this.destroy(data.get(type));

            // delete key
            data.delete(type);
            data.delete(key);

            if (!data.size) {
                Util.$poolMap(data);
                this._$store.delete(id);
            }

            return ;
        }
        data.set(key, lifeCount);

        // next
        const timer = Util.$setTimeout;
        timer(this._$delayLifeCheck, 5000, id, type);
    }

    /**
     * @param  {string|number} unique_key
     * @param  {array}         [matrix=null]
     * @param  {Float32Array}  [color=null]
     * @return {array}
     * @method
     * @public
     */
    generateKeys (unique_key, matrix = null, color = null)
    {

        let str = "";
        if (matrix) {
            str += `${matrix.join("_")}`;
        }

        // color
        if (color) {
            str += this.colorToString(color);
        }

        const keys = Util.$getArray();
        keys[1] = str ? this.generateHash(str) : "_0";
        keys[0] = `${unique_key}`;

        return keys;
    }

    /**
     * @param  {Float32Array} [c=null]
     * @return {string}
     * @method
     * @public
     */
    colorToString (c = null)
    {
        return !c || c[7] === 0 ? "" : `_${c[7]}`;
    }

    /**
     * @param  {string} str
     * @return {string}
     * @method
     * @public
     */
    generateHash (str)
    {
        let hash = 0;
        const length = str.length;
        for (let idx = 0; idx < length; idx++) {

            const chr = str.charCodeAt(idx);

            hash  = (hash << 5) - hash + chr;
            hash |= 0;
        }
        return `_${hash}`;
    }
}

/**
 * @class
 */
class BitmapShaderVariantCollection
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @constructor
     */
    constructor (context, gl, keyword)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$keyword    = keyword;
        this._$collection = new Map();
    }

    /**
     * @return {CanvasToWebGLShader}
     * @public
     */
    getBitmapShader ()
    {
        const key = "b";

        if (!this._$collection.has(key)) {
            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceTexture.TEMPLATE(this._$keyword, 0, 0, false)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @public
     */
    setBitmapUniform ()
    {
        // uniform設定不要
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} sx
     * @param {number} sy
     * @param {number} tx
     * @param {number} ty
     * @public
     */
    setGetPixelsUniform (uniform, sx, sy, tx, ty)
    {
        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0]  = 1;
        highp[1]  = 0;
        highp[2]  = 0;

        highp[4]  = 0;
        highp[5]  = 1;
        highp[6]  = 0;

        highp[8]  = 0;
        highp[9]  = 0;
        highp[10] = 1;

        // vertex: u_src_tex_matrix
        highp[12] = sx;
        highp[13] = 0;
        highp[14] = 0;

        highp[16] = 0;
        highp[17] = sy;
        highp[18] = 0;

        highp[3]  = tx;
        highp[7]  = ty;
        highp[11] = 1;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} sx1
     * @param {number} sy1
     * @param {number} tx1
     * @param {number} ty1
     * @param {number} sx2
     * @param {number} sy2
     * @param {number} tx2
     * @param {number} ty2
     * @public
     */
    setSetPixelsUniform (uniform, sx1, sy1, tx1, ty1, sx2, sy2, tx2, ty2)
    {
        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0]  = sx1;
        highp[1]  = 0;
        highp[2]  = 0;

        highp[4]  = 0;
        highp[5]  = sy1;
        highp[6]  = 0;

        highp[8]  = tx1;
        highp[9]  = ty1;
        highp[10] = 1;

        // vertex: u_src_tex_matrix
        highp[12] = sx2;
        highp[13] = 0;
        highp[14] = 0;

        highp[16] = 0;
        highp[17] = sy2;
        highp[18] = 0;

        highp[3]  = tx2;
        highp[7]  = ty2;
        highp[11] = 1;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {array} colorTransform
     * @public
     */
    setColorTransformUniform (uniform, colorTransform)
    {
        const mediump = uniform.mediump;

        // fragment: u_color_transform_mul
        mediump[0] = colorTransform[0];
        mediump[1] = colorTransform[1];
        mediump[2] = colorTransform[2];
        mediump[3] = colorTransform[3];
        // fragment: u_color_transform_add
        mediump[4] = colorTransform[4] / 255;
        mediump[5] = colorTransform[5] / 255;
        mediump[6] = colorTransform[6] / 255;
        mediump[7] = colorTransform[7] / 255;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {array}      matrix
     * @param {boolean}    use_source_texture
     * @param {array}      src_tex_mat
     * @param {BitmapData} alpha_bitmap_data
     * @param {array}      alpha_tex_mat
     * @public
     */
    setManipulatePixelsUniform (
        uniform, matrix, use_source_texture,
        src_tex_mat, alpha_bitmap_data, alpha_tex_mat
    ) {

        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0]  = matrix[0];
        highp[1]  = matrix[1];
        highp[2]  = matrix[2];

        highp[4]  = matrix[3];
        highp[5]  = matrix[4];
        highp[6]  = matrix[5];

        highp[8]  = matrix[6];
        highp[9]  = matrix[7];
        highp[10] = matrix[8];

        if (alpha_bitmap_data) {
            // vertex: u_src_tex_matrix
            highp[12] = src_tex_mat[0];
            highp[13] = src_tex_mat[1];
            highp[14] = src_tex_mat[2];

            highp[16] = src_tex_mat[3];
            highp[17] = src_tex_mat[4];
            highp[18] = src_tex_mat[5];

            highp[20] = src_tex_mat[6];
            highp[21] = src_tex_mat[7];
            highp[22] = src_tex_mat[8];

            // vertex: u_alpha_tex_matrix
            highp[24] = alpha_tex_mat[0];
            highp[25] = alpha_tex_mat[1];
            highp[26] = alpha_tex_mat[2];

            highp[3]  = alpha_tex_mat[3];
            highp[7]  = alpha_tex_mat[4];
            highp[11] = alpha_tex_mat[5];

            highp[15] = alpha_tex_mat[6];
            highp[19] = alpha_tex_mat[7];
            highp[23] = alpha_tex_mat[8];
        } else if (use_source_texture) {
            // vertex: u_src_tex_matrix
            highp[12] = src_tex_mat[0];
            highp[13] = src_tex_mat[1];
            highp[14] = src_tex_mat[2];

            highp[16] = src_tex_mat[3];
            highp[17] = src_tex_mat[4];
            highp[18] = src_tex_mat[5];

            highp[3]  = src_tex_mat[6];
            highp[7]  = src_tex_mat[7];
            highp[11] = src_tex_mat[8];
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} source_channel
     * @param {number} dest_channel
     * @public
     */
    setCopyChannelUniform (uniform, source_channel, dest_channel)
    {
        const textures = uniform.textures;
        textures[0] = 0;
        textures[1] = 1;

        const mediump = uniform.mediump;

        // fragment: u_src_ch
        mediump[0] = source_channel      & 0x01;
        mediump[1] = source_channel >> 1 & 0x01;
        mediump[2] = source_channel >> 2 & 0x01;
        mediump[3] = source_channel >> 3 & 0x01;
        // fragment: u_dst_ch
        mediump[4] = dest_channel      & 0x01;
        mediump[5] = dest_channel >> 1 & 0x01;
        mediump[6] = dest_channel >> 2 & 0x01;
        mediump[7] = dest_channel >> 3 & 0x01;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {WebGLTexture} alpha_tex
     * @public
     */
    setCopyPixelsUniform (uniform, alpha_tex)
    {
        if (alpha_tex) {
            const textures = uniform.textures;
            textures[0] = 0;
            textures[1] = 1;
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     * @public
     */
    setFillRectUniform (uniform, r, g, b, a)
    {
        const mediump = uniform.mediump;

        // fragment: u_color
        mediump[0] = r;
        mediump[1] = g;
        mediump[2] = b;
        mediump[3] = a;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {array}  tex_matrix
     * @param {array}  tex_step
     * @param {number} scan_loop
     * @param {array}  mask
     * @param {array}  color
     * @public
     */
    setGetColorBoundsRectUniform (
        uniform, tex_matrix, tex_step, scan_loop, mask, color
    ) {

        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0]  = 1;
        highp[1]  = 0;
        highp[2]  = 0;

        highp[4]  = 0;
        highp[5]  = 1;
        highp[6]  = 0;

        highp[8]  = 0;
        highp[9]  = 0;
        highp[10] = 1;

        // vertex: u_tex_matrix
        highp[12] = tex_matrix[0];
        highp[13] = tex_matrix[1];
        highp[14] = tex_matrix[2];

        highp[16] = tex_matrix[3];
        highp[17] = tex_matrix[4];
        highp[18] = tex_matrix[5];

        highp[3]  = tex_matrix[6];
        highp[7]  = tex_matrix[7];
        highp[11] = tex_matrix[8];

        const mediump = uniform.mediump;

        // fragment: u_src_tex_step
        mediump[0] = tex_step[0];
        mediump[1] = tex_step[1];

        // fragment: u_scan_loop
        mediump[2] = scan_loop;

        const integer = uniform.integer;

        // fragment: u_mask
        integer[0] = mask[0];
        integer[1] = mask[1];
        integer[2] = mask[2];
        integer[3] = mask[3];

        // fragment: u_color
        integer[4] = color[0];
        integer[5] = color[1];
        integer[6] = color[2];
        integer[7] = color[3];
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     * @public
     */
    setMergeUniform (uniform, r, g, b, a)
    {
        const textures = uniform.textures;
        textures[0] = 0;
        textures[1] = 1;

        const mediump = uniform.mediump;

        // fragment: u_multipliers
        mediump[0] = r;
        mediump[1] = g;
        mediump[2] = b;
        mediump[3] = a;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} seed_r
     * @param {number} seed_g
     * @param {number} seed_b
     * @param {number} seed_a
     * @param {number} amp_r
     * @param {number} amp_g
     * @param {number} amp_b
     * @param {number} amp_a
     * @param {number} low_r
     * @param {number} low_g
     * @param {number} low_b
     * @param {number} low_a
     * @public
     */
    setNoiseUniform (
        uniform,
        seed_r, seed_g, seed_b, seed_a,
        amp_r, amp_g, amp_b, amp_a,
        low_r, low_g, low_b, low_a
    ) {
        const mediump = uniform.mediump;

        // fragment: u_seed
        mediump[0]  = seed_r;
        mediump[1]  = seed_g;
        mediump[2]  = seed_b;
        mediump[3]  = seed_a;

        // fragment: u_amp
        mediump[4]  = amp_r;
        mediump[5]  = amp_g;
        mediump[6]  = amp_b;
        mediump[7]  = amp_a;

        // fragment: u_low
        mediump[8]  = low_r;
        mediump[9]  = low_g;
        mediump[10] = low_b;
        mediump[11] = low_a;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @public
     */
    setPaletteMapUniform (uniform)
    {
        const textures = uniform.textures;
        textures[0] = 0;
        textures[1] = 2;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     * @public
     */
    setPixelDissolveUniform (uniform, r, g, b, a)
    {
        const mediump = uniform.mediump;

        // fragment: u_color
        mediump[0] = r;
        mediump[1] = g;
        mediump[2] = b;
        mediump[3] = a;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @public
     */
    setFlushSetPixelQueueUniform (uniform)
    {
        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0] = 1;
        highp[1] = 0;
        highp[2] = 0;

        highp[3] = 0;
        highp[4] = -1;
        highp[5] = 0;

        highp[6] = 0;
        highp[7] = 1;
        highp[8] = 1;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} tr
     * @param {number} tg
     * @param {number} tb
     * @param {number} ta
     * @param {number} cr
     * @param {number} cg
     * @param {number} cb
     * @param {number} ca
     * @param {number} mr
     * @param {number} mg
     * @param {number} mb
     * @param {number} ma
     * @public
     */
    setThresholdUniform (
        uniform, tr, tg, tb, ta, cr, cg, cb, ca, mr, mg, mb, ma
    ) {

        const mediump = uniform.mediump;

        // fragment: u_threshold
        mediump[0] = tr;
        mediump[1] = tg;
        mediump[2] = tb;
        mediump[3] = ta;

        // fragment: u_out_color
        mediump[4] = cr;
        mediump[5] = cg;
        mediump[6] = cb;
        mediump[7] = ca;

        const integer = uniform.integer;

        // fragment: u_masked
        integer[0] = mr;
        integer[1] = mg;
        integer[2] = mb;
        integer[3] = ma;
    }
}
/**
 * @class
 */
class BlendShaderVariantCollection
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @constructor
     * @public
     */
    constructor (context, gl, keyword)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$keyword    = keyword;
        this._$collection = new Map();
    }

    /**
     * @param  {boolean} with_color_transform
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getNormalBlendShader (with_color_transform)
    {
        const key = `n${with_color_transform ? "y" : "n"}`;

        if (!this._$collection.has(key)) {
            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.BLEND(this._$keyword),
                FragmentShaderSourceTexture.TEMPLATE(this._$keyword, with_color_transform)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getClipShader ()
    {
        const key = "c";

        if (!this._$collection.has(key)) {
            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.BLEND_CLIP(this._$keyword),
                FragmentShaderSourceTexture.TEMPLATE(this._$keyword, false)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {string}  operation
     * @param  {boolean} with_color_transform
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getBlendShader (operation, with_color_transform)
    {
        const key = `${operation}${with_color_transform ? "y" : "n"}`;

        if (!this._$collection.has(key)) {
            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.BLEND(this._$keyword),
                FragmentShaderSourceBlend.TEMPLATE(this._$keyword, operation, with_color_transform)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number}  x
     * @param {number}  y
     * @param {number}  w
     * @param {number}  h
     * @param {array}   matrix
     * @param {number}  render_width
     * @param {number}  render_height
     * @param {boolean} with_color_transform
     * @param {number}  ct0
     * @param {number}  ct1
     * @param {number}  ct2
     * @param {number}  ct3
     * @param {number}  ct4
     * @param {number}  ct5
     * @param {number}  ct6
     * @param {number}  ct7
     * @method
     * @public
     */
    setNormalBlendUniform (
        uniform, x, y, w, h, matrix, render_width, render_height,
        with_color_transform, ct0, ct1, ct2, ct3, ct4, ct5, ct6, ct7)
    {
        const highp = uniform.highp;

        // vertex: u_offset
        highp[0] = x;
        highp[1] = y;
        // vertex: u_size
        highp[2] = w;
        highp[3] = h;

        // vertex: u_matrix
        highp[4]  = matrix[0];
        highp[5]  = matrix[1];
        highp[6]  = matrix[2];

        highp[8]  = matrix[3];
        highp[9]  = matrix[4];
        highp[10] = matrix[5];

        highp[12] = matrix[6];
        highp[13] = matrix[7];
        highp[14] = matrix[8];

        // vertex: u_viewport
        highp[7]  = render_width;
        highp[11] = render_height;

        if (with_color_transform) {
            const mediump = uniform.mediump;

            // fragment: u_color_transform_mul
            mediump[0] = ct0;
            mediump[1] = ct1;
            mediump[2] = ct2;
            mediump[3] = ct3;
            // fragment: u_color_transform_add
            mediump[4] = ct4;
            mediump[5] = ct5;
            mediump[6] = ct6;
            mediump[7] = ct7;
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number}  x
     * @param {number}  y
     * @param {number}  w
     * @param {number}  h
     * @param {array}   inverse_matrix
     * @param {number}  render_width
     * @param {number}  render_height
     * @method
     * @public
     */
    setClipUniform (
        uniform, x, y, w, h, inverse_matrix, render_width, render_height
    ) {

        const highp = uniform.highp;

        // vertex: u_offset
        highp[0] = x;
        highp[1] = y;
        // vertex: u_size
        highp[2] = w;
        highp[3] = h;

        // vertex: u_inverse_matrix
        highp[4]  = inverse_matrix[0];
        highp[5]  = inverse_matrix[1];
        highp[6]  = inverse_matrix[2];

        highp[8]  = inverse_matrix[3];
        highp[9]  = inverse_matrix[4];
        highp[10] = inverse_matrix[5];

        highp[12] = inverse_matrix[6];
        highp[13] = inverse_matrix[7];
        highp[14] = inverse_matrix[8];

        // vertex: u_viewport
        highp[7]  = render_width;
        highp[11] = render_height;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number}  x
     * @param {number}  y
     * @param {number}  w
     * @param {number}  h
     * @param {array}   matrix
     * @param {number}  render_width
     * @param {number}  render_height
     * @param {boolean} with_color_transform
     * @param {number}  ct0
     * @param {number}  ct1
     * @param {number}  ct2
     * @param {number}  ct3
     * @param {number}  ct4
     * @param {number}  ct5
     * @param {number}  ct6
     * @param {number}  ct7
     * @method
     * @public
     */
    setBlendUniform (
        uniform, x, y, w, h, matrix, render_width, render_height,
        with_color_transform, ct0, ct1, ct2, ct3, ct4, ct5, ct6, ct7
    ) {
        const textures = uniform.textures;
        textures[0] = 0;
        textures[1] = 1;

        const highp = uniform.highp;

        // vertex: u_offset
        highp[0] = x;
        highp[1] = y;
        // vertex: u_size
        highp[2] = w;
        highp[3] = h;

        // vertex: u_matrix
        highp[4]  = matrix[0];
        highp[5]  = matrix[1];
        highp[6]  = matrix[2];

        highp[8]  = matrix[3];
        highp[9]  = matrix[4];
        highp[10] = matrix[5];

        highp[12] = matrix[6];
        highp[13] = matrix[7];
        highp[14] = matrix[8];

        // vertex: u_viewport
        highp[7]  = render_width;
        highp[11] = render_height;

        if (with_color_transform) {
            const mediump = uniform.mediump;

            // fragment: u_color_transform_mul
            mediump[0] = ct0;
            mediump[1] = ct1;
            mediump[2] = ct2;
            mediump[3] = ct3;
            // fragment: u_color_transform_add
            mediump[4] = ct4;
            mediump[5] = ct5;
            mediump[6] = ct6;
            mediump[7] = ct7;
        }
    }
}

/**
 * @class
 */
class FilterShaderVariantCollection
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @constructor
     * @public
     */
    constructor (context, gl, keyword)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$keyword    = keyword;
        this._$collection = new Map();
    }

    /**
     * @param  {number}  half_blur
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getBlurFilterShader (half_blur)
    {
        const key = `b${half_blur}`;

        if (!this._$collection.has(key)) {
            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceBlurFilter.TEMPLATE(this._$keyword, half_blur)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {boolean} transforms_base
     * @param  {boolean} transforms_blur
     * @param  {boolean} is_glow
     * @param  {string}  type
     * @param  {boolean} knockout
     * @param  {boolean} applies_strength
     * @param  {boolean} is_gradient
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getBitmapFilterShader (
        transforms_base, transforms_blur, is_glow,
        type, knockout, applies_strength, is_gradient
    ) {

        const key1 = transforms_base ? "y" : "n";
        const key2 = transforms_blur ? "y" : "n";
        const key3 = is_glow ? "y" : "n";
        const key4 = knockout ? "y" : "n";
        const key5 = applies_strength ? "y" : "n";
        const key = `f${key1}${key2}${key3}${type}${key4}${key5}`;

        if (!this._$collection.has(key)) {
            let texturesLength = 1;
            if (transforms_base) { texturesLength++ }
            if (is_gradient) { texturesLength++ }

            let mediumpLength = (transforms_base ? 4 : 0)
                + (transforms_blur ? 4 : 0)
                + (applies_strength ? 1 : 0);
            if (is_gradient) {
                // do nothing
            } else {
                mediumpLength += is_glow ? 4 : 8;
            }
            mediumpLength = $Math.ceil(mediumpLength / 4);

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceFilter.TEMPLATE(
                    this._$keyword, texturesLength, mediumpLength,
                    transforms_base, transforms_blur,
                    is_glow, type, knockout,
                    applies_strength, is_gradient
                )
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getColorMatrixFilterShader ()
    {
        const key = "m";

        if (!this._$collection.has(key)) {
            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceColorMatrixFilter.TEMPLATE(this._$keyword)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {number}  x
     * @param  {number}  y
     * @param  {boolean} preserve_alpha
     * @param  {boolean} clamp
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getConvolutionFilterShader (x, y, preserve_alpha, clamp)
    {
        const key1 = ("0" + x).slice(-2);
        const key2 = ("0" + y).slice(-2);
        const key3 = preserve_alpha ? "y" : "n";
        const key4 = clamp ? "y" : "n";
        const key = `c${key1}${key2}${key3}${key4}`;

        if (!this._$collection.has(key)) {
            const mediumpLength = (clamp ? 1 : 2) + $Math.ceil(x * y / 4);

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceConvolutionFilter.TEMPLATE(
                    this._$keyword, mediumpLength,
                    x, y, preserve_alpha, clamp
                )
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {number} component_x
     * @param  {number} component_y
     * @param  {string} mode
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getDisplacementMapFilterShader (component_x, component_y, mode)
    {
        const key = `d${component_x}${component_y}${mode}`;

        if (!this._$collection.has(key)) {
            const mediumpLength = mode === DisplacementMapFilterMode.COLOR ? 3 : 2;

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceDisplacementMapFilter.TEMPLATE(
                    this._$keyword, mediumpLength,
                    component_x, component_y, mode
                )
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number}  width
     * @param {number}  height
     * @param {boolean} is_horizontal
     * @param {number}  fraction
     * @param {number}  samples
     * @method
     * @public
     */
    setBlurFilterUniform (uniform, width, height, is_horizontal, fraction, samples)
    {
        const mediump = uniform.mediump;

        // fragment: u_offset
        if (is_horizontal) {
            mediump[0] = 1 / width;
            mediump[1] = 0;
        } else {
            mediump[0] = 0;
            mediump[1] = 1 / height;
        }

        // fragment: u_fraction
        mediump[2] = fraction;

        // fragment: u_samples
        mediump[3] = samples;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number}  width
     * @param {number}  height
     * @param {number}  base_width
     * @param {number}  base_height
     * @param {number}  base_offset_x
     * @param {number}  base_offset_y
     * @param {number}  blur_width
     * @param {number}  blur_height
     * @param {number}  blur_offset_x
     * @param {number}  blur_offset_y
     * @param {boolean} is_glow
     * @param {number}  strength
     * @param {number}  color_r1
     * @param {number}  color_g1
     * @param {number}  color_b1
     * @param {number}  color_a1
     * @param {number}  color_r2
     * @param {number}  color_g2
     * @param {number}  color_b2
     * @param {number}  color_a2
     * @param {boolean} transforms_base
     * @param {boolean} transforms_blur
     * @param {boolean} applies_strength
     * @param {boolean} is_gradient
     * @method
     * @public
     */
    setBitmapFilterUniform (
        uniform, width, height,
        base_width, base_height, base_offset_x, base_offset_y,
        blur_width, blur_height, blur_offset_x, blur_offset_y,
        is_glow, strength,
        color_r1, color_g1, color_b1, color_a1,
        color_r2, color_g2, color_b2, color_a2,
        transforms_base, transforms_blur, applies_strength, is_gradient
    ) {
        let textures;
        // fragment: u_textures
        if (transforms_base) {
            textures = uniform.textures;
            textures[0] = 0;
            textures[1] = 1;
            if (is_gradient) {
                textures[2] = 2;
            }
        } else if (is_gradient) {
            textures = uniform.textures;
            textures[0] = 0;
            textures[1] = 2;
        }

        const mediump = uniform.mediump;
        let i = 0;

        if (transforms_base) {
            // fragment: u_uv_scale
            mediump[i]     = width / base_width;
            mediump[i + 1] = height / base_height;
            // fragment: u_uv_offset
            mediump[i + 2] = base_offset_x / base_width;
            mediump[i + 3] = (height - base_height - base_offset_y) / base_height;
            i += 4;
        }

        if (transforms_blur) {
            // fragment: u_st_scale
            mediump[i]     = width / blur_width;
            mediump[i + 1] = height / blur_height;
            // fragment: u_st_offset
            mediump[i + 2] = blur_offset_x / blur_width;
            mediump[i + 3] = (height - blur_height - blur_offset_y) / blur_height;
            i += 4;
        }

        if (is_gradient) {
            // do nothing
        } else if (is_glow) {
            // fragment: u_color
            mediump[i]     = color_r1;
            mediump[i + 1] = color_g1;
            mediump[i + 2] = color_b1;
            mediump[i + 3] = color_a1;
            i += 4;
        } else {
            // fragment: u_highlight_color
            mediump[i]     = color_r1;
            mediump[i + 1] = color_g1;
            mediump[i + 2] = color_b1;
            mediump[i + 3] = color_a1;
            // fragment: u_shadow_color
            mediump[i + 4] = color_r2;
            mediump[i + 5] = color_g2;
            mediump[i + 6] = color_b2;
            mediump[i + 7] = color_a2;
            i += 8;
        }

        if (applies_strength) {
            // fragment: u_strength
            mediump[i++] = strength;
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {array} matrix
     * @method
     * @public
     */
    setColorMatrixFilterUniform (uniform, matrix)
    {
        const mediump = uniform.mediump;

        // fragment: u_mul
        mediump[0]  = matrix[0];
        mediump[1]  = matrix[1];
        mediump[2]  = matrix[2];
        mediump[3]  = matrix[3];

        mediump[4]  = matrix[5];
        mediump[5]  = matrix[6];
        mediump[6]  = matrix[7];
        mediump[7]  = matrix[8];

        mediump[8]  = matrix[10];
        mediump[9]  = matrix[11];
        mediump[10] = matrix[12];
        mediump[11] = matrix[13];

        mediump[12] = matrix[15];
        mediump[13] = matrix[16];
        mediump[14] = matrix[17];
        mediump[15] = matrix[18];

        // fragment: u_add
        mediump[16] = matrix[4]  / 255;
        mediump[17] = matrix[9]  / 255;
        mediump[18] = matrix[14] / 255;
        mediump[19] = matrix[19] / 255;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number}  width
     * @param {number}  height
     * @param {array}   matrix
     * @param {number}  divisor
     * @param {number}  bias
     * @param {boolean} clamp
     * @param {number}  color_r
     * @param {number}  color_g
     * @param {number}  color_b
     * @param {number}  color_a
     * @method
     * @public
     */
    setConvolutionFilterUniform (
        uniform,
        width, height, matrix, divisor, bias, clamp,
        color_r, color_g, color_b, color_a
    ) {
        const mediump = uniform.mediump;

        // fragment: u_rcp_size
        mediump[0] = 1 / width;
        mediump[1] = 1 / height;

        // fragment: u_rcp_divisor
        mediump[2] = 1 / divisor;

        // fragment: u_bias
        mediump[3] = bias / 255;

        let i = 4;

        if (!clamp) {
            // fragment: u_substitute_color
            mediump[i]     = color_r;
            mediump[i + 1] = color_g;
            mediump[i + 2] = color_b;
            mediump[i + 3] = color_a;
            i += 4;
        }

        // fragment: u_matrix
        const length = matrix.length;
        for (let j = 0; j < length; j++) {
            mediump[i++] = matrix[j];
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} map_width
     * @param {number} map_height
     * @param {number} base_width
     * @param {number} base_height
     * @param {number} point_x
     * @param {number} point_y
     * @param {number} scale_x
     * @param {number} scale_y
     * @param {string} mode
     * @param {number} color_r
     * @param {number} color_g
     * @param {number} color_b
     * @param {number} color_a
     * @method
     * @public
     */
    setDisplacementMapFilterUniform (
        uniform, map_width, map_height, base_width, base_height,
        point_x, point_y, scale_x, scale_y, mode,
        color_r, color_g, color_b, color_a
    ) {
        const textures = uniform.textures;
        textures[0] = 0;
        textures[1] = 1;

        const mediump = uniform.mediump;

        // fragment: u_uv_to_st_scale
        mediump[0] = base_width  / map_width;
        mediump[1] = base_height / map_height;
        // fragment: u_uv_to_st_offset
        mediump[2] = point_x / map_width;
        mediump[3] = (base_height - map_height - point_y) / map_height;

        // fragment: u_scale
        mediump[4] =  scale_x / base_width;
        mediump[5] = -scale_y / base_height;

        if (mode === DisplacementMapFilterMode.COLOR) {
            // fragment: u_substitute_color
            mediump[8]  = color_r;
            mediump[9]  = color_g;
            mediump[10] = color_b;
            mediump[11] = color_a;
        }
    }
}
/**
 * @class
 */
class GradientLUTShaderVariantCollection
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @constructor
     * @public
     */
    constructor (context, gl, keyword)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$keyword    = keyword;
        this._$collection = new Map();
    }

    /**
     * @param  {number}  stops_length
     * @param  {boolean} is_linear_space
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getGradientLUTShader (stops_length, is_linear_space)
    {
        const key1 = ("00" + stops_length).slice(-3);
        const key2 = is_linear_space ? "y" : "n";
        const key = `l${key1}${key2}`;

        if (!this._$collection.has(key)) {
            const mediumpLength = $Math.ceil(stops_length * 5 / 4);

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                VertexShaderSource.TEXTURE(this._$keyword),
                FragmentShaderSourceGradientLUT.TEMPLATE(this._$keyword, mediumpLength, stops_length, is_linear_space)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {array}  stops
     * @param {number} begin
     * @param {number} end
     * @param {array}  table
     * @method
     * @public
     */
    setGradientLUTUniformForShape (uniform, stops, begin, end, table)
    {
        let i = 0;
        const mediump = uniform.mediump;

        // fragment: u_gradient_color
        for (let j = begin; j < end; j++) {
            const color = stops[j][1];
            mediump[i++] = table[color[0]];
            mediump[i++] = table[color[1]];
            mediump[i++] = table[color[2]];
            mediump[i++] = table[color[3]];
        }

        // fragment: u_gradient_t
        for (let j = begin; j < end; j++) {
            mediump[i++] = stops[j][0];
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {array}  ratios
     * @param {array}  colors
     * @param {array}  alphas
     * @param {number} begin
     * @param {number} end
     * @method
     * @public
     */
    setGradientLUTUniformForFilter (uniform, ratios, colors, alphas, begin, end)
    {
        let i = 0;
        const mediump = uniform.mediump;

        // fragment: u_gradient_color
        for (let j = begin; j < end; j++) {
            const color = colors[j];
            mediump[i++] = ((color >> 16)       ) / 255;
            mediump[i++] = (color  >>   8 & 0xFF) / 255;
            mediump[i++] = (color         & 0xFF) / 255;
            mediump[i++] = alphas[j];
        }

        // fragment: u_gradient_t
        for (let j = begin; j < end; j++) {
            mediump[i++] = ratios[j];
        }
    }
}
/**
 * @class
 */
class GradientShapeShaderVariantCollection
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @constructor
     * @public
     */
    constructor (context, gl, keyword)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$keyword    = keyword;
        this._$collection = new Map();
    }

    /**
     * @param  {boolean} is_stroke
     * @param  {boolean} has_grid
     * @param  {boolean} is_radial
     * @param  {boolean} has_focal_point
     * @param  {string}  spread_method
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getGradientShapeShader (
        is_stroke, has_grid, is_radial, has_focal_point, spread_method
    ) {

        const key = this.createCollectionKey(
            is_stroke, has_grid, is_radial, has_focal_point, spread_method
        );

        if (!this._$collection.has(key)) {
            let highpLength = (has_grid ? 13 : 5) + (is_stroke ? 1 : 0) + 1;
            const fragmentIndex = highpLength - 1;

            let vertexShaderSource;
            if (is_stroke) {
                vertexShaderSource = VertexShaderSourceStroke.TEMPLATE(
                    this._$keyword, highpLength, fragmentIndex,
                    true, has_grid
                );
            } else {
                vertexShaderSource = VertexShaderSourceFill.TEMPLATE(
                    this._$keyword, highpLength,
                    true, false, has_grid
                );
            }

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                vertexShaderSource,
                FragmentShaderSourceGradient.TEMPLATE(
                    this._$keyword, highpLength, fragmentIndex,
                    is_radial, has_focal_point, spread_method
                )
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {boolean} is_stroke
     * @param  {boolean} has_grid
     * @param  {boolean} is_radial
     * @param  {boolean} has_focal_point
     * @param  {string}  spread_method
     * @return {string}
     * @method
     * @private
     */
    createCollectionKey (is_stroke, has_grid, is_radial, has_focal_point, spread_method)
    {
        const key1 = is_stroke ? "y" : "n";
        const key2 = has_grid  ? "y" : "n";
        const key3 = is_radial ? "y" : "n";
        const key4 = is_radial && has_focal_point ? "y" : "n";
        let key5 = 0;
        switch (spread_method) {
            case "reflect":
                key5 = 1;
                break;
            case "repeat":
                key5 = 2;
                break;
        }

        return `${key1}${key2}${key3}${key4}${key5}`;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {boolean} is_stroke
     * @param {number}  half_width
     * @param {number}  face
     * @param {number}  miter_limit
     * @param {boolean} has_grid
     * @param {array}   matrix
     * @param {array}   inverse_matrix
     * @param {number}  viewport_width
     * @param {number}  viewport_height
     * @param {CanvasToWebGLContextGrid} grid
     * @param {boolean} is_radial
     * @param {array}   points
     * @param {number}  focal_point_ratio
     * @method
     * @public
     */
    setGradientShapeUniform (
        uniform,
        is_stroke, half_width, face, miter_limit,
        has_grid, matrix, inverse_matrix,
        viewport_width, viewport_height, grid,
        is_radial, points, focal_point_ratio
    ) {
        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0]  = matrix[0];
        highp[1]  = matrix[1];
        highp[2]  = matrix[2];

        highp[4]  = matrix[3];
        highp[5]  = matrix[4];
        highp[6]  = matrix[5];

        highp[8]  = matrix[6];
        highp[9]  = matrix[7];
        highp[10] = matrix[8];

        // vertex: u_inverse_matrix
        highp[12] = inverse_matrix[0];
        highp[13] = inverse_matrix[1];
        highp[14] = inverse_matrix[2];

        highp[16] = inverse_matrix[3];
        highp[17] = inverse_matrix[4];
        highp[18] = inverse_matrix[5];

        highp[11] = inverse_matrix[6];
        highp[15] = inverse_matrix[7];
        highp[19] = inverse_matrix[8];

        // vertex: u_viewport
        highp[3] = viewport_width;
        highp[7] = viewport_height;

        let i = 20;
        if (has_grid) {
            // vertex: u_parent_matrix
            highp[i]      = grid.parentMatrixA;
            highp[i + 1]  = grid.parentMatrixB;
            highp[i + 2]  = grid.parentMatrixC;

            highp[i + 4]  = grid.parentMatrixD;
            highp[i + 5]  = grid.parentMatrixE;
            highp[i + 6]  = grid.parentMatrixF;

            highp[i + 8]  = grid.parentMatrixG;
            highp[i + 9]  = grid.parentMatrixH;
            highp[i + 10] = grid.parentMatrixI;

            // vertex: u_ancestor_matrix
            highp[i + 12] = grid.ancestorMatrixA;
            highp[i + 13] = grid.ancestorMatrixB;
            highp[i + 14] = grid.ancestorMatrixC;

            highp[i + 16] = grid.ancestorMatrixD;
            highp[i + 17] = grid.ancestorMatrixE;
            highp[i + 18] = grid.ancestorMatrixF;

            highp[i + 20] = grid.ancestorMatrixG;
            highp[i + 21] = grid.ancestorMatrixH;
            highp[i + 22] = grid.ancestorMatrixI;

            // vertex: u_parent_viewport
            highp[i + 11] = grid.parentViewportX;
            highp[i + 15] = grid.parentViewportY;
            highp[i + 19] = grid.parentViewportW;
            highp[i + 23] = grid.parentViewportH;

            // vertex: u_grid_min
            highp[i + 24] = grid.minXST;
            highp[i + 25] = grid.minYST;
            highp[i + 26] = grid.minXPQ;
            highp[i + 27] = grid.minYPQ;
            // vertex: u_grid_max
            highp[i + 28] = grid.maxXST;
            highp[i + 29] = grid.maxYST;
            highp[i + 30] = grid.maxXPQ;
            highp[i + 31] = grid.maxYPQ;

            i = 52;
        }

        if (is_stroke) {
            // vertex: u_half_width
            highp[i]     = half_width;
            // vertex: u_face
            highp[i + 1] = face;
            // vertex: u_miter_limit
            highp[i + 2] = miter_limit;

            i += 4;
        }

        if (is_radial) {
            // fragment: u_radial_point
            highp[i]     = points[5];
            // fragment: u_focal_point_ratio
            highp[i + 1] = focal_point_ratio;
        } else {
            // fragment: u_linear_points
            highp[i]     = points[0];
            highp[i + 1] = points[1];
            highp[i + 2] = points[2];
            highp[i + 3] = points[3];
        }
    }
}

/**
 * @class
 */
class ShapeShaderVariantCollection
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @constructor
     * @public
     */
    constructor (context, gl, keyword)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$keyword    = keyword;
        this._$collection = new Map();
    }

    /**
     * @param  {boolean} is_stroke
     * @param  {boolean} has_grid
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getSolidColorShapeShader (is_stroke, has_grid)
    {
        const key = `s${is_stroke ? "y" : "n"}${has_grid ? "y" : "n"}`;

        if (!this._$collection.has(key)) {
            const highpLength = (has_grid ? 8 : 3) + (is_stroke ? 1 : 0);
            const fragmentIndex = highpLength;

            let vertexShaderSource;
            if (is_stroke) {
                vertexShaderSource = VertexShaderSourceStroke.TEMPLATE(
                    this._$keyword, highpLength, fragmentIndex,
                    false, false, has_grid
                );
            } else {
                vertexShaderSource = VertexShaderSourceFill.TEMPLATE(
                    this._$keyword, highpLength,
                    false, false, has_grid
                );
            }

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                vertexShaderSource,
                FragmentShaderSource.SOLID_COLOR(this._$keyword)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {boolean} is_stroke
     * @param  {boolean} repeat
     * @param  {boolean} has_grid
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getBitmapShapeShader (is_stroke, repeat, has_grid)
    {
        const key = `b${is_stroke ? "y" : "n"}${repeat ? "y" : "n"}${has_grid ? "y" : "n"}`;

        if (!this._$collection.has(key)) {
            const highpLength = (has_grid ? 13 : 5) + (is_stroke ? 1 : 0);
            const fragmentIndex = highpLength;

            let vertexShaderSource;
            if (is_stroke) {
                vertexShaderSource = VertexShaderSourceStroke.TEMPLATE(
                    this._$keyword, highpLength, fragmentIndex,
                    true, false, has_grid
                );
            } else {
                vertexShaderSource = VertexShaderSourceFill.TEMPLATE(
                    this._$keyword, highpLength,
                    true, false, has_grid
                );
            }

            const fragmentShaderSource = repeat
                ? FragmentShaderSource.BITMAP_PATTERN(this._$keyword)
                : FragmentShaderSource.BITMAP_CLIPPED(this._$keyword);

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                vertexShaderSource,
                fragmentShaderSource
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param  {boolean} is_stroke
     * @param  {boolean} has_grid
     * @return {CanvasToWebGLShader}
     * @method
     * @public
     */
    getMaskShapeShader (is_stroke, has_grid)
    {
        const key = `m${is_stroke ? "y" : "n"}${has_grid ? "y" : "n"}`;

        if (!this._$collection.has(key)) {
            const highpLength = (has_grid ? 8 : 3) + (is_stroke ? 1 : 0);
            const fragmentIndex = highpLength;

            let vertexShaderSource;
            if (is_stroke) {
                vertexShaderSource = VertexShaderSourceStroke.TEMPLATE(
                    this._$keyword, highpLength, fragmentIndex,
                    false, true, has_grid
                );
            } else {
                vertexShaderSource = VertexShaderSourceFill.TEMPLATE(
                    this._$keyword, highpLength,
                    false, true, has_grid
                );
            }

            this._$collection.set(key, new CanvasToWebGLShader(
                this._$gl, this._$context,
                vertexShaderSource,
                FragmentShaderSource.MASK(this._$keyword)
            ));
        }

        return this._$collection.get(key);
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {boolean} is_stroke
     * @param {number}  half_width
     * @param {number}  face
     * @param {number}  miter_limit
     * @param {boolean} has_grid
     * @param {array}   matrix
     * @param {number}  viewport_width
     * @param {number}  viewport_height
     * @param {CanvasToWebGLContextGrid} grid
     * @param {array}   color
     * @param {number}  alpha
     * @method
     * @public
     */
    setSolidColorShapeUniform (
        uniform,
        is_stroke, half_width, face, miter_limit,
        has_grid, matrix,
        viewport_width, viewport_height, grid,
        color, alpha
    ) {
        const highp = uniform.highp;
        let i;

        if (has_grid) {
            // vertex: u_parent_matrix
            highp[0]  = grid.parentMatrixA;
            highp[1]  = grid.parentMatrixB;
            highp[2]  = grid.parentMatrixC;

            highp[4]  = grid.parentMatrixD;
            highp[5]  = grid.parentMatrixE;
            highp[6]  = grid.parentMatrixF;

            highp[8]  = grid.parentMatrixG;
            highp[9]  = grid.parentMatrixH;
            highp[10] = grid.parentMatrixI;

            // vertex: u_ancestor_matrix
            highp[12] = grid.ancestorMatrixA;
            highp[13] = grid.ancestorMatrixB;
            highp[14] = grid.ancestorMatrixC;

            highp[16] = grid.ancestorMatrixD;
            highp[17] = grid.ancestorMatrixE;
            highp[18] = grid.ancestorMatrixF;

            highp[20] = grid.ancestorMatrixG;
            highp[21] = grid.ancestorMatrixH;
            highp[22] = grid.ancestorMatrixI;

            // vertex: u_viewport
            highp[3]  = viewport_width;
            highp[7]  = viewport_height;

            // vertex: u_parent_viewport
            highp[11] = grid.parentViewportX;
            highp[15] = grid.parentViewportY;
            highp[19] = grid.parentViewportW;
            highp[23] = grid.parentViewportH;

            // vertex: u_grid_min
            highp[24] = grid.minXST;
            highp[25] = grid.minYST;
            highp[26] = grid.minXPQ;
            highp[27] = grid.minYPQ;
            // vertex: u_grid_max
            highp[28] = grid.maxXST;
            highp[29] = grid.maxYST;
            highp[30] = grid.maxXPQ;
            highp[31] = grid.maxYPQ;

            i = 32;
        } else {
            // vertex: u_matrix
            highp[0]  = matrix[0];
            highp[1]  = matrix[1];
            highp[2]  = matrix[2];

            highp[4]  = matrix[3];
            highp[5]  = matrix[4];
            highp[6]  = matrix[5];

            highp[8]  = matrix[6];
            highp[9]  = matrix[7];
            highp[10] = matrix[8];

            // vertex: u_viewport
            highp[3] = viewport_width;
            highp[7] = viewport_height;

            i = 12;
        }

        if (is_stroke) {
            // vertex: u_half_width
            highp[i]     = half_width;
            // vertex: u_face
            highp[i + 1] = face;
            // vertex: u_miter_limit
            highp[i + 2] = miter_limit;
        }

        const mediump = uniform.mediump;

        // fragment: u_color
        mediump[0] = color[0];
        mediump[1] = color[1];
        mediump[2] = color[2];
        mediump[3] = color[3] * alpha;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {boolean} is_stroke
     * @param {number}  half_width
     * @param {number}  face
     * @param {number}  miter_limit
     * @param {boolean} has_grid
     * @param {array}   matrix
     * @param {array}   inverse_matrix
     * @param {number}  viewport_width
     * @param {number}  viewport_height
     * @param {CanvasToWebGLContextGrid} grid
     * @param {number}  texture_width
     * @param {number}  texture_height
     * @param {number}  mul1
     * @param {number}  mul2
     * @param {number}  mul3
     * @param {number}  mul4
     * @param {number}  add1
     * @param {number}  add2
     * @param {number}  add3
     * @param {number}  add4
     * @method
     * @public
     */
    setBitmapShapeUniform (
        uniform,
        is_stroke, half_width, face, miter_limit,
        has_grid, matrix, inverse_matrix,
        viewport_width, viewport_height, grid,
        texture_width, texture_height,
        mul1, mul2, mul3, mul4,
        add1, add2, add3, add4
    ) {
        const highp = uniform.highp;
        let i;

        // vertex: u_matrix
        highp[0]  = matrix[0];
        highp[1]  = matrix[1];
        highp[2]  = matrix[2];

        highp[4]  = matrix[3];
        highp[5]  = matrix[4];
        highp[6]  = matrix[5];

        highp[8]  = matrix[6];
        highp[9]  = matrix[7];
        highp[10] = matrix[8];

        // vertex: u_inverse_matrix
        highp[12] = inverse_matrix[0];
        highp[13] = inverse_matrix[1];
        highp[14] = inverse_matrix[2];

        highp[16] = inverse_matrix[3];
        highp[17] = inverse_matrix[4];
        highp[18] = inverse_matrix[5];

        highp[11] = inverse_matrix[6];
        highp[15] = inverse_matrix[7];
        highp[19] = inverse_matrix[8];

        // vertex: u_viewport
        highp[3] = viewport_width;
        highp[7] = viewport_height;

        i = 20;

        if (has_grid) {
            // vertex: u_parent_matrix
            highp[i]      = grid.parentMatrixA;
            highp[i + 1]  = grid.parentMatrixB;
            highp[i + 2]  = grid.parentMatrixC;

            highp[i + 4]  = grid.parentMatrixD;
            highp[i + 5]  = grid.parentMatrixE;
            highp[i + 6]  = grid.parentMatrixF;

            highp[i + 8]  = grid.parentMatrixG;
            highp[i + 9]  = grid.parentMatrixH;
            highp[i + 10] = grid.parentMatrixI;

            // vertex: u_ancestor_matrix
            highp[i + 12] = grid.ancestorMatrixA;
            highp[i + 13] = grid.ancestorMatrixB;
            highp[i + 14] = grid.ancestorMatrixC;

            highp[i + 16] = grid.ancestorMatrixD;
            highp[i + 17] = grid.ancestorMatrixE;
            highp[i + 18] = grid.ancestorMatrixF;

            highp[i + 20] = grid.ancestorMatrixG;
            highp[i + 21] = grid.ancestorMatrixH;
            highp[i + 22] = grid.ancestorMatrixI;

            // vertex: u_parent_viewport
            highp[i + 11] = grid.parentViewportX;
            highp[i + 15] = grid.parentViewportY;
            highp[i + 19] = grid.parentViewportW;
            highp[i + 23] = grid.parentViewportH;

            // vertex: u_grid_min
            highp[i + 24] = grid.minXST;
            highp[i + 25] = grid.minYST;
            highp[i + 26] = grid.minXPQ;
            highp[i + 27] = grid.minYPQ;
            // vertex: u_grid_max
            highp[i + 28] = grid.maxXST;
            highp[i + 29] = grid.maxYST;
            highp[i + 30] = grid.maxXPQ;
            highp[i + 31] = grid.maxYPQ;

            i = 52;
        }

        if (is_stroke) {
            // vertex: u_half_width
            highp[i]     = half_width;
            // vertex: u_face
            highp[i + 1] = face;
            // vertex: u_miter_limit
            highp[i + 2] = miter_limit;
        }

        const mediump = uniform.mediump;

        // fragment: u_uv
        mediump[0] = texture_width;
        mediump[1] = texture_height;

        // fragment: u_color_transform_mul
        mediump[4] = mul1;
        mediump[5] = mul2;
        mediump[6] = mul3;
        mediump[7] = mul4;
        // fragment: u_color_transform_add
        mediump[8]  = add1;
        mediump[9]  = add2;
        mediump[10] = add3;
        mediump[11] = add4;
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {boolean} hasGrid
     * @param {number}  matrix_a
     * @param {number}  matrix_b
     * @param {number}  matrix_c
     * @param {number}  matrix_d
     * @param {number}  matrix_e
     * @param {number}  matrix_f
     * @param {number}  matrix_g
     * @param {number}  matrix_h
     * @param {number}  matrix_i
     * @param {number}  viewport_width
     * @param {number}  viewport_height
     * @param {CanvasToWebGLContextGrid} grid
     * @method
     * @public
     */
    setMaskShapeUniform (
        uniform, hasGrid,
        matrix_a, matrix_b, matrix_c,
        matrix_d, matrix_e, matrix_f,
        matrix_g, matrix_h, matrix_i,
        viewport_width, viewport_height, grid
    ) {
        const highp = uniform.highp;

        if (hasGrid) {
            // vertex: u_parent_matrix
            highp[0]  = grid.parentMatrixA;
            highp[1]  = grid.parentMatrixB;
            highp[2]  = grid.parentMatrixC;

            highp[4]  = grid.parentMatrixD;
            highp[5]  = grid.parentMatrixE;
            highp[6]  = grid.parentMatrixF;

            highp[8]  = grid.parentMatrixG;
            highp[9]  = grid.parentMatrixH;
            highp[10] = grid.parentMatrixI;

            // vertex: u_ancestor_matrix
            highp[12] = grid.ancestorMatrixA;
            highp[13] = grid.ancestorMatrixB;
            highp[14] = grid.ancestorMatrixC;

            highp[16] = grid.ancestorMatrixD;
            highp[17] = grid.ancestorMatrixE;
            highp[18] = grid.ancestorMatrixF;

            highp[20] = grid.ancestorMatrixG;
            highp[21] = grid.ancestorMatrixH;
            highp[22] = grid.ancestorMatrixI;

            // vertex: u_viewport
            highp[3]  = viewport_width;
            highp[7]  = viewport_height;

            // vertex: u_parent_viewport
            highp[11] = grid.parentViewportX;
            highp[15] = grid.parentViewportY;
            highp[19] = grid.parentViewportW;
            highp[23] = grid.parentViewportH;

            // vertex: u_grid_min
            highp[24] = grid.minXST;
            highp[25] = grid.minYST;
            highp[26] = grid.minXPQ;
            highp[27] = grid.minYPQ;
            // vertex: u_grid_max
            highp[28] = grid.maxXST;
            highp[29] = grid.maxYST;
            highp[30] = grid.maxXPQ;
            highp[31] = grid.maxYPQ;
        } else {
            // vertex: u_matrix
            highp[0]  = matrix_a;
            highp[1]  = matrix_b;
            highp[2]  = matrix_c;

            highp[4]  = matrix_d;
            highp[5]  = matrix_e;
            highp[6]  = matrix_f;

            highp[8]  = matrix_g;
            highp[9]  = matrix_h;
            highp[10] = matrix_i;

            // vertex: u_viewport
            highp[3] = viewport_width;
            highp[7] = viewport_height;
        }
    }

    /**
     * @param {WebGLShaderUniform} uniform
     * @param {number} width
     * @param {number} height
     * @method
     * @public
     */
    setMaskShapeUniformIdentity (uniform, width, height)
    {
        const highp = uniform.highp;

        // vertex: u_matrix
        highp[0]  = 1;
        highp[1]  = 0;
        highp[2]  = 0;

        highp[4]  = 0;
        highp[5]  = 1;
        highp[6]  = 0;

        highp[8]  = 0;
        highp[9]  = 0;
        highp[10] = 1;

        // vertex: u_viewport
        highp[3] = width;
        highp[7] = height;
    }
}
/**
 * @class
 */
class FragmentShaderLibrary
{
    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_IS_INSIDE ()
    {
        return `

float isInside(in vec2 uv) {
    return step(4.0, dot(step(vec4(0.0, uv.x, 0.0, uv.y), vec4(uv.x, 1.0, uv.y, 1.0)), vec4(1.0)));
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_COLOR_TRANSFORM_ON (mediump_index)
    {
        return `
    vec4 mul = u_mediump[${mediump_index}];
    vec4 add = u_mediump[${mediump_index + 1}];

    src.rgb /= max(0.0001, src.a);
    src = clamp(src * mul + add, 0.0, 1.0);
    src.rgb *= src.a;
`;
    }
}

/**
 * @class
 */
class FragmentShaderSource
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SOLID_COLOR (k)
    {
        return `${k.version()}
precision mediump float;

uniform vec4 u_mediump;

${k.outColor()}

void main() {
    ${k.fragColor()} = vec4(u_mediump.rgb * u_mediump.a, u_mediump.a);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static BITMAP_CLIPPED (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_texture;
uniform vec4 u_mediump[3];

${k.varyingIn()} vec2 v_uv;
${k.outColor()}

void main() {
    vec2 uv = vec2(v_uv.x, u_mediump[0].y - v_uv.y) / u_mediump[0].xy;

    vec4 src = ${k.texture2D()}(u_texture, uv);
    ${FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(1)}
    ${k.fragColor()} = src;
}`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static BITMAP_PATTERN (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_texture;
uniform vec4 u_mediump[3];

${k.varyingIn()} vec2 v_uv;
${k.outColor()}

void main() {
    vec2 uv = fract(vec2(v_uv.x, -v_uv.y) / u_mediump[0].xy);
    
    vec4 src = ${k.texture2D()}(u_texture, uv);
    ${FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(1)}
    ${k.fragColor()} = src;
}`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static MASK (k)
    {
        return `${k.version()}
${k.extensionDerivatives()}
precision mediump float;

${k.varyingIn()} vec2 v_bezier;
${k.outColor()}

void main() {
    vec2 px = dFdx(v_bezier);
    vec2 py = dFdy(v_bezier);

    vec2 f = (2.0 * v_bezier.x) * vec2(px.x, py.x) - vec2(px.y, py.y);
    float alpha = 0.5 - (v_bezier.x * v_bezier.x - v_bezier.y) / length(f);

    if (alpha > 0.0) {
        ${k.fragColor()} = vec4(min(alpha, 1.0));
    } else {
        discard;
    }    
}

`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceBitmapData
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static FILL_COLOR (k)
    {
        return `${k.version()}
precision mediump float;

uniform vec4 u_mediump;

${k.outColor()}

void main() {
    ${k.fragColor()} = u_mediump;
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static COPY_SRC_TEX (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    ${k.fragColor()} = ${k.texture2D()}(u_src_tex, v_src_tex_coord);
}

`;
    }

    /**
     * @param  {boolean} transparent
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static COPY_CHANNEL (transparent, k)
    {
        transparent |= 0;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[2];
uniform vec4 u_mediump[2];

${k.varyingIn()} vec2 v_src_tex_coord;
${k.varyingIn()} vec2 v_dst_tex_coord;
${k.outColor()}

void main() {
    vec4 src_ch = u_mediump[0];
    vec4 dst_ch = u_mediump[1];

    vec4 src_color = ${k.texture2D()}(u_textures[0], v_src_tex_coord);
    vec4 dst_color = ${k.texture2D()}(u_textures[1], v_dst_tex_coord);

    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);
    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);

    // src_color から必要なチャンネルのスカラー値を取り出したもの
    float src_value = dot(src_color, src_ch);

    // コピー先の他のチャンネルと合成
    vec4 mixed = mix(dst_color, vec4(src_value), dst_ch);

#if ${transparent}
    ${k.fragColor()} = vec4(mixed.rgb * mixed.a, mixed.a);
#else
    ${k.fragColor()} = vec4(mixed.rgb, 1.0);
#endif
}

`;
    }

    /**
     * @param  {boolean} transparent
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static MERGE (transparent, k)
    {
        transparent |= 0;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[2];
uniform vec4 u_mediump;

${k.varyingIn()} vec2 v_src_tex_coord;
${k.varyingIn()} vec2 v_dst_tex_coord;
${k.outColor()}

void main() {
    vec4 src_color = ${k.texture2D()}(u_textures[0], v_src_tex_coord);
    vec4 dst_color = ${k.texture2D()}(u_textures[1], v_dst_tex_coord);

    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);
    dst_color = vec4(dst_color.rgb/max(0.0001, dst_color.a), dst_color.a);

    vec4 merged = mix(dst_color, src_color, u_mediump);

#if ${transparent}
    ${k.fragColor()} = vec4(merged.rgb * merged.a, merged.a);
#else
    ${k.fragColor()} = vec4(merged.rgb, 1.0);
#endif
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static COPY_PIXELS_WITH_ALPHA_BITMAP_DATA (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[2];

${k.varyingIn()} vec2 v_src_tex_coord;
${k.varyingIn()} vec2 v_alpha_tex_coord;
${k.outColor()}

void main() {
    vec4 src_color = ${k.texture2D()}(u_textures[0], v_src_tex_coord);
    float alpha = ${k.texture2D()}(u_textures[1], v_alpha_tex_coord).a;

    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);
    alpha *= src_color.a;

    ${k.fragColor()} = vec4(src_color.rgb * alpha, alpha);
}

`;
    }

    /**
     * @param  {boolean} transparent
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static PALETTE_MAP (transparent, k)
    {
        transparent |= 0;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[2];

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    vec4 src_color = ${k.texture2D()}(u_textures[0], v_src_tex_coord);
    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);

                                                // ↓ 256*4のテクスチャの画素の中心をサンプリング
    vec4 map_r = ${k.texture2D()}(u_textures[1], vec2((0.5+src_color.r*255.0)/256.0, 0.125));
    vec4 map_g = ${k.texture2D()}(u_textures[1], vec2((0.5+src_color.g*255.0)/256.0, 0.375));
    vec4 map_b = ${k.texture2D()}(u_textures[1], vec2((0.5+src_color.b*255.0)/256.0, 0.625));
    vec4 map_a = ${k.texture2D()}(u_textures[1], vec2((0.5+src_color.a*255.0)/256.0, 0.875));

    // u_plt_tex(u_textures[1]) のパレットデータは BGRA で格納されているので、これを取り出すには .bgra
    // TODO プラットフォームのバイトオーダーがビッグエンディアンの場合は ARGB で格納されるので、これを取り出すには .gbar
    vec4 color = (map_r + map_g + map_b + map_a).bgra;

    // fract は 1.0, 2.0, ... のときに 0.0 を返すが 1.0 が欲しい
    vec4 color_fract = fract(color);
    color = color_fract + sign(color) - sign(color_fract);

#if ${transparent}
    ${k.fragColor()} = vec4(color.rgb * color.a, color.a);
#else
    ${k.fragColor()} = vec4(color.rgb, 1.0);
#endif
}

`;
    }

    /**
     * @param  {boolean} transparent
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static PIXEL_DISSOLVE_TEXTURE (transparent, k)
    {
        transparent |= 0;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    vec4 src_color = ${k.texture2D()}(u_src_tex, v_src_tex_coord);

#if ${transparent}
    ${k.fragColor()} = src_color;
#else
    ${k.fragColor()} = vec4(src_color.rgb, 1.0);
#endif
}

`;
    }

    /**
     * @param  {boolean} transparent
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static COLOR_TRANSFORM (transparent, k)
    {
        transparent |= 0;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;
uniform vec4 u_mediump[2];

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    vec4 ct_mul = u_mediump[0];
    vec4 ct_add = u_mediump[1];

    vec4 src_color = ${k.texture2D()}(u_src_tex, v_src_tex_coord);
    src_color = vec4(src_color.rgb/max(0.0001, src_color.a), src_color.a);

    vec4 color = clamp(ct_mul * src_color + ct_add, 0.0, 1.0);

    color = vec4(color.rgb * color.a, color.a);

#if !${transparent}
    color.a = 1.0;
#endif

    ${k.fragColor()} = color * sign(src_color.a);  // 元の色が無色透明の場合、結果も常に無色透明になる。
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static bitwiseAnd() {
        return `
#if __VERSION__ < 130
// 8bitまでの整数どうしのビット積
int bitwiseAnd(int a, int b) {
    //ivec4 c1 = ivec4(1,2,4,8);
    //ivec4 c2 = ivec4(16,32,64,128);

    //ivec4 a1 = ivec4(a) / c1;
    //ivec4 a2 = ivec4(a) / c2;
    //ivec4 b1 = ivec4(b) / c1;
    //ivec4 b2 = ivec4(b) / c2;

    //ivec4 r = (a1-a1/2*2) * (b1-b1/2*2) * c1
    //        + (a2-a2/2*2) * (b2-b2/2*2) * c2;

    //return r.x + r.y + r.z + r.w;

    // ↑ intのままで計算した場合（rakusanの開発環境ではintの方が遅かった）
    // ↓ floatに変換してから計算した場合

    vec4 a0 = vec4(float(a));
    vec4 b0 = vec4(float(b));
    vec4 a1 = floor(a0 * vec4(1.0, 0.5, 0.25, 0.125));
    vec4 a2 = floor(a0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));
    vec4 b1 = floor(b0 * vec4(1.0, 0.5, 0.25, 0.125));
    vec4 b2 = floor(b0 * vec4(0.0625, 0.03125, 0.015625, 0.0078125));

    return int(dot((a1-floor(a1*0.5)*2.0)*(b1-floor(b1*0.5)*2.0), vec4(1.0,2.0,4.0,8.0))
             + dot((a2-floor(a2*0.5)*2.0)*(b2-floor(b2*0.5)*2.0), vec4(16.0,32.0,64.0,128.0)));
}

ivec4 bitwiseAnd(ivec4 a, ivec4 b) {
    return ivec4(bitwiseAnd(a.r, b.r),
                 bitwiseAnd(a.g, b.g),
                 bitwiseAnd(a.b, b.b),
                 bitwiseAnd(a.a, b.a));
}
#else
#define bitwiseAnd(a, b) ((a)&(b))
#endif
`;
    }

    /**
     * @param  {string} operation
     * @param  {boolean} copy_source
     * @param  {boolean} transparent
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static THRESHOLD (operation, copy_source, transparent, k)
    {
        copy_source |= 0;
        transparent |= 0;

        return `${k.version()}
#if __VERSION__ < 130
#extension GL_EXT_draw_buffers : require
#endif

precision mediump float;

uniform sampler2D u_src_tex;
uniform vec4 u_mediump[2]; // u_threshold(u_mediump[0]) はJS側でマスク済み
uniform ivec4 u_integer;

${k.varyingIn()} vec2 v_src_tex_coord;

#if __VERSION__ < 130
#define outColor0 gl_FragData[0]
#define outColor1 gl_FragData[1]
#else
layout (location = 0) out vec4 outColor0;
layout (location = 1) out vec4 outColor1;
#endif

${FragmentShaderSourceBitmapData.bitwiseAnd()}

bool less(vec4 x) {
    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) < 0.0;
}

bool greater(vec4 x) {
    return dot(sign(x - u_mediump[0]), vec4(4.0, 2.0, 1.0, 8.0)) > 0.0;
}

bool lessEqual(vec4 x) {
    return !greater(x);
}

bool greaterEqual(vec4 x) {
    return !less(x);
}

// 組込関数に equal があるので thresholdEqual にしている。
bool thresholdEqual(vec4 x) {
    return all(equal(x, u_mediump[0]));
}

// 組込関数に notEqual があるので thresholdNotEqual にしている。
bool thresholdNotEqual(vec4 x) {
    return any(notEqual(x, u_mediump[0]));
}

void main() {
    // 乗算済みのままで比較するとFlash Playerと一致する。

    vec4 src_color = ${k.texture2D()}(u_src_tex, v_src_tex_coord);
    ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), u_integer);

    if (${operation}(vec4(masked))) {
        outColor0 = u_mediump[1];
        outColor1 = vec4(1.0);
    } else {
#if ${copy_source}
    #if ${transparent}
        outColor0 = src_color;
    #else
        outColor0 = vec4(src_color.rgb, 1.0);
    #endif
        outColor1 = vec4(0.0);
#else
        discard;
#endif
    }
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static THRESHOLD_SUBTOTAL (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;
uniform vec4 u_mediump;

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    vec2 src_tex_step   = u_mediump.xy;
    float subtotal_loop = u_mediump.z;

    float subtotal = 0.0;

#if __VERSION__ < 130
    float j = 0.0;
    for (float i = 0.0; i < 4095.0; ++i) {      // この 4095.0 というマジックナンバーについては
        if (j++ >= subtotal_loop) {           // BitmapData.prototype.threshold のコメントを見てください。
            break;
        }
#else
    for (float i = 0.0; i < subtotal_loop; ++i) {
#endif
        subtotal += ${k.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i).a;
    }

    vec4 v1 = floor(subtotal * vec4(1.0, 0.00390625, 0.0000152587890625, 5.960464477539063e-8));  // vec4(1.0, 1.0/256.0, 1.0/65536.0, 1.0/16777216.0)
    vec4 v2 = vec4(v1.yzw, 0.0);
    ${k.fragColor()} = (v1 - v2*256.0) * 0.00392156862745098;  // 1.0/255.0
}

`;
    }

    /**
     * @param  {boolean} find_color
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static GET_COLOR_BOUNDS_RECT (find_color, k)
    {
        find_color |= 0;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;
uniform vec4 u_mediump;
uniform ivec4 u_integer[2];

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

${FragmentShaderSourceBitmapData.bitwiseAnd()}

void main() {
    vec2 src_tex_step = u_mediump.xy;
    float scan_loop   = u_mediump.z;
    ivec4 mask  = u_integer[0];
    ivec4 color = u_integer[1];

    float found = 0.0;

#if __VERSION__ < 130
    float j = 0.0;
    for (float i = 0.0; i < 8191.0; ++i) {      // BitmapData の幅または高さの最大サイズは 8191 ピクセル
        if (j++ >= scan_loop) {
            break;
        }
#else
    for (float i = 0.0; i < scan_loop; ++i) {
#endif
        vec4 src_color = ${k.texture2D()}(u_src_tex, v_src_tex_coord + src_tex_step * i);
        ivec4 masked = bitwiseAnd(ivec4(src_color * 255.0), mask);

#if ${find_color}
        if (all(equal(masked, color))) {
#else
        if (any(notEqual(masked, color))) {
#endif
            found = 1.0;
            break;
        }
    }

    ${k.fragColor()} = vec4(found);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static NOISE (k)
    {
        return `${k.version()}
precision mediump float;

uniform vec4 u_mediump[3];

${k.outColor()}

// https://stackoverflow.com/a/28095165
//
// Gold Noise ©2015 dcerisano@standard3d.com
// - based on the Golden Ratio
// - uniform normalized distribution
// - fastest static noise generator function (also runs at low precision)

float PHI = 1.61803398874989484820459;  // Φ = Golden Ratio

vec4 gold_noise(vec2 xy, vec4 seed) {
    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

void main() {
    vec4 seed = u_mediump[0];
    vec4 amp  = u_mediump[1];
    vec4 low  = u_mediump[2];

    vec4 noise = gold_noise(gl_FragCoord.xy, seed);
    vec4 color = noise * amp + low;
    ${k.fragColor()} = vec4(color.rgb * color.a, color.a);
}

`;
    }

    /**
     * @param  {string} byte_order
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static GET_PIXELS (byte_order, k)
    {
        switch (byte_order) {
            case "RGBA":
                byte_order = 1;
                break;
            case "BGRA":
                byte_order = 2;
                break;
            default: // ARGB
                byte_order = 0;
                break;
        }

        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    vec4 color = ${k.texture2D()}(u_src_tex, v_src_tex_coord);

#if ${byte_order} == 1  // RGBA
    ${k.fragColor()} = vec4(color.rgb / max(0.0001, color.a), color.a);
#elif ${byte_order} == 2  // BGRA
    ${k.fragColor()} = vec4(color.bgr / max(0.0001, color.a), color.a);
#else  // ARGB
    ${k.fragColor()} = vec4(color.a, color.rgb / max(0.0001, color.a));
#endif
}

`;
    }

    /**
     * @param  {string} byte_order
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SET_PIXELS (byte_order, k)
    {
        switch (byte_order) {
            case "RGBA":
                byte_order = 1;
                break;
            case "BGRA":
                byte_order = 2;
                break;
            default: // ARGB
                byte_order = 0;
                break;
        }

        return `${k.version()}
precision mediump float;

uniform sampler2D u_src_tex;

${k.varyingIn()} vec2 v_src_tex_coord;
${k.outColor()}

void main() {
    vec4 color = ${k.texture2D()}(u_src_tex, v_src_tex_coord);

#if ${byte_order} == 1  // RGBA
    ${k.fragColor()} = vec4(color.rgb * color.a, color.a);
#elif ${byte_order} == 2  // BGRA
    ${k.fragColor()} = vec4(color.bgr * color.a, color.a);
#else  // ARGB
    ${k.fragColor()} = vec4(color.gba * color.r, color.r);
#endif
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SET_PIXEL_QUEUE (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_dst_tex;

${k.varyingIn()} vec2 v_dst_tex_coord;
${k.varyingIn()} vec4 v_color;
${k.outColor()}

void main() {
    float da = ${k.texture2D()}(u_dst_tex, v_dst_tex_coord).a;
    float a = v_color.a;

    ${k.fragColor()} = max( a, 0.0) * v_color
                     + max(-a, 0.0) * vec4(v_color.rgb * da, da);
}

`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceBlend
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {string}  operation
     * @param  {boolean} with_color_transform
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, operation, with_color_transform)
    {
        let blendFunction;
        switch (operation) {
            case BlendMode.SUBTRACT:
                blendFunction = this.FUNCTION_SUBTRACT();
                break;
            case BlendMode.MULTIPLY:
                blendFunction = this.FUNCTION_MULTIPLY();
                break;
            case BlendMode.LIGHTEN:
                blendFunction = this.FUNCTION_LIGHTEN();
                break;
            case BlendMode.DARKEN:
                blendFunction = this.FUNCTION_DARKEN();
                break;
            case BlendMode.OVERLAY:
                blendFunction = this.FUNCTION_OVERLAY();
                break;
            case BlendMode.HARDLIGHT:
                blendFunction = this.FUNCTION_HARDLIGHT();
                break;
            case BlendMode.DIFFERENCE:
                blendFunction = this.FUNCTION_DIFFERENCE();
                break;
            case BlendMode.INVERT:
                blendFunction = this.FUNCTION_INVERT();
                break;
            default:
                blendFunction = this.FUNCTION_NORMAL();
                break;
        }

        const colorTransformUniform = with_color_transform
            ? "uniform vec4 u_mediump[2];"
            : "";
        const colorTransformStatement = with_color_transform
            ? FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(0)
            : "";

        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[2];
${colorTransformUniform}

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

${blendFunction}

void main() {
    vec4 dst = ${k.texture2D()}(u_textures[0], v_coord);
    vec4 src = ${k.texture2D()}(u_textures[1], v_coord);
    ${colorTransformStatement}
    ${k.fragColor()} = blend(src, dst);
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_NORMAL ()
    {
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    return src + dst - dst * src.a;
}

`;
    }

    // 各ブレンド式は、前景と背景の両方のアルファを考慮する必要がある
    // https://odashi.hatenablog.com/entry/20110921/1316610121
    // https://hakuhin.jp/as3/blend.html
    //
    // [基本計算式]
    // ・色(rgb)はストレートアルファ
    // ・アルファ(a)が0の場合は例外処理をする
    // 前景色 a: src.rgb * (src.a * (1.0 - dst.a))
    // 背景色 b: dst.rgb * (dst.a * (1.0 - src.a))
    // 合成色 c: mix.rgb * (src.a * dst.a)
    // 最終結果: a + b + c

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_SUBTRACT ()
    {
        // [合成色計算式]
        // dst - src
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;

    src.rgb /= src.a;
    dst.rgb /= dst.a;

    vec4 c = vec4(dst.rgb - src.rgb, src.a * dst.a);
    c.rgb *= c.a;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_MULTIPLY ()
    {
        // [合成色計算式]
        // src * dst
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;
    vec4 c = src * dst;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_LIGHTEN ()
    {
        // [合成色計算式]
        // (src > dst) ? src : dst
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;

    src.rgb /= src.a;
    dst.rgb /= dst.a;

    vec4 c = vec4(mix(src.rgb, dst.rgb, step(src.rgb, dst.rgb)), src.a * dst.a);
    c.rgb *= c.a;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_DARKEN ()
    {
        // [合成色計算式]
        // (src < dst) ? src : dst
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;

    src.rgb /= src.a;
    dst.rgb /= dst.a;

    vec4 c = vec4(mix(src.rgb, dst.rgb, step(dst.rgb, src.rgb)), src.a * dst.a);
    c.rgb *= c.a;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_OVERLAY ()
    {
        // [合成色計算式]
        // if (dst < 0.5) {
        //     return 2.0 * src * dst
        // } else {
        //     return 1.0 - 2.0 * (1.0 - src) * (1.0 - dst)
        // }
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;

    src.rgb /= src.a;
    dst.rgb /= dst.a;

    vec4 mul = src * dst;
    vec3 c1 = 2.0 * mul.rgb;
    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;
    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), dst.rgb)), mul.a);
    c.rgb *= c.a;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_HARDLIGHT ()
    {
        // [合成色計算式]
        // if (src < 0.5) {
        //     return 2.0 * src * dst
        // } else {
        //     return 1.0 - 2.0 * (1.0 - src) * (1.0 - dst)
        // }
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;

    src.rgb /= src.a;
    dst.rgb /= dst.a;

    vec4 mul = src * dst;
    vec3 c1 = 2.0 * mul.rgb;
    vec3 c2 = 2.0 * (src.rgb + dst.rgb - mul.rgb) - 1.0;
    vec4 c = vec4(mix(c1, c2, step(vec3(0.5), src.rgb)), mul.a);
    c.rgb *= c.a;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_DIFFERENCE ()
    {
        // [合成色計算式]
        // abs(src - dst)
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 a = src - src * dst.a;
    vec4 b = dst - dst * src.a;

    src.rgb /= src.a;
    dst.rgb /= dst.a;

    vec4 c = vec4(abs(src.rgb - dst.rgb), src.a * dst.a);
    c.rgb *= c.a;

    return a + b + c;
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_INVERT ()
    {
        // [基本計算式]
        // ((1.0 - dst) * src.a) + (dst * (1.0 - src.a))
        return `

vec4 blend (in vec4 src, in vec4 dst) {
    if (src.a == 0.0) { return dst; }
    if (dst.a == 0.0) { return src; }

    vec4 b = dst - dst * src.a;
    vec4 c = vec4(src.a - dst.rgb * src.a, src.a);

    return b + c;
}

`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceGradient
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number}  highp_length
     * @param  {number}  fragment_index
     * @param  {boolean} is_radial
     * @param  {boolean} has_focal_point
     * @param  {string}  spread_method
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, highp_length, fragment_index, is_radial, has_focal_point, spread_method)
    {
        const gradientTypeStatement = is_radial
            ? this.STATEMENT_GRADIENT_TYPE_RADIAL(fragment_index, has_focal_point)
            : this.STATEMENT_GRADIENT_TYPE_LINEAR(fragment_index);

        let spread_methodExpression;
        switch (spread_method) {
            case "reflect":
                spread_methodExpression = "1.0 - abs(fract(t * 0.5) * 2.0 - 1.0)";
                break;
            case "repeat":
                spread_methodExpression = "fract(t)";
                break;
            default:
                spread_methodExpression = "clamp(t, 0.0, 1.0)";
                break;
        }

        return `${k.version()}
precision highp float;

uniform sampler2D u_texture;
uniform vec4 u_highp[${highp_length}];

${k.varyingIn()} vec2 v_uv;
${k.outColor()}

void main() {
    vec2 p = v_uv;
    ${gradientTypeStatement}
    t = ${spread_methodExpression};
    ${k.fragColor()} = ${k.texture2D()}(u_texture, vec2(t, 0.5));
}

`;
    }

    /**
     * @param  {number} index
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_GRADIENT_TYPE_LINEAR (index)
    {
        return `
    vec2 a = u_highp[${index}].xy;
    vec2 b = u_highp[${index}].zw;

    vec2 ab = b - a;
    vec2 ap = p - a;

    float t = dot(ab, ap) / dot(ab, ab);
`;
    }

    /**
     * @param  {number}  index
     * @param  {boolean} has_focal_point
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_GRADIENT_TYPE_RADIAL (index, has_focal_point)
    {
        const focalPointStatement = has_focal_point
            ? this.STATEMENT_FOCAL_POINT_ON(index)
            : this.STATEMENT_FOCAL_POINT_OFF();
        return `
    float radius = u_highp[${index}][0];

    vec2 coord = p / radius;
    ${focalPointStatement}
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_FOCAL_POINT_OFF ()
    {
        return `
    float t = length(coord);
`;
    }

    /**
     * @param  {number} index
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_FOCAL_POINT_ON (index)
    {
        return `
    vec2 focal = vec2(u_highp[${index}][1], 0.0);

    vec2 dir = normalize(coord - focal);

    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, focal);
    float c = dot(focal, focal) - 1.0;
    float x = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);

    float t = distance(focal, coord) / distance(focal, focal + dir * x);
`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceGradientLUT
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number}  mediump_length
     * @param  {number}  stops_length
     * @param  {boolean} is_linear_space
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, mediump_length, stops_length, is_linear_space)
    {
        let loopStatement = "";
        for (let i = 1; i < stops_length; i++) {
            const i0 = i - 1;
            const i1 = i;
            const t0 = `u_mediump[${stops_length + $Math.floor(i0 / 4)}][${i0 % 4}]`;
            const t1 = `u_mediump[${stops_length + $Math.floor(i1 / 4)}][${i1 % 4}]`;
            const c0 = `u_mediump[${i0}]`;
            const c1 = `u_mediump[${i1}]`;
            loopStatement += `
    if (t <= ${t1}) {
        return mix(${c0}, ${c1}, (t - ${t0}) / (${t1} - ${t0}));
    }
`;
        }

        const colorSpaceStatement = is_linear_space
            ? "color = pow(color, vec4(0.45454545));"
            : "";

        return `${k.version()}
precision mediump float;

uniform vec4 u_mediump[${mediump_length}];

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

vec4 getGradientColor(in float t) {
    if (t <= u_mediump[${stops_length}][0]) {
        return u_mediump[0];
    }
    ${loopStatement}
    return u_mediump[${stops_length - 1}];
}

void main() {
    vec4 color = getGradientColor(v_coord.x);
    ${colorSpaceStatement}
    color.rgb *= color.a;

    ${k.fragColor()} = color;
}

`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceTexture
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {boolean} with_color_transform
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, with_color_transform)
    {
        const colorTransformUniform = with_color_transform
            ? "uniform vec4 u_mediump[2];"
            : "";
        const colorTransformStatement = with_color_transform
            ? FragmentShaderLibrary.STATEMENT_COLOR_TRANSFORM_ON(0)
            : "";

        return `${k.version()}
precision mediump float;

uniform sampler2D u_texture;
${colorTransformUniform}

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

void main() {
    vec4 src = ${k.texture2D()}(u_texture, v_coord);
    ${colorTransformStatement}
    ${k.fragColor()} = src;
}

`;
    }
}
/**
 * @class
 */
class VertexShaderLibrary
{
    /**
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_GRID_OFF ()
    {
        return `

vec2 applyMatrix(in vec2 vertex) {
    mat3 matrix = mat3(
        u_highp[0].xyz,
        u_highp[1].xyz,
        u_highp[2].xyz
    );

    vec2 position = (matrix * vec3(vertex, 1.0)).xy;

    return position;
}

`;
    }

    /**
     * @param  {number} index
     * @return {string}
     * @method
     * @static
     */
    static FUNCTION_GRID_ON (index)
    {
        return `

vec2 applyMatrix(in vec2 vertex) {
    mat3 parent_matrix = mat3(
        u_highp[${index    }].xyz,
        u_highp[${index + 1}].xyz,
        u_highp[${index + 2}].xyz
    );
    mat3 ancestor_matrix = mat3(
        u_highp[${index + 3}].xyz,
        u_highp[${index + 4}].xyz,
        u_highp[${index + 5}].xyz
    );
    vec2 parent_offset = vec2(u_highp[${index + 2}].w, u_highp[${index + 3}].w);
    vec2 parent_size   = vec2(u_highp[${index + 4}].w, u_highp[${index + 5}].w);
    vec4 grid_min = u_highp[${index + 6}];
    vec4 grid_max = u_highp[${index + 7}];

    vec2 position = (parent_matrix * vec3(vertex, 1.0)).xy;
    position = (position - parent_offset) / parent_size;

    vec4 ga = grid_min;
    vec4 gb = grid_max  - grid_min;
    vec4 gc = vec4(1.0) - grid_max;

    vec2 pa = position;
    vec2 pb = position - grid_min.st;
    vec2 pc = position - grid_max.st;

    position = (ga.pq / ga.st) * min(pa, ga.st)
             + (gb.pq / gb.st) * clamp(pb, vec2(0.0), gb.st)
             + (gc.pq / gc.st) * max(vec2(0.0), pc);

    position = position * parent_size + parent_offset;
    position = (ancestor_matrix * vec3(position, 1.0)).xy;

    return position;
}

`;
    }
}
/**
 * @class
 */
class VertexShaderSource
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static TEXTURE (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

${k.varyingOut()} vec2 v_coord;

void main() {
    v_coord = a_vertex;

    vec2 position = a_vertex * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static BLEND (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform vec4 u_highp[4];

${k.varyingOut()} vec2 v_coord;

void main() {
    v_coord = a_vertex;

    vec2 offset   = u_highp[0].xy;
    vec2 size     = u_highp[0].zw;
    mat3 matrix   = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);
    vec2 viewport = vec2(u_highp[1].w, u_highp[2].w);

    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);
    position = position * size + offset;
    position = (matrix * vec3(position, 1.0)).xy;
    position /= viewport;

    position = position * 2.0 - 1.0;
    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static BLEND_CLIP (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform vec4 u_highp[4];

${k.varyingOut()} vec2 v_coord;

void main() {
    v_coord = a_vertex;

    vec2 offset     = u_highp[0].xy;
    vec2 size       = u_highp[0].zw;
    mat3 inv_matrix = mat3(u_highp[1].xyz, u_highp[2].xyz, u_highp[3].xyz);
    vec2 viewport   = vec2(u_highp[1].w, u_highp[2].w);

    vec2 position = vec2(a_vertex.x, 1.0 - a_vertex.y);
    position *= viewport;
    position = (inv_matrix * vec3(position, 1.0)).xy;
    position = (position - offset) / size;

    position = position * 2.0 - 1.0;
    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);
}

`;
    }
}
/**
 * @class
 */
class VertexShaderSourceBitmapData
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static POSITION_ONLY (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform vec4 u_highp[3];

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);

    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SRC_AND_DST_TEX_COORD (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform vec4 u_highp[5];

${k.varyingOut()} vec2 v_src_tex_coord;
${k.varyingOut()} vec2 v_dst_tex_coord;

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);
    mat3 src_tex_matrix = mat3(
        u_highp[3].xyz,
        u_highp[4].xyz,
        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)
    );

    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;
    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);

    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SRC_TEX_COORD (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform vec4 u_highp[5];

${k.varyingOut()} vec2 v_src_tex_coord;

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);
    mat3 src_tex_matrix = mat3(
        u_highp[3].xyz,
        u_highp[4].xyz,
        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)
    );

    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;

    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SRC_AND_ALPHA_TEX_COORD (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform vec4 u_highp[7];

${k.varyingOut()} vec2 v_src_tex_coord;
${k.varyingOut()} vec2 v_alpha_tex_coord;

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);
    mat3 src_tex_matrix = mat3(u_highp[3].xyz, u_highp[4].xyz, u_highp[5].xyz);
    mat3 alpha_tex_matrix = mat3(
        u_highp[6].xyz,
        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w),
        vec3(u_highp[3].w, u_highp[4].w, u_highp[5].w)
    );

    v_src_tex_coord = (src_tex_matrix * vec3(a_vertex, 1.0)).xy;
    v_alpha_tex_coord = (alpha_tex_matrix * vec3(a_vertex, 1.0)).xy;

    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static PIXEL_DISSOLVE_COLOR (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform mat3 u_highp[3];

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);

    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);

    gl_PointSize = 1.0;
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static PIXEL_DISSOLVE_TEXTURE (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;

uniform mat3 u_highp[5];

${k.varyingOut()} vec2 v_src_tex_coord;

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);
    mat3 src_tex_matrix = mat3(
        u_highp[3].xyz,
        u_highp[4].xyz,
        vec3(u_highp[0].w, u_highp[1].w, u_highp[2].w)
    );

    v_src_tex_coord = (u_src_tex_matrix * vec3(a_vertex, 1.0)).xy;

    vec2 position = (u_matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);

    gl_PointSize = 1.0;
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static SET_PIXEL_QUEUE (k)
    {
        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;
${k.attribute(1)} vec4 a_color;

uniform mat3 u_highp[3];

${k.varyingOut()} vec2 v_dst_tex_coord;
${k.varyingOut()} vec4 v_color;

void main() {
    mat3 matrix = mat3(u_highp[0].xyz, u_highp[1].xyz, u_highp[2].xyz);

    v_dst_tex_coord = vec2(a_vertex.x, 1.0 - a_vertex.y);
    v_color = a_color;

    vec2 position = (matrix * vec3(a_vertex, 1.0)).xy * 2.0 - 1.0;
    gl_Position = vec4(position, 0.0, 1.0);
}

`;
    }
}
/**
 * @class
 */
class VertexShaderSourceFill
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number}  highp_length
     * @param  {boolean} with_uv
     * @param  {boolean} for_mask
     * @param  {boolean} has_grid
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, highp_length, with_uv, for_mask, has_grid)
    {
        const bezierAttribute = for_mask
            ? this.ATTRIBUTE_BEZIER_ON(k)
            : "";
        const uvVarying =
              for_mask ? this.VARYING_BEZIER_ON(k)
                  : with_uv  ? this.VARYING_UV_ON(k)
                      : "";
        const uvStatement =
              for_mask ? this.STATEMENT_BEZIER_ON()
                  : with_uv  ? this.STATEMENT_UV_ON()
                      : "";
        const gridFunction = has_grid
            ? VertexShaderLibrary.FUNCTION_GRID_ON(with_uv ? 5 : 0)
            : VertexShaderLibrary.FUNCTION_GRID_OFF();

        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;
${bezierAttribute}

uniform vec4 u_highp[${highp_length}];

${uvVarying}

${gridFunction}

void main() {
    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);

    ${uvStatement}

    vec2 pos = applyMatrix(a_vertex) / viewport;
    pos = pos * 2.0 - 1.0;
    gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     */
    static ATTRIBUTE_BEZIER_ON (k)
    {
        return `
${k.attribute(1)} vec2 a_bezier;
`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static VARYING_UV_ON (k)
    {
        return `
${k.varyingOut()} vec2 v_uv;
`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static VARYING_BEZIER_ON (k)
    {
        return `
${k.varyingOut()} vec2 v_bezier;
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_UV_ON ()
    {
        return `
    mat3 uv_matrix = mat3(
        u_highp[0].xyz,
        u_highp[1].xyz,
        u_highp[2].xyz
    );
    mat3 inverse_matrix = mat3(
        u_highp[3].xyz,
        u_highp[4].xyz,
        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)
    );

    v_uv = (inverse_matrix * uv_matrix * vec3(a_vertex, 1.0)).xy;
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BEZIER_ON ()
    {
        return `
    v_bezier = a_bezier;
`;
    }
}
/**
 * @class
 */
class VertexShaderSourceStroke
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number}  highp_length
     * @param  {number}  fragment_index
     * @param  {boolean} with_uv
     * @param  {boolean} has_grid
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, highp_length, fragment_index, with_uv, has_grid)
    {
        const strokeIndex = fragment_index - 1;

        const uvVarying = with_uv
            ? this.VARYING_UV_ON(k)
            : "";
        const uvStatement = with_uv
            ? this.STATEMENT_UV_ON()
            : "";
        const gridFunction = has_grid
            ? VertexShaderLibrary.FUNCTION_GRID_ON(with_uv ? 5 : 0)
            : VertexShaderLibrary.FUNCTION_GRID_OFF();

        return `${k.version()}

${k.attribute(0)} vec2 a_vertex;
${k.attribute(1)} vec2 a_option1;
${k.attribute(2)} vec2 a_option2;
${k.attribute(3)} float a_type;

uniform vec4 u_highp[${highp_length}];

${uvVarying}

${gridFunction}

float crossVec2(in vec2 v1, in vec2 v2) {
    return v1.x * v2.y - v2.x * v1.y;
}

vec2 perpendicularVec2(in vec2 v1) {
    float face = u_highp[${strokeIndex}][1];

    return face * vec2(v1.y, -v1.x);
}

vec2 calculateNormal(in vec2 direction) {
    vec2 normalized = normalize(direction);
    return perpendicularVec2(normalized);
}

vec2 calculateIntersection(in vec2 v1, in vec2 v2, in vec2 o1, in vec2 o2) {
    float t = crossVec2(o2 - o1, v2) / crossVec2(v1, v2);
    return (o1 + t * v1);
}

vec2 calculateAnchor(in vec2 position, in float convex, out vec2 v1, out vec2 v2, out vec2 o1, out vec2 o2) {
    float miter_limit = u_highp[${strokeIndex}][2];

    vec2 a = applyMatrix(a_option1);
    vec2 b = applyMatrix(a_option2);

    v1 = convex * (position - a);
    v2 = convex * (b - position);
    o1 = calculateNormal(v1) + a;
    o2 = calculateNormal(v2) + position;

    vec2 anchor = calculateIntersection(v1, v2, o1, o2) - position;
    return normalize(anchor) * min(length(anchor), miter_limit);
}

void main() {
    vec2 viewport = vec2(u_highp[0].w, u_highp[1].w);
    float half_width = u_highp[${strokeIndex}][0];

    vec2 position = applyMatrix(a_vertex);
    vec2 offset = vec2(0.0);
    vec2 v1, v2, o1, o2;

    if (a_type == 1.0 || a_type == 2.0) { // 線分
        offset = calculateNormal(a_option2 * (applyMatrix(a_option1) - position));
    } else if (a_type == 10.0) { // スクエア線端
        offset = normalize(position - applyMatrix(a_option1));
        offset += a_option2 * perpendicularVec2(offset);
    } else if (a_type == 21.0) { // マイター結合（線分Bの凸側）
        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);
        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;
    } else if (a_type == 22.0) { // マイター結合（線分Aの凸側）
        offset = calculateAnchor(position, 1.0, v1, v2, o1, o2);
        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;
    } else if (a_type == 23.0) { // マイター結合（線分Aの凹側）
        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);
        offset = calculateIntersection(v1, perpendicularVec2(offset), o1, position + offset) - position;
    } else if (a_type == 24.0) { // マイター結合（線分Bの凹側）
        offset = calculateAnchor(position, -1.0, v1, v2, o1, o2);
        offset = calculateIntersection(v2, perpendicularVec2(offset), o2, position + offset) - position;
    } else if (a_type >= 30.0) { // ラウンド結合
        float face = u_highp[${strokeIndex}][1];
        float rad = face * (a_type - 30.0) * 0.3488888889; /* 0.3488888889 = PI / 9.0 */
        offset = mat2(cos(rad), sin(rad), -sin(rad), cos(rad)) * vec2(1.0, 0.0);
    }
    
    offset *= half_width;
    position += offset;
    ${uvStatement}

    position /= viewport;
    position = position * 2.0 - 1.0;
    gl_Position = vec4(position.x, -position.y, 0.0, 1.0);
}

`;
    }

    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static VARYING_UV_ON (k)
    {
        return `
${k.varyingOut()} vec2 v_uv;
`;
    }

    /**
     * @return {string}
     */
    static STATEMENT_UV_ON ()
    {
        return `
    mat3 uv_matrix = mat3(
        u_highp[0].xyz,
        u_highp[1].xyz,
        u_highp[2].xyz
    );
    mat3 inverse_matrix = mat3(
        u_highp[3].xyz,
        u_highp[4].xyz,
        vec3(u_highp[2].w, u_highp[3].w, u_highp[4].w)
    );

    v_uv = (uv_matrix * vec3(a_vertex, 1.0)).xy;
    v_uv += offset;
    v_uv = (inverse_matrix * vec3(v_uv, 1.0)).xy;
`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceBlurFilter
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number} half_blur
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, half_blur)
    {
        const halfBlurFixed = half_blur.toFixed(1);

        return `${k.version()}
precision mediump float;

uniform sampler2D u_texture;
uniform vec4 u_mediump;

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

void main() {
    vec2  offset   = u_mediump.xy;
    float fraction = u_mediump.z;
    float samples  = u_mediump.w;
    
    vec4 color = ${k.texture2D()}(u_texture, v_coord);

    for (float i = 1.0; i < ${halfBlurFixed}; i += 1.0) {
        color += ${k.texture2D()}(u_texture, v_coord + offset * i);
        color += ${k.texture2D()}(u_texture, v_coord - offset * i);
    }
    color += ${k.texture2D()}(u_texture, v_coord + offset * ${halfBlurFixed}) * fraction;
    color += ${k.texture2D()}(u_texture, v_coord - offset * ${halfBlurFixed}) * fraction;
    color /= samples;

    ${k.fragColor()} = color;
}

`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceColorMatrixFilter
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k)
    {
        return `${k.version()}
precision mediump float;

uniform sampler2D u_texture;
uniform vec4 u_mediump[5];

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

void main() {
    mat4 mul = mat4(u_mediump[0], u_mediump[1], u_mediump[2], u_mediump[3]);
    vec4 add = u_mediump[4];
    
    vec4 color = ${k.texture2D()}(u_texture, v_coord);

    color.rgb /= max(0.0001, color.a);
    color = clamp(color * mul + add, 0.0, 1.0);
    color.rgb *= color.a;

    ${k.fragColor()} = color;
}

`;
    }
}
/**
 * @class
 */
class FragmentShaderSourceConvolutionFilter
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number}  mediump_length
     * @param  {number}  x
     * @param  {number}  y
     * @param  {boolean} preserve_alpha
     * @param  {boolean} clamp
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, mediump_length, x, y, preserve_alpha, clamp)
    {
        const halfX = $Math.floor(x * 0.5);
        const halfY = $Math.floor(y * 0.5);
        const size = x * y;

        let matrixStatement = "";
        const matrixIndex = clamp ? 1 : 2;
        for (let idx = 0; idx < size; ++idx) {
            const index     = matrixIndex + $Math.floor(idx / 4);
            const component = idx % 4;
            matrixStatement += `
    result += getWeightedColor(${idx}, u_mediump[${index}][${component}]);
`;
        }

        const preserve_alphaStatement = preserve_alpha
            ? `result.a = ${k.texture2D()}(u_texture, v_coord).a;`
            : "";
        const clampStatement = clamp
            ? ""
            : `
    vec4 substitute_color = u_mediump[1];
    color = mix(substitute_color, color, isInside(uv));
`;

        return `${k.version()}
precision mediump float;

uniform sampler2D u_texture;
uniform vec4 u_mediump[${mediump_length}];

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

${FragmentShaderLibrary.FUNCTION_IS_INSIDE()}

vec4 getWeightedColor (in int i, in float weight) {
    vec2 rcp_size = u_mediump[0].xy;

    int i_div_x = i / ${x};
    int i_mod_x = i - ${x} * i_div_x;
    vec2 offset = vec2(i_mod_x - ${halfX}, ${halfY} - i_div_x);
    vec2 uv = v_coord + offset * rcp_size;

    vec4 color = ${k.texture2D()}(u_texture, uv);
    color.rgb /= max(0.0001, color.a);
    ${clampStatement}

    return color * weight;
}

void main() {
    float rcp_divisor = u_mediump[0].z;
    float bias        = u_mediump[0].w;

    vec4 result = vec4(0.0);
    ${matrixStatement}
    result = clamp(result * rcp_divisor + bias, 0.0, 1.0);
    ${preserve_alphaStatement}

    result.rgb *= result.a;
    ${k.fragColor()} = result;
}

`;
    }
}

/**
 * @class
 */
class FragmentShaderSourceDisplacementMapFilter
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number} mediump_length
     * @param  {number} component_x
     * @param  {number} component_y
     * @param  {string} mode
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (k, mediump_length, component_x, component_y, mode)
    {
        let cx, cy, modeStatement;

        switch (component_x) {
            case BitmapDataChannel.RED:
                cx = "map_color.r";
                break;
            case BitmapDataChannel.GREEN:
                cx = "map_color.g";
                break;
            case BitmapDataChannel.BLUE:
                cx = "map_color.b";
                break;
            case BitmapDataChannel.ALPHA:
                cx = "map_color.a";
                break;
            default:
                cx = "0.5";
                break;
        }

        switch (component_y) {
            case BitmapDataChannel.RED:
                cy = "map_color.r";
                break;
            case BitmapDataChannel.GREEN:
                cy = "map_color.g";
                break;
            case BitmapDataChannel.BLUE:
                cy = "map_color.b";
                break;
            case BitmapDataChannel.ALPHA:
                cy = "map_color.a";
                break;
            default:
                cy = "0.5";
                break;
        }

        switch (mode) {
            case DisplacementMapFilterMode.CLAMP:
                modeStatement = `
    vec4 source_color = ${k.texture2D()}(u_textures[0], uv);
`;
                break;
            case DisplacementMapFilterMode.IGNORE:
                // 置き換え後の座標が範囲外なら、置き換え前の座標をとる（x軸とy軸を別々に判定する）
                modeStatement = `
    vec4 source_color =${k.texture2D()}(u_textures[0], mix(v_coord, uv, step(abs(uv - vec2(0.5)), vec2(0.5))));
`;
                break;
            case DisplacementMapFilterMode.COLOR:
                modeStatement = `
    vec4 substitute_color = u_mediump[2];
    vec4 source_color = mix(substitute_color, ${k.texture2D()}(u_textures[0], uv), isInside(uv));
`;
                break;
            case DisplacementMapFilterMode.WRAP:
            default:
                modeStatement = `
    vec4 source_color = ${k.texture2D()}(u_textures[0], fract(uv));
`;
                break;
        }

        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[2];
uniform vec4 u_mediump[${mediump_length}];

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

${FragmentShaderLibrary.FUNCTION_IS_INSIDE()}

void main() {
    vec2 uv_to_st_scale  = u_mediump[0].xy;
    vec2 uv_to_st_offset = u_mediump[0].zw;
    vec2 scale           = u_mediump[1].xy;

    vec2 st = v_coord * uv_to_st_scale - uv_to_st_offset;
    vec4 map_color = ${k.texture2D()}(u_textures[1], st);

    vec2 offset = vec2(${cx}, ${cy}) - 0.5;
    vec2 uv = v_coord + offset * scale;
    ${modeStatement}

    ${k.fragColor()} = mix(${k.texture2D()}(u_textures[0], v_coord), source_color, isInside(st));
}

`;
    }
}

/**
 * @class
 */
class FragmentShaderSourceFilter
{
    /**
     * @param  {WebGLShaderKeyword} k
     * @param  {number}  textures_length
     * @param  {number}  mediump_length
     * @param  {boolean} transforms_base
     * @param  {boolean} transforms_blur
     * @param  {boolean} isGlow
     * @param  {string}  type
     * @param  {boolean} knockout
     * @param  {boolean} applies_strength
     * @param  {boolean} is_gradient
     * @return {string}
     * @method
     * @static
     */
    static TEMPLATE (
        k, textures_length, mediump_length,
        transforms_base, transforms_blur,
        isGlow, type, knockout,
        applies_strength, is_gradient
    ) {
        let index = 0;

        const baseStatement = transforms_base
            ? this.STATEMENT_BASE_TEXTURE_TRANSFORM(k, index++)
            : "";
        const blurStatement = transforms_blur
            ? this.STATEMENT_BLUR_TEXTURE_TRANSFORM(k, index++)
            : this.STATEMENT_BLUR_TEXTURE(k);
        const isInner = type === BitmapFilterType.INNER;

        const colorIndex = index;
        let strengthOffset = index * 4;
        let colorStatement;
        if (is_gradient) {
            colorStatement = isGlow
                ? this.STATEMENT_GLOW(k, false, transforms_base, applies_strength, is_gradient, colorIndex, strengthOffset)
                : this.STATEMENT_BEVEL(k, transforms_base, transforms_blur, applies_strength, is_gradient, colorIndex, strengthOffset);
        } else if (isGlow) {
            strengthOffset += 4;
            colorStatement = this.STATEMENT_GLOW(k, isInner, transforms_base, applies_strength, is_gradient, colorIndex, strengthOffset);
        } else {
            strengthOffset += 8;
            colorStatement = this.STATEMENT_BEVEL(k, transforms_base, transforms_blur, applies_strength, is_gradient, colorIndex, strengthOffset);
        }

        let modeExpression;
        switch (type) {
            case BitmapFilterType.OUTER:
                modeExpression = knockout
                    ? "blur - blur * base.a"
                    : "base + blur - blur * base.a";
                break;
            case BitmapFilterType.FULL:
                modeExpression = knockout
                    ? "blur"
                    : "base - base * blur.a + blur";
                break;
            case BitmapFilterType.INNER:
            default:
                modeExpression = "blur";
                break;
        }

        return `${k.version()}
precision mediump float;

uniform sampler2D u_textures[${textures_length}];
uniform vec4 u_mediump[${mediump_length}];

${k.varyingIn()} vec2 v_coord;
${k.outColor()}

${FragmentShaderLibrary.FUNCTION_IS_INSIDE()}

void main() {
    ${baseStatement}
    ${blurStatement}
    ${colorStatement}
    ${k.fragColor()} = ${modeExpression};
}

`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BASE_TEXTURE_TRANSFORM (k, index)
    {
        return `
    vec2 base_scale  = u_mediump[${index}].xy;
    vec2 base_offset = u_mediump[${index}].zw;

    vec2 uv = v_coord * base_scale - base_offset;
    vec4 base = mix(vec4(0.0), ${k.texture2D()}(u_textures[1], uv), isInside(uv));
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BLUR_TEXTURE (k)
    {
        return `
    vec4 blur = ${k.texture2D()}(u_textures[0], v_coord);
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BLUR_TEXTURE_TRANSFORM (k, index)
    {
        return `
    vec2 blur_scale  = u_mediump[${index}].xy;
    vec2 blur_offset = u_mediump[${index}].zw;

    vec2 st = v_coord * blur_scale - blur_offset;
    vec4 blur = mix(vec4(0.0), ${k.texture2D()}(u_textures[0], st), isInside(st));
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_GLOW (k, isInner, transforms_base, applies_strength, is_gradient, colorIndex, strengthOffset)
    {
        const innerStatement = isInner
            ? "blur.a = 1.0 - blur.a;"
            : "";
        const strengthStatement = applies_strength
            ? this.STATEMENT_GLOW_STRENGTH(strengthOffset)
            : "";
        const colorStatement = is_gradient
            ? this.STATEMENT_GLOW_GRADIENT_COLOR(k, transforms_base)
            : this.STATEMENT_GLOW_SOLID_COLOR(colorIndex);

        return `
    ${innerStatement}
    ${strengthStatement}
    ${colorStatement}
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_GLOW_STRENGTH (offset)
    {
        const index     = $Math.floor(offset / 4);
        const component = offset % 4;
        return `
    float strength = u_mediump[${index}][${component}];
    blur.a = clamp(blur.a * strength, 0.0, 1.0);
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_GLOW_SOLID_COLOR (index)
    {
        return `
    vec4 color = u_mediump[${index}];
    blur = color * blur.a;
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_GLOW_GRADIENT_COLOR (k, transforms_base)
    {
        const unit = transforms_base ? 2 : 1;

        return `
    blur = ${k.texture2D()}(u_textures[${unit}], vec2(blur.a, 0.5));
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BEVEL (k, transforms_base, transforms_blur, applies_strength, is_gradient, colorIndex, strengthOffset)
    {
        const blur2Statement = transforms_blur
            ? this.STATEMENT_BLUR_TEXTURE_TRANSFORM_2(k)
            : this.STATEMENT_BLUR_TEXTURE_2(k);
        const strengthStatement = applies_strength
            ? this.STATEMENT_BEVEL_STRENGTH(strengthOffset)
            : "";
        const colorStatement = is_gradient
            ? this.STATEMENT_BEVEL_GRADIENT_COLOR(k, transforms_base)
            : this.STATEMENT_BEVEL_SOLID_COLOR(colorIndex);

        return `
    ${blur2Statement}
    float highlight_alpha = blur.a - blur2.a;
    float shadow_alpha    = blur2.a - blur.a;
    ${strengthStatement}
    highlight_alpha = clamp(highlight_alpha, 0.0, 1.0);
    shadow_alpha    = clamp(shadow_alpha, 0.0, 1.0);
    ${colorStatement}
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BLUR_TEXTURE_2 (k)
    {
        return `
    vec4 blur2 = ${k.texture2D()}(u_textures[0], 1.0 - v_coord);
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BLUR_TEXTURE_TRANSFORM_2 (k)
    {
        return `
    vec2 pq = (1.0 - v_coord) * blur_scale - blur_offset;
    vec4 blur2 = mix(vec4(0.0), ${k.texture2D()}(u_textures[0], pq), isInside(pq));
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BEVEL_STRENGTH (offset)
    {
        const index     = $Math.floor(offset / 4);
        const component = offset % 4;
        return `
    float strength = u_mediump[${index}][${component}];
    highlight_alpha *= strength;
    shadow_alpha    *= strength;
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BEVEL_SOLID_COLOR (index)
    {
        return `
    vec4 highlight_color = u_mediump[${index}];
    vec4 shadow_color    = u_mediump[${index + 1}];
    blur = highlight_color * highlight_alpha + shadow_color * shadow_alpha;
`;
    }

    /**
     * @return {string}
     * @method
     * @static
     */
    static STATEMENT_BEVEL_GRADIENT_COLOR (k, transforms_base)
    {
        const unit = transforms_base ? 2 : 1;

        return `
    blur = ${k.texture2D()}(u_textures[${unit}], vec2(
        0.5019607843137255 - 0.5019607843137255 * shadow_alpha + 0.4980392156862745 * highlight_alpha,
        0.5
    ));
`;
    }
}

/**
 * @class
 */
class BezierConverter
{
    /**
     * @param  {number} fromX
     * @param  {number} fromY
     * @param  {number} cx1
     * @param  {number} cy1
     * @param  {number} cx2
     * @param  {number} cy2
     * @param  {number} x
     * @param  {number} y
     * @return void
     * @method
     * @static
     * @public
     */
    static cubicToQuad (fromX, fromY, cx1, cy1, cx2, cy2, x, y)
    {
        this._$split2Cubic(fromX, fromY, cx1, cy1, cx2, cy2, x, y, 0, 16);
        this._$split2Cubic(
            Util.$bezierConverterBuffer[0], Util.$bezierConverterBuffer[1], Util.$bezierConverterBuffer[2], Util.$bezierConverterBuffer[3],
            Util.$bezierConverterBuffer[4], Util.$bezierConverterBuffer[5], Util.$bezierConverterBuffer[6], Util.$bezierConverterBuffer[7],
            0, 8
        );
        this._$split2Cubic(
            Util.$bezierConverterBuffer[16], Util.$bezierConverterBuffer[17], Util.$bezierConverterBuffer[18], Util.$bezierConverterBuffer[19],
            Util.$bezierConverterBuffer[20], Util.$bezierConverterBuffer[21], Util.$bezierConverterBuffer[22], Util.$bezierConverterBuffer[23],
            16, 24
        );
        this._$split2Quad(
            Util.$bezierConverterBuffer[0], Util.$bezierConverterBuffer[1], Util.$bezierConverterBuffer[2], Util.$bezierConverterBuffer[3],
            Util.$bezierConverterBuffer[4], Util.$bezierConverterBuffer[5], Util.$bezierConverterBuffer[6], Util.$bezierConverterBuffer[7],
            0
        );
        this._$split2Quad(
            Util.$bezierConverterBuffer[8], Util.$bezierConverterBuffer[9], Util.$bezierConverterBuffer[10], Util.$bezierConverterBuffer[11],
            Util.$bezierConverterBuffer[12], Util.$bezierConverterBuffer[13], Util.$bezierConverterBuffer[14], Util.$bezierConverterBuffer[15],
            8
        );
        this._$split2Quad(
            Util.$bezierConverterBuffer[16], Util.$bezierConverterBuffer[17], Util.$bezierConverterBuffer[18], Util.$bezierConverterBuffer[19],
            Util.$bezierConverterBuffer[20], Util.$bezierConverterBuffer[21], Util.$bezierConverterBuffer[22], Util.$bezierConverterBuffer[23],
            16
        );
        this._$split2Quad(
            Util.$bezierConverterBuffer[24], Util.$bezierConverterBuffer[25], Util.$bezierConverterBuffer[26], Util.$bezierConverterBuffer[27],
            Util.$bezierConverterBuffer[28], Util.$bezierConverterBuffer[29], Util.$bezierConverterBuffer[30], Util.$bezierConverterBuffer[31],
            24
        );
    }

    /**
     * @description 3次ベジェを、2つの3次ベジェに分割する
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} p4
     * @param  {number} p5
     * @param  {number} p6
     * @param  {number} p7
     * @param  {number} offset1
     * @param  {number} offset2
     * @return void
     * @method
     * @static
     * @private
     */
    static _$split2Cubic (p0, p1, p2, p3, p4, p5, p6, p7, offset1, offset2)
    {
        const mx = (p0 + 3 * (p2 + p4) + p6) * 0.125;
        const my = (p1 + 3 * (p3 + p5) + p7) * 0.125;
        const dx = (p6 + p4 - p2 - p0) * 0.125;
        const dy = (p7 + p5 - p3 - p1) * 0.125;

        Util.$bezierConverterBuffer[offset1    ] = p0;
        Util.$bezierConverterBuffer[offset1 + 1] = p1;
        Util.$bezierConverterBuffer[offset1 + 2] = (p0 + p2) * 0.5;
        Util.$bezierConverterBuffer[offset1 + 3] = (p1 + p3) * 0.5;
        Util.$bezierConverterBuffer[offset1 + 4] = mx - dx;
        Util.$bezierConverterBuffer[offset1 + 5] = my - dy;
        Util.$bezierConverterBuffer[offset1 + 6] = mx;
        Util.$bezierConverterBuffer[offset1 + 7] = my;

        Util.$bezierConverterBuffer[offset2    ] = mx;
        Util.$bezierConverterBuffer[offset2 + 1] = my;
        Util.$bezierConverterBuffer[offset2 + 2] = mx + dx;
        Util.$bezierConverterBuffer[offset2 + 3] = my + dy;
        Util.$bezierConverterBuffer[offset2 + 4] = (p4 + p6) * 0.5;
        Util.$bezierConverterBuffer[offset2 + 5] = (p5 + p7) * 0.5;
        Util.$bezierConverterBuffer[offset2 + 6] = p6;
        Util.$bezierConverterBuffer[offset2 + 7] = p7;
    }

    /**
     * @description 3次ベジェを、2つの2次ベジェに変換する
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} p4
     * @param  {number} p5
     * @param  {number} p6
     * @param  {number} p7
     * @param  {number} offset
     * @return void
     * @method
     * @static
     * @private
     */
    static _$split2Quad (p0, p1, p2, p3, p4, p5, p6, p7, offset)
    {
        const mx = (p0 + 3 * (p2 + p4) + p6) * 0.125;
        const my = (p1 + 3 * (p3 + p5) + p7) * 0.125;

        // 2次ベジェの始点の値は不要なので含めない

        // this.result[offset - 2] = p0;
        // this.result[offset - 1] = p1;
        Util.$bezierConverterBuffer[offset    ] = p0 * 0.25 + p2 * 0.75;
        Util.$bezierConverterBuffer[offset + 1] = p1 * 0.25 + p3 * 0.75;
        Util.$bezierConverterBuffer[offset + 2] = mx;
        Util.$bezierConverterBuffer[offset + 3] = my;

        // this.result[offset + 2] = mx;
        // this.result[offset + 3] = my;
        Util.$bezierConverterBuffer[offset + 4] = p4 * 0.75 + p6 * 0.25;
        Util.$bezierConverterBuffer[offset + 5] = p5 * 0.75 + p7 * 0.25;
        Util.$bezierConverterBuffer[offset + 6] = p6;
        Util.$bezierConverterBuffer[offset + 7] = p7;
    }
}

/**
 * @class
 */
class CanvasGradientToWebGL
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$rgb             = InterpolationMethod.RGB;
        this._$mode            = SpreadMethod.PAD;
        this._$focalPointRatio = 0;
        this._$points          = Util.$getFloat32Array6(); // fixed size 6
        this._$stops           = Util.$getArray();
        this._$type            = null;
    }

    /**
     * @param  {number} x0
     * @param  {number} y0
     * @param  {number} x1
     * @param  {number} y1
     * @param  {string} [rgb=InterpolationMethod.RGB]
     * @param  {string} [mode=SpreadMethod.PAD]
     * @return {CanvasGradientToWebGL}
     * @method
     * @public
     */
    linear (
        x0, y0, x1, y1,
        rgb = InterpolationMethod.RGB, mode = SpreadMethod.PAD
    ) {

        this._$type      = GradientType.LINEAR;
        this._$points[0] = x0;
        this._$points[1] = y0;
        this._$points[2] = x1;
        this._$points[3] = y1;
        this._$rgb       = rgb;
        this._$mode      = mode;

        if (this._$stops.length) {
            this._$stops.length = 0;
        }

        return this;
    }

    /**
     * @param  {number} x0
     * @param  {number} y0
     * @param  {number} r0
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} r1
     * @param  {string} [rgb=InterpolationMethod.RGB]
     * @param  {string} [mode=SpreadMethod.PAD]
     * @param  {number} [focal_point_ratio=0]
     * @return {CanvasGradientToWebGL}
     * @method
     * @public
     */
    radial (
        x0, y0, r0, x1, y1, r1,
        rgb = InterpolationMethod.RGB, mode = SpreadMethod.PAD,
        focal_point_ratio = 0
    ) {

        this._$type            = GradientType.RADIAL;
        this._$points[0]       = x0;
        this._$points[1]       = y0;
        this._$points[2]       = r0;
        this._$points[3]       = x1;
        this._$points[4]       = y1;
        this._$points[5]       = r1;
        this._$rgb             = rgb;
        this._$mode            = mode;
        this._$focalPointRatio = Util.$clamp(focal_point_ratio, -0.975, 0.975, 0);

        if (this._$stops.length) {
            this._$stops.length = 0;
        }

        return this;
    }

    /**
     * @param  {number} offset
     * @param  {array}  color
     * @return {void}
     * @method
     * @public
     */
    addColorStop (offset, color)
    {
        // add
        this._$stops.push([offset, color]);

        // sort
        this._$stops.sort(function(a, b)
        {
            switch (true) {

                case a[0] > b[0]:
                    return 1;

                case b[0] > a[0]:
                    return -1;

                default:
                    return 0;

            }
        });
    }
}

/**
 * @class
 */
class CanvasPatternToWebGL
{
    /**
     * @param {WebGLTexture} [texture=null]
     * @param {string}       [repeat=null]
     * @param {array}        [color_transform=null]
     * @constructor
     * @public
     */
    constructor (texture = null, repeat = null, color_transform = null)
    {
        this._$initialization(texture, repeat, color_transform);
    }

    /**
     * @param  {WebGLTexture} [texture=null]
     * @param  {string}       [repeat=null]
     * @param  {array}        [color_transform=null]
     * @return {CanvasPatternToWebGL}
     * @method
     * @private
     */
    _$initialization (texture = null, repeat = null, color_transform = null)
    {
        this._$texture         = texture;
        this._$repeat          = repeat;
        this._$color_transform = color_transform;
        return this;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {WebGLTexture}
     * @readonly
     * @public
     */
    get texture ()
    {
        return this._$texture;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {string}
     * @readonly
     * @public
     */
    get repeat ()
    {
        return this._$repeat;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {array}
     * @readonly
     * @public
     */
    get colorTransform ()
    {
        return this._$color_transform;
    }
}
/**
 * @class
 */
class CanvasToWebGLContext
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {boolean}               isWebGL2Context
     * @constructor
     */
    constructor (gl, isWebGL2Context)
    {
        this._$gl = gl;

        const samples = isWebGL2Context
            ? $Math.min(Util.$currentPlayer().getSamples(), gl.getParameter(gl.MAX_SAMPLES))
            : 0;

        // setup
        this._$isWebGL2Context = isWebGL2Context;
        this._$maxTextureSize  = $Math.min(8192, gl.getParameter(gl.MAX_TEXTURE_SIZE)) - 2;

        // render params
        this._$contextStyle             = new CanvasToWebGLContextStyle();
        this._$style                    = this._$contextStyle;
        this._$fillBuffer               = null;
        this._$strokeBuffer             = null;
        this._$cacheCurrentBounds       = { "x": 0, "y": 0, "w": 0, "h": 0 };
        this._$cacheCurrentBuffer       = null;
        this._$stack                    = [];
        this._$globalAlpha              = 1;
        this._$imageSmoothingEnabled    = false;
        this._$globalCompositeOperation = BlendMode.NORMAL;
        this._$matrix                   = Util.$getFloat32Array9(1, 0, 0, 0, 1, 0, 0, 0, 1);

        this._$clearColorR = 1;
        this._$clearColorG = 1;
        this._$clearColorB = 1;
        this._$clearColorA = 1;

        this._$viewportWidth  = 0;
        this._$viewportHeight = 0;

        this._$frameBufferManager = new FrameBufferManager(gl, isWebGL2Context, samples);
        this._$path = new CanvasToWebGLContextPath();
        this._$grid = new CanvasToWebGLContextGrid();

        // filter params
        this._$offsetX = 0;
        this._$offsetY = 0;

        // layer
        this._$blends    = [];
        this._$positions = [];
        this._$isLayer   = false;

        // shader
        this._$shaderList = new CanvasToWebGLShaderList(this, gl);
        this._$gradientLUT = new GradientLUTGenerator(this, gl);

        // vertex array object
        this._$vao = new VertexArrayObjectManager(gl, isWebGL2Context);
        // pixel buffer object
        this._$pbo = new PixelBufferObjectManager(gl, isWebGL2Context);

        this._$mask  = new CanvasToWebGLContextMask(this, gl);
        this._$blend = new CanvasToWebGLContextBlend(this, gl);

        // singleton
        this._$canvasPatternToWebGL  = new CanvasPatternToWebGL();
        this._$canvasGradientToWebGL = new CanvasGradientToWebGL();
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @return {HTMLCanvasElement}
     * @public
     */
    get canvas ()
    {
        return this._$gl.canvas;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {Float32Array|CanvasGradientToWebGL}
     * @return   {Float32Array|CanvasGradientToWebGL}
     * @public
     */
    get fillStyle ()
    {
        return this._$style._$fillStyle;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {Float32Array|CanvasGradientToWebGL}
     * @param    {Float32Array|CanvasGradientToWebGL} fill_style
     * @return   void
     * @public
     */
    set fillStyle (fill_style)
    {
        if (this._$style._$fillStyle.constructor === Float32Array) {
            Util.$poolFloat32Array4(this._$style._$fillStyle);
        }
        this._$style._$fillStyle = fill_style;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {Float32Array}
     * @return {Float32Array|CanvasGradientToWebGL}
     * @public
     */
    get strokeStyle ()
    {
        return this._$style._$strokeStyle;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {array}
     * @param  {*} stroke_style
     * @return {void}
     * @public
     */
    set strokeStyle (stroke_style)
    {
        if (this._$style._$strokeStyle.constructor === Float32Array) {
            Util.$poolFloat32Array4(this._$style._$strokeStyle);
        }
        this._$style._$strokeStyle = stroke_style;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @return {number}
     * @public
     */
    get lineWidth ()
    {
        return this._$style._$lineWidth;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @param {number} line_width
     * @return {void}
     * @public
     */
    set lineWidth (line_width)
    {
        this._$style._$lineWidth = line_width;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {string}
     * @return {string}
     * @public
     */
    get lineCap ()
    {
        return this._$style._$lineCap;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {string}
     * @param {string} line_cap
     * @return {void}
     * @public
     */
    set lineCap (line_cap)
    {
        switch (line_cap) {

            case CapsStyle.NONE:
            case CapsStyle.SQUARE:
                this._$style._$lineCap = line_cap;
                break;

            default:
                this._$style._$lineCap = CapsStyle.ROUND;
                break;

        }
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @return {string}
     * @public
     */
    get lineJoin ()
    {
        return this._$style._$lineJoin;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @param {string} line_join
     * @return {void}
     * @public
     */
    set lineJoin (line_join)
    {

        switch (line_join) {

            case JointStyle.BEVEL:
            case JointStyle.MITER:
                this._$style._$lineJoin = line_join;
                break;

            default:
                this._$style._$lineJoin = JointStyle.ROUND;
                break;

        }

    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @return {number}
     * @public
     */
    get miterLimit ()
    {
        return this._$style._$miterLimit;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @param {number} miter_limit
     * @return {void}
     * @public
     */
    set miterLimit (miter_limit)
    {
        this._$style._$miterLimit = miter_limit;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @return {number}
     * @public
     */
    get globalAlpha ()
    {
        return this._$globalAlpha;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {number}
     * @param {number} global_alpha
     * @return {void}
     * @public
     */
    set globalAlpha (global_alpha)
    {
        this._$globalAlpha = Util.$clamp(global_alpha, 0, 1, 1);
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {boolean} [imageSmoothingEnabled=false]
     * @return {boolean}
     * @public
     */
    get imageSmoothingEnabled ()
    {
        return this._$imageSmoothingEnabled;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {boolean} [imageSmoothingEnabled=false]
     * @param {boolean} image_smoothing_enabled
     * @return void
     * @public
     */
    set imageSmoothingEnabled (image_smoothing_enabled)
    {
        this._$imageSmoothingEnabled = Util.$toBoolean(image_smoothing_enabled);
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {string} [globalCompositeOperation=BlendMode.NORMAL]
     * @return {string}
     * @public
     */
    get globalCompositeOperation ()
    {
        return this._$globalCompositeOperation;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {string} [globalCompositeOperation=BlendMode.NORMAL]
     * @param {string} global_composite_operation
     * @return {void}
     * @public
     */
    set globalCompositeOperation (global_composite_operation)
    {
        this._$globalCompositeOperation = global_composite_operation;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {FrameBufferManager}
     * @return {FrameBufferManager}
     * @public
     */
    get frameBuffer ()
    {
        return this._$frameBufferManager;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {CanvasToWebGLContextPath}
     * @return {CanvasToWebGLContextPath}
     * @public
     */
    get path ()
    {
        return this._$path;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {CanvasToWebGLContextGrid}
     * @return {CanvasToWebGLContextGrid}
     * @public
     */
    get grid ()
    {
        return this._$grid;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {VertexArrayObjectManager}
     * @return {VertexArrayObjectManager}
     * @public
     */
    get vao ()
    {
        return this._$vao;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {PixelBufferObjectManager}
     * @return {PixelBufferObjectManager}
     * @public
     */
    get pbo ()
    {
        return this._$pbo;
    }

    /**
     * @memberof CanvasToWebGLContext#
     * @property {CanvasToWebGLContextBlend}
     * @return {CanvasToWebGLContextBlend}
     * @public
     */
    get blend ()
    {
        return this._$blend;
    }

    /**
     * @param  {object} attachment
     * @return void
     * @public
     */
    _$bind (attachment)
    {
        if (!attachment) {
            return;
        }

        this._$frameBufferManager.bind(attachment);

        const colorBuffer   = attachment.color;
        const stencilBuffer = attachment.stencil;
        const width         = attachment.width;
        const height        = attachment.height;

        if (this._$viewportWidth !== width || this._$viewportHeight !== height) {
            this._$viewportWidth  = width;
            this._$viewportHeight = height;
            this._$gl.viewport(0, 0, width, height);
        }

        // カラーバッファorステンシルバッファが、未初期化の場合はクリアする
        if (colorBuffer.dirty || stencilBuffer && stencilBuffer.dirty) {
            colorBuffer.dirty = false;
            if (stencilBuffer) {
                stencilBuffer.dirty = false;
            }

            this._$gl.clearColor(0, 0, 0, 0);
            this.clearRect(0, 0, this._$viewportWidth, this._$viewportHeight);
            this._$gl.clearColor(this._$clearColorR, this._$clearColorG, this._$clearColorB, this._$clearColorA);

            this._$mask._$onClear(attachment.mask);
        }

        this._$mask._$onBind(attachment.mask);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @return void
     * @public
     */
    fillRect (x, y, w, h)
    {
        if (!w || !h) {
            return ;
        }

        // set size
        this._$viewportWidth  = w;
        this._$viewportHeight = h;

        // create buffer
        let removed = false;
        if (!this._$fillBuffer) {

            removed = true;

            const vertices = this._$path.createRectVertices(x, y, w, h);
            this._$fillBuffer = this._$vao.createFill(vertices);

            // object pool
            Util.$poolArray(vertices.pop());
            Util.$poolArray(vertices);
        }

        const hasGrid = this._$grid.enabled;
        const variants = this._$shaderList.shapeShaderVariants;
        const shader = variants.getSolidColorShapeShader(false, hasGrid);
        const uniform = shader.uniform;
        variants.setSolidColorShapeUniform(
            uniform, false, 0, 0, 0,
            hasGrid, this._$matrix,
            this._$viewportWidth, this._$viewportHeight, this._$grid,
            this.fillStyle, this._$globalAlpha
        );

        shader._$fill(this._$fillBuffer);

        if (removed) {
            this._$vao.release(this._$fillBuffer);
            Util.$poolArray(this._$fillBuffer.indexRanges);
        }

        // reset
        this.beginPath();
    }

    /**
     * @param  {number} a
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @param  {number} e
     * @param  {number} f
     * @return void
     * @public
     */
    setTransform (a, b, c, d, e, f)
    {
        this._$matrix[0] = a;
        this._$matrix[1] = b;
        this._$matrix[3] = c;
        this._$matrix[4] = d;
        this._$matrix[6] = e;
        this._$matrix[7] = f;
    }

    /**
     * @param  {number} a
     * @param  {number} b
     * @param  {number} c
     * @param  {number} d
     * @param  {number} e
     * @param  {number} f
     * @return void
     * @public
     */
    transform (a, b, c, d, e, f)
    {
        const a00 = this._$matrix[0];
        const a01 = this._$matrix[1];
        const a10 = this._$matrix[3];
        const a11 = this._$matrix[4];
        const a20 = this._$matrix[6];
        const a21 = this._$matrix[7];

        this._$matrix[0] = a * a00 + b * a10;
        this._$matrix[1] = a * a01 + b * a11;
        this._$matrix[3] = c * a00 + d * a10;
        this._$matrix[4] = c * a01 + d * a11;
        this._$matrix[6] = e * a00 + f * a10 + a20;
        this._$matrix[7] = e * a01 + f * a11 + a21;
    }

    /**
     * @param  {WebGLTexture|object} image
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @param  {Float32Array} [color_transform=null]
     * @return void
     * @public
     */
    drawImage (image, x, y, w, h, color_transform = null)
    {
        let ct0 = 1, ct1 = 1, ct2 = 1, ct3 = this._$globalAlpha;
        let ct4 = 0, ct5 = 0, ct6 = 0, ct7 = 0;
        if (color_transform) {
            ct0 = color_transform[0];
            ct1 = color_transform[1];
            ct2 = color_transform[2];
            ct4 = color_transform[4] / 255;
            ct5 = color_transform[5] / 255;
            ct6 = color_transform[6] / 255;
        }

        this._$blend.drawImage(
            image, x, y, w, h,
            ct0, ct1, ct2, ct3, ct4, ct5, ct6, ct7,
            this._$globalCompositeOperation,
            this._$viewportWidth, this._$viewportHeight,
            this._$matrix,
            this._$imageSmoothingEnabled
        );
    }

    /**
     * @param  {number} r
     * @param  {number} g
     * @param  {number} b
     * @param  {number} a
     * @return void
     * @public
     */
    _$setColor (r = 0, g = 0, b = 0, a = 0)
    {
        this._$clearColorR = r;
        this._$clearColorG = g;
        this._$clearColorB = b;
        this._$clearColorA = a;
        this._$gl.clearColor(r, g, b, a);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @return void
     * @public
     */
    clearRect (x, y, w, h)
    {
        this._$mask._$onClearRect();
        this._$gl.enable(this._$gl.SCISSOR_TEST);
        this._$gl.scissor(x, y, w, h);
        this._$gl.clear(this._$gl.COLOR_BUFFER_BIT | this._$gl.STENCIL_BUFFER_BIT);
        this._$gl.disable(this._$gl.SCISSOR_TEST);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @return void
     * @private
     */
    _$clearRectStencil (x, y, w, h)
    {
        this._$mask._$onClearRect();
        this._$gl.enable(this._$gl.SCISSOR_TEST);
        this._$gl.scissor(x, y, w, h);
        this._$gl.clear(this._$gl.STENCIL_BUFFER_BIT);
        this._$gl.disable(this._$gl.SCISSOR_TEST);
    }

    /**
     * @param  {DisplayObject} display_object
     * @param  {Float32Array} matrix
     * @return {Float32Array}
     * @public
     */
    _$startClip (display_object, matrix)
    {
        return this._$mask._$startClip(display_object, matrix);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @return void
     * @public
     */
    moveTo (x, y)
    {
        this._$path.moveTo(x, y);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @return void
     * @public
     */
    lineTo (x, y)
    {
        this._$path.lineTo(x, y);
    }

    /**
     * @return void
     * @public
     */
    beginPath ()
    {
        this._$path.begin();

        if (this._$isGraphics) {

            if (this._$fillBuffer) {

                this.vao.release(this._$fillBuffer);
                this.vao.release(this._$fillBuffer.boundObject);

                Util.$poolArray(this._$fillBuffer.indexRanges);
                Util.$poolArray(this._$fillBuffer.boundObject.indexRanges);
            }

            if (this._$strokeBuffer) {
                this.vao.release(this._$strokeBuffer);
            }

        }

        this._$isGraphics   = false;
        this._$fillBuffer   = null;
        this._$strokeBuffer = null;
    }

    /**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} x
     * @param  {number} y
     * @return void
     * @public
     */
    quadraticCurveTo (cx, cy, x ,y)
    {
        this._$path.quadTo(cx, cy, x, y);
    }

    /**
     * @param {number} cp1x
     * @param {number} cp1y
     * @param {number} cp2x
     * @param {number} cp2y
     * @param {number} dx
     * @param {number} dy
     * @return void
     * @public
     */
    bezierCurveTo (cp1x, cp1y, cp2x, cp2y, dx, dy)
    {
        this._$path.cubicTo(cp1x, cp1y, cp2x, cp2y, dx, dy);
    }

    /**
     * @return {array}
     * @public
     */
    _$getVertices ()
    {
        return this._$path.vertices;
    }

    /**
     * @return void
     * @public
     */
    fill ()
    {
        let matrix = this._$matrix;
        switch (true) {
            case this.fillStyle.constructor === CanvasGradientToWebGL:
                switch (this.fillStyle._$type) {
                    case GradientType.LINEAR:
                        break;
                    default:
                        matrix = this._$stack[this._$stack.length - 1];
                        break;
                }
                break;
            case this.fillStyle.constructor === CanvasPatternToWebGL:
                matrix = this._$stack[this._$stack.length - 1];
                break;
        }

        let texture, variants, shader;

        const hasGrid = this._$grid.enabled;

        switch (true) {

            // Gradient
            case this.fillStyle.constructor === CanvasGradientToWebGL:
                {
                    const gradient = this.fillStyle;
                    const stops = gradient._$stops;
                    const isLinearSpace = gradient._$rgb === "linearRGB";

                    texture = this._$gradientLUT.generateForShape(stops, isLinearSpace);
                    this._$frameBufferManager._$textureManager.bind0(texture, true);

                    variants = this._$shaderList.gradientShapeShaderVariants;
                    if (gradient._$type === GradientType.LINEAR) {
                        shader = variants.getGradientShapeShader(false, hasGrid, false, false, gradient._$mode);
                        variants.setGradientShapeUniform(
                            shader.uniform, false, 0, 0, 0,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            false, gradient._$points, 0
                        );
                    } else {
                        const hasFocalPoint = gradient._$focalPointRatio !== 0;
                        shader = variants.getGradientShapeShader(false, hasGrid, true, hasFocalPoint, gradient._$mode);
                        variants.setGradientShapeUniform(
                            shader.uniform, false, 0, 0, 0,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            true, gradient._$points, gradient._$focalPointRatio
                        );
                    }
                }
                break;

            case this.fillStyle.constructor === CanvasPatternToWebGL:
                {
                    const pattern = this.fillStyle;
                    const pct = pattern.colorTransform;

                    texture = pattern.texture;
                    this._$frameBufferManager._$textureManager.bind0(texture, this._$imageSmoothingEnabled);

                    variants = this._$shaderList.shapeShaderVariants;
                    shader = variants.getBitmapShapeShader(false, pattern.repeat !== "", hasGrid);

                    if (pct) {
                        variants.setBitmapShapeUniform(
                            shader.uniform, false, 0, 0, 0,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            texture.width, texture.height,
                            pct[0], pct[1], pct[2], this._$globalAlpha,
                            pct[4] / 255, pct[5] / 255, pct[6] / 255, 0
                        );
                    } else {
                        variants.setBitmapShapeUniform(
                            shader.uniform, false, 0, 0, 0,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            texture.width, texture.height,
                            1, 1, 1, this._$globalAlpha,
                            0, 0, 0, 0
                        );
                    }
                }
                break;

            // Shape
            default:

                variants = this._$shaderList.shapeShaderVariants;
                shader = variants.getSolidColorShapeShader(false, this._$grid.enabled);
                variants.setSolidColorShapeUniform(
                    shader.uniform, false, 0, 0, 0,
                    hasGrid, matrix,
                    this._$viewportWidth, this._$viewportHeight, this._$grid,
                    this.fillStyle, this._$globalAlpha
                );

                break;

        }

        const coverageVariants = this._$shaderList.shapeShaderVariants;
        const coverageShader = coverageVariants.getMaskShapeShader(false, hasGrid);
        coverageVariants.setMaskShapeUniform(
            coverageShader.uniform, hasGrid,
            matrix[0], matrix[1], matrix[2],
            matrix[3], matrix[4], matrix[5],
            matrix[6], matrix[7], matrix[8],
            this._$viewportWidth, this._$viewportHeight, this._$grid
        );

        // to triangle
        if (!this._$fillBuffer) {

            const fillVertices = this._$getVertices();
            if (!fillVertices.length) {
                return ;
            }

            const checkVertices = Util.$getArray();
            for (let idx = 0; idx < fillVertices.length; ++idx) {

                const vertices = fillVertices[idx];
                if (9 > vertices.length) {
                    continue;
                }

                checkVertices.push(vertices);
            }

            if (!checkVertices.length) {
                return ;
            }

            this._$isGraphics = true;
            this._$fillBuffer = this._$vao.createFill(checkVertices);

            const vertices = this._$path.getBoundsVertices();
            this._$fillBuffer.boundObject = this._$vao.createFill(vertices);

            // object pool
            Util.$poolArray(vertices.pop());
            Util.$poolArray(vertices);

        }

        // mask on
        this._$gl.enable(this._$gl.STENCIL_TEST);
        this._$gl.stencilMask(0xff);

        // shape clip
        this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE);
        this._$gl.stencilFunc(this._$gl.ALWAYS, 0, 0xff);
        this._$gl.stencilOp(this._$gl.KEEP, this._$gl.INVERT, this._$gl.INVERT);
        this._$gl.colorMask(false, false, false, false);
        coverageShader._$fill(this._$fillBuffer);
        this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE);

        // draw shape
        this._$gl.stencilFunc(this._$gl.NOTEQUAL, 0, 0xff);
        this._$gl.stencilOp(this._$gl.KEEP, this._$gl.ZERO, this._$gl.ZERO);
        this._$gl.colorMask(true, true, true, true);
        shader._$fill(this._$fillBuffer.boundObject);

        // mask off
        this._$gl.disable(this._$gl.STENCIL_TEST);
    }

    /**
     * @return void
     * @public
     */
    _$enterClip ()
    {
        this._$mask._$enterClip();
    }

    /**
     * @return void
     * @public
     */
    _$beginClipDef ()
    {
        this._$mask._$beginClipDef();
    }

    /**
     * @return void
     * @public
     */
    _$endClipDef ()
    {
        this._$mask._$endClipDef();
    }

    /**
     * @return void
     * @public
     */
    _$leaveClip ()
    {
        this._$mask._$leaveClip();
    }

    /**
     * @return void
     * @public
     */
    _$drawContainerClip ()
    {
        this._$mask._$drawContainerClip();
    }

    /**
     * @param  {uint} level
     * @param  {uint} w
     * @param  {uint} h
     * @return void
     * @private
     */
    _$unionStencilMask (level, w, h)
    {
        this._$mask._$unionStencilMask(level, w, h);
    }

    /**
     * @return void
     * @public
     */
    closePath ()
    {
        this._$path.close();
    }

    /**
     * @return void
     * @public
     */
    stroke ()
    {

        // set
        if (!this._$strokeBuffer) {

            const strokeVertices = this._$getVertices();

            if (!strokeVertices.length) {
                return;
            }

            const checkVertices = Util.$getArray();
            for (let idx = 0; idx < strokeVertices.length; ++idx) {

                const vertices = strokeVertices[idx];
                if (6 > vertices.length) {
                    continue;
                }

                checkVertices.push(vertices);
            }

            if (!checkVertices.length) {
                return ;
            }

            this._$isGraphics = true;

            this._$strokeBuffer = this._$vao.createStroke(
                strokeVertices,
                this.lineCap,
                this.lineJoin
            );
        }

        let matrix = this._$matrix;
        switch (true) {
            case this.strokeStyle.constructor === CanvasGradientToWebGL:
                switch (this.strokeStyle._$type) {
                    case GradientType.LINEAR:
                        break;
                    default:
                        matrix = this._$stack[this._$stack.length - 1];
                        break;
                }
                break;
            case this.strokeStyle.constructor === CanvasPatternToWebGL:
                matrix = this._$stack[this._$stack.length - 1];
                break;
        }

        let face = $Math.sign(matrix[0] * matrix[4]);
        if (face > 0 && matrix[1] !== 0 && matrix[3] !== 0) {
            face = -$Math.sign(matrix[1] * matrix[3]);
        }

        let lineWidth = this.lineWidth * 0.5;
        let scaleX, scaleY;
        if (this._$grid.enabled) {
            lineWidth *= Util.$getSameScaleBase();
            scaleX = $Math.abs(this._$grid.ancestorMatrixA + this._$grid.ancestorMatrixD);
            scaleY = $Math.abs(this._$grid.ancestorMatrixB + this._$grid.ancestorMatrixE);
        } else {
            scaleX = $Math.abs(matrix[0] + matrix[3]);
            scaleY = $Math.abs(matrix[1] + matrix[4]);
        }
        const scaleMin = $Math.min(scaleX, scaleY);
        const scaleMax = $Math.max(scaleX, scaleY);
        lineWidth *= scaleMax * (1 - 0.3 * $Math.cos($Math.PI * 0.5 * (scaleMin / scaleMax)));
        lineWidth = $Math.max(1, lineWidth);

        let texture, variants, shader;

        const hasGrid = this._$grid.enabled;

        switch (true) {

            // Gradient
            case this.strokeStyle.constructor === CanvasGradientToWebGL:
                {
                    const gradient = this.strokeStyle;
                    const stops = gradient._$stops;
                    const isLinearSpace = gradient._$rgb === "linearRGB";

                    texture = this._$gradientLUT.generateForShape(stops, isLinearSpace);
                    this._$frameBufferManager._$textureManager.bind0(texture, true);

                    variants = this._$shaderList.gradientShapeShaderVariants;
                    if (gradient._$type === GradientType.LINEAR) {
                        shader = variants.getGradientShapeShader(true, hasGrid, false, false, gradient._$mode);
                        variants.setGradientShapeUniform(
                            shader.uniform, true, lineWidth, face, this.miterLimit,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            false, gradient._$points, 0
                        );
                    } else {
                        const hasFocalPoint = gradient._$focalPointRatio !== 0;
                        shader = variants.getGradientShapeShader(true, hasGrid, true, hasFocalPoint, gradient._$mode);
                        variants.setGradientShapeUniform(
                            shader.uniform, true, lineWidth, face, this.miterLimit,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            true, gradient._$points, gradient._$focalPointRatio
                        );
                    }
                }
                break;

            case this.strokeStyle.constructor === CanvasPatternToWebGL:
                {
                    const pattern = this.strokeStyle;
                    const pct = pattern.colorTransform;

                    texture = pattern.texture;
                    this._$frameBufferManager._$textureManager.bind0(texture);

                    variants = this._$shaderList.shapeShaderVariants;
                    shader = variants.getBitmapShapeShader(true, pattern.repeat !== "", this._$grid.enabled);

                    if (pct) {
                        variants.setBitmapShapeUniform(
                            shader.uniform, true, lineWidth, face, this.miterLimit,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            texture.width, texture.height,
                            pct[0], pct[1], pct[2], this._$globalAlpha,
                            pct[4] / 255, pct[5] / 255, pct[6] / 255, 0
                        );
                    } else {
                        variants.setBitmapShapeUniform(
                            shader.uniform, true, lineWidth, face, this.miterLimit,
                            hasGrid, matrix, Util.$inverseMatrix(this._$matrix),
                            this._$viewportWidth, this._$viewportHeight, this._$grid,
                            texture.width, texture.height,
                            1, 1, 1, this._$globalAlpha,
                            0, 0, 0, 0
                        );
                    }
                }
                break;

            default:

                variants = this._$shaderList.shapeShaderVariants;
                shader = variants.getSolidColorShapeShader(true, this._$grid.enabled);
                variants.setSolidColorShapeUniform(
                    shader.uniform, true, lineWidth, face, this.miterLimit,
                    hasGrid, matrix,
                    this._$viewportWidth, this._$viewportHeight, this._$grid,
                    this.strokeStyle, this._$globalAlpha
                );

                break;
        }

        shader._$stroke(this._$strokeBuffer);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} radius
     * @return void
     * @public
     */
    arc (x, y, radius)
    {
        this._$path.drawCircle(x, y, radius);
    }

    /**
     * @param  {boolean} [removed = false]
     * @return void
     * @public
     */
    clip (removed = false)
    {
        const variants = this._$shaderList.shapeShaderVariants;
        const shader = variants.getMaskShapeShader(false, false);
        const uniform = shader.uniform;
        variants.setMaskShapeUniform(
            uniform, false,
            this._$matrix[0], this._$matrix[1], this._$matrix[2],
            this._$matrix[3], this._$matrix[4], this._$matrix[5],
            this._$matrix[6], this._$matrix[7], this._$matrix[8],
            this._$viewportWidth, this._$viewportHeight, null
        );

        // to triangle
        if (!this._$fillBuffer) {

            this._$fillBuffer = this._$vao.createFill(this._$getVertices());

            const vertices = this._$path.getBoundsVertices();
            this._$fillBuffer.boundObject = this._$vao.createFill(vertices);

            // object pool
            Util.$poolArray(vertices.pop());
            Util.$poolArray(vertices);
        }

        if (this._$mask._$onClip(this._$matrix, this._$viewportWidth, this._$viewportHeight)) {
            return;
        }

        // mask render
        shader._$fill(this._$fillBuffer);

        if (removed) {

            // pool
            this._$vao.release(this._$fillBuffer);
            this._$vao.release(this._$fillBuffer.boundObject);

            Util.$poolArray(this._$fillBuffer.indexRanges);
            Util.$poolArray(this._$fillBuffer.boundObject.indexRanges);

            // reset
            this._$fillBuffer = null;
        }

        this.beginPath();
    }

    /**
     * @return void
     * @public
     */
    save ()
    {

        // matrix
        const m = this._$matrix;
        this._$stack.push(Util.$getFloat32Array9(
            m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]
        ));

        // mask
        this._$mask._$onSave();
    }

    /**
     * @return void
     * @public
     */
    restore ()
    {
        //matrix
        if (this._$stack.length) {
            Util.$poolFloat32Array9(this._$matrix);
            this._$matrix = this._$stack.pop();
        }

        // mask
        this._$mask._$onRestore();
    }

    /**
     * @param  {WebGLTexture} texture
     * @param  {string}       repeat
     * @param  {Float32Array} color_transform
     * @return {CanvasPatternToWebGL}
     * @public
     */
    createPattern (texture, repeat, color_transform)
    {
        return this
            ._$canvasPatternToWebGL
            ._$initialization(texture, repeat, color_transform);
    }

    /**
     * @param  {number} x0
     * @param  {number} y0
     * @param  {number} x1
     * @param  {number} y1
     * @param  {string} [rgb=InterpolationMethod.RGB]
     * @param  {string} [mode=SpreadMethod.PAD]
     * @return {CanvasGradientToWebGL}
     * @public
     */
    createLinearGradient (
        x0, y0, x1, y1,
        rgb = InterpolationMethod.RGB, mode = SpreadMethod.PAD
    ) {
        return this
            ._$canvasGradientToWebGL
            .linear(x0, y0, x1, y1, rgb, mode);
    }

    /**
     * @param  {number} x0
     * @param  {number} y0
     * @param  {number} r0
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} r1
     * @param  {string} [rgb=InterpolationMethod.RGB]
     * @param  {string} [mode=SpreadMethod.PAD]
     * @param  {number} [focal_point_ratio=0]
     * @return {CanvasGradientToWebGL}
     * @public
     */
    createRadialGradient (
        x0, y0, r0, x1, y1, r1,
        rgb = InterpolationMethod.RGB, mode = SpreadMethod.PAD,
        focal_point_ratio = 0
    ) {
        return this
            ._$canvasGradientToWebGL
            .radial(x0, y0, r0, x1, y1, r1, rgb, mode, focal_point_ratio);
    }

    /**
     * @param  {WebGLTexture} texture
     * @param  {boolean}      isHorizontal
     * @param  {number}       blur
     * @return {void}
     * @public
     */
    _$applyBlurFilter (texture, isHorizontal, blur)
    {
        const currentBuffer = this._$frameBufferManager.currentAttachment;
        const width  = currentBuffer.width;
        const height = currentBuffer.height;

        this._$frameBufferManager._$textureManager.bind0(texture, true);

        const halfBlur = $Math.ceil(blur * 0.5);
        const fraction = 1 - (halfBlur - blur * 0.5);
        const samples  = 1 + blur;

        const variants = this._$shaderList.filterShaderVariants;
        const shader = variants.getBlurFilterShader(halfBlur);
        variants.setBlurFilterUniform(shader.uniform, width, height, isHorizontal, fraction, samples);
        shader._$drawImage();
    }

    /**
     * @param  {WebGLTexture} blurTexture
     * @param  {number}  width
     * @param  {number}  height
     * @param  {number}  baseWidth
     * @param  {number}  baseHeight
     * @param  {number}  baseOffsetX
     * @param  {number}  baseOffsetY
     * @param  {number}  blurWidth
     * @param  {number}  blurHeight
     * @param  {number}  blurOffsetX
     * @param  {number}  blurOffsetY
     * @param  {boolean} isGlow
     * @param  {string}  type
     * @param  {boolean} knockout
     * @param  {number}  strength
     * @param  {number}  blurX
     * @param  {number}  blurY
     * @param  {array}   ratios
     * @param  {array}   colors
     * @param  {array}   alphas
     * @param  {number}  colorR1
     * @param  {number}  colorG1
     * @param  {number}  colorB1
     * @param  {number}  colorA1
     * @param  {number}  colorR2
     * @param  {number}  colorG2
     * @param  {number}  colorB2
     * @param  {number}  colorA2
     * @return {void}
     * @public
     */
    _$applyBitmapFilter (
        blurTexture, width, height,
        baseWidth, baseHeight, baseOffsetX, baseOffsetY,
        blurWidth, blurHeight, blurOffsetX, blurOffsetY,
        isGlow, type, knockout,
        strength, ratios, colors, alphas,
        colorR1, colorG1, colorB1, colorA1,
        colorR2, colorG2, colorB2, colorA2
    ) {
        const isInner = type === BitmapFilterType.INNER;

        const baseAttachment = this._$frameBufferManager.currentAttachment;
        const baseTexture = this._$frameBufferManager.getTextureFromCurrentAttachment();

        let lut;
        const isGradient = ratios !== null;
        if (isGradient) {
            lut = this._$gradientLUT.generateForFilter(ratios, colors, alphas);
        }

        let targetTextureAttachment;
        if (isInner) {
            if (isGradient) {
                this._$frameBufferManager._$textureManager.bind02(blurTexture, lut, true);
            } else {
                this._$frameBufferManager._$textureManager.bind0(blurTexture);
            }
        } else {
            targetTextureAttachment = this._$frameBufferManager.createTextureAttachment(width, height);
            this._$bind(targetTextureAttachment);

            if (isGradient) {
                this._$frameBufferManager._$textureManager.bind012(blurTexture, baseTexture, lut, true);
            } else {
                this._$frameBufferManager._$textureManager.bind01(blurTexture, baseTexture);
            }
        }

        // if (blurX < 2 && blurY < 2 && (blurX > 0 || blurY > 0)) {
        //    // ぼかし幅が2より小さい場合は、強さを調整して見た目を合わせる
        //    strength *= ($Math.max(1, blurX, blurY) - 1) * 0.4 + 0.2;
        // }

        const transformsBase = !(isInner || type === BitmapFilterType.FULL && knockout);
        const transformsBlur = !(width === blurWidth && height === blurHeight && blurOffsetX === 0 && blurOffsetY === 0);
        const appliesStrength = !(strength === 1);

        const variants = this._$shaderList.filterShaderVariants;
        const shader = variants.getBitmapFilterShader(
            transformsBase, transformsBlur,
            isGlow, type, knockout,
            appliesStrength, isGradient
        );
        variants.setBitmapFilterUniform(
            shader.uniform, width, height,
            baseWidth, baseHeight, baseOffsetX, baseOffsetY,
            blurWidth, blurHeight, blurOffsetX, blurOffsetY,
            isGlow, strength,
            colorR1, colorG1, colorB1, colorA1,
            colorR2, colorG2, colorB2, colorA2,
            transformsBase, transformsBlur, appliesStrength, isGradient
        );

        if (!isInner) {
            this.blend.toOneZero();
        } else if (knockout) {
            this.blend.toSourceIn();
        } else {
            this.blend.toSourceAtop();
        }

        shader._$drawImage();

        if (!isInner) {
            this._$frameBufferManager.releaseAttachment(baseAttachment, true);
        }
    }

    /**
     * @param  {WebGLTexture} texture
     * @param  {array} matrix
     * @return void
     * @public
     */
    _$applyColorMatrixFilter (texture, matrix)
    {
        this._$frameBufferManager._$textureManager.bind0(texture, true);

        const variants = this._$shaderList.filterShaderVariants;
        const shader = variants.getColorMatrixFilterShader();
        variants.setColorMatrixFilterUniform(shader.uniform, matrix);

        this.blend.reset();
        shader._$drawImage();
    }

    /**
     * @param  {WebGLTexture} texture
     * @param  {number}  matrix_x
     * @param  {number}  matrix_y
     * @param  {array}   matrix
     * @param  {number}  divisor
     * @param  {number}  bias
     * @param  {boolean} preserve_alpha
     * @param  {boolean} clamp
     * @param  {number}  colorR
     * @param  {number}  colorG
     * @param  {number}  colorB
     * @param  {number}  colorA
     * @return void
     * @public
     */
    _$applyConvolutionFilter (
        texture, matrix_x, matrix_y, matrix,
        divisor, bias, preserve_alpha, clamp,
        colorR, colorG, colorB, colorA
    ) {
        const width  = texture.width;
        const height = texture.height;

        const targetTextureAttachment = this._$frameBufferManager.createTextureAttachment(width, height);
        this._$bind(targetTextureAttachment);

        this._$frameBufferManager._$textureManager.bind0(texture, true);

        const variants = this._$shaderList.filterShaderVariants;
        const shader = variants.getConvolutionFilterShader(matrix_x, matrix_y, preserve_alpha, clamp);
        variants.setConvolutionFilterUniform(
            shader.uniform,
            width, height, matrix, divisor, bias, clamp,
            colorR, colorG, colorB, colorA
        );

        this.blend.reset();
        shader._$drawImage();
    }

    /**
     * @param  {WebGLTexture} source
     * @param  {WebGLTexture} map
     * @param  {number} base_width
     * @param  {number} base_height
     * @param  {Point}  [point=null]
     * @param  {number} component_x
     * @param  {number} component_y
     * @param  {number} scale_x
     * @param  {number} scale_y
     * @param  {string} mode
     * @param  {number} colorR
     * @param  {number} colorG
     * @param  {number} colorB
     * @param  {number} colorA
     * @return void
     * @private
     */
    _$applyDisplacementMapFilter (
        source, map, base_width, base_height, point,
        component_x, component_y, scale_x, scale_y, mode,
        colorR, colorG, colorB, colorA
    ) {
        const width  = source.width;
        const height = source.height;

        const targetTextureAttachment = this._$frameBufferManager.createTextureAttachment(width, height);
        this._$bind(targetTextureAttachment);

        if (!point) {
            point = { "x": 0, "y": 0 };
        }

        this._$frameBufferManager._$textureManager.bind01(source, map);

        const variants = this._$shaderList.filterShaderVariants;
        const shader = variants.getDisplacementMapFilterShader(component_x, component_y, mode);
        variants.setDisplacementMapFilterUniform(
            shader.uniform, map.width, map.height, base_width, base_height,
            point.x, point.y, scale_x, scale_y, mode,
            colorR, colorG, colorB, colorA
        );

        this.blend.reset();
        shader._$drawImage();
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @return {Uint8Array}
     * @public
     */
    getImageData (x, y, w, h)
    {
        const length = w * h * 4;
        const data = Util.$getUint8Array(length);

        this._$gl.readPixels(
            x, h - (h - y), w, h,
            this._$gl.RGBA, this._$gl.UNSIGNED_BYTE,
            data
        );

        // アルファ値を除算
        for (let idx = 0; idx < length; idx += 4) {

            const a = data[idx + 3];
            if (a) {
                data[idx    ] = $Math.min(data[idx    ] * 255 / a, 255) & 0xff;
                data[idx + 1] = $Math.min(data[idx + 1] * 255 / a, 255) & 0xff;
                data[idx + 2] = $Math.min(data[idx + 2] * 255 / a, 255) & 0xff;
            }

        }

        return data;
    }

    /**
     * @param  {object} position
     * @return void
     */
    _$startLayer (position)
    {
        this._$positions.push(position);
        this._$blends.push(this._$isLayer);
        this._$isLayer = true;
    }

    /**
     * @return void
     */
    _$endLayer ()
    {
        Util.$poolBoundsObject(this._$positions.pop());
        this._$isLayer = Util.$toBoolean(this._$blends.pop());
    }

    /**
     * @return {object}
     * @private
     */
    _$getCurrentPosition ()
    {
        return this._$positions[this._$positions.length - 1];
    }

    /**
     * @description 最大テクスチャサイズを超えないスケール値を取得する
     * @param  {number} width
     * @param  {number} height
     * @return {number}
     */
    _$textureScale (width, height)
    {
        const maxSize = $Math.max(width, height);
        if (maxSize > this._$maxTextureSize) {
            return this._$maxTextureSize / maxSize;
        }
        return 1;
    }

    /**
     * @param  {uint} samples
     * @return void
     * @public
     */
    changeSamples (samples = 4)
    {
        if (this._$isWebGL2Context) {

            samples = $Math.min(samples, this._$gl.getParameter(this._$gl.MAX_SAMPLES));

            const manager = this._$frameBufferManager;

            // reset
            manager._$objectPool = [];
            manager._$colorBufferPool._$objectPool   = [];
            manager._$stencilBufferPool._$objectPool = [];

            // edit param
            manager._$colorBufferPool._$samples       = samples;

        }
    }
}

/**
 * @class
 */
class CanvasToWebGLContextBlend
{
    /**
     * @constructor
     */
    constructor (context, gl)
    {
        this._$context  = context;
        this._$gl       = gl;
        this._$enabled  = false;
        this._$funcCode = 600;

        this.enable();
    }

    /**
     * @return void
     * @public
     */
    enable ()
    {
        if (!this._$enabled) {
            this._$enabled = true;
            this._$gl.enable(this._$gl.BLEND);
        }

        this.reset();
    }

    /**
     * @return void
     * @public
     */
    disable ()
    {
        if (this._$enabled) {
            this._$enabled = false;
            this._$gl.disable(this._$gl.BLEND);
        }
    }

    /**
     * @return void
     * @public
     */
    reset ()
    {
        if (this._$funcCode !== 613) {
            this._$funcCode = 613;
            this._$gl.blendFunc(this._$gl.ONE, this._$gl.ONE_MINUS_SRC_ALPHA);
        }
    }

    /**
     * @return void
     * @public
     */
    toOneZero ()
    {
        if (this._$funcCode !== 610) {
            this._$funcCode = 610;
            this._$gl.blendFunc(this._$gl.ONE, this._$gl.ZERO);
        }
    }

    /**
     * @return void
     * @public
     */
    toZeroOne ()
    {
        if (this._$funcCode !== 601) {
            this._$funcCode = 601;
            this._$gl.blendFuncSeparate(
                this._$gl.ZERO, this._$gl.ONE,
                this._$gl.ONE, this._$gl.ZERO
            );
        }
    }

    /**
     * @return void
     * @public
     */
    toAdd ()
    {
        if (this._$funcCode !== 611) {
            this._$funcCode = 611;
            this._$gl.blendFunc(this._$gl.ONE, this._$gl.ONE);
        }
    }

    /**
     * @return void
     * @public
     */
    toScreen ()
    {
        if (this._$funcCode !== 641) {
            this._$funcCode = 641;
            this._$gl.blendFunc(this._$gl.ONE_MINUS_DST_COLOR, this._$gl.ONE);
        }
    }

    /**
     * @return void
     * @public
     */
    toAlpha ()
    {
        if (this._$funcCode !== 606) {
            this._$funcCode = 606;
            this._$gl.blendFunc(this._$gl.ZERO, this._$gl.SRC_ALPHA);
        }
    }

    /**
     * @return void
     * @public
     */
    toErase ()
    {
        if (this._$funcCode !== 603) {
            this._$funcCode = 603;
            this._$gl.blendFunc(this._$gl.ZERO, this._$gl.ONE_MINUS_SRC_ALPHA);
        }
    }

    /**
     * @return void
     * @public
     */
    toSourceAtop ()
    {
        if (this._$funcCode !== 673) {
            this._$funcCode = 673;
            this._$gl.blendFunc(this._$gl.DST_ALPHA, this._$gl.ONE_MINUS_SRC_ALPHA);
        }
    }/**
     * @return void
     * @public
     */
    toSourceIn ()
    {
        if (this._$funcCode !== 670) {
            this._$funcCode = 670;
            this._$gl.blendFunc(this._$gl.DST_ALPHA, this._$gl.ZERO);
        }
    }

    toOperation (operation)
    {
        switch (operation) {
            case BlendMode.ADD:
                this.toAdd();
                break;
            case BlendMode.SCREEN:
                this.toScreen();
                break;
            case BlendMode.ALPHA:
                this.toAlpha();
                break;
            case BlendMode.ERASE:
                this.toErase();
                break;
            case "copy":
                this.toOneZero();
                break;
            default:
                this.reset();
                break;
        }
    }

    /**
     * @return void
     * @public
     */
    drawImage (
        image, x, y, w, h,
        ct0, ct1, ct2, ct3, ct4, ct5, ct6, ct7,
        operation, renderWidth, renderHeight, matrix, imageSmoothingEnabled
    ) {
        const currentBuffer = this._$context._$frameBufferManager.currentAttachment;

        const withCT =
            ct0 !== 1 || ct1 !== 1 || ct2 !== 1 || ct3 !== 1 ||
            ct4 !== 0 || ct5 !== 0 || ct6 !== 0 || ct7 !== 0
        ;

        const variants = this._$context._$shaderList.blendShaderVariants;

        switch (operation) {
            case BlendMode.NORMAL:
            case BlendMode.LAYER:
            case BlendMode.ADD:
            case BlendMode.SCREEN:
            case BlendMode.ALPHA:
            case BlendMode.ERASE:
            case "copy":
                {
                    this._$context._$frameBufferManager._$textureManager.bind0(image, imageSmoothingEnabled);

                    const shader = variants.getNormalBlendShader(withCT);
                    variants.setNormalBlendUniform(
                        shader.uniform, x, y, w, h, matrix, renderWidth, renderHeight,
                        withCT, ct0, ct1, ct2, ct3, ct4, ct5, ct6, ct7
                    );

                    const a  = matrix[0];
                    const b  = matrix[1];
                    const c  = matrix[3];
                    const d  = matrix[4];
                    const tx = matrix[6];
                    const ty = matrix[7];

                    if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                        const left   = x;
                        const right  = x + w;
                        const top    = y;
                        const bottom = y + h;

                        const x0 = +(right * a + bottom * c + tx);
                        const x1 = +(right * a + top    * c + tx);
                        const x2 = +(left  * a + bottom * c + tx);
                        const x3 = +(left  * a + top    * c + tx);
                        const y0 = +(right * b + bottom * d + ty);
                        const y1 = +(right * b + top    * d + ty);
                        const y2 = +(left  * b + bottom * d + ty);
                        const y3 = +(left  * b + top    * d + ty);

                        const no = $Number.MAX_VALUE;
                        const xMin = +$Math.min($Math.min($Math.min($Math.min( no, x0), x1), x2), x3);
                        const xMax = +$Math.max($Math.max($Math.max($Math.max(-no, x0), x1), x2), x3);
                        const yMin = +$Math.min($Math.min($Math.min($Math.min( no, y0), y1), y2), y3);
                        const yMax = +$Math.max($Math.max($Math.max($Math.max(-no, y0), y1), y2), y3);

                        const sx = $Math.max(0, xMin | 0);
                        const sy = $Math.max(0, yMin | 0);
                        const sw = $Math.min($Math.max(0, renderWidth  - sx), $Math.ceil($Math.abs(xMax - xMin)));
                        const sh = $Math.min($Math.max(0, renderHeight - sy), $Math.ceil($Math.abs(yMax - yMin)));

                        if (!sw || !sh) {
                            return ;
                        }

                        this._$gl.enable(this._$gl.SCISSOR_TEST);
                        this._$gl.scissor(sx, $Math.max(0, renderHeight - (sy + sh)), sw + 1, sh + 1);
                    } else {
                        const sx = $Math.max(0, x + tx | 0);
                        const sy = $Math.max(0, y + ty | 0);
                        const sw = $Math.min($Math.max(0, renderWidth  - sx), w);
                        const sh = $Math.min($Math.max(0, renderHeight - sy), h);

                        if (!sw || !sh) {
                            return ;
                        }

                        this._$gl.enable(this._$gl.SCISSOR_TEST);
                        this._$gl.scissor(sx, $Math.max(0, renderHeight - (sy + sh)), sw + 1, sh + 1);
                    }

                    this.toOperation(operation);
                    shader._$drawImage();

                    this._$gl.disable(this._$gl.SCISSOR_TEST);
                }
                break;

            default:
                {
                    const sx = $Math.max(0, x + matrix[6] | 0);
                    const sy = $Math.max(0, y + matrix[7] | 0);
                    const sw = $Math.min($Math.max(0, renderWidth  - sx), w);
                    const sh = $Math.min($Math.max(0, renderHeight - sy), h);

                    if (!sw || !sh) {
                        return ;
                    }

                    const texture = this._$context._$frameBufferManager.getTextureFromCurrentAttachment();

                    const backTextureAttachment = this._$context._$frameBufferManager.createTextureAttachment(w, h);
                    this._$context._$bind(backTextureAttachment);
                    this._$context._$frameBufferManager._$textureManager.bind0(texture);

                    const clipShader = variants.getClipShader();
                    const clipUniform = clipShader.uniform;
                    variants.setClipUniform(clipUniform, x, y, w, h, Util.$inverseMatrix(matrix), renderWidth, renderHeight);

                    this.reset();
                    clipShader._$drawImage();
                    const backTexture = this._$context._$frameBufferManager.getTextureFromCurrentAttachment();

                    this._$context._$bind(currentBuffer);

                    this._$context._$frameBufferManager._$textureManager.bind01(backTexture, image, imageSmoothingEnabled);

                    const shader = variants.getBlendShader(operation, withCT);
                    variants.setBlendUniform(
                        shader.uniform, x, y, w, h, matrix, renderWidth, renderHeight,
                        withCT, ct0, ct1, ct2, ct3, ct4, ct5, ct6, ct7
                    );

                    this._$gl.enable(this._$gl.SCISSOR_TEST);
                    this._$gl.scissor(sx, $Math.max(0, renderHeight - (sy + sh)), sw, sh);

                    this.toOneZero();
                    shader._$drawImage();

                    this._$gl.disable(this._$gl.SCISSOR_TEST);

                    this._$context._$frameBufferManager.releaseAttachment(backTextureAttachment, true);

                }
                break;
        }
    }
}
/**
 * @class
 */
class CanvasToWebGLContextGrid
{
    /**
     * @constructor
     */
    constructor ()
    {
        this.enabled = false;

        this.parentMatrixA = 1;
        this.parentMatrixB = 0;
        this.parentMatrixC = 0;
        this.parentMatrixD = 0;
        this.parentMatrixE = 1;
        this.parentMatrixF = 0;
        this.parentMatrixG = 0;
        this.parentMatrixH = 0;
        this.parentMatrixI = 1;

        this.ancestorMatrixA = 1;
        this.ancestorMatrixB = 0;
        this.ancestorMatrixC = 0;
        this.ancestorMatrixD = 0;
        this.ancestorMatrixE = 1;
        this.ancestorMatrixF = 0;
        this.ancestorMatrixG = 0;
        this.ancestorMatrixH = 0;
        this.ancestorMatrixI = 1;

        this.parentViewportX = 0;
        this.parentViewportY = 0;
        this.parentViewportW = 0;
        this.parentViewportH = 0;

        this.minXST = 0.00001;
        this.minYST = 0.00001;
        this.minXPQ = 0.00001;
        this.minYPQ = 0.00001;

        this.maxXST = 0.99999;
        this.maxYST = 0.99999;
        this.maxXPQ = 0.99999;
        this.maxYPQ = 0.99999;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} bounds
     * @param {Rectangle} grid
     * @param {number} parentA
     * @param {number} parentB
     * @param {number} parentC
     * @param {number} parentD
     * @param {number} parentE
     * @param {number} parentF
     * @param {number} ancestorA
     * @param {number} ancestorB
     * @param {number} ancestorC
     * @param {number} ancestorD
     * @param {number} ancestorE
     * @param {number} ancestorF
     * @return void
     * @public
     */
    enable (
        x, y, width, height, bounds, grid,
        parentA, parentB, parentC, parentD, parentE, parentF,
        ancestorA, ancestorB, ancestorC, ancestorD, ancestorE, ancestorF
    ) {

        const boundsWidth  = bounds.xMax - bounds.xMin;
        const boundsHeight = bounds.yMax - bounds.yMin;
        const gridWidth  = grid._$width;
        const gridHeight = grid._$height;

        const player = Util.$currentPlayer();
        const sameScale  = player._$scale * player._$ratio;
        const sameWidth  = $Math.abs($Math.ceil(boundsWidth  * sameScale));
        const sameHeight = $Math.abs($Math.ceil(boundsHeight * sameScale));

        // 等倍サイズでの正規化grid
        const minXST = gridWidth  > 0 ? (grid._$x - bounds.xMin) / boundsWidth  : 0.00001;
        const minYST = gridHeight > 0 ? (grid._$y - bounds.yMin) / boundsHeight : 0.00001;
        const maxXST = gridWidth  > 0 ? (grid._$x + grid._$width  - bounds.xMin) / boundsWidth  : 0.99999;
        const maxYST = gridHeight > 0 ? (grid._$y + grid._$height - bounds.yMin) / boundsHeight : 0.99999;

        // 現在サイズでの正規化grid
        let minXPQ = sameWidth  * minXST / width;
        let minYPQ = sameHeight * minYST / height;
        let maxXPQ = (width  - sameWidth  * (1 - maxXST)) / width;
        let maxYPQ = (height - sameHeight * (1 - maxYST)) / height;

        if (minXPQ >= maxXPQ) {
            const m = minXST / (minXST + (1 - maxXST));
            minXPQ = $Math.max(m - 0.00001, 0);
            maxXPQ = $Math.min(m + 0.00001, 1);
        }

        if (minYPQ >= maxYPQ) {
            const m = minYST / (minYST + (1 - maxYST));
            minYPQ = $Math.max(m - 0.00001, 0);
            maxYPQ = $Math.min(m + 0.00001, 1);
        }

        this.enabled = true;

        this.parentMatrixA = parentA;
        this.parentMatrixB = parentB;
        this.parentMatrixD = parentC;
        this.parentMatrixE = parentD;
        this.parentMatrixG = parentE;
        this.parentMatrixH = parentF;

        this.ancestorMatrixA = ancestorA;
        this.ancestorMatrixB = ancestorB;
        this.ancestorMatrixD = ancestorC;
        this.ancestorMatrixE = ancestorD;
        this.ancestorMatrixG = ancestorE;
        this.ancestorMatrixH = ancestorF;

        this.parentViewportX = x;
        this.parentViewportY = y;
        this.parentViewportW = width;
        this.parentViewportH = height;

        this.minXST = minXST;
        this.minYST = minYST;
        this.minXPQ = minXPQ;
        this.minYPQ = minYPQ;

        this.maxXST = maxXST;
        this.maxYST = maxYST;
        this.maxXPQ = maxXPQ;
        this.maxYPQ = maxYPQ;
    }

    /**
     * @return void
     * @public
     */
    disable ()
    {
        this.enabled = false;
    }
}
/**
 * @class
 */
class CanvasToWebGLContextMask
{
    /**
     * @constructor
     */
    constructor (context, gl)
    {
        this._$context       = context;
        this._$gl            = gl;
        this._$clips         = [];
        this._$clipStatus    = false;
        this._$containerClip = false;
        this._$poolClip      = [];
        this._$currentClip   = false;
    }

    _$onClear (mask)
    {
        if (mask) {
            this._$gl.enable(this._$gl.STENCIL_TEST);
            this._$currentClip = true;
        }
    }

    _$onBind (mask)
    {
        if (!mask && this._$currentClip) {
            // キャッシュ作成前は、一旦マスクを無効にする
            this._$gl.disable(this._$gl.STENCIL_TEST);
            this._$currentClip = false;
        } else if (mask && !this._$currentClip) {
            // キャッシュ作成後は、マスクの状態を復元する
            this._$gl.enable(this._$gl.STENCIL_TEST);
            this._$currentClip = true;
            this._$endClipDef();
        }
    }

    _$onClearRect ()
    {
        this._$gl.disable(this._$gl.STENCIL_TEST);
        this._$currentClip = false;
    }

    /**
     * @private
     */
    _$endClip ()
    {
        const manager = this._$context._$frameBufferManager;

        const texture = manager.getTextureFromCurrentAttachment();
        const currentBuffer = manager.currentAttachment;

        this._$context._$bind(this._$context._$cacheCurrentBuffer);
        this._$context._$cacheCurrentBuffer = null;

        // blend off
        this._$context._$blend.disable();

        const x = this._$context._$cacheCurrentBounds.x;
        const y = this._$context._$cacheCurrentBounds.y;
        const w = this._$context._$cacheCurrentBounds.w;
        const h = this._$context._$cacheCurrentBounds.h;

        Util.$resetContext(this._$context);
        this._$context.setTransform(1, 0, 0, 1, 0, 0);
        this._$context.drawImage(texture, x, y, w, h);

        // blend restart
        this._$context._$blend.enable();

        manager.releaseAttachment(currentBuffer, true);
    }

    /**
     * @param  {DisplayObject} display_object
     * @param  {Float32Array} matrix
     * @return {Float32Array}
     * @public
     */
    _$startClip (display_object, matrix)
    {

        const tMatrix = Util.$multiplicationMatrix(
            matrix,
            display_object._$transform._$rawMatrix()
        );

        const baseBounds = display_object._$getBounds(null);
        const bounds = Util.$boundsMatrix(baseBounds, tMatrix);
        Util.$poolFloat32Array9(tMatrix);
        Util.$poolBoundsObject(baseBounds);

        // size
        let x      = bounds.xMin;
        let y      = bounds.yMin;
        let width  = $Math.abs(bounds.xMax - bounds.xMin);
        let height = $Math.abs(bounds.yMax - bounds.yMin);
        Util.$poolBoundsObject(bounds);

        // resize
        const manager = this._$context._$frameBufferManager;
        const currentBuffer = manager.currentAttachment;
        if (width + x > currentBuffer.texture.width) {
            width -= width - currentBuffer.texture.width + x;
        }

        if (height + y > currentBuffer.texture.height) {
            height -= height - currentBuffer.texture.height + y;
        }

        if (0 > x) {
            width += x;
            x = 0;
        }

        if (0 > y) {
            height += y;
            y = 0;
        }

        if (0 >= width || 0 >= height) {
            return null;
        }

        width  = $Math.ceil(width);
        height = $Math.ceil(height);

        // set bounds
        this._$context._$cacheCurrentBounds.x = x;
        this._$context._$cacheCurrentBounds.y = y;
        this._$context._$cacheCurrentBounds.w = width;
        this._$context._$cacheCurrentBounds.h = height;

        // cache
        const texture = manager.getTextureFromCurrentAttachment();

        this._$context._$cacheCurrentBuffer = currentBuffer;

        const player = Util.$currentPlayer();

        const samples = this._$context._$isWebGL2Context
            && (player._$quality === StageQuality.LOW || player._$quality === StageQuality.MIDDLE)
            ? $Math.min(Util.$HIGH_SAMPLES, this._$gl.getParameter(this._$gl.MAX_SAMPLES))
            : 0;

        // create new buffer
        const buffer = manager
            .createCacheAttachment(width, height, true, samples);
        this._$context._$bind(buffer);

        // draw background
        Util.$resetContext(this._$context);
        this._$context.setTransform(1, 0, 0, 1, 0, 0);
        this._$context.drawImage(texture, -x, -y, texture.width, texture.height);

        return Util.$getFloat32Array9(
            matrix[0], matrix[1], matrix[2], matrix[3],
            matrix[4] - x,
            matrix[5] - y
        );
    }

    /**
     * @return void
     * @public
     */
    _$enterClip ()
    {
        if (!this._$currentClip) {
            this._$gl.enable(this._$gl.STENCIL_TEST);
            this._$currentClip = true;
        }

        // buffer mask on
        const currentBuffer = this._$context._$frameBufferManager.currentAttachment;
        currentBuffer.mask  = true;
        ++currentBuffer.clipLevel;
    }

    /**
     * @return void
     * @public
     */
    _$beginClipDef ()
    {
        const currentBuffer = this._$context._$frameBufferManager.currentAttachment;

        this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE);
        this._$gl.stencilFunc(this._$gl.ALWAYS, 0, 0xff);
        this._$gl.stencilOp(this._$gl.KEEP, this._$gl.INVERT, this._$gl.INVERT);
        this._$gl.stencilMask(1 << currentBuffer.clipLevel - 1);
        this._$gl.colorMask(false, false, false, false);
    }

    /**
     * @return void
     * @public
     */
    _$endClipDef ()
    {
        const currentBuffer = this._$context._$frameBufferManager.currentAttachment;
        const clipLevel = currentBuffer.clipLevel;

        let mask = 0;
        for (let idx = 0; idx < clipLevel; ++idx) {
            mask |= (1 << clipLevel - idx) - 1;
        }

        this._$gl.disable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE);
        this._$gl.stencilFunc(this._$gl.EQUAL, mask & 0xff, mask);
        this._$gl.stencilOp(this._$gl.KEEP, this._$gl.KEEP, this._$gl.KEEP);
        this._$gl.stencilMask(0xff);
        this._$gl.colorMask(true, true, true, true);
    }

    /**
     * @return void
     * @public
     */
    _$leaveClip ()
    {
        const currentBuffer = this._$context._$frameBufferManager.currentAttachment;
        --currentBuffer.clipLevel;
        currentBuffer.mask = Util.$toBoolean(currentBuffer.clipLevel);

        // end clip
        if (!currentBuffer.clipLevel) {
            this._$context._$clearRectStencil(0, 0, currentBuffer.width, currentBuffer.height);
            if (this._$context._$cacheCurrentBuffer) {
                this._$endClip();
            }
            return;
        }

        // replace
        const w = currentBuffer.width;
        const h = currentBuffer.height;

        // create buffer
        const vertices = this._$context._$path.createRectVertices(0, 0, w, h);
        const object = this._$context._$vao.createFill(vertices);
        Util.$poolArray(vertices.pop());
        Util.$poolArray(vertices);

        const variants = this._$context._$shaderList.shapeShaderVariants;
        const shader = variants.getMaskShapeShader(false, false);
        const uniform = shader.uniform;
        variants.setMaskShapeUniformIdentity(uniform, w, h);

        const range = object.indexRanges[0];

        // deny
        if (!this._$currentClip) {
            this._$currentClip = true;
            this._$gl.enable(this._$gl.STENCIL_TEST);
        }

        this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE);
        this._$gl.stencilFunc(this._$gl.ALWAYS, 0, 0xff);
        this._$gl.stencilOp(this._$gl.REPLACE, this._$gl.REPLACE, this._$gl.REPLACE);
        this._$gl.stencilMask(1 << currentBuffer.clipLevel);
        this._$gl.colorMask(false, false, false, false);

        shader._$containerClip(object, range.first, range.count);

        // object pool
        this._$context._$vao.release(object);
        Util.$poolArray(object.indexRanges);

        this._$context._$endClipDef();
    }

    /**
     * @return void
     * @public
     */
    _$drawContainerClip ()
    {
        const currentBuffer = this._$context._$frameBufferManager.currentAttachment;
        const currentClipLevel = currentBuffer.clipLevel;

        const length = this._$poolClip.length;
        const variants = this._$context._$shaderList.shapeShaderVariants;
        const shader = variants.getMaskShapeShader(false, false);
        const uniform = shader.uniform;

        let useLevel = currentClipLevel;

        // create buffer
        const w = currentBuffer.width;
        const h = currentBuffer.height;

        this._$gl.enable(this._$gl.SAMPLE_ALPHA_TO_COVERAGE);
        this._$gl.stencilFunc(this._$gl.ALWAYS, 0, 0xff);
        this._$gl.stencilOp(this._$gl.KEEP, this._$gl.INVERT, this._$gl.INVERT);
        this._$gl.colorMask(false, false, false, false);
        for (let idx = 0; idx < length; ++idx) {

            const object = this._$poolClip.shift(); // fixed

            variants.setMaskShapeUniform(
                uniform, false,
                object.matrixA, object.matrixB, object.matrixC,
                object.matrixD, object.matrixE, object.matrixF,
                object.matrixG, object.matrixH, object.matrixI,
                object.viewportWidth, object.viewportHeight, null
            );

            const oLen = object.fillBuffer.indexRanges.length;
            for (let idx = 0; idx < oLen; ++idx) {

                const range = object.fillBuffer.indexRanges[idx];

                this._$gl.stencilMask(1 << useLevel - 1);
                shader._$containerClip(object.fillBuffer, range.first, range.count);

            }

            ++useLevel;

            // union
            if (useLevel > 7) {

                // union
                this._$context._$unionStencilMask(currentClipLevel, w, h);

                // reset
                useLevel = currentClipLevel;

            }

        }

        // last union
        if (useLevel > currentClipLevel + 1) {
            this._$context._$unionStencilMask(currentClipLevel, w, h);
        }
    }

    /**
     * @param  {uint} level
     * @param  {uint} w
     * @param  {uint} h
     * @return void
     * @private
     */
    _$unionStencilMask (level, w, h)
    {
        // create buffer
        const vertices = this._$context._$path.createRectVertices(0, 0, w, h);
        const object = this._$context._$vao.createFill(vertices);
        Util.$poolArray(vertices.pop());
        Util.$poolArray(vertices);

        const variants = this._$context._$shaderList.shapeShaderVariants;
        const shader = variants.getMaskShapeShader(false, false);
        const uniform = shader.uniform;
        variants.setMaskShapeUniformIdentity(uniform, w, h);

        const range = object.indexRanges[0];

        // 例として level=4 の場合
        //
        // ステンシルバッファの4ビット目以上を4ビット目に統合する。
        //   |?|?|?|?|?|*|*|*|  ->  | | | | |?|*|*|*|
        //
        // このとき、4ビット目以上に1のビットが1つでもあれば4ビット目を1、
        // そうでなければ4ビット目を0とする。
        //
        //   00000***  ->  00000***
        //   00001***  ->  00001***
        //   00010***  ->  00001***
        //   00011***  ->  00001***
        //   00100***  ->  00001***
        //    ...
        //   11101***  ->  00001***
        //   11110***  ->  00001***
        //   11111***  ->  00001***
        //
        // したがってステンシルの現在の値を 00001000 と比較すればよい。
        // 比較して 00001000 以上であれば 00001*** で更新し、そうでなければ 00000*** で更新する。
        // 下位3ビットは元の値を保持する必要があるので 11111000 でマスクする。

        this._$gl.stencilFunc(this._$gl.LEQUAL, 1 << level - 1, 0xff);
        this._$gl.stencilOp(this._$gl.ZERO, this._$gl.REPLACE, this._$gl.REPLACE);
        this._$gl.stencilMask(~((1 << level - 1) - 1));

        shader._$containerClip(object, range.first, range.count);

        // reset
        if (this._$poolClip.length) {
            this._$gl.stencilFunc(this._$gl.ALWAYS, 0, 0xff);
            this._$gl.stencilOp(this._$gl.KEEP, this._$gl.INVERT, this._$gl.INVERT);
        }

        // object pool
        this._$context._$vao.release(object);
        Util.$poolArray(object.indexRanges);

    }

    /**
     * @return {boolean}
     */
    _$onClip (matrix, viewportWidth, viewportHeight)
    {
        this._$clipStatus = true;

        if (this._$containerClip) {

            this._$poolClip[this._$poolClip.length] = {
                "fillBuffer": this._$context._$fillBuffer,
                "matrixA": matrix[0],
                "matrixB": matrix[1],
                "matrixC": matrix[2],
                "matrixD": matrix[3],
                "matrixE": matrix[4],
                "matrixF": matrix[5],
                "matrixG": matrix[6],
                "matrixH": matrix[7],
                "matrixI": matrix[8],
                "viewportWidth": viewportWidth,
                "viewportHeight": viewportHeight
            };

            return true;
        }

        return false;
    }

    /**
     * @return void
     * @public
     */
    _$onSave ()
    {
        this._$clips[this._$clips.length] = this._$clipStatus;
    }

    /**
     * @return void
     * @public
     */
    _$onRestore ()
    {
        if (this._$clips.length) {
            this._$clipStatus = Util.$toBoolean(this._$clips.pop());
        }
    }
}

/**
 * @class
 */
class CanvasToWebGLContextPath
{
    /**
     * @constructor
     */
    constructor ()
    {
        this._$currentPath = [];
        this._$vertices    = [];
        this._$bounds      = { "xMin": 0, "xMax": 0, "yMin": 0, "yMax": 0 };
        this._$resetBounds();
    }

    /**
     * @memberof CanvasToWebGLContextPath#
     * @property {array}
     * @return {array}
     * @public
     */
    get vertices ()
    {
        this._$pushCurrentPathToVertices();
        return this._$vertices;
    }

    /**
     * @return void
     * @public
     */
    begin ()
    {
        this._$currentPath.length = 0;

        while (this._$vertices.length) {
            Util.$poolArray(this._$vertices.pop());
        }

        this._$resetBounds();
    }

    /**
     * @param {number} x
     * @param {number} y
     * @return void
     * @public
     */
    moveTo (x, y)
    {
        if (!this._$currentPath.length) {
            this._$pushPointToCurrentPath(x, y, false);
            return;
        }

        if (this._$equalsToLastPoint(x, y)) {
            return;
        }

        this._$pushCurrentPathToVertices();
        this._$pushPointToCurrentPath(x, y, false);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @return void
     * @public
     */
    lineTo (x, y)
    {
        if (!this._$currentPath.length) {
            this.moveTo(0, 0);
        }

        if (this._$equalsToLastPoint(x, y)) {
            return;
        }

        this._$pushPointToCurrentPath(x, y, false);
    }

    /**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} x
     * @param  {number} y
     * @return void
     * @public
     */
    quadTo (cx, cy, x, y)
    {
        if (!this._$currentPath.length) {
            this.moveTo(0, 0);
        }

        if (this._$equalsToLastPoint(x, y)) {
            return;
        }

        this._$pushPointToCurrentPath(cx, cy, true);
        this._$pushPointToCurrentPath(x, y, false);
    }

    /**
     * @param {number} cx1
     * @param {number} cy1
     * @param {number} cx2
     * @param {number} cy2
     * @param {number} x
     * @param {number} y
     * @return void
     * @public
     */
    cubicTo (cx1, cy1, cx2, cy2, x, y)
    {
        if (!this._$currentPath.length) {
            this.moveTo(0, 0);
        }

        if (this._$equalsToLastPoint(x, y)) {
            return;
        }

        const fromX = this._$currentPath[this._$currentPath.length - 3];
        const fromY = this._$currentPath[this._$currentPath.length - 2];
        BezierConverter.cubicToQuad(fromX, fromY, cx1, cy1, cx2, cy2, x, y);

        const length = Util.$bezierConverterBuffer.length;
        for (let i = 0; i < length; ) {
            this.quadTo(
                Util.$bezierConverterBuffer[i++],
                Util.$bezierConverterBuffer[i++],
                Util.$bezierConverterBuffer[i++],
                Util.$bezierConverterBuffer[i++]
            );
        }
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @return void
     * @public
     */
    drawCircle (x, y, radius)
    {
        const r = radius;
        const k = radius * 0.5522847498307936;
        this.cubicTo(x + r, y + k, x + k, y + r, x, y + r);
        this.cubicTo(x - k, y + r, x - r, y + k, x - r, y);
        this.cubicTo(x - r, y - k, x - k, y - r, x, y - r);
        this.cubicTo(x + k, y - r, x + r, y - k, x + r, y);
    }

    /**
     * @return void
     * @public
     */
    close ()
    {
        if (this._$currentPath.length <= 6) {
            return;
        }

        const x = this._$currentPath[0];
        const y = this._$currentPath[1];

        if (this._$equalsToLastPoint(x, y)) {
            return;
        }

        this._$pushPointToCurrentPath(x, y, false);
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     * @private
     */
    _$equalsToLastPoint (x, y)
    {
        const lastX = this._$currentPath[this._$currentPath.length - 3];
        const lastY = this._$currentPath[this._$currentPath.length - 2];
        return x === lastX && y === lastY;
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {boolean} isControlPoint
     * @return void
     * @private
     */
    _$pushPointToCurrentPath (x, y, isControlPoint)
    {
        this._$currentPath.push(x);
        this._$currentPath.push(y);
        this._$currentPath.push(isControlPoint);

        this._$bounds.xMin = $Math.min(x, this._$bounds.xMin);
        this._$bounds.xMax = $Math.max(x, this._$bounds.xMax);
        this._$bounds.yMin = $Math.min(y, this._$bounds.yMin);
        this._$bounds.yMax = $Math.max(y, this._$bounds.yMax);
    }

    /**
     * @return void
     * @private
     */
    _$pushCurrentPathToVertices ()
    {
        if (this._$currentPath.length <= 3) {
            this._$currentPath.length = 0;
            return;
        }

        this._$vertices.push(this._$currentPath);
        this._$currentPath = Util.$getArray();
    }

    /**
     * @return void
     * @private
     */
    _$resetBounds ()
    {
        const v = $Number.MAX_VALUE;
        this._$bounds.xMin =  v;
        this._$bounds.xMax = -v;
        this._$bounds.yMin =  v;
        this._$bounds.yMax = -v;
    }

    /**
     * @return {array}
     * @public
     */
    getBoundsVertices ()
    {
        return Util.$getArray(Util.$getArray(
            this._$bounds.xMin, this._$bounds.yMin, false,
            this._$bounds.xMax, this._$bounds.yMin, false,
            this._$bounds.xMax, this._$bounds.yMax, false,
            this._$bounds.xMin, this._$bounds.yMax, false
        ));
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} w
     * @param  {number} h
     * @return {array}
     * @public
     */
    createRectVertices (x, y, w, h)
    {
        return Util.$getArray(Util.$getArray(
            x,     y,     false,
            x + w, y,     false,
            x + w, y + h, false,
            x,     y + h, false
        ));
    }
}

/**
 * @class
 */
class CanvasToWebGLContextStyle
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        this._$fillStyle   = new $Float32Array([1, 1, 1, 1]); // fixed size 4
        this._$strokeStyle = new $Float32Array([1, 1, 1, 1]); // fixed size 4
        this._$lineWidth   = 1;
        this._$lineCap     = 0;
        this._$lineJoin    = 0;
        this._$miterLimit  = 5;
    }
}
/**
 * @class
 */
class ColorBufferPool
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {number}                samples
     * @constructor
     */
    constructor (gl, samples)
    {
        this._$gl         = gl;
        this._$samples    = samples;
        this._$objectPool = [];
    }

    /**
     * @return {WebGLRenderbuffer}
     * @private
     */
    _$createColorBuffer ()
    {
        const colorBuffer   = this._$gl.createRenderbuffer();
        colorBuffer.stencil = this._$gl.createRenderbuffer();
        colorBuffer.width   = 0;
        colorBuffer.height  = 0;
        colorBuffer.area    = 0;
        colorBuffer.dirty   = true;
        return colorBuffer;
    }

    /**
     * @param  {number} area
     * @return {WebGLRenderbuffer}
     * @private
     */
    _$getColorBuffer (area)
    {
        if (!this._$objectPool.length) {
            return this._$createColorBuffer();
        }

        const index = this._$bsearch(area);
        if (index < this._$objectPool.length) {
            const colorBuffer = this._$objectPool[index];
            this._$objectPool.splice(index, 1);
            return colorBuffer;
        }

        return this._$objectPool.shift();
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {uint}   [samples=0]
     * @return {WebGLRenderbuffer}
     * @public
     */
    create (width, height, samples = 0)
    {
        // 128以下で描画崩れが発生する場合がある？ため、256を最小サイズにする
        width  = $Math.max(256, Util.$upperPowerOfTwo(width));
        height = $Math.max(256, Util.$upperPowerOfTwo(height));

        const colorBuffer = this._$getColorBuffer(width * height);

        if (colorBuffer.width < width
            || colorBuffer.height < height
            || samples && colorBuffer.samples !== samples
        ) {
            width  = $Math.max(width,  colorBuffer.width);
            height = $Math.max(height, colorBuffer.height);

            colorBuffer.samples = samples || this._$samples;
            colorBuffer.width   = width;
            colorBuffer.height  = height;
            colorBuffer.area    = width * height;
            colorBuffer.dirty   = false;

            this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER, colorBuffer);
            this._$gl.renderbufferStorageMultisample(
                this._$gl.RENDERBUFFER,
                samples || this._$samples,
                this._$gl.RGBA8,
                width, height
            );

            this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER, colorBuffer.stencil);
            this._$gl.renderbufferStorageMultisample(
                this._$gl.RENDERBUFFER,
                samples || this._$samples,
                this._$gl.STENCIL_INDEX8,
                width, height
            );
        }

        return colorBuffer;
    }

    /**
     * @param  {WebGLRenderbuffer} colorBuffer
     * @return void
     * @public
     */
    release (colorBuffer)
    {
        colorBuffer.dirty = true;

        const index = this._$bsearch(colorBuffer.area);
        this._$objectPool.splice(index, 0, colorBuffer);
    }

    /**
     * @description 「めぐる式二分探索法」で面積が引数以上の要素のインデックスを求める
     * @param  {number} area
     * @return {number}
     * @private
     */
    _$bsearch (area)
    {
        let ng = -1;
        let ok = this._$objectPool.length;

        while ($Math.abs(ok - ng) > 1) {
            const mid = $Math.floor((ok + ng) / 2);
            if (area <= this._$objectPool[mid].area) {
                ok = mid;
            } else {
                ng = mid;
            }
        }

        return ok;
    }
}
const ConvexHullVars = {};
ConvexHullVars.vertices           = null;
ConvexHullVars.subhulls           = new Array(512);
ConvexHullVars.subhullsIndex      = 0;
ConvexHullVars.extremePoints      = new Array(32);
ConvexHullVars.extremePointsIndex = 0;
ConvexHullVars.t                  = 0;
ConvexHullVars.hulls              = [new Array(16), new Array(64), new Array(256)];
ConvexHullVars.hullsIndex         = 0;

/**
 * @class
 */
class ConvexHull
{
    /**
     * @param  {array} vertices
     * @return {array}
     */
    static compute (vertices)
    {
        // 頂点数が3以下ならそのまま返す
        if (vertices.length <= 9) {
            return vertices;
        }

        ConvexHullVars.vertices = vertices;

        this.chansAlgorithm();

        // 最後に凸包の配列を生成する
        const result = new Array(ConvexHullVars.hullsIndex * 3);
        for (let i = 0; i < ConvexHullVars.hullsIndex; i++) {
            result[i * 3    ] = vertices[ConvexHullVars.subhulls[ConvexHullVars.hulls[ConvexHullVars.t][i]]];
            result[i * 3 + 1] = vertices[ConvexHullVars.subhulls[ConvexHullVars.hulls[ConvexHullVars.t][i]] + 1];
            result[i * 3 + 2] = false;
        }

        ConvexHullVars.vertices = null;

        return result;
    }

    static chansAlgorithm ()
    {
        for (let t = 0; t < 3; t++) {
            ConvexHullVars.t = t;

            // 要素数mは、元のアルゴリズムではなくswf2js用にカスタムして計算する
            // const m = $Math.pow(2, $Math.pow(2, t));
            const m = 16 * $Math.pow(4, t);
            const m3 = m * 3;

            // 点集合を要素数mの部分集合に分割し、部分凸包(subhulls)を求める
            this.clearSubhulls();
            this.clearExtremePoints();
            const verticesLength = ConvexHullVars.vertices.length;
            for (let i = 0; i < verticesLength; i += m3) {
                this.calcSubhulls(i, $Math.min(i + m3, verticesLength));
            }

            // 部分凸包のサイズを求めるために、最後にConvexHullVars.subhullsIndexを追加する
            this.addExtremePoint(ConvexHullVars.subhullsIndex);

            // this.calcSubhulls()で流用したConvexHullVars.hullsを初期化しておく
            this.clearHulls();

            // x座標が最も小さい点を、初期の基準点にする
            // （初期の基準点まで戻ったら凸包完成判定）
            const extremeSubhullsIndex = this.getExtremeSubhullsIndex();

            // console.log("initial",extremeSubhullsIndex,ConvexHullVars.vertices[ConvexHullVars.subhulls[extremeSubhullsIndex]],ConvexHullVars.vertices[ConvexHullVars.subhulls[extremeSubhullsIndex] + 1]);

            let currentSubhullsIndex = extremeSubhullsIndex;
            let isComplete = false;
            for (;;) {
                // 基準点を、凸包(hulls)に追加する
                ConvexHullVars.hulls[ConvexHullVars.t][ConvexHullVars.hullsIndex++] = currentSubhullsIndex;

                // もし凸包サイズがmに達したら、tを更新して再計算する
                if (ConvexHullVars.hullsIndex >= m) {
                    break;
                }

                // 次の基準点候補の初期値は、基準点以外の点にする
                const currentExtremePointsIndex = this.getCurrentExtremePointsIndex(currentSubhullsIndex);
                let nextSubhullsIndex = this.getNextSubhullsIndex(currentSubhullsIndex, currentExtremePointsIndex);

                // console.log("next",nextSubhullsIndex,ConvexHullVars.vertices[ConvexHullVars.subhulls[nextSubhullsIndex]],ConvexHullVars.vertices[ConvexHullVars.subhulls[nextSubhullsIndex] + 1]);

                // 基準点から最も時計回り側にある点を、次の基準点にする
                const subhullsLength = ConvexHullVars.extremePointsIndex - 1;
                for (let i = 0; i < subhullsLength; i++) {
                    const subhullsIndex = this.binarySearch(i, currentSubhullsIndex);

                    // console.log("[point]", subhullsIndex,ConvexHullVars.vertices[ConvexHullVars.subhulls[subhullsIndex]],ConvexHullVars.vertices[ConvexHullVars.subhulls[subhullsIndex] + 1]);

                    const a = ConvexHullVars.subhulls[nextSubhullsIndex];
                    const b = ConvexHullVars.subhulls[subhullsIndex];
                    const o = ConvexHullVars.subhulls[currentSubhullsIndex];
                    if (this.clockwise(a, b, o) > 0) {
                        nextSubhullsIndex = subhullsIndex;
                    }
                }

                currentSubhullsIndex = nextSubhullsIndex;

                // console.log("vert", currentSubhullsIndex,ConvexHullVars.vertices[ConvexHullVars.subhulls[currentSubhullsIndex]],ConvexHullVars.vertices[ConvexHullVars.subhulls[currentSubhullsIndex] + 1]);

                // 基準点とx座標が最も小さい点が一致しているなら、凸包が完成している
                if (currentSubhullsIndex === extremeSubhullsIndex) {
                    isComplete = true;
                    break;
                }
            }

            if (isComplete) {
                break;
            }
        }
    }

    static calcSubhulls (startVerticesIndex, endVerticesIndex)
    {
        const size = endVerticesIndex - startVerticesIndex;

        this.addExtremePoint(ConvexHullVars.subhullsIndex);

        // 部分集合のサイズが1以下なら、そのまま部分凸包になる
        if (size <= 3) {
            this.addSubhull(startVerticesIndex);
            return;
        }

        // 部分集合をx座標が小さい順にソートする
        // （ソートはhullsを流用して行う）
        this.clearHulls();
        for (let i = 0; i < size; i += 3) {
            ConvexHullVars.hulls[ConvexHullVars.t][i] = startVerticesIndex + i;
            ConvexHullVars.hullsIndex++;
        }
        ConvexHullVars.hulls[ConvexHullVars.t].sort(this.compare);

        // 下包を求める
        const lowerIndex = ConvexHullVars.subhullsIndex;
        for (let i = 0; i < ConvexHullVars.hullsIndex; i++) {
            const b = ConvexHullVars.hulls[ConvexHullVars.t][i];

            while (ConvexHullVars.subhullsIndex - lowerIndex >= 2) {
                const a = ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex - 1];
                const o = ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex - 2];
                if (this.clockwise(a, b, o) < 0) {
                    break;
                }

                ConvexHullVars.subhullsIndex--;
            }

            if (ConvexHullVars.subhullsIndex - lowerIndex > 0) {
                const a = ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex - 1];
                if (this.almostEquals(a, b)) {
                    ConvexHullVars.subhullsIndex--;
                }
            }

            this.addSubhull(ConvexHullVars.hulls[ConvexHullVars.t][i]);
        }

        // 下包の最後の点は、上包の最初の点と重複するので削除する
        ConvexHullVars.subhullsIndex--;

        // 上包を求める
        const upperIndex = ConvexHullVars.subhullsIndex;
        for (let i = ConvexHullVars.hullsIndex - 1; i >= 0; i--) {
            const b = ConvexHullVars.hulls[ConvexHullVars.t][i];

            while (ConvexHullVars.subhullsIndex - upperIndex >= 2) {
                const a = ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex - 1];
                const o = ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex - 2];
                if (this.clockwise(a, b, o) < 0) {
                    break;
                }

                ConvexHullVars.subhullsIndex--;
            }

            if (ConvexHullVars.subhullsIndex - upperIndex > 0) {
                const a = ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex - 1];
                if (this.almostEquals(a, b)) {
                    ConvexHullVars.subhullsIndex--;
                }
            }

            this.addSubhull(ConvexHullVars.hulls[ConvexHullVars.t][i]);
        }

        // 上包の最後の点は、下包の最初の点と重複するので削除する
        ConvexHullVars.subhullsIndex--;
    }

    static addSubhull (subhull)
    {
        ConvexHullVars.subhulls[ConvexHullVars.subhullsIndex++] = subhull;
        if (ConvexHullVars.subhullsIndex > ConvexHullVars.subhulls.length) {
            ConvexHullVars.subhulls.length *= 2;
        }
    }

    static addExtremePoint (extremePoint)
    {
        ConvexHullVars.extremePoints[ConvexHullVars.extremePointsIndex++] = extremePoint;
        if (ConvexHullVars.extremePointsIndex > ConvexHullVars.extremePoints.length) {
            ConvexHullVars.extremePoints.length *= 2;
        }
    }

    static compare (a, b)
    {
        if (a < 0 && b < 0) {
            return 0;
        } else if (a < 0) {
            return 1;
        } else if (b < 0) {
            return -1;
        }

        const ax = ConvexHullVars.vertices[a];
        const ay = ConvexHullVars.vertices[a + 1];
        const bx = ConvexHullVars.vertices[b];
        const by = ConvexHullVars.vertices[b + 1];

        return ax - bx || ay - by;
    }

    static clockwise (a, b, o)
    {
        const ax = ConvexHullVars.vertices[a];
        const ay = ConvexHullVars.vertices[a + 1];
        const bx = ConvexHullVars.vertices[b];
        const by = ConvexHullVars.vertices[b + 1];
        const ox = ConvexHullVars.vertices[o];
        const oy = ConvexHullVars.vertices[o + 1];

        // aよりbが時計回り側にあるなら正の値を返す
        return Util.$cross(ax - ox, ay - oy, bx - ox, by - oy);
    }

    static almostEquals (a, b)
    {
        const ax = ConvexHullVars.vertices[a];
        const ay = ConvexHullVars.vertices[a + 1];
        const bx = ConvexHullVars.vertices[b];
        const by = ConvexHullVars.vertices[b + 1];

        // aとbの値がほぼ等しいかどうか
        const absX = $Math.abs(ax - bx);
        const absY = $Math.abs(ay - by);
        return absX < 0.001 && absY < 0.001;
    }

    static getExtremeSubhullsIndex()
    {
        let minIndex = 0;
        for (let i = 0; i < ConvexHullVars.extremePoints.length; i++) {
            const subhullsIndex = ConvexHullVars.extremePoints[i];
            if (subhullsIndex < 0) { break }

            const ax = ConvexHullVars.vertices[ConvexHullVars.subhulls[subhullsIndex]];
            const bx = ConvexHullVars.vertices[ConvexHullVars.subhulls[minIndex]];
            if (ax < bx) {
                minIndex = subhullsIndex;
            }
        }
        return minIndex;
    }

    static getCurrentExtremePointsIndex(currentSubhullsIndex)
    {
        // TODO 二分探索にできる
        for (let i = 0; i < ConvexHullVars.extremePoints.length; i++) {
            const subhullsIndex = ConvexHullVars.extremePoints[i + 1];
            if (currentSubhullsIndex < subhullsIndex) {
                return i;
            }
        }
    }

    static getNextSubhullsIndex(currentSubhullsIndex, currentExtremePointsIndex)
    {
        const extremeSubhullsIndex     = ConvexHullVars.extremePoints[currentExtremePointsIndex];
        const nextExtremeSubhullsIndex = ConvexHullVars.extremePoints[currentExtremePointsIndex + 1];

        const subhullsSize = nextExtremeSubhullsIndex - extremeSubhullsIndex;

        if (subhullsSize > 2) {
            const nextSubhullsIndex = currentSubhullsIndex + 1;
            if (nextSubhullsIndex < nextExtremeSubhullsIndex) {
                return nextSubhullsIndex;
            }
            return extremeSubhullsIndex;

        }
        if (nextExtremeSubhullsIndex < ConvexHullVars.extremePointsIndex - 1) {
            return nextExtremeSubhullsIndex;
        }
        return 0;

    }

    static binarySearch(extremePointsIndex, currentSubhullsIndex)
    {
        const extremeSubhullsIndex     = ConvexHullVars.extremePoints[extremePointsIndex];
        const nextExtremeSubhullsIndex = ConvexHullVars.extremePoints[extremePointsIndex + 1];

        let beginIndex = extremeSubhullsIndex;
        let endIndex   = nextExtremeSubhullsIndex;

        while (beginIndex < endIndex) {
            let prevBeginIndex = beginIndex - 1;
            let nextBeginIndex = beginIndex + 1;
            if (prevBeginIndex < extremeSubhullsIndex) {
                prevBeginIndex = nextExtremeSubhullsIndex - 1;
            }
            if (nextBeginIndex >= nextExtremeSubhullsIndex) {
                nextBeginIndex = extremeSubhullsIndex;
            }

            // 始点と基準点が同じ座標なら、始点の次の点が最も時計回り側にある点になる
            if (this.almostEquals(ConvexHullVars.subhulls[beginIndex], ConvexHullVars.subhulls[currentSubhullsIndex])) {
                return nextBeginIndex;
            }

            const beginPrev = this.clockwise(
                ConvexHullVars.subhulls[beginIndex],
                ConvexHullVars.subhulls[prevBeginIndex],
                ConvexHullVars.subhulls[currentSubhullsIndex]
            );
            const beginNext = this.clockwise(
                ConvexHullVars.subhulls[beginIndex],
                ConvexHullVars.subhulls[nextBeginIndex],
                ConvexHullVars.subhulls[currentSubhullsIndex]
            );

            const centerIndex = $Math.floor((beginIndex + endIndex) / 2);
            let prevCenterIndex = centerIndex - 1;
            let nextCenterIndex = centerIndex + 1;
            if (prevCenterIndex < extremeSubhullsIndex) {
                prevCenterIndex = nextExtremeSubhullsIndex - 1;
            }
            if (nextCenterIndex >= nextExtremeSubhullsIndex) {
                nextCenterIndex = extremeSubhullsIndex;
            }

            // 中心点と基準点が同じ座標なら、中心点の次の点が最も時計回り側にある点になる
            if (this.almostEquals(ConvexHullVars.subhulls[centerIndex], ConvexHullVars.subhulls[currentSubhullsIndex])) {
                return nextCenterIndex;
            }

            const centerPrev = this.clockwise(
                ConvexHullVars.subhulls[centerIndex],
                ConvexHullVars.subhulls[prevCenterIndex],
                ConvexHullVars.subhulls[currentSubhullsIndex]
            );
            const centerNext = this.clockwise(
                ConvexHullVars.subhulls[centerIndex],
                ConvexHullVars.subhulls[nextCenterIndex],
                ConvexHullVars.subhulls[currentSubhullsIndex]
            );

            // 中心点の前の点と次の点が、中心点より反時計回り側にあるなら、中心点が最も時計回り側にある点になる
            if (centerPrev <= 0 && centerNext <= 0) {
                return centerIndex;
            }

            // 探索する方向を求める
            const centerSide = this.clockwise(
                ConvexHullVars.subhulls[beginIndex],
                ConvexHullVars.subhulls[centerIndex],
                ConvexHullVars.subhulls[currentSubhullsIndex]
            );
            const pattern1 = centerSide   < 0 && (beginPrev <= 0 && beginNext <= 0); // 始点が最も時計回り側にあるパターン
            const pattern2 = centerSide   < 0 && (beginPrev  < 0 || beginNext  > 0); // 中心点が始点より反時計回り側にあるパターン
            const pattern3 = centerSide   > 0 && (centerPrev > 0 || centerNext < 0); // 中心点が始点より時計回り側にあるパターン
            const pattern4 = centerSide === 0 && (centerPrev > 0 || centerNext < 0); // 中心点と始点が平行しているパターン
            if (pattern1 || pattern2 || pattern3 || pattern4) {
                endIndex = centerIndex;
            } else {
                beginIndex = centerIndex + 1;
            }
        }

        return beginIndex;
    }

    static clearSubhulls ()
    {
        for (let i = 0; i < ConvexHullVars.subhulls.length; i++) {
            ConvexHullVars.subhulls[i] = -1;
        }
        ConvexHullVars.subhullsIndex = 0;
    }

    static clearExtremePoints ()
    {
        for (let i = 0; i < ConvexHullVars.extremePoints.length; i++) {
            ConvexHullVars.extremePoints[i] = -1;
        }
        ConvexHullVars.extremePointsIndex = 0;
    }

    static clearHulls ()
    {
        const hulls = ConvexHullVars.hulls[ConvexHullVars.t];
        for (let i = 0; i < hulls.length; i++) {
            hulls[i] = -1;
        }
        ConvexHullVars.hullsIndex = 0;
    }
}
/**
 * @class
 */
class FrameBufferManager
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {boolean}               isWebGL2Context
     * @param {number}                samples
     * @constructor
     */
    constructor (gl, isWebGL2Context, samples)
    {
        this._$gl                 = gl;
        this._$isWebGL2Context    = isWebGL2Context;
        this._$objectPool         = [];
        this._$frameBuffer        = gl.createFramebuffer();
        this._$frameBufferTexture = null;
        this._$currentAttachment  = null;
        this._$isBinding          = false;
        this._$textureManager     = new TextureManager(gl, isWebGL2Context);
        this._$colorBufferPool    = null;
        this._$stencilBufferPool  = new StencilBufferPool(gl);

        if (isWebGL2Context) {
            this._$frameBufferTexture = gl.createFramebuffer();
            this._$colorBufferPool    = new ColorBufferPool(gl, samples);

            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._$frameBuffer);
        }
    }

    /**
     * @memberof FrameBufferManager#
     * @property {object}
     * @return   {object}
     * @public
     */
    get currentAttachment ()
    {
        return this._$currentAttachment;
    }

    /**
     * @param  {number}  width
     * @param  {number}  height
     * @param  {boolean} [multisample=false]
     * @param  {uint}    [samples=0]
     * @return {object}
     * @public
     */
    createCacheAttachment (width, height, multisample = false, samples = 0)
    {
        const attachment = this._$objectPool.length
            ? this._$objectPool.pop()
            : {};
        const texture = this._$textureManager.create(width, height);

        attachment.width  = width;
        attachment.height = height;

        if (this._$isWebGL2Context && multisample) {
            attachment.color   = this._$colorBufferPool.create(width, height, samples);
            attachment.texture = texture;
            attachment.msaa    = true;
            attachment.stencil = attachment.color.stencil;
        } else {
            attachment.color   = texture;
            attachment.texture = texture;
            attachment.msaa    = false;
            attachment.stencil = this._$stencilBufferPool.create(texture.width, texture.height);
        }

        attachment.mask      = false;
        attachment.clipLevel = 0;
        attachment.isActive  = true;

        return attachment;
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @return {object}
     * @public
     */
    createTextureAttachment (width, height)
    {
        const attachment = this._$objectPool.length
            ? this._$objectPool.pop()
            : {};
        const texture = this._$textureManager.create(width, height);

        attachment.width     = width;
        attachment.height    = height;
        attachment.color     = texture;
        attachment.texture   = texture;
        attachment.msaa      = false;
        attachment.stencil   = null;
        attachment.mask      = false;
        attachment.clipLevel = 0;
        attachment.isActive  = true;

        return attachment;
    }

    /**
     * @param  {WebGLTexture} texture
     * @return {object}
     * @public
     */
    createTextureAttachmentFrom (texture)
    {
        const attachment = this._$objectPool.length
            ? this._$objectPool.pop()
            : {};

        attachment.width     = texture.width;
        attachment.height    = texture.height;
        attachment.color     = texture;
        attachment.texture   = texture;
        attachment.msaa      = false;
        attachment.stencil   = null;
        attachment.mask      = false;
        attachment.clipLevel = 0;
        attachment.isActive  = true;

        return attachment;
    }

    /**
     * @param  {object}  attachment
     * @param  {boolean} [shouldReleaseTexture=false]
     * @return void
     * @public
     */
    releaseAttachment (attachment, shouldReleaseTexture = false)
    {
        if (!attachment.isActive) {
            return;
        }

        if (attachment.msaa) {
            this._$colorBufferPool.release(attachment.color);
        } else if (attachment.stencil) {
            this._$stencilBufferPool.release(attachment.stencil);
        }

        if (shouldReleaseTexture) {
            this._$textureManager.release(attachment.texture);
        }

        attachment.color    = null;
        attachment.texture  = null;
        attachment.stencil  = null;
        attachment.isActive = false;

        this._$objectPool.push(attachment);
    }

    /**
     * @param  {object} attachment
     * @return void
     * @public
     */
    bind (attachment)
    {
        this._$currentAttachment = attachment;
        if (!this._$isBinding) {
            this._$isBinding = true;
            this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER, this._$frameBuffer);
        }

        if (attachment.msaa) {
            this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER, attachment.color);
            this._$gl.framebufferRenderbuffer(
                this._$gl.FRAMEBUFFER, this._$gl.COLOR_ATTACHMENT0,
                this._$gl.RENDERBUFFER, attachment.color
            );
        } else {
            this._$textureManager.bind0(attachment.color);

            this._$gl.framebufferTexture2D(
                this._$gl.FRAMEBUFFER, this._$gl.COLOR_ATTACHMENT0,
                this._$gl.TEXTURE_2D, attachment.color, 0
            );
        }

        this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER, attachment.stencil);
        this._$gl.framebufferRenderbuffer(
            this._$gl.FRAMEBUFFER, this._$gl.STENCIL_ATTACHMENT,
            this._$gl.RENDERBUFFER, attachment.stencil
        );
    }

    /**
     * @return void
     * @public
     */
    unbind ()
    {
        this._$currentAttachment = null;
        if (this._$isBinding) {
            this._$isBinding = false;
            this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER, null);
        }
    }

    /**
     * @return {WebGLTexture}
     * @public
     */
    getTextureFromCurrentAttachment ()
    {
        if (!this._$currentAttachment.msaa) {
            return this._$currentAttachment.texture;
        }

        const width   = this._$currentAttachment.width;
        const height  = this._$currentAttachment.height;
        const texture = this._$currentAttachment.texture;
        texture.dirty = false;

        this._$gl.bindFramebuffer(this._$gl.DRAW_FRAMEBUFFER, this._$frameBufferTexture);

        this._$textureManager.bind0(texture);

        this._$gl.framebufferTexture2D(
            this._$gl.FRAMEBUFFER, this._$gl.COLOR_ATTACHMENT0,
            this._$gl.TEXTURE_2D, texture, 0
        );

        this._$gl.blitFramebuffer(
            0, 0, width, height,
            0, 0, width, height,
            this._$gl.COLOR_BUFFER_BIT,
            this._$gl.NEAREST
        );

        this._$gl.bindFramebuffer(this._$gl.FRAMEBUFFER, this._$frameBuffer);

        return texture;
    }

    /**
     * @param  {number}     width
     * @param  {number}     height
     * @param  {Uint8Array} [pixels=null]
     * @param  {boolean}    [premultipliedAlpha=false]
     * @param  {boolean}    [flipY=true]
     * @return {WebGLTexture}
     * @public
     */
    createTextureFromPixels (width, height, pixels = null, premultipliedAlpha = false, flipY = true)
    {
        return this._$textureManager.create(width, height, pixels, premultipliedAlpha, flipY);
    }

    /**
     * @param  {HTMLCanvasElement} canvas
     * @return {WebGLTexture}
     * @public
     */
    createTextureFromCanvas (canvas)
    {
        return this._$textureManager.createFromCanvas(canvas);
    }

    /**
     * @param  {HTMLImageElement} image
     * @return {WebGLTexture}
     * @public
     */
    createTextureFromImage (image)
    {
        return this._$textureManager.createFromImage(image);
    }

    /**
     * @param  {number}     width
     * @param  {number}     height
     * @param  {Uint8Array} pixels
     * @return {WebGLTexture}
     * @public
     */
    createAlphaTextureFromPixels (width, height, pixels)
    {
        return this._$textureManager.createAlpha(width, height, pixels);
    }

    /**
     * @param  {HTMLVideoElement} video
     * @param  {boolean} [smoothing=false]
     * @param  {WebGLTexture} [target_texture=null]
     * @return {WebGLTexture}
     * @public
     */
    createTextureFromVideo (video, smoothing = false, target_texture = null)
    {
        return this._$textureManager.createFromVideo(video, smoothing, target_texture);
    }

    /**
     * @return {WebGLTexture}
     * @public
     */
    createTextureFromCurrentAttachment ()
    {
        const width   = this._$currentAttachment.width;
        const height  = this._$currentAttachment.height;
        const texture = this._$textureManager.create(width, height);

        this._$textureManager.bind0(texture);

        this._$gl.copyTexSubImage2D(
            this._$gl.TEXTURE_2D, 0,
            0, 0, 0, 0, width, height
        );

        return texture;
    }

    /**
     * @param  {WebGLTexture} texture
     * @return void
     * @public
     */
    releaseTexture (texture)
    {
        this._$textureManager.release(texture);
    }

}
/**
 * @class
 */
class PixelBufferObjectManager
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {boolean}               isWebGL2Context
     * @constructor
     */
    constructor (gl, isWebGL2Context)
    {
        this._$gl              = gl;
        this._$isWebGL2Context = isWebGL2Context;
        this._$objectPool      = [];
        this._$maxWidth        = 0;
        this._$maxHeight       = 0;
        this._$cacheSize       = 0;
    }

    /**
     * @param  {number} size
     * @return {WebGLBuffer}
     * @private
     */
    _$getPixelBufferObject (size)
    {
        if (!this._$objectPool.length) {
            const pixelBufferObject = this._$gl.createBuffer();
            pixelBufferObject.size  = 0;
            return pixelBufferObject;
        }

        for (let i = 0; i < this._$objectPool.length; i++) {
            const pixelBufferObject = this._$objectPool[i];
            if (pixelBufferObject.size === size) {
                this._$objectPool.splice(i, 1);
                this._$cacheSize -= pixelBufferObject.size / 4;
                return pixelBufferObject;
            }
        }

        const pixelBufferObject = this._$objectPool.shift();
        this._$cacheSize -= pixelBufferObject.size / 4;

        return pixelBufferObject;
    }

    /**
     * @param  {number} x
     * @param  {number} y
     * @param  {number} width
     * @param  {number} height
     * @return {WebGLBuffer}
     * @public
     */
    readPixelsAsync (x, y, width, height)
    {
        if (!this._$isWebGL2Context) {
            return null;
        }

        const size              = width * height * 4;
        const pixelBufferObject = this._$getPixelBufferObject(size);

        this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER, pixelBufferObject);

        if (pixelBufferObject.size !== size) {
            pixelBufferObject.size = size;
            this._$gl.bufferData(this._$gl.PIXEL_PACK_BUFFER, size, this._$gl.DYNAMIC_COPY);
        }

        this._$gl.readPixels(
            x, y, width, height,
            this._$gl.RGBA, this._$gl.UNSIGNED_BYTE,
            0
        );
        this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER, null);

        return pixelBufferObject;
    }

    /**
     * @param  {WebGLBuffer} pixelBufferObject
     * @return {Uint8Array}
     * @public
     */
    getBufferSubDataAsync (pixelBufferObject)
    {
        const data = new Uint8Array(pixelBufferObject.size);

        this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER, pixelBufferObject);
        this._$gl.getBufferSubData(this._$gl.PIXEL_PACK_BUFFER, 0, data);
        this._$gl.bindBuffer(this._$gl.PIXEL_PACK_BUFFER, null);

        this.release(pixelBufferObject);

        return data;
    }

    /**
     * @param  {WebGLBuffer} pixelBufferObject
     * @return void
     * @public
     */
    release (pixelBufferObject)
    {
        if (pixelBufferObject.size > this._$maxWidth * this._$maxHeight * 4) {
            this._$gl.deleteBuffer(pixelBufferObject);
            return;
        }

        this._$objectPool.push(pixelBufferObject);
        this._$cacheSize += pixelBufferObject.size / 4;

        // プール容量が一定を超えたら、古いbufferから削除していく
        if (this._$cacheSize > this._$maxWidth * this._$maxHeight * 10) {
            const oldBufferObject = this._$objectPool.shift();
            this._$cacheSize -= oldBufferObject.size / 4;
            this._$gl.deleteBuffer(oldBufferObject);
        }
    }
}
/**
 * @class
 */
class StencilBufferPool
{
    /**
     * @param {WebGLRenderingContext} gl
     * @constructor
     */
    constructor (gl)
    {
        this._$gl             = gl;
        this._$objectPool     = [];
        this._$objectPoolArea = 0;
        this._$maxWidth       = 0;
        this._$maxHeight      = 0;
    }

    /**
     * @return {WebGLRenderbuffer}
     * @private
     */
    _$createStencilBuffer ()
    {
        const stencilBuffer  = this._$gl.createRenderbuffer();
        stencilBuffer.width  = 0;
        stencilBuffer.height = 0;
        stencilBuffer.area   = 0;
        stencilBuffer.dirty  = true;
        return stencilBuffer;
    }

    /**
     * @param  {number}  width
     * @param  {number}  height
     * @return {WebGLRenderbuffer}
     * @private
     */
    _$getStencilBuffer (width, height)
    {
        const length = this._$objectPool.length;
        for (let i = 0; i < length; i++) {
            const stencilBuffer = this._$objectPool[i];
            if (stencilBuffer.width === width && stencilBuffer.height === height) {
                this._$objectPool.splice(i, 1);
                this._$objectPoolArea -= stencilBuffer.area;
                return stencilBuffer;
            }
        }

        if (length > 100) {
            const stencilBuffer = this._$objectPool.shift();
            this._$objectPoolArea -= stencilBuffer.area;
            return stencilBuffer;
        }

        return this._$createStencilBuffer();
    }

    /**
     * @param  {number}  width
     * @param  {number}  height
     * @return {WebGLRenderbuffer}
     * @public
     */
    create (width, height)
    {
        const stencilBuffer = this._$getStencilBuffer(width, height);

        if (stencilBuffer.width !== width || stencilBuffer.height !== height) {
            stencilBuffer.width  = width;
            stencilBuffer.height = height;
            stencilBuffer.area   = width * height;
            stencilBuffer.dirty  = false;

            this._$gl.bindRenderbuffer(this._$gl.RENDERBUFFER, stencilBuffer);
            this._$gl.renderbufferStorage(
                this._$gl.RENDERBUFFER,
                this._$gl.STENCIL_INDEX8,
                width, height
            );
        }

        return stencilBuffer;
    }

    /**
     * @param  {WebGLRenderbuffer} stencilBuffer
     * @return void
     * @public
     */
    release (stencilBuffer)
    {
        // ステンシルバッファのサイズが非常に大きい場合はプールしない
        if (stencilBuffer.area > this._$maxWidth * this._$maxHeight * 2 | 0) {
            this._$gl.deleteRenderbuffer(stencilBuffer);
            return;
        }

        stencilBuffer.dirty = true;
        this._$objectPool.push(stencilBuffer);
        this._$objectPoolArea += stencilBuffer.area;

        // プール容量が一定を超えたら、古いステンシルバッファから削除していく
        if (this._$objectPoolArea > this._$maxWidth * this._$maxHeight * 10) {
            const oldStencilBuffer = this._$objectPool.shift();
            this._$objectPoolArea -= oldStencilBuffer.area;
            this._$gl.deleteRenderbuffer(oldStencilBuffer);
        }
    }
}
/**
 * @class
 */
class TextureManager
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {boolean}               isWebGL2Context
     * @constructor
     */
    constructor (gl, isWebGL2Context)
    {
        this._$gl              = gl;
        this._$isWebGL2Context = isWebGL2Context;
        this._$objectPool      = [];
        this._$objectPoolArea  = 0;
        this._$activeTexture   = -1;
        this._$boundTextures   = [null, null, null];
        this._$maxWidth        = 0;
        this._$maxHeight       = 0;

        this._$gl.pixelStorei(this._$gl.UNPACK_ALIGNMENT, 1);
        this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL, true);
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @return {WebGLTexture}
     * @private
     */
    _$createTexture (width, height)
    {
        const texture = this._$gl.createTexture();

        texture.width     = 0;
        texture.height    = 0;
        texture.area      = 0;
        texture.dirty     = true;
        texture.smoothing = true;
        texture._$offsetX = 0;
        texture._$offsetY = 0;

        this.bind0(texture, false);

        this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_WRAP_S, this._$gl.CLAMP_TO_EDGE);
        this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_WRAP_T, this._$gl.CLAMP_TO_EDGE);

        if (this._$isWebGL2Context) {
            texture.width  = width;
            texture.height = height;
            texture.area   = width * height;
            texture.dirty  = false;
            this._$gl.texStorage2D(this._$gl.TEXTURE_2D, 1, this._$gl.RGBA8, width, height);

            if (window.glstats) {
                glstats.ontex(texture.area);
            }
        }

        return texture;
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @return {WebGLTexture}
     * @private
     */
    _$getTexture (width, height)
    {
        // プールに同じサイズのテクスチャがあれば、それを使い回す
        for (let i = 0; i < this._$objectPool.length; i++) {
            const texture = this._$objectPool[i];
            if (texture.width === width && texture.height === height) {
                this._$objectPool.splice(i, 1);
                this._$objectPoolArea -= texture.area;

                this.bind0(texture, false);

                return texture;
            }
        }

        return this._$createTexture(width, height);
    }

    /**
     * @param  {number}     width
     * @param  {number}     height
     * @param  {Uint8Array} pixels
     * @return {WebGLTexture}
     * @public
     */
    createAlpha (width, height, pixels)
    {
        if (!this._$alphaTexture) {
            this._$alphaTexture = this._$gl.createTexture();

            this.bind0(this._$alphaTexture);
            this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_WRAP_S, this._$gl.CLAMP_TO_EDGE);
            this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_WRAP_T, this._$gl.CLAMP_TO_EDGE);
            this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_MIN_FILTER, this._$gl.NEAREST);
            this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_MAG_FILTER, this._$gl.NEAREST);
        } else {

            this.bind0(this._$alphaTexture);

        }

        this._$alphaTexture.width  = width;
        this._$alphaTexture.height = height;
        this._$alphaTexture.dirty  = false;

        this._$gl.texImage2D(
            this._$gl.TEXTURE_2D, 0, this._$gl.ALPHA, width, height,
            0, this._$gl.ALPHA, this._$gl.UNSIGNED_BYTE, pixels
        );

        return this._$alphaTexture;
    }

    /**
     * @param  {number}     width
     * @param  {number}     height
     * @param  {Uint8Array} [pixels=null]
     * @param  {boolean}    [premultipliedAlpha=false]
     * @param  {boolean}    [flipY=true]
     * @return {WebGLTexture}
     */
    create (width, height, pixels = null, premultipliedAlpha = false, flipY = true)
    {
        const texture = this._$getTexture(width, height);

        if (premultipliedAlpha) {
            this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        }

        if (!flipY) {
            this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL, false);
        }

        if (texture.width !== width || texture.height !== height) {
            texture.width  = width;
            texture.height = height;
            texture.area   = width * height;
            texture.dirty  = false;

            this._$gl.texImage2D(
                this._$gl.TEXTURE_2D, 0, this._$gl.RGBA, width, height,
                0, this._$gl.RGBA, this._$gl.UNSIGNED_BYTE, pixels
            );

            if (window.glstats) {
                glstats.ontex(texture.area);
            }
        } else if (pixels) {
            texture.dirty = false;

            this._$gl.texSubImage2D(
                this._$gl.TEXTURE_2D, 0, 0, 0, width, height,
                this._$gl.RGBA, this._$gl.UNSIGNED_BYTE, pixels
            );
        }

        if (premultipliedAlpha) {
            this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        }

        if (!flipY) {
            this._$gl.pixelStorei(this._$gl.UNPACK_FLIP_Y_WEBGL, true);
        }

        return texture;
    }

    /**
     * @param  {HTMLImageElement} image
     * @return {WebGLTexture}
     * @public
     */
    createFromImage (image)
    {
        return this._$createFromElement(image.width, image.height, image, false, null);
    }

    /**
     * @param  {HTMLCanvasElement} canvas
     * @return {WebGLTexture}
     */
    createFromCanvas (canvas)
    {
        return this._$createFromElement(canvas.width, canvas.height, canvas, false, null);
    }

    /**
     * @param  {HTMLVideoElement} video
     * @param  {boolean} [smoothing=false]
     * @param  {WebGLTexture} [target_texture=null]
     * @return {WebGLTexture}
     */
    createFromVideo (video, smoothing = false, target_texture = null)
    {
        return this._$createFromElement(video.videoWidth, video.videoHeight, video, smoothing, target_texture);
    }

    /**
     * @param  {number} width
     * @param  {number} height
     * @param  {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} element
     * @param  {boolean} [smoothing=false]
     * @param  {WebGLTexture} [target_texture=null]
     * @return {WebGLTexture}
     * @private
     */
    _$createFromElement (width, height, element, smoothing = false, target_texture = null)
    {
        const texture = target_texture || this._$getTexture(width, height);

        texture.dirty = false;
        this.bind0(texture, smoothing);

        this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

        if (texture.width !== width || texture.height !== height) {
            texture.width  = width;
            texture.height = height;
            texture.area   = width * height;

            this._$gl.texImage2D(
                this._$gl.TEXTURE_2D, 0, this._$gl.RGBA,
                this._$gl.RGBA, this._$gl.UNSIGNED_BYTE, element
            );

            if (window.glstats) {
                glstats.ontex(texture.area);
            }
        } else {
            this._$gl.texSubImage2D(
                this._$gl.TEXTURE_2D, 0, 0, 0,
                this._$gl.RGBA, this._$gl.UNSIGNED_BYTE, element
            );
        }

        this._$gl.pixelStorei(this._$gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);

        return texture;
    }

    /**
     * @param  {WebGLTexture} texture
     * @return void
     */
    release (texture)
    {
        // テクスチャのサイズが非常に大きい場合はプールしない
        if (texture.area > this._$maxWidth * this._$maxHeight * 2 | 0) {
            this._$gl.deleteTexture(texture);
            return;
        }

        texture.dirty = true;
        this._$objectPool.push(texture);
        this._$objectPoolArea += texture.area;

        // プール容量が一定を超えたら、古いテクスチャから削除していく
        if (this._$objectPoolArea > this._$maxWidth * this._$maxHeight * 10) {
            const oldTexture = this._$objectPool.shift();
            this._$objectPoolArea -= oldTexture.area;
            this._$gl.deleteTexture(oldTexture);
        }
    }

    /**
     * @param  {WebGLTexture} texture0
     * @param  {boolean}      [smoothing0=null]
     * @return void
     */
    bind0 (texture0, smoothing0 = null)
    {
        this._$bindTexture(2, this._$gl.TEXTURE2, null, null);
        this._$bindTexture(1, this._$gl.TEXTURE1, null, null);
        this._$bindTexture(0, this._$gl.TEXTURE0, texture0, smoothing0);
    }

    /**
     * @param  {WebGLTexture} texture0
     * @param  {WebGLTexture} texture1
     * @param  {boolean}      [smoothing01=null]
     * @return void
     */
    bind01 (texture0, texture1, smoothing01 = null)
    {
        this._$bindTexture(2, this._$gl.TEXTURE2, null, null);
        this._$bindTexture(1, this._$gl.TEXTURE1, texture1, smoothing01);
        this._$bindTexture(0, this._$gl.TEXTURE0, texture0, smoothing01);
    }

    /**
     * @param  {WebGLTexture} texture0
     * @param  {WebGLTexture} texture1
     * @param  {WebGLTexture} texture2
     * @param  {boolean}      [smoothing2=null]
     * @return void
     */
    bind012 (texture0, texture1, texture2, smoothing2 = null)
    {
        this._$bindTexture(2, this._$gl.TEXTURE2, texture2, smoothing2);
        this._$bindTexture(1, this._$gl.TEXTURE1, texture1, null);
        this._$bindTexture(0, this._$gl.TEXTURE0, texture0, null);
    }

    /**
     * @param  {WebGLTexture} texture0
     * @param  {WebGLTexture} texture2
     * @param  {boolean}      [smoothing2=null]
     * @return void
     */
    bind02 (texture0, texture2, smoothing2 = null)
    {
        this._$bindTexture(2, this._$gl.TEXTURE2, texture2, smoothing2);
        this._$bindTexture(1, this._$gl.TEXTURE1, null, null);
        this._$bindTexture(0, this._$gl.TEXTURE0, texture0, null);
    }

    /**
     * @param  {number}       index
     * @param  {number}       target
     * @param  {WebGLTexture} texture
     * @param  {boolean}      smoothing
     * @return void
     */
    _$bindTexture (index, target, texture, smoothing)
    {
        const shouldBind   = texture !== this._$boundTextures[index];
        const shouldSmooth = smoothing !== null && smoothing !== texture.smoothing;
        const shouldActive = (shouldBind || shouldSmooth || target === this._$gl.TEXTURE0)
            && target !== this._$activeTexture;

        if (shouldActive) {
            this._$activeTexture = target;
            this._$gl.activeTexture(target);
        }

        if (shouldBind) {
            this._$boundTextures[index] = texture;
            this._$gl.bindTexture(this._$gl.TEXTURE_2D, texture);
        }

        if (shouldSmooth) {
            texture.smoothing = smoothing;
            const filter = smoothing && Util.$currentPlayer()._$quality !== StageQuality.LOW
                ? this._$gl.LINEAR
                : this._$gl.NEAREST;
            this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_MIN_FILTER, filter);
            this._$gl.texParameteri(this._$gl.TEXTURE_2D, this._$gl.TEXTURE_MAG_FILTER, filter);
        }
    }
}
/**
 * @class
 */
class VertexArrayObjectManager
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {boolean}               isWebGL2Context
     * @constructor
     * @public
     */
    constructor (gl, isWebGL2Context)
    {
        this._$gl                     = gl;
        this._$isWebGL2Context        = isWebGL2Context;
        this._$fillVertexArrayPool    = [];
        this._$strokeVertexArrayPool  = [];
        this._$boundVertexArray       = null;

        this._$extension = isWebGL2Context ? null : gl.getExtension("OES_vertex_array_object");
        this._$fillAttrib_vertex    = 0;
        this._$fillAttrib_bezier    = 1;
        this._$strokeAttrib_vertex  = 0;
        this._$strokeAttrib_option1 = 1;
        this._$strokeAttrib_option2 = 2;
        this._$strokeAttrib_type    = 3;
        this._$vertexBufferData     = new $Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);

        this._$commonVertexArray = this._$getVertexArray(0, 1);
    }

    /**
     * @return {WebGLVertexArrayObject}
     * @method
     * @private
     */
    _$createVertexArray ()
    {
        return this._$isWebGL2Context
            ? this._$gl.createVertexArray()
            : this._$extension.createVertexArrayOES();
    }

    /**
     * @param  {number} begin
     * @param  {number} end
     * @return {WebGLVertexArrayObject}
     * @method
     * @private
     */
    _$getVertexArray (begin, end)
    {
        const vertexArray = this._$createVertexArray();
        this.bind(vertexArray);

        const vertexBuffer = this._$gl.createBuffer();
        this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER, vertexBuffer);

        this._$vertexBufferData[0] = begin;
        this._$vertexBufferData[2] = begin;
        this._$vertexBufferData[4] = end;
        this._$vertexBufferData[6] = end;
        this._$gl.bufferData(this._$gl.ARRAY_BUFFER, this._$vertexBufferData, this._$gl.STATIC_DRAW);

        this._$gl.enableVertexAttribArray(0);
        this._$gl.vertexAttribPointer(0, 2, this._$gl.FLOAT, false, 0, 0);

        return vertexArray;
    }

    /**
     * @return {WebGLVertexArrayObject}
     * @method
     * @private
     */
    _$getFillVertexArray ()
    {
        if (this._$fillVertexArrayPool.length) {
            return this._$fillVertexArrayPool.pop();
        }

        const vertexArray = this._$createVertexArray();
        this.bind(vertexArray);

        const vertexBuffer = this._$gl.createBuffer();
        vertexArray.vertexBuffer = vertexBuffer;
        vertexArray.vertexLength = 0;
        this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER, vertexBuffer);

        this._$gl.enableVertexAttribArray(0);
        this._$gl.enableVertexAttribArray(1);
        this._$gl.vertexAttribPointer(this._$fillAttrib_vertex, 2, this._$gl.FLOAT, false, 16, 0);
        this._$gl.vertexAttribPointer(this._$fillAttrib_bezier, 2, this._$gl.FLOAT, false, 16, 8);

        return vertexArray;
    }

    /**
     * @return {WebGLVertexArrayObject}
     * @method
     * @private
     */
    _$getStrokeVertexArray ()
    {
        if (this._$strokeVertexArrayPool.length) {
            return this._$strokeVertexArrayPool.pop();
        }

        const vertexArray = this._$createVertexArray();
        this.bind(vertexArray);

        const vertexBuffer = this._$gl.createBuffer();
        vertexArray.vertexBuffer = vertexBuffer;
        vertexArray.vertexLength = 0;
        this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER, vertexBuffer);

        const indexBuffer = this._$gl.createBuffer();
        vertexArray.indexBuffer = indexBuffer;
        vertexArray.indexLength  = 0;
        this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        this._$gl.enableVertexAttribArray(0);
        this._$gl.enableVertexAttribArray(1);
        this._$gl.enableVertexAttribArray(2);
        this._$gl.enableVertexAttribArray(3);
        this._$gl.vertexAttribPointer(this._$strokeAttrib_vertex,  2, this._$gl.FLOAT, false, 28, 0);
        this._$gl.vertexAttribPointer(this._$strokeAttrib_option1, 2, this._$gl.FLOAT, false, 28, 8);
        this._$gl.vertexAttribPointer(this._$strokeAttrib_option2, 2, this._$gl.FLOAT, false, 28, 16);
        this._$gl.vertexAttribPointer(this._$strokeAttrib_type,    1, this._$gl.FLOAT, false, 28, 24);

        return vertexArray;
    }

    /**
     * @param vertices
     * @return {WebGLVertexArrayObject}
     * @method
     * @public
     */
    createFill (vertices)
    {
        const mesh = WebGLFillMeshGenerator.generate(vertices);
        const vertexBufferData = mesh.vertexBufferData;

        const vertexArray = this._$getFillVertexArray();
        vertexArray.indexRanges = mesh.indexRanges;
        this.bind(vertexArray);

        this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER, vertexArray.vertexBuffer);

        if (vertexArray.vertexLength < vertexBufferData.length) {
            vertexArray.vertexLength = Util.$upperPowerOfTwo(vertexBufferData.length);
            this._$gl.bufferData(this._$gl.ARRAY_BUFFER, vertexArray.vertexLength * 4, this._$gl.DYNAMIC_DRAW);
        }

        this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER, 0, vertexBufferData);

        return vertexArray;
    }

    /**
     * @param vertices
     * @param lineCap
     * @param lineJoin
     * @return {WebGLVertexArrayObject}
     * @method
     * @public
     */
    createStroke (vertices, lineCap, lineJoin)
    {
        const mesh = WebGLStrokeMeshGenerator.generate(vertices, lineCap, lineJoin);
        const vertexBufferData = mesh.vertexBufferData;
        const indexBufferData  = mesh.indexBufferData;

        const vertexArray = this._$getStrokeVertexArray();
        vertexArray.indexCount = indexBufferData.length;
        this.bind(vertexArray);

        this._$gl.bindBuffer(this._$gl.ARRAY_BUFFER, vertexArray.vertexBuffer);
        this._$gl.bindBuffer(this._$gl.ELEMENT_ARRAY_BUFFER, vertexArray.indexBuffer);

        if (vertexArray.vertexLength < vertexBufferData.length) {
            vertexArray.vertexLength = Util.$upperPowerOfTwo(vertexBufferData.length);
            this._$gl.bufferData(this._$gl.ARRAY_BUFFER, vertexArray.vertexLength * 4, this._$gl.DYNAMIC_DRAW);
        }

        if (vertexArray.indexLength < indexBufferData.length) {
            vertexArray.indexLength = Util.$upperPowerOfTwo(indexBufferData.length);
            this._$gl.bufferData(this._$gl.ELEMENT_ARRAY_BUFFER, vertexArray.indexLength * 2, this._$gl.DYNAMIC_DRAW);
        }

        this._$gl.bufferSubData(this._$gl.ARRAY_BUFFER, 0, vertexBufferData);
        this._$gl.bufferSubData(this._$gl.ELEMENT_ARRAY_BUFFER, 0, indexBufferData);

        return vertexArray;
    }

    /**
     * @param  {WebGLVertexArrayObject} vertexArray
     * @return {void}
     * @method
     * @public
     */
    release (vertexArray)
    {
        if (!vertexArray.indexBuffer) {
            this._$fillVertexArrayPool.push(vertexArray);
        } else {
            this._$strokeVertexArrayPool.push(vertexArray);
        }
    }

    /**
     * @param  {WebGLVertexArrayObject} vertexArray
     * @return {void}
     * @method
     * @public
     */
    bind (vertexArray)
    {
        if (!vertexArray) {
            this._$boundVertexArray = null;
        } else if (vertexArray === this._$boundVertexArray) {
            return;
        } else {
            this._$boundVertexArray = vertexArray;
        }

        if (this._$isWebGL2Context) {
            this._$gl.bindVertexArray(vertexArray);
        } else {
            this._$extension.bindVertexArrayOES(vertexArray);
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    bindCommonVertexArray ()
    {
        this.bind(this._$commonVertexArray);
    }

    /**
     * @param  {number} begin
     * @param  {number} end
     * @return {void}
     * @method
     * @public
     */
    bindGradientVertexArray (begin, end)
    {
        const vertexArray = this._$getVertexArray(begin, end);
        this.bind(vertexArray);
    }
}
/**
 * @class
 */
class WebGLFillMeshGenerator
{
    /**
     * @param  {array}  vertices
     * @return {object}
     * @method
     * @static
     */
    static generate (vertices)
    {
        let vertexBufferLen = 0;
        for (let i = 0; i < vertices.length; i++) {
            vertexBufferLen += (vertices[i].length / 3 - 2) * 12;
        }

        this._$vertexBufferData = new $Float32Array(vertexBufferLen);
        this._$indexRanges      = Util.$getArray();
        this._$currentIndex     = 0;

        for (let i = 0; i < vertices.length; i++) {
            const first = this._$currentIndex;
            this._$generateMesh(vertices[i]);
            const count = this._$currentIndex - first;

            this._$indexRanges.push({ "first": first, "count": count });
        }

        return {
            "vertexBufferData": this._$vertexBufferData,
            "indexRanges"     : this._$indexRanges
        };
    }

    /**
     * @param  {array} vertex
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$generateMesh (vertex)
    {
        const vbd = this._$vertexBufferData;
        let currentIndex = this._$currentIndex;

        const length = vertex.length - 5;
        for (let v = 3; v < length; v += 3) {
            let i = currentIndex * 4;
            if (vertex[v + 2]) {
                vbd[i++] = vertex[v - 3];
                vbd[i++] = vertex[v - 2];
                vbd[i++] = 0;
                vbd[i++] = 0;

                vbd[i++] = vertex[v];
                vbd[i++] = vertex[v + 1];
                vbd[i++] = 0.5;
                vbd[i++] = 0;

                vbd[i++] = vertex[v + 3];
                vbd[i++] = vertex[v + 4];
                vbd[i++] = 1;
                vbd[i++] = 1;

            } else if (vertex[v + 5]) {
                vbd[i++] = vertex[0];
                vbd[i++] = vertex[1];
                vbd[i++] = 0.5;
                vbd[i++] = 0.5;

                vbd[i++] = vertex[v];
                vbd[i++] = vertex[v + 1];
                vbd[i++] = 0.5;
                vbd[i++] = 0.5;

                vbd[i++] = vertex[v + 6];
                vbd[i++] = vertex[v + 7];
                vbd[i++] = 0.5;
                vbd[i++] = 0.5;

            } else {
                vbd[i++] = vertex[0];
                vbd[i++] = vertex[1];
                vbd[i++] = 0.5;
                vbd[i++] = 0.5;

                vbd[i++] = vertex[v];
                vbd[i++] = vertex[v + 1];
                vbd[i++] = 0.5;
                vbd[i++] = 0.5;

                vbd[i++] = vertex[v + 3];
                vbd[i++] = vertex[v + 4];
                vbd[i++] = 0.5;
                vbd[i++] = 0.5;

            }
            currentIndex += 3;
        }

        this._$currentIndex = currentIndex;
    }
}
/**
 * @class
 */
class WebGLStrokeMeshGenerator
{
    /**
     * @param  {array}  vertices
     * @param  {string} line_cap
     * @param  {string} line_join
     * @return {object}
     * @method
     * @static
     */
    static generate (vertices, line_cap, line_join)
    {
        this._$vertexBufferData = this._$vertexBufferData || new $Float32Array(1024);
        this._$vertexBufferPos = 0;

        this._$indexBufferData = this._$indexBufferData || new $Int16Array(256);
        this._$indexBufferPos = 0;

        this._$lineCap  = line_cap;
        this._$lineJoin = line_join;

        for (let i = 0; i < vertices.length; i++) {
            const vertexBeginOffset = this._$vertexBufferPos;
            this._$generateLineSegment(vertices[i]);
            const vertexEndOffset   = this._$vertexBufferPos;

            this._$generateLineJoin(vertexBeginOffset, vertexEndOffset);
            this._$generateLineCap(vertexBeginOffset, vertexEndOffset);
        }

        return {
            "vertexBufferData": this._$vertexBufferData.slice(0, this._$vertexBufferPos),
            "indexBufferData" : this._$indexBufferData.slice(0, this._$indexBufferPos)
        };
    }

    /**
     * @param  {number} delta_length
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$expandVertexBufferIfNeeded (delta_length)
    {
        if (this._$vertexBufferPos + delta_length > this._$vertexBufferData.length) {
            const biggerBuffer = new $Float32Array(this._$vertexBufferData.length * 2);
            biggerBuffer.set(this._$vertexBufferData);
            this._$vertexBufferData = biggerBuffer;
        }
    }

    /**
     * @param  {number} delta_length
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$expandIndexBufferIfNeeded(delta_length)
    {
        if (this._$indexBufferPos + delta_length > this._$indexBufferData.length) {
            const biggerBuffer = new $Int16Array(this._$indexBufferData.length * 2);
            biggerBuffer.set(this._$indexBufferData);
            this._$indexBufferData = biggerBuffer;
        }
    }

    /**
     * @param  {array} vertex
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$generateLineSegment (vertex)
    {
        const length = vertex.length - 5;
        for (let v = 0; v < length; v += 3) {
            if (vertex[v + 2]) {
                continue;
            }

            if (vertex[v + 5]) {
                this._$addQuadSegmentMesh(
                    vertex[v],     vertex[v + 1],
                    vertex[v + 3], vertex[v + 4],
                    vertex[v + 6], vertex[v + 7]
                );
            } else {
                this._$addLineSegmentMesh(
                    vertex[v],     vertex[v + 1],
                    vertex[v + 3], vertex[v + 4]
                );
            }
        }
    }

    /**
     * @param  {number} x1 線分の始点のx座標
     * @param  {number} y1 線分の始点のy座標
     * @param  {number} cx 線分の制御点のx座標
     * @param  {number} cy 線分の制御点のy座標
     * @param  {number} x2 線分の終点のx座標
     * @param  {number} y2 線分の終点のy座標
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addQuadSegmentMesh (x1, y1, cx, cy, x2, y2)
    {
        const div = 11;

        let stx = x1;
        let sty = y1;
        for (let i = 1; i < div; i++) {
            const t = i / div;
            const rt = 1 - t;
            const edx = (x1 * rt + cx * t) * rt + (cx * rt + x2 * t) * t;
            const edy = (y1 * rt + cy * t) * rt + (cy * rt + y2 * t) * t;
            this._$addLineSegmentMesh(stx, sty, edx, edy, 2);

            stx = edx;
            sty = edy;
        }
        this._$addLineSegmentMesh(stx, sty, x2, y2);
    }

    /**
     * @param  {number} x1 線分の始点のx座標
     * @param  {number} y1 線分の始点のy座標
     * @param  {number} x2 線分の終点のx座標
     * @param  {number} y2 線分の終点のy座標
     * @param  {number} [type = 1]
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addLineSegmentMesh (x1, y1, x2, y2, type = 1)
    {
        const index0 = this._$vertexBufferPos / 7;
        const index1 = index0 + 1;
        const index2 = index0 + 2;
        const index3 = index0 + 3;

        this._$expandIndexBufferIfNeeded(6);
        const ibd = this._$indexBufferData;
        let ibp = this._$indexBufferPos;

        ibd[ibp++] = index0;
        ibd[ibp++] = index1;
        ibd[ibp++] = index3;

        ibd[ibp++] = index3;
        ibd[ibp++] = index2;
        ibd[ibp++] = index0;

        this._$indexBufferPos = ibp;

        this._$expandVertexBufferIfNeeded(28);
        const vbd = this._$vertexBufferData;
        let vbp = this._$vertexBufferPos;

        vbd[vbp++] = x1;
        vbd[vbp++] = y1;
        vbd[vbp++] = x2;
        vbd[vbp++] = y2;
        vbd[vbp++] = 1;
        vbd[vbp++] = 1;
        vbd[vbp++] = 1;

        vbd[vbp++] = x1;
        vbd[vbp++] = y1;
        vbd[vbp++] = x2;
        vbd[vbp++] = y2;
        vbd[vbp++] = -1;
        vbd[vbp++] = -1;
        vbd[vbp++] = 1;

        vbd[vbp++] = x2;
        vbd[vbp++] = y2;
        vbd[vbp++] = x1;
        vbd[vbp++] = y1;
        vbd[vbp++] = -1;
        vbd[vbp++] = -1;
        vbd[vbp++] = type;

        vbd[vbp++] = x2;
        vbd[vbp++] = y2;
        vbd[vbp++] = x1;
        vbd[vbp++] = y1;
        vbd[vbp++] = 1;
        vbd[vbp++] = 1;
        vbd[vbp++] = type;

        this._$vertexBufferPos = vbp;
    }

    /**
     * @param  {number} vertex_begin_offset 結合対象の頂点の範囲（開始）
     * @param  {number} vertex_end_offset   結合対象の頂点の範囲（終了）
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$generateLineJoin (vertex_begin_offset, vertex_end_offset)
    {
        const vbd = this._$vertexBufferData;
        const length = vertex_end_offset - 55;
        for (let v = vertex_begin_offset; v < length; v += 28) {
            const indexOffset = v / 7;
            this._$addLineJoinMesh(
                vbd[v],      vbd[v + 1],
                vbd[v + 21], vbd[v + 22], vbd[v + 27],
                vbd[v + 49], vbd[v + 50],
                indexOffset + 2, indexOffset + 3, indexOffset + 4, indexOffset + 5
            );
        }
    }

    /**
     * @param  {number} x1            線分Aの始点のx座標
     * @param  {number} y1            線分Aの始点のy座標
     * @param  {number} x2            結合点のx座標
     * @param  {number} y2            結合点のy座標
     * @param  {number} type          線分タイプ
     * @param  {number} x3            線分Bの終点のx座標
     * @param  {number} y3            線分Bの終点のy座標
     * @param  {number} index_offset2 線分Aの凸側の頂点インデックス
     * @param  {number} index_offset3 線分Aの凹側の頂点インデックス
     * @param  {number} index_offset4 線分Bの凸側の頂点インデックス
     * @param  {number} index_offset5 線分Bの凹側の頂点インデックス
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addLineJoinMesh (
        x1, y1, x2, y2, type, x3, y3,
        index_offset2, index_offset3, index_offset4, index_offset5
    ) {
        // AとBがほぼ平行なら、結合せずに終了
        const ax = x2 - x1;
        const ay = y2 - y1;
        const bx = x3 - x2;
        const by = y3 - y2;
        const det = Util.$cross(ax, ay, bx, by);
        if ($Math.abs(det) < 0.0001) { return }

        // 分割したベジェ曲線はベベルで結合する
        if (type === 2) {
            this._$addBevelJoinMesh(
                x2, y2,
                index_offset4, index_offset2, index_offset3, index_offset5
            );
            return;
        }

        // 結合タイプに合わせたメッシュを追加する
        switch (this._$lineJoin) {

            case JointStyle.ROUND:
                this._$addRoundJoinMesh(x2, y2);
                break;

            case JointStyle.MITER:
                this._$addMiterJoinMesh(
                    x2, y2, x1, y1, x3, y3,
                    index_offset4, index_offset2, index_offset3, index_offset5
                );
                break;

            default:
                this._$addBevelJoinMesh(
                    x2, y2,
                    index_offset4, index_offset2, index_offset3, index_offset5
                );
                break;

        }
    }

    /**
     * @param  {number} x 結合点のx座標
     * @param  {number} y 結合点のy座標
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addRoundJoinMesh (x, y)
    {
        const index0 = this._$vertexBufferPos / 7;

        this._$expandIndexBufferIfNeeded(57);
        const ibd = this._$indexBufferData;
        let ibp = this._$indexBufferPos;

        for (let i = 1; i < 18; i++) {
            const indexN = index0 + i;
            ibd[ibp++] = index0;
            ibd[ibp++] = indexN;
            ibd[ibp++] = indexN + 1;
        }
        ibd[ibp++] = index0;
        ibd[ibp++] = index0 + 18;
        ibd[ibp++] = index0 + 1;

        this._$indexBufferPos = ibp;

        this._$expandVertexBufferIfNeeded(133);
        const vbd = this._$vertexBufferData;
        let vbp = this._$vertexBufferPos;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;

        for (let i = 0; i < 18; i++) {
            vbd[vbp++] = x;
            vbd[vbp++] = y;
            vbd[vbp++] = 0;
            vbd[vbp++] = 0;
            vbd[vbp++] = 0;
            vbd[vbp++] = 0;
            vbd[vbp++] = 30 + i;
        }

        this._$vertexBufferPos = vbp;
    }

    /**
     * @param  {number} x      結合点のx座標
     * @param  {number} y      結合点のy座標
     * @param  {number} ax     線分Aの始点のx座標
     * @param  {number} ay     線分Aの始点のy座標
     * @param  {number} bx     線分Bの終点のx座標
     * @param  {number} by     線分Bの終点のy座標
     * @param  {number} index1
     * @param  {number} index4
     * @param  {number} index5
     * @param  {number} index8
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addMiterJoinMesh (
        x, y, ax, ay, bx, by, index1, index4, index5, index8
    ) {

        const index0 = this._$vertexBufferPos / 7;
        const index2 = index0 + 1;
        const index3 = index0 + 2;
        const index6 = index0 + 3;
        const index7 = index0 + 4;

        this._$expandIndexBufferIfNeeded(18);
        const ibd = this._$indexBufferData;
        let ibp = this._$indexBufferPos;

        ibd[ibp++] = index0;
        ibd[ibp++] = index1;
        ibd[ibp++] = index2;

        ibd[ibp++] = index0;
        ibd[ibp++] = index2;
        ibd[ibp++] = index3;

        ibd[ibp++] = index0;
        ibd[ibp++] = index3;
        ibd[ibp++] = index4;

        ibd[ibp++] = index0;
        ibd[ibp++] = index5;
        ibd[ibp++] = index6;

        ibd[ibp++] = index0;
        ibd[ibp++] = index6;
        ibd[ibp++] = index7;

        ibd[ibp++] = index0;
        ibd[ibp++] = index7;
        ibd[ibp++] = index8;

        this._$indexBufferPos = ibp;

        this._$expandVertexBufferIfNeeded(35);
        const vbd = this._$vertexBufferData;
        let vbp = this._$vertexBufferPos;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = ax;
        vbd[vbp++] = ay;
        vbd[vbp++] = bx;
        vbd[vbp++] = by;
        vbd[vbp++] = 0;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = ax;
        vbd[vbp++] = ay;
        vbd[vbp++] = bx;
        vbd[vbp++] = by;
        vbd[vbp++] = 21;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = ax;
        vbd[vbp++] = ay;
        vbd[vbp++] = bx;
        vbd[vbp++] = by;
        vbd[vbp++] = 22;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = ax;
        vbd[vbp++] = ay;
        vbd[vbp++] = bx;
        vbd[vbp++] = by;
        vbd[vbp++] = 23;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = ax;
        vbd[vbp++] = ay;
        vbd[vbp++] = bx;
        vbd[vbp++] = by;
        vbd[vbp++] = 24;

        this._$vertexBufferPos = vbp;
    }

    /**
     * @param  {number} x      結合点のx座標
     * @param  {number} y      結合点のy座標
     * @param  {number} index1
     * @param  {number} index2
     * @param  {number} index3
     * @param  {number} index4
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addBevelJoinMesh (x, y, index1, index2, index3, index4)
    {
        const index0 = this._$vertexBufferPos / 7;

        this._$expandIndexBufferIfNeeded(6);
        const ibd = this._$indexBufferData;
        let ibp = this._$indexBufferPos;

        ibd[ibp++] = index0;
        ibd[ibp++] = index1;
        ibd[ibp++] = index2;

        ibd[ibp++] = index0;
        ibd[ibp++] = index3;
        ibd[ibp++] = index4;

        this._$indexBufferPos = ibp;

        this._$expandVertexBufferIfNeeded(7);
        const vbd = this._$vertexBufferData;
        let vbp = this._$vertexBufferPos;

        vbd[vbp++] = x;
        vbd[vbp++] = y;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;
        vbd[vbp++] = 0;

        this._$vertexBufferPos = vbp;
    }

    /**
     * @param  {number} vertexBeginOffset 結合対象の頂点の範囲（開始）
     * @param  {number} vertexEndOffset   結合対象の頂点の範囲（終了）
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$generateLineCap (vertexBeginOffset, vertexEndOffset)
    {
        const vbd = this._$vertexBufferData;
        const stx1 = vbd[vertexBeginOffset];
        const sty1 = vbd[vertexBeginOffset + 1];
        const stx2 = vbd[vertexBeginOffset + 2];
        const sty2 = vbd[vertexBeginOffset + 3];
        const edx1 = vbd[vertexEndOffset - 7];
        const edy1 = vbd[vertexEndOffset - 6];
        const edx2 = vbd[vertexEndOffset - 5];
        const edy2 = vbd[vertexEndOffset - 4];

        const indexBeginOffset = vertexBeginOffset / 7;
        const indexEndOffset   = vertexEndOffset / 7;

        // 始点st1と終点ed1が同じなら、線端は追加せずに結合する
        if (stx1 === edx1 && sty1 === edy1) {
            this._$addLineJoinMesh(
                edx2, edy2, stx1, sty1, stx2, sty2,
                indexEndOffset - 2, indexEndOffset - 1,
                indexBeginOffset, indexBeginOffset + 1
            );
            return;
        }

        // 始点の線端を追加する
        this._$addLineCapMesh(stx1, sty1, stx2, sty2, indexBeginOffset, indexBeginOffset + 1);

        // 終点の線端を追加する
        this._$addLineCapMesh(edx1, edy1, edx2, edy2, indexEndOffset - 1, indexEndOffset - 2);
    }

    /**
     * @param  {number} x1     線端のx座標
     * @param  {number} y1     線端のy座標
     * @param  {number} x2     もう一方の端点のx座標
     * @param  {number} y2     もう一方の端点のy座標
     * @param  {number} index1 端点から反時計回り側の頂点インデックス
     * @param  {number} index2 端点から時計回り側の頂点インデックス
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addLineCapMesh (x1, y1, x2, y2, index1, index2)
    {
        // 線端タイプに合わせたメッシュを追加する
        switch (this._$lineCap) {
            case CapsStyle.ROUND:
                this._$addRoundJoinMesh(x1, y1);
                break;
            case CapsStyle.SQUARE:
                this._$addSquareCapMesh(x1, y1, x2, y2, index1, index2);
                break;
        }
    }

    /**
     * @param  {number} x1     線端のx座標
     * @param  {number} y1     線端のy座標
     * @param  {number} x2     もう一方の端点のx座標
     * @param  {number} y2     もう一方の端点のy座標
     * @param  {number} index1 端点から反時計回り側の頂点インデックス
     * @param  {number} index2 端点から時計回り側の頂点インデックス
     * @return {void}
     * @method
     * @static
     * @private
     */
    static _$addSquareCapMesh (x1, y1, x2, y2, index1, index2)
    {
        const index3 = this._$vertexBufferPos / 7;
        const index4 = index3 + 1;

        this._$expandIndexBufferIfNeeded(6);
        const ibd = this._$indexBufferData;
        let ibp = this._$indexBufferPos;

        ibd[ibp++] = index1;
        ibd[ibp++] = index3;
        ibd[ibp++] = index4;

        ibd[ibp++] = index4;
        ibd[ibp++] = index2;
        ibd[ibp++] = index1;

        this._$indexBufferPos = ibp;

        this._$expandVertexBufferIfNeeded(14);
        const vbd = this._$vertexBufferData;
        let vbp = this._$vertexBufferPos;

        vbd[vbp++] = x1;
        vbd[vbp++] = y1;
        vbd[vbp++] = x2;
        vbd[vbp++] = y2;
        vbd[vbp++] = -1;
        vbd[vbp++] = -1;
        vbd[vbp++] = 10;

        vbd[vbp++] = x1;
        vbd[vbp++] = y1;
        vbd[vbp++] = x2;
        vbd[vbp++] = y2;
        vbd[vbp++] = 1;
        vbd[vbp++] = 1;
        vbd[vbp++] = 10;

        this._$vertexBufferPos = vbp;
    }
}
/**
 * @class
 */
class CanvasToWebGLShader
{
    /**
     * @param   {WebGLRenderingContext} gl
     * @param   {CanvasToWebGLContext}  context
     * @param   {string} vertex_source
     * @param   {string} fragment_source
     * @constructor
     * @public
     */
    constructor (gl, context, vertex_source, fragment_source)
    {
        this._$gl      = gl;
        this._$context = context;
        this._$program = this._$createProgram(vertex_source, fragment_source);
        this._$uniform = new WebGLShaderUniform(gl, this._$program);
    }

    /**
     * @return {WebGLShaderUniform}
     * @readonly
     * @public
     */
    get uniform ()
    {
        return this._$uniform;
    }

    /**
     * @param  {string} vertex_source
     * @param  {string} fragment_source
     * @return {WebGLProgram}
     * @method
     * @private
     */
    _$createProgram (vertex_source, fragment_source)
    {
        const program = this._$gl.createProgram();

        // control number
        program.id = programId++;

        const vertexShader = this._$gl.createShader(this._$gl.VERTEX_SHADER);
        this._$gl.shaderSource(vertexShader, vertex_source);
        this._$gl.compileShader(vertexShader);

        const fragmentShader = this._$gl.createShader(this._$gl.FRAGMENT_SHADER);
        this._$gl.shaderSource(fragmentShader, fragment_source);
        this._$gl.compileShader(fragmentShader);

        if (!this._$context._$isWebGL2Context) {
            // https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glBindAttribLocation.xml
            //
            // It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.
            // 頂点シェーダ内で使用されていない属性変数名を属性インデックスにバインドすることができる。
            //
            // If name was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices,
            // but you can bind multiple user-defined attribute variables to the same index.
            // 属性変数名を複数のインデックスにバインドすることはできないが、複数の属性変数名を1つのインデックスにバインドすることはできる。

            // 上に引用した仕様により、以下の属性変数名がシェーダに存在しなくても問題なく、
            // また、a_bezier と a_option1 のどちらも 1 にバインドすることも問題ない。

            this._$gl.bindAttribLocation(program, 0, "a_vertex");
            this._$gl.bindAttribLocation(program, 1, "a_bezier");
            this._$gl.bindAttribLocation(program, 1, "a_option1");
            this._$gl.bindAttribLocation(program, 2, "a_option2");
            this._$gl.bindAttribLocation(program, 3, "a_type");
        }

        this._$gl.attachShader(program, vertexShader);
        this._$gl.attachShader(program, fragmentShader);
        this._$gl.linkProgram(program);

        this._$gl.detachShader(program, vertexShader);
        this._$gl.detachShader(program, fragmentShader);

        this._$gl.deleteShader(vertexShader);
        this._$gl.deleteShader(fragmentShader);

        return program;
    }

    /**
     * @return void
     * @private
     */
    _$attachProgram ()
    {
        if (this._$context._$shaderList._$currentProgramId !== this._$program.id) {
            this._$context._$shaderList._$currentProgramId = this._$program.id;
            this._$gl.useProgram(this._$program);
        }
    }

    /**
     * @return void
     * @public
     */
    _$drawImage ()
    {
        if (window.glstats) {
            glstats.ondraw();
        }

        this._$attachProgram();
        this._$uniform.bindUniforms();
        this._$context.vao.bindCommonVertexArray();
        this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP, 0, 4);
    }

    /**
     * @param  {number} begin
     * @param  {number} end
     * @return void
     * @public
     */
    _$drawGradient (begin, end)
    {
        if (window.glstats) {
            glstats.ondraw();
        }

        this._$attachProgram();
        this._$uniform.bindUniforms();
        this._$context.vao.bindGradientVertexArray(begin, end);
        this._$gl.drawArrays(this._$gl.TRIANGLE_STRIP, 0, 4);
    }

    /**
     * @param  {object} object
     * @return void
     * @public
     */
    _$stroke (object)
    {
        if (window.glstats) {
            glstats.ondraw();
        }

        // setup
        this._$attachProgram();

        // set alpha
        this._$context.blend.reset();

        // update data
        this._$uniform.bindUniforms();

        // bind vertex array
        this._$context.vao.bind(object);

        // draw
        this._$gl.drawElements(this._$gl.TRIANGLES, object.indexCount, this._$gl.UNSIGNED_SHORT, 0);
    }

    /**
     * @param  {object} object
     * @return void
     * @public
     */
    _$fill (object)
    {
        if (window.glstats) {
            glstats.ondraw();
        }

        // setup
        this._$attachProgram();

        // set alpha
        this._$context.blend.reset();

        // update data
        this._$uniform.bindUniforms();

        // bind vertex array
        this._$context.vao.bind(object);

        // draw fill
        const range = object.indexRanges[object.indexRanges.length - 1];
        const count = range.first + range.count;
        this._$gl.drawArrays(this._$gl.TRIANGLES, 0, count);
    }

    /**
     * @param {WebGLVertexArrayObjectOES} vertex_array
     * @param {uint} first
     * @param {uint} count
     * @public
     */
    _$containerClip (vertex_array, first, count)
    {
        if (window.glstats) {
            glstats.ondraw();
        }

        // setup
        this._$attachProgram();

        // set alpha
        this._$context.blend.reset();

        // update data
        this._$uniform.bindUniforms();

        // bind vertex array
        this._$context.vao.bind(vertex_array);

        // draw fill
        this._$gl.drawArrays(this._$gl.TRIANGLES, first, count);
    }

    /**
     * @param {WebGLVertexArrayObjectOES} vertex_array
     * @param {uint} first
     * @param {uint} count
     * @public
     */
    _$drawPoints (vertex_array, first, count)
    {
        if (window.glstats) {
            glstats.ondraw();
        }

        // setup
        this._$attachProgram();

        // ここでblendの設定はしない
        // this._$context.blend.reset();

        // update data
        this._$uniform.bindUniforms();

        // bind vertex array
        this._$context.vao.bind(vertex_array);

        // draw fill
        this._$gl.drawArrays(this._$gl.POINTS, first, count);
    }
}

/**
 * @class
 */
class CanvasToWebGLShaderList
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @constructor
     * @public
     */
    constructor (context, gl)
    {
        const keyword = new WebGLShaderKeyword(gl, context._$isWebGL2Context);
        this._$currentProgramId = -1;

        this._$shapeShaderVariants         = new ShapeShaderVariantCollection(context, gl, keyword);
        this._$bitmapShaderVariants        = new BitmapShaderVariantCollection(context, gl, keyword);
        this._$gradientShapeShaderVariants = new GradientShapeShaderVariantCollection(context, gl, keyword);
        this._$gradientLUTShaderVariants   = new GradientLUTShaderVariantCollection(context, gl, keyword);
        this._$filterShaderVariants        = new FilterShaderVariantCollection(context, gl, keyword);
        this._$blendShaderVariants         = new BlendShaderVariantCollection(context, gl, keyword);

        // BitmapData
        const colorTransform = {
            "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.COLOR_TRANSFORM.bind(null, false)),
            "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.COLOR_TRANSFORM.bind(null, true))
        };
        const copyChannel = {
            "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_AND_DST_TEX_COORD, FragmentShaderSourceBitmapData.COPY_CHANNEL.bind(null, false)),
            "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_AND_DST_TEX_COORD, FragmentShaderSourceBitmapData.COPY_CHANNEL.bind(null, true))
        };
        const merge = {
            "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_AND_DST_TEX_COORD, FragmentShaderSourceBitmapData.MERGE.bind(null, false)),
            "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_AND_DST_TEX_COORD, FragmentShaderSourceBitmapData.MERGE.bind(null, true))
        };
        const paletteMap = {
            "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.PALETTE_MAP.bind(null, false)),
            "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.PALETTE_MAP.bind(null, true))
        };
        const pixelDissolve = {
            "color": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.POSITION_ONLY, FragmentShaderSourceBitmapData.FILL_COLOR),
            "texture": {
                "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.PIXEL_DISSOLVE_TEXTURE, FragmentShaderSourceBitmapData.PIXEL_DISSOLVE_TEXTURE.bind(null, false)),
                "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.PIXEL_DISSOLVE_TEXTURE, FragmentShaderSourceBitmapData.PIXEL_DISSOLVE_TEXTURE.bind(null, true))
            }
        };
        const copySrcTex = new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.COPY_SRC_TEX);
        const copyPixels = {
            "withAlphaBitmapData": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_AND_ALPHA_TEX_COORD, FragmentShaderSourceBitmapData.COPY_PIXELS_WITH_ALPHA_BITMAP_DATA),
            "noAlphaBitmapData": copySrcTex
        };
        const fillRect = new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.POSITION_ONLY, FragmentShaderSourceBitmapData.FILL_COLOR);
        const noise = new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.POSITION_ONLY, FragmentShaderSourceBitmapData.NOISE);

        const thresholdBuilder = function(operation) {
            return {
                "discardSource": {
                    "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.THRESHOLD.bind(null, operation, false, false)),
                    "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.THRESHOLD.bind(null, operation, false, true))
                },
                "copySource": {
                    "opaque":      new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.THRESHOLD.bind(null, operation, true, false)),
                    "transparent": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.THRESHOLD.bind(null, operation, true, true))
                }
            };
        };
        const threshold = {
            "less":         thresholdBuilder("less"),
            "lessEqual":    thresholdBuilder("lessEqual"),
            "greater":      thresholdBuilder("greater"),
            "greaterEqual": thresholdBuilder("greaterEqual"),
            "equal":        thresholdBuilder("thresholdEqual"),
            "notEqual":     thresholdBuilder("thresholdNotEqual"),

            "subtotal": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.THRESHOLD_SUBTOTAL)
        };

        const getColorBoundsRect = {
            "findColor"   : new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.GET_COLOR_BOUNDS_RECT.bind(null, true)),
            "findNotColor": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.GET_COLOR_BOUNDS_RECT.bind(null, false))
        };

        const getPixels = {
            "RGBA": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.GET_PIXELS.bind(null, "RGBA")),
            "BGRA": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.GET_PIXELS.bind(null, "BGRA")),
            "ARGB": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.GET_PIXELS.bind(null, "ARGB"))
        };
        const setPixels = {
            "RGBA": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.SET_PIXELS.bind(null, "RGBA")),
            "BGRA": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.SET_PIXELS.bind(null, "BGRA")),
            "ARGB": new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SRC_TEX_COORD, FragmentShaderSourceBitmapData.SET_PIXELS.bind(null, "ARGB"))
        };
        const setPixelQueue = new WebGLShaderProxy(context, gl, keyword, VertexShaderSourceBitmapData.SET_PIXEL_QUEUE, FragmentShaderSourceBitmapData.SET_PIXEL_QUEUE);

        this._$bitmapData = {
            colorTransform,
            copyChannel,
            merge,
            paletteMap,
            pixelDissolve,
            copyPixels,
            "scroll": copySrcTex,
            fillRect,
            noise,
            threshold,
            getColorBoundsRect,
            getPixels,
            setPixels,
            setPixelQueue
        };
    }

    /**
     * @memberof CanvasToWebGLShaderList#
     * @property {ShapeShaderVariantCollection} shapeShaderVariants
     * @return {ShapeShaderVariantCollection}
     * @readonly
     * @public
     */
    get shapeShaderVariants ()
    {
        return this._$shapeShaderVariants;
    }

    /**
     * @memberof CanvasToWebGLShaderList#
     * @property {BitmapShaderVariantCollection} bitmapShaderVariants
     * @return {BitmapShaderVariantCollection}
     * @readonly
     * @public
     */
    get bitmapShaderVariants ()
    {
        return this._$bitmapShaderVariants;
    }

    /**
     * @memberof CanvasToWebGLShaderList#
     * @property {GradientShapeShaderVariantCollection} gradientShapeShaderVariants
     * @return {GradientShapeShaderVariantCollection}
     * @readonly
     * @public
     */
    get gradientShapeShaderVariants ()
    {
        return this._$gradientShapeShaderVariants;
    }

    /**
     * @memberof CanvasToWebGLShaderList#
     * @property {GradientLUTShaderVariantCollection} gradientLUTShaderVariants
     * @return {GradientLUTShaderVariantCollection}
     * @readonly
     * @public
     */
    get gradientLUTShaderVariants ()
    {
        return this._$gradientLUTShaderVariants;
    }

    /**
     * @memberof CanvasToWebGLShaderList#
     * @property {FilterShaderVariantCollection} filterShaderVariants
     * @return {FilterShaderVariantCollection}
     * @readonly
     * @public
     */
    get filterShaderVariants ()
    {
        return this._$filterShaderVariants;
    }

    /**
     * @memberof CanvasToWebGLShaderList#
     * @property {BlendShaderVariantCollection} blendShaderVariants
     * @return {BlendShaderVariantCollection}
     * @readonly
     * @public
     */
    get blendShaderVariants ()
    {
        return this._$blendShaderVariants;
    }
}
/**
 * @class
 */
class GradientLUTGenerator
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {CanvasToWebGLContext}  context
     * @constructor
     * @public
     */
    constructor (context, gl)
    {
        this._$context    = context;
        this._$gl         = gl;
        this._$attachment = context.frameBuffer.createTextureAttachment(512, 1);
        this._$maxLength  = $Math.floor(this._$gl.getParameter(this._$gl.MAX_FRAGMENT_UNIFORM_VECTORS) * 0.75);

        this._$rgbToLinearTable = new $Float32Array(256);
        this._$rgbIdentityTable = new $Float32Array(256);
        for (let i = 0; i < 256; i++) {
            const t = i / 255;
            this._$rgbToLinearTable[i] = $Math.pow(t, 2.23333333);
            this._$rgbIdentityTable[i] = t;
        }
    }

    /**
     * @param  {array}   stops
     * @param  {boolean} is_linear_space
     * @return {WebGLTexture}
     * @method
     * @public
     */
    generateForShape (stops, is_linear_space)
    {
        const currentAttachment = this._$context.frameBuffer.currentAttachment;

        this._$context._$bind(this._$attachment);

        const stopsLength = stops.length;
        const variants = this._$context._$shaderList.gradientLUTShaderVariants;
        const table = is_linear_space ? this._$rgbToLinearTable : this._$rgbIdentityTable;

        this._$context.blend.toOneZero();

        for (let begin = 0; begin < stopsLength; begin += this._$maxLength - 1) {
            const end = $Math.min(begin + this._$maxLength, stopsLength);

            const shader = variants.getGradientLUTShader(end - begin, is_linear_space);
            const uniform = shader.uniform;
            variants.setGradientLUTUniformForShape(uniform, stops, begin, end, table);

            shader._$drawGradient(
                begin === 0 ? 0 : stops[begin][0],
                end === stopsLength ? 1 : stops[end - 1][0]
            );
        }

        this._$context._$bind(currentAttachment);

        return this._$attachment.texture;
    }

    /**
     * @param  {array} ratios
     * @param  {array} colors
     * @param  {array} alphas
     * @return {WebGLTexture}
     * @method
     * @public
     */
    generateForFilter (ratios, colors, alphas)
    {
        const currentAttachment = this._$context.frameBuffer.currentAttachment;

        this._$context._$bind(this._$attachment);

        const stopsLength = ratios.length;
        const variants = this._$context._$shaderList.gradientLUTShaderVariants;

        this._$context.blend.toOneZero();

        for (let begin = 0; begin < stopsLength; begin += this._$maxLength - 1) {
            const end = $Math.min(begin + this._$maxLength, stopsLength);

            const shader = variants.getGradientLUTShader(end - begin, false);
            const uniform = shader.uniform;
            variants.setGradientLUTUniformForFilter(uniform, ratios, colors, alphas, begin, end);

            shader._$drawGradient(
                begin === 0 ? 0 : ratios[begin],
                end === stopsLength ? 1 : ratios[end - 1]
            );
        }

        this._$context._$bind(currentAttachment);

        return this._$attachment.texture;
    }
}
/**
 * @class
 */
class WebGLShaderKeyword
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {boolean} is_web_gl2_context
     * @constructor
     * @public
     */
    constructor (gl, is_web_gl2_context)
    {
        this._$isWebGL2Context = is_web_gl2_context;

        if (!is_web_gl2_context) {
            gl.getExtension("OES_standard_derivatives");
        }
    }

    /**
     * @return {string}
     * @method
     * @public
     */
    version ()
    {
        return this._$isWebGL2Context
            ? "#version 300 es"
            : "";
    }

    /**
     * @param  {number} index
     * @return {string}
     * @method
     * @public
     */
    attribute (index)
    {
        return this._$isWebGL2Context
            ? `layout (location = ${index}) in`
            : "attribute";
    }

    /**
     * @param  {boolean} [centroid=false]
     * @return {string}
     * @method
     * @public
     */
    varyingOut (centroid = false)
    {
        return this._$isWebGL2Context
            ? `${centroid ? "centroid " : ""}out`
            : "varying";
    }

    /**
     * @param  {boolean} [centroid=false]
     * @return {string}
     * @method
     * @public
     */
    varyingIn (centroid = false)
    {
        return this._$isWebGL2Context
            ? `${centroid ? "centroid " : ""}in`
            : "varying";
    }

    /**
     * @return {string}
     * @method
     * @public
     */
    outColor ()
    {
        return this._$isWebGL2Context
            ? "out vec4 o_color;"
            : "";
    }

    /**
     * @return {string}
     * @method
     * @public
     */
    fragColor ()
    {
        return this._$isWebGL2Context
            ? "o_color"
            : "gl_FragColor";
    }

    /**
     * @return {string}
     * @method
     * @public
     */
    texture2D ()
    {
        return this._$isWebGL2Context
            ? "texture"
            : "texture2D";
    }

    /**
     * @return {string}
     * @method
     * @public
     */
    extensionDerivatives ()
    {
        return this._$isWebGL2Context
            ? ""
            : "#extension GL_OES_standard_derivatives : enable";
    }
}

/**
 * @class
 */
class WebGLShaderProxy
{
    /**
     * @param {CanvasToWebGLContext}  context
     * @param {WebGLRenderingContext} gl
     * @param {WebGLShaderKeyword}    keyword
     * @param {function} vertex_source
     * @param {function} fragment_source
     * @constructor
     * @public
     */
    constructor (context, gl, keyword, vertex_source, fragment_source)
    {
        this._$context        = context;
        this._$gl             = gl;
        this._$keyword        = keyword;
        this._$vertexSource   = vertex_source;
        this._$fragmentSource = fragment_source;
        this._$instance       = null;
    }

    /**
     * @memberof WebGLShaderProxy#
     * @property {CanvasToWebGLShader}
     * @readonly
     * @public
     */
    get instance ()
    {
        if (!this._$instance) {
            this._$instance = new CanvasToWebGLShader(
                this._$gl, this._$context,
                this._$vertexSource(this._$keyword),
                this._$fragmentSource(this._$keyword)
            );
        }
        return this._$instance;
    }
}

/**
 * @class
 */
class WebGLShaderUniform
{
    /**
     * @param {WebGLRenderingContext} gl
     * @param {WebGLProgram}          program
     * @constructor
     * @public
     */
    constructor (gl, program)
    {
        this._$gl     = gl;
        this._$array = [];
        this._$map    = new Map();

        const activeUniforms = this._$gl.getProgramParameter(program, this._$gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < activeUniforms; i++) {
            const info = this._$gl.getActiveUniform(program, i);
            const name = info.name.endsWith("[0]") ? info.name.slice(0, -3) : info.name;

            // console.log("info:", info.name, info.type, info.size);

            const data = {};
            const location = this._$gl.getUniformLocation(program, name);

            // WebGLの仕様でuniformのint型のデフォルト値は0に設定されるため、
            // sampler2D（size=1）の値の更新は不要
            if (info.type === this._$gl.SAMPLER_2D && info.size === 1) {
                continue;
            }

            switch (info.type) {
                // uniformの値の設定は、gl.uniform4[fi]v()が最速のため、
                // 可能な限りFloat32Arrayに値をパックして転送するようにする
                case this._$gl.FLOAT_VEC4:
                    data.method = this._$gl.uniform4fv.bind(this._$gl, location);
                    data.array = new Float32Array(4 * info.size);
                    data.assign = -1;
                    break;
                case this._$gl.INT_VEC4:
                    data.method = this._$gl.uniform4iv.bind(this._$gl, location);
                    data.array = new Int32Array(4 * info.size);
                    data.assign = -1;
                    break;
                // uniformの値の設定は、programに保持されるため、
                // sampler2Dは一度だけ設定するようにする
                case this._$gl.SAMPLER_2D:
                    data.method = this._$gl.uniform1iv.bind(this._$gl, location);
                    data.array = new Int32Array(info.size);
                    data.assign = 1;
                    break;
                case this._$gl.FLOAT:
                case this._$gl.FLOAT_VEC2:
                case this._$gl.FLOAT_VEC3:
                case this._$gl.FLOAT_MAT2:
                case this._$gl.FLOAT_MAT3:
                case this._$gl.FLOAT_MAT4:
                case this._$gl.INT:
                case this._$gl.INT_VEC2:
                case this._$gl.INT_VEC3:
                default:
                    throw new Error("Use gl.FLOAT_VEC4 or gl.INT_VEC4 instead");
            }

            this._$array.push(data);
            this._$map.set(name, data);
        }

        // console.log(this._$map);
        // console.log("------------------");
    }

    /**
     * @param {string} name
     * @method
     * @public
     */
    getArray (name)
    {
        return this._$map.get(name).array;
    }

    /**
     * @memberof WebGLShaderUniform#
     * @property {Int32Array}
     * @return {Int32Array}
     * @readonly
     * @public
     */
    get textures ()
    {
        return this._$map.get("u_textures").array;
    }

    /**
     * @memberof WebGLShaderUniform#
     * @property {Float32Array}
     * @return {Float32Array}
     * @readonly
     * @public
     */
    get highp ()
    {
        return this._$map.get("u_highp").array;
    }

    /**
     * @memberof WebGLShaderUniform#
     * @property {Float32Array}
     * @return {Float32Array}
     * @readonly
     * @public
     */
    get mediump ()
    {
        return this._$map.get("u_mediump").array;
    }

    /**
     * @memberof WebGLShaderUniform#
     * @property {Int32Array}
     * @return   {Int32Array}
     * @readonly
     * @public
     */
    get integer ()
    {
        return this._$map.get("u_integer").array;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    bindUniforms ()
    {
        const length = this._$array.length;
        for (let i = 0; i < length; i++) {
            const data = this._$array[i];
            if (data.assign < 0) {
                data.method(data.array);
            } else if (data.assign > 0) {
                data.assign--;
                data.method(data.array);
            }
        }
    }
}
/**
 * @class
 */
class Player
{
    /**
     * @constructor
     * @public
     */
    constructor()
    {
        /**
         * @type {Stage}
         * @private
         */
        this._$stage = new Stage();
        this._$stage._$player = this;

        /**
         * @type {CacheStore}
         * @private
         */
        this._$cacheStore = new CacheStore();

        /**
         * @type {string}
         * @private
         */
        this._$mode = "loader";

        /**
         * @type {number}
         * @private
         */
        this._$actionOffset = 0;

        /**
         * @type {array}
         * @private
         */
        this._$actions = Util.$getArray();

        /**
         * @type {array}
         * @private
         */
        this._$loaders = Util.$getArray();

        /**
         * @type {array}
         * @private
         */
        this._$sounds = Util.$getMap();

        /**
         * @type {object}
         * @private
         */
        this._$hitObject = {
            "x": 0,
            "y": 0,
            "pointer": "",
            "hit": null
        };

        /**
         * @type {DisplayObject}
         * @default null
         * @private
         */
        this._$rollOverObject = null;

        /**
         * @type {DisplayObject}
         * @default null
         * @private
         */
        this._$mouseOverTarget = null;

        /**
         * @type {number}
         * @private
         */
        this._$ratio = Util.$devicePixelRatio;

        /**
         * @type {boolean}
         * @default true
         * @private
         */
        this._$stopFlag = true;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$startTime = 0;

        /**
         * @type {number}
         * @default 60
         * @private
         */
        this._$fps = 60;

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$isLoad = false;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$loadStatus = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$width = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$height = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$baseWidth = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$baseHeight = 0;

        /**
         * @type {number}
         * @default 1
         * @private
         */
        this._$scale = 1;

        /**
         * @type {Float32Array}
         * @private
         */
        this._$matrix = new $Float32Array([1, 0, 0, 1, 0, 0]); // fixed size 6

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$tx = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$ty = 0;

        /**
         * @type {string|number}
         * @default null
         * @private
         */
        this._$backgroundColor = null;

        /**
         * @type {string}
         * @default up
         * @private
         */
        this._$state = "up";

        /**
         * @type {boolean}
         * @default false
         * @private
         */
        this._$hitTestStart = false;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$stageX = -1;

        /**
         * @type {number}
         * @default -1
         * @private
         */
        this._$stageY = -1;

        /**
         * @type {Map}
         * @private
         */
        this._$broadcastEvents = Util.$getMap();

        /**
         * @type {null}
         * @default null
         * @private
         */
        this._$context = null;

        /**
         * @type {null}
         * @default null
         * @private
         */
        this._$canvas = null;

        /**
         * @type {null}
         * @default null
         * @private
         */
        this._$buffer = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$optionWidth = 0;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$optionHeight = 0;

        /**
         * @type {string|null}
         * @default null
         * @private
         */
        this._$tagId = null;

        /**
         * @type {string|boolean}
         * @default null
         * @private
         */
        this._$bgColor = null;

        /**
         * @type {string}
         * @default ""
         * @private
         */
        this._$base = "";

        /**
         * @type {boolean}
         * @default ""
         * @private
         */
        this._$fullScreen = false;

        /**
         * @type {string}
         * @default StageQuality.HIGH
         * @private
         */
        this._$quality = StageQuality.HIGH;

        /**
         * @type {array}
         * @private
         */
        this._$sources = Util.$getArray();

        /**
         * @type {array}
         * @private
         */
        this._$videos = Util.$getArray();

        /**
         * @type {TextField}
         * @default null
         * @private
         */
        this._$textField = null;

        /**
         * @type {number}
         * @default 0
         * @private
         */
        this._$touchY = 0;

        // delay
        this._$bindRun = this._$run.bind(this);
        this._$timerId = -1;
        this._$loadId  = -1;
    }

    /**
     * @return  {number}
     * @default 1
     * @const
     * @static
     */
    static get LOAD_START ()
    {
        return 1;
    }

    /**
     * @return {number}
     * @default 2
     * @const
     * @static
     */
    static get LOAD_END ()
    {
        return 2;
    }

    /**
     * @return {Map}
     * @readonly
     * @public
     */
    get broadcastEvents ()
    {
        return this._$broadcastEvents;
    }

    /**
     * @member {string}
     * @default ""
     * @public
     */
    get base ()
    {
        return this._$base;
    }
    set base (base)
    {
        if (typeof base === "string") {

            if (base.indexOf("//") === -1) {

                const urls = base.split("/");
                if (urls[0] === "" || urls[0] === ".") {
                    urls.shift();
                }
                urls.pop();

                this._$base = `${Util.$location.origin}/`;
                if (urls.length) {
                    this._$base += `${urls.join("/")}/`;
                }

            } else {

                if (base.indexOf("?") === -1) {

                    this._$base = base.slice(-1) === "/" ? base : `${base}/`;

                } else {

                    const path  = base.split("?")[0];
                    this._$base = path.slice(-1) === "/" ? path : `${path}/`;

                }

            }
        }
    }

    /**
     * @return {Stage}
     * @readonly
     * @public
     */
    get stage ()
    {
        return this._$stage;
    }

    /**
     * @member {number}
     * @readonly
     * @public
     */
    get x ()
    {
        return this._$tx;
    }

    /**
     * @member {number}
     * @readonly
     * @public
     */
    get y ()
    {
        return this._$ty;
    }

    /**
     * @member {number}
     * @readonly
     * @public
     */
    get scaleX ()
    {
        return this._$matrix[0];
    }

    /**
     * @member {number}
     * @readonly
     * @public
     */
    get scaleY ()
    {
        return this._$matrix[3];
    }

    /**
     * @return {string}
     * @readonly
     * @public
     */
    get contentElementId ()
    {
        return `${Util.$PREFIX}`;
    }

    /**
     * @member {number}
     * @public
     */
    get width ()
    {
        return this._$baseWidth;
    }
    set width (width)
    {
        this._$baseWidth = width | 0;
    }

    /**
     * @member {number}
     * @public
     */
    get height ()
    {
        return this._$baseHeight;
    }
    set height (height)
    {
        this._$baseHeight = height | 0;
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    play ()
    {
        if (this._$stopFlag) {

            this._$stopFlag = false;

            if (this._$timerId > -1) {
                const clearTimer = Util.$cancelAnimationFrame;
                clearTimer(this._$timerId);
            }

            this._$startTime = Util.$performance.now();

            this._$fps = 1000 / this._$stage._$frameRate;

            const timer = Util.$requestAnimationFrame;
            this._$timerId = timer(this._$bindRun);
        }
    }

    /**
     * @return {void}
     * @method
     * @public
     */
    stop ()
    {
        const clearTimer = Util.$cancelAnimationFrame;
        clearTimer(this._$timerId);

        this._$stopFlag = true;
        this._$timerId  = -1;

        SoundMixer.stopAll();
        Util.$cacheStore().reset();
    }

    /**
     * @param  {object} [options=null]
     * @return {void}
     * @public
     */
    setOptions (options = null)
    {
        if (options) {
            this._$optionWidth  = options.width  || this._$optionWidth;
            this._$optionHeight = options.height || this._$optionHeight;
            this._$tagId        = options.tagId  || this._$tagId;
            this.base           = options.base   || this._$base;
            this._$fullScreen   = !!options.fullScreen;

            if ("bgColor" in options) {
                this._$bgColor = options.bgColor;
            }
        }

        this._$initialize();
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$updateLoadStatus ()
    {
        if (this._$loadStatus === Player.LOAD_END) {
            this._$loaded();
            return ;
        }

        const timer = Util.$requestAnimationFrame;
        this._$loadId = timer(this._$updateLoadStatus.bind(this));
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$loaded ()
    {
        const element = Util.$document.getElementById(this.contentElementId);
        if (element) {

            // set backgroundColor
            if (this._$bgColor !== null) {
                this._$backgroundColor = this._$bgColor;
            }

            // background color
            if (this._$context) {

                if (!this._$backgroundColor || this._$backgroundColor === "transparent") {

                    this._$context._$setColor(0, 0, 0, 0);

                } else {

                    this._$context._$setColor(
                        this._$backgroundColor[0],
                        this._$backgroundColor[1],
                        this._$backgroundColor[2],
                        this._$backgroundColor[3]
                    );

                }

            }

            // DOM
            this._$deleteNode();

            // append canvas
            element.appendChild(this._$canvas);

            // start
            this.play();

            // stage init action
            this._$stage._$prepareActions();

            // constructed event
            if (this._$broadcastEvents.has(Event.FRAME_CONSTRUCTED)) {
                this._$dispatchEvent(new Event(Event.FRAME_CONSTRUCTED));
            }

            // frame1 action
            this._$doAction();

            // exit event
            if (this._$broadcastEvents.has(Event.EXIT_FRAME)) {
                this._$dispatchEvent(new Event(Event.EXIT_FRAME));
            }

            // loader events
            const length = this._$loaders.length | 0;
            for (let idx = 0; idx < length; ++idx) {

                const loader = this._$loaders.shift();

                // unlock
                if (loader instanceof LoaderInfo) {
                    loader._$lock = false;
                }

                // init event
                if (loader.hasEventListener(Event.INIT)) {
                    loader.dispatchEvent(new Event(Event.INIT));
                }

                // complete event
                if (loader.hasEventListener(Event.COMPLETE)) {
                    loader.dispatchEvent(new Event(Event.COMPLETE));
                }

                // reset scope player
                loader._$player = null;
            }

            // activate event
            if (this._$broadcastEvents.has(Event.ACTIVATE)) {
                this._$dispatchEvent(new Event(Event.ACTIVATE));
            }

            // frame action
            this._$doAction();

            // render
            this._$draw();

        }

    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$initialize ()
    {
        const doc = Util.$document;
        if (doc.readyState === "loading") {

            const initialize = function (event)
            {
                event.target.removeEventListener("DOMContentLoaded", initialize);
                this._$initialize();

            }.bind(this);

            Util.$window.addEventListener("DOMContentLoaded", initialize);

            return ;
        }

        const contentElementId = this.contentElementId;
        if (this._$tagId === null) {

            doc
                .body
                .insertAdjacentHTML(
                    "beforeend", `<div id="${contentElementId}"></div>`
                );

        } else {

            const container = doc.getElementById(this._$tagId);
            if (!container) {
                alert("Not Found Tag ID:" + this._$tagId);
                return ;
            }

            const div = doc.getElementById(contentElementId);
            if (!div) {

                const element    = doc.createElement("div");
                element.id       = contentElementId;
                element.tabIndex = -1;
                container.appendChild(element);

            } else {

                this._$deleteNode();

            }

        }

        if (!this._$canvas) {
            this._$initializeCanvas();
        }

        const element = doc.getElementById(contentElementId);
        const parent = element.parentNode;
        if (parent) {

            this._$initStyle(element);
            this._$buildWait();

            const width  = this._$optionWidth
                ? this._$optionWidth
                : parent.tagName === "BODY"
                    ? Util.$window.innerWidth
                    : parent.offsetWidth;

            const height = this._$optionHeight
                ? this._$optionHeight
                : parent.tagName === "BODY"
                    ? Util.$window.innerHeight
                    : parent.offsetHeight;

            // set center
            if (this._$mode === "loader" && width && height) {
                this._$baseWidth  = width;
                this._$baseHeight = height;
                this._$resize();
            }
        }

        if (this._$mode === "loader") {
            this._$loadStatus = Player.LOAD_START;
            this._$updateLoadStatus();
        } else {
            this._$resize();
            this._$loaded();
        }
    }

    /**
     * @param   {object} element
     * @returns {void}
     * @method
     * @private
     */
    _$initStyle (element)
    {
        const style = element.style;

        // set css
        style.position        = "relative";
        style.top             = "0";
        style.left            = "0";
        style.backgroundColor = "transparent";
        style.overflow        = "hidden";
        style.padding         = "0";
        style.margin          = "0";
        style.userSelect      = "none";
        style.outline         = "none";

        const width  = this._$optionWidth;
        const height = this._$optionHeight;

        const parent = element.parentNode;
        if (parent.tagName === "BODY") {
            style.width  = width  ? `${width}px`  : `${window.innerWidth}px`;
            style.height = height ? `${height}px` : `${window.innerHeight}px`;
            return ;
        }

        style.width  = width  ? `${width}px`  : `${parent.offsetWidth}px`;
        style.height = height ? `${height}px` : `${parent.offsetHeight}px`;
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$buildWait ()
    {
        const element = Util.$document.getElementById(this.contentElementId);
        if (element) {

            const loadingId = `${this.contentElementId}_loading`;

            element.innerHTML = `<style>
#${loadingId} {
    position: absolute;
    top: 50%;
    left: 50%;
    margin: -24px 0 0 -24px;
    width: 50px;
    height: 50px;
    border-radius: 50px;
    border: 8px solid #dcdcdc;
    border-right-color: transparent;
    box-sizing: border-box;
    animation: ${loadingId} 0.8s infinite linear;
}
@keyframes ${loadingId} {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}
</style>`;

            const div = Util.$document.createElement("div");
            div.id    = loadingId;

            element.appendChild(div);
        }
    }

    /**
     * @returns {void}
     * @method
     * @private
     */
    _$deleteNode ()
    {
        const element = Util.$document.getElementById(this.contentElementId);
        if (element) {
            while (element.childNodes.length) {
                element.removeChild(element.childNodes[0]);
            }
        }
    }

    /**
     * @return {void}
     * @private
     */
    _$initializeCanvas ()
    {
        // main canvas
        const canvas  = Util.$document.createElement("canvas");
        canvas.width  = 1;
        canvas.height = 1;
        this._$canvas = canvas;

        // create gl context
        const option = {
            "stencil": true,
            "premultipliedAlpha": true,
            "antialias": false,
            "depth": false,
            "preserveDrawingBuffer": true
        };

        let isWebGL2Context = true;

        let gl = canvas.getContext("webgl2", option);
        if (!gl) {
            gl = canvas.getContext("webgl", option)
                || canvas.getContext("experimental-webgl", option);
            isWebGL2Context = false;
        }

        if (gl) {
            this._$context = new CanvasToWebGLContext(gl, isWebGL2Context);
        } else {
            alert("WebGL setting is off. Please turn the setting on.");
        }

        if (window.glstats) {
            glstats.init(gl, isWebGL2Context, Util.$isChrome, Util.$isFireFox);
        }

        // set event
        if (Util.$isTouch) {

            const loadSpAudio = function (event)
            {
                event.target.removeEventListener(Util.$TOUCH_END, loadSpAudio);
                Util.$loadAudioData();
            };

            // audio context load event
            canvas.addEventListener(Util.$TOUCH_END, loadSpAudio);

            // touch event
            canvas.addEventListener(Util.$TOUCH_START, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$TOUCH_START;
                // start position
                this._$touchY   = event.changedTouches[0].pageY;
                this._$hitTest();
            }.bind(this));

            canvas.addEventListener(Util.$TOUCH_MOVE, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$TOUCH_MOVE;

                this._$hitTest();
            }.bind(this));

            canvas.addEventListener(Util.$TOUCH_END, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$TOUCH_END;

                this._$hitTest();
            }.bind(this));

            // mouse wheel
            canvas.addEventListener(Util.$TOUCH_MOVE, function (event)
            {
                // update
                const pageY   = event.changedTouches[0].pageY;
                event.deltaY  = this._$touchY - pageY;
                this._$touchY = pageY;

                Util.$event     = event;
                Util.$eventType = Util.$MOUSE_WHEEL;

                this._$hitTest();
            }.bind(this), { "passive": false });

        } else {

            const loadWebAudio = function (event)
            {
                event.target.removeEventListener(Util.$MOUSE_DOWN, loadWebAudio);
                Util.$loadAudioData();
            };

            // audio context load event
            canvas.addEventListener(Util.$MOUSE_DOWN, loadWebAudio);

            // mouse event
            canvas.addEventListener(Util.$MOUSE_DOWN, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$MOUSE_DOWN;

                if (!event.button) {
                    this._$hitTest();
                }
            }.bind(this));

            canvas.addEventListener(Util.$DOUBLE_CLICK, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$DOUBLE_CLICK;

                if (!event.button) {
                    this._$hitTest();
                }
            }.bind(this));

            canvas.addEventListener(Util.$MOUSE_LEAVE, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$MOUSE_LEAVE;

                this._$hitTest();

                Util.$event = null;
                this._$stageX = -1;
                this._$stageY = -1;
            }.bind(this));

            canvas.addEventListener(Util.$MOUSE_UP, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$MOUSE_UP;

                if (!event.button) {
                    this._$hitTest();
                }
            }.bind(this));

            canvas.addEventListener(Util.$MOUSE_MOVE, function (event)
            {
                Util.$event     = event;
                Util.$eventType = Util.$MOUSE_MOVE;

                this._$hitTest();
            }.bind(this));

            // mouse wheel
            canvas.addEventListener(Util.$MOUSE_WHEEL, function (event)
            {
                if (!event.defaultPrevented) {

                    Util.$event     = event;
                    Util.$eventType = Util.$MOUSE_WHEEL;

                    this._$hitTest();
                }
            }.bind(this), { "passive": false });

        }

        // set css
        const style = canvas.style;
        style.position                = "absolute";
        style.top                     = "0";
        style.left                    = "0";
        style.webkitTapHighlightColor = "rgba(0,0,0,0)";
        style.backfaceVisibility      = "hidden";
        style.transformOrigin         = "0 0";
        if (Util.$devicePixelRatio !== 1) {
            style.transform = `scale(${1 / Util.$devicePixelRatio})`;
        }

    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$resize ()
    {
        const div = Util.$document.getElementById(this.contentElementId);
        if (div) {

            const parent = div.parentNode;

            const innerWidth = this._$optionWidth
                ? this._$optionWidth
                : parent.tagName === "BODY"
                    ? Util.$window.innerWidth
                    : parent.offsetWidth
                        ? parent.offsetWidth
                        : Util.$parseFloat(parent.style.width);

            const innerHeight = this._$optionHeight
                ? this._$optionHeight
                : parent.tagName === "BODY"
                    ? Util.$window.innerHeight
                    : parent.offsetHeight
                        ? parent.offsetHeight
                        : Util.$parseFloat(parent.style.height);

            const screenWidth = parent.tagName === "BODY"
                ? Util.$window.innerWidth
                : parent.offsetWidth;

            const scale = $Math.min(
                innerWidth  / this._$baseWidth,
                innerHeight / this._$baseHeight
            );

            let width = this._$fullScreen
                ? innerWidth
                : this._$baseWidth  * scale | 0;

            let height = this._$fullScreen
                ? innerHeight
                : this._$baseHeight * scale | 0;

            // div
            const style  = div.style;
            style.width  = `${width}px`;
            style.height = `${height}px`;
            style.top    = "0";
            style.left   = this._$fullScreen
                ? "0"
                : `${screenWidth / 2 - width / 2}px`;

            width  *= Util.$devicePixelRatio;
            height *= Util.$devicePixelRatio;

            // params
            this._$scale  = scale;
            this._$width  = width;
            this._$height = height;

            // main
            this._$canvas.width  = width;
            this._$canvas.height = height;
            this._$canvas.style.transform = this._$ratio === 1 && Util.$devicePixelRatio === 1
                ? ""
                : `scale(${1 / this._$ratio})`;

            // stage buffer
            if (this._$context) { // unit test

                this._$context._$gl.viewport(0, 0, width, height);

                const manager = this._$context._$frameBufferManager;
                if (this._$buffer) {
                    manager.unbind();
                    manager.releaseAttachment(this._$buffer, true);
                }

                this._$buffer = manager
                    .createCacheAttachment(width, height, false);

                // update cache max size
                manager._$stencilBufferPool._$maxWidth  = width;
                manager._$stencilBufferPool._$maxHeight = height;
                manager._$textureManager._$maxWidth     = width;
                manager._$textureManager._$maxHeight    = height;
                this._$context._$pbo._$maxWidth         = width;
                this._$context._$pbo._$maxHeight        = height;
            }

            const mScale = this._$scale * this._$ratio;
            this._$matrix[0] = mScale;
            this._$matrix[3] = mScale;

            if (this._$fullScreen) {

                this._$tx = (width -
                        this._$baseWidth
                        * scale
                        * Util.$devicePixelRatio) / 2;

                this._$ty = (height -
                        this._$baseHeight
                        * scale
                        * Util.$devicePixelRatio) / 2;

                this._$matrix[4] = this._$tx;
                this._$matrix[5] = this._$ty;

            }

            if (div.children.length > 1) {
                div.children[1].dispatchEvent(
                    new Util.$window.Event(`${Util.$PREFIX}_blur`)
                );
            }

            // cache reset
            this._$stage._$doChanged();
            this._$cacheStore.reset();

        }
    }

    /**
     * @return {uint}
     * @method
     * @public
     */
    getSamples ()
    {
        switch (this._$quality) {

            case StageQuality.HIGH:
                return Util.$HIGH_SAMPLES;

            case StageQuality.MEDIUM:
                return Util.$MEDIUM_SAMPLES;

            default:
                return Util.$LOW_SAMPLES;

        }
    }

    /**
     * @param  {Event} event
     * @return {boolean}
     * @method
     * @private
     */
    _$dispatchEvent (event)
    {
        if (this._$broadcastEvents.size
            && this._$broadcastEvents.has(event.type)
        ) {

            // clone
            const events = this
                ._$broadcastEvents
                .get(event.type)
                .slice(0);

            // start target
            event._$eventPhase = EventPhase.AT_TARGET;

            const length = events.length;
            for (let idx = 0; idx < length; ++idx) {

                const obj = events[idx];

                // event execute
                event._$currentTarget = obj.target;

                event._$listener = obj.listener;
                obj.listener.call(Util.$window, event);

                if (event._$stopImmediatePropagation) {
                    break;
                }

            }

            Util.$poolArray(events);

            return true;

        }
    }

    /**
     * @param  {number} timestamp
     * @return {void}
     * @method
     * @private
     */
    _$run (timestamp = 0)
    {
        if (this._$stopFlag) {
            return ;
        }

        if (window.stats) {
            stats.begin();
        }

        if (window.glstats) {
            glstats.begin();
        }

        // delay action
        this._$doAction();

        let delta = timestamp - this._$startTime;
        if (delta > this._$fps) {

            // update
            this._$startTime = timestamp - delta % this._$fps;

            // execute
            this._$action();
            this._$draw(0);

            // draw event
            if (!this._$hitTestStart
                && this._$state === "up" && Util.$event
                && this._$stageX > -1 && this._$stageY > -1
            ) {
                this._$pointerCheck();
            }
        }

        if (window.stats) {
            stats.end();
        }

        if (window.glstats) {
            glstats.end();
        }

        // next frame
        const timer = Util.$requestAnimationFrame;
        this._$timerId = timer(this._$bindRun);
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$pointerCheck ()
    {
        const stageX = this._$stageX;
        const stageY = this._$stageY;

        // setup
        this._$hitObject.x       = stageX;
        this._$hitObject.y       = stageY;
        this._$hitObject.pointer = "";
        this._$hitObject.hit     = null;

        // reset
        Util.$hitContext.setTransform(1, 0, 0, 1, 0, 0);
        Util.$hitContext.beginPath();

        // hit test
        Util.$MATRIX_HIT_ARRAY_IDENTITY[4] = this._$tx / this._$scale / Util.$devicePixelRatio;
        Util.$MATRIX_HIT_ARRAY_IDENTITY[5] = this._$ty / this._$scale / Util.$devicePixelRatio;
        this._$stage._$mouseHit(
            Util.$hitContext, Util.$MATRIX_HIT_ARRAY_IDENTITY,
            this._$hitObject, true
        );

        // change state
        // params
        let instance       = null;
        let target         = null;
        let canPointerText = false;
        let canPointer     = false;

        // execute
        if (this._$hitObject.hit) {

            instance = this._$hitObject.hit;

            // (1) mouseOut
            if (this._$mouseOverTarget
                && this._$mouseOverTarget !== instance
            ) {

                const outInstance = this._$mouseOverTarget;

                if (outInstance.willTrigger(MouseEvent.MOUSE_OUT)) {
                    outInstance.dispatchEvent(new MouseEvent(
                        MouseEvent.MOUSE_OUT, true, false,
                        outInstance.mouseX, outInstance.mouseY
                    ));
                }

            }

            // rollOut and rollOver
            if (this._$rollOverObject !== instance) {

                let hitParent = null;
                if (this._$rollOverObject) {

                    // (2) prev object rollOut
                    target = this._$rollOverObject;

                    if (target.willTrigger(MouseEvent.ROLL_OUT)) {
                        target.dispatchEvent(new MouseEvent(
                            MouseEvent.ROLL_OUT, false, false,
                            target.mouseX, target.mouseY
                        ));
                    }

                    // rollOver flag instance
                    hitParent = target._$parent;
                    while (hitParent && hitParent._$root !== hitParent) {

                        if (hitParent === instance) {
                            break;
                        }

                        if (hitParent._$mouseEnabled
                            && hitParent._$outCheck(stageX, stageY)
                        ) {

                            let isUpperLayer = false;
                            let check = instance;
                            while (check && check._$root !== check) {

                                if (check !== hitParent) {
                                    check = check._$parent;
                                    continue;
                                }

                                isUpperLayer = true;

                                break;
                            }

                            if (!isUpperLayer && hitParent._$parent === instance._$parent
                                && hitParent._$index > instance._$index
                            ) {
                                isUpperLayer = true;
                            }

                            if (isUpperLayer) {
                                break;
                            }

                        }

                        if (hitParent.willTrigger(MouseEvent.ROLL_OUT)) {
                            hitParent.dispatchEvent(new MouseEvent(
                                MouseEvent.ROLL_OUT, false, false,
                                hitParent.mouseX, hitParent.mouseY
                            ));
                        }

                        hitParent = hitParent._$parent;

                    }
                }

                // (3) current object rollOver
                target = instance;
                for (;;) {

                    if (target.willTrigger(MouseEvent.ROLL_OVER)) {
                        target.dispatchEvent(new MouseEvent(
                            MouseEvent.ROLL_OVER, false, false,
                            target.mouseX, target.mouseY
                        ));
                    }

                    target = target._$parent;
                    if (!target || target === hitParent
                        || target.stage === target
                    ) {
                        break;
                    }

                }

            }

            this._$rollOverObject = instance;

            // (4) mouseOver
            switch (true) {

                case this._$mouseOverTarget === null:
                case this._$mouseOverTarget !== instance:

                    if (instance.willTrigger(MouseEvent.MOUSE_OVER)) {
                        instance.dispatchEvent(new MouseEvent(
                            MouseEvent.MOUSE_OVER, true, false,
                            instance.mouseX, instance.mouseY
                        ));
                    }

                    // set target
                    this._$mouseOverTarget = instance;
                    break;

            }

            // click reset
            if (this._$state === "up") {
                this._$clickTarget = null;
            }

            // PC
            if (!Util.$isTouch && this._$state === "up") {

                target = instance;
                while (target && target.root !== target) {

                    switch (true) {

                        case target instanceof TextField:
                            if (target._$type === TextFieldType.INPUT) {
                                canPointerText = true;
                            }
                            break;

                        case target.buttonMode:
                            canPointer = true;
                            break;

                    }

                    if (canPointerText || canPointer) {
                        break;
                    }

                    target = target._$parent;

                }

            }

        } else {

            // (1) mouseOut
            if (this._$mouseOverTarget) {

                instance = this._$mouseOverTarget;

                if (instance.willTrigger(MouseEvent.MOUSE_OUT)) {
                    instance.dispatchEvent(new MouseEvent(
                        MouseEvent.MOUSE_OUT, true, false,
                        instance.mouseX, instance.mouseY
                    ));
                }
            }

            // (2) rollOut
            if (this._$rollOverObject) {

                target = this._$rollOverObject;

                // parent target
                while (target && target.root !== target) {

                    if (target.willTrigger(MouseEvent.ROLL_OUT)) {
                        target.dispatchEvent(new MouseEvent(
                            MouseEvent.ROLL_OUT, false, false,
                            target.mouseX, target.mouseY
                        ));
                    }

                    target = target._$parent;

                }

            }

            // reset
            this._$rollOverObject  = null;
            this._$mouseOverTarget = null;
        }

        // change cursor
        switch (true) {

            case canPointerText:
                this._$canvas.style.cursor = "text";
                break;

            case canPointer:
                this._$canvas.style.cursor = "pointer";
                break;

            case !Util.$isTouch && this._$state === "up":
                this._$canvas.style.cursor = "auto";
                break;

        }

        if (this._$actions.length > 1) {
            this._$doAction();
        }
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$action ()
    {

        if (this._$stopFlag) {
            return ;
        }

        let loaders = null;

        const length = this._$loaders.length;
        if (length) {

            // clone
            loaders = this._$loaders.slice(0);

            // array reset
            this._$loaders.length = 0;

            for (let idx = 0; idx < length; ++idx) {

                const loader = loaders[idx];

                // first action
                if ("content" in loader) {
                    loader.content._$prepareActions();
                }
            }
        }

        // next frame
        this._$stage._$nextFrame();

        // enter frame event
        if (this._$broadcastEvents.has(Event.ENTER_FRAME)) {
            this._$dispatchEvent(new Event(Event.ENTER_FRAME));
        }

        // constructed event
        if (this._$broadcastEvents.has(Event.FRAME_CONSTRUCTED)) {
            this._$dispatchEvent(new Event(Event.FRAME_CONSTRUCTED));
        }

        // execute frame action
        this._$doAction();

        // exit event
        if (this._$broadcastEvents.has(Event.EXIT_FRAME)) {
            this._$dispatchEvent(new Event(Event.EXIT_FRAME));
        }

        // render event
        if (this._$stage._$invalidate) {

            // reset
            this._$stage._$invalidate = false;

            // execute render event
            this._$dispatchEvent(new Event(Event.RENDER));

        }

        // loader events
        if (length) {

            for (let idx = 0; idx < length; ++idx) {

                const loader = loaders[idx];

                // init event
                if (loader.hasEventListener(Event.INIT)) {
                    loader.dispatchEvent(new Event(Event.INIT));
                }

                // complete event
                if (loader.hasEventListener(Event.COMPLETE)) {
                    loader.dispatchEvent(new Event(Event.COMPLETE));
                }

            }

            // pool
            Util.$poolArray(loaders);
        }

        // execute frame action
        this._$doAction();
    }

    /**
     * @returns void
     * @private
     */
    _$draw ()
    {
        const canvas  = this._$canvas;
        const width   = canvas.width;
        const height  = canvas.height;
        const context = this._$context;

        if (this._$buffer && this._$stage._$updated
            && context && width > 0 && height > 0
        ) {

            context._$bind(this._$buffer);

            // pre draw
            Util.$resetContext(context);
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, width, height);

            // draw
            context.beginPath();

            this
                ._$stage
                ._$draw(context, this._$matrix, Util.$COLOR_ARRAY_IDENTITY);

            // stage end
            this._$stage._$updated = false;

            // start sound
            if (this._$sounds.size) {
                const values = this._$sounds.values();
                for (let movieClip of values) {
                    movieClip._$soundPlay();
                }
                this._$sounds.clear();
            }

            const bufferTexture = context
                .frameBuffer
                .getTextureFromCurrentAttachment();

            context.frameBuffer.unbind();

            // reset and draw to canvas
            Util.$resetContext(context);
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, width, height);
            context.drawImage(bufferTexture, 0, 0, width, height);

            context._$bind(this._$buffer);
        }

    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$doAction ()
    {
        while (this._$actions.length) {

            Util.$actionProcess = true;

            // target object
            const mc = this._$actions.pop();
            mc._$canAction    = false;
            mc._$actionOffset = 0;
            mc._$actionLimit  = 0;

            const frame = mc._$currentFrame;
            if (!mc._$actions.has(frame)) {
                continue;
            }

            mc._$actionProcess = true;
            const actions = mc._$actions.get(frame);
            const length  = actions.length;
            for (let idx = 0; idx < length; ++idx) {
                Util.$currentLoaderInfo = mc._$loaderInfo;
                actions[idx].apply(mc);
            }
            mc._$actionProcess = false;

            // adjustment
            if (mc._$frameCache.size) {
                mc._$currentFrame = mc._$frameCache.get("nextFrame");
                mc._$clearChildren();

                mc._$stopFlag  = mc._$frameCache.get("stopFlag");
                mc._$isPlaying = mc._$frameCache.get("isPlaying");
                mc._$frameCache.clear();
            }

        }

        Util.$currentLoaderInfo = null;
        Util.$actionProcess     = false;
    }

    /**
     * @return {void}
     * @method
     * @private
     */
    _$hitTest ()
    {
        if (this._$stopFlag) {
            return ;
        }

        // update flags
        this._$hitTestStart = true;
        Util.$isUpdated     = false;

        // setup
        const event = Util.$event;

        // params
        let instance = null;
        let target   = null;

        let x = Util.$window.pageXOffset;
        let y = Util.$window.pageYOffset;

        const div = Util.$document.getElementById(this.contentElementId);
        if (div) {
            const rect = div.getBoundingClientRect();
            x += rect.left;
            y += rect.top;
        }

        let stageX = 0;
        let stageY = 0;

        if (Util.$isTouch) {
            const changedTouche = event.changedTouches[0];
            stageX = changedTouche.pageX;
            stageY = changedTouche.pageY;
        } else {
            stageX = event.pageX;
            stageY = event.pageY;
        }

        // drop point
        stageX = (stageX - x) / this._$scale;
        stageY = (stageY - y) / this._$scale;

        // update
        event._$stageX = stageX;
        event._$stageY = stageY;
        this._$stageX  = stageX;
        this._$stageY  = stageY;

        // setup
        this._$hitObject.x       = stageX;
        this._$hitObject.y       = stageY;
        this._$hitObject.pointer = "";
        this._$hitObject.hit     = null;

        // reset
        Util.$hitContext.setTransform(1, 0, 0, 1, 0, 0);
        Util.$hitContext.beginPath();

        // hit test
        Util.$MATRIX_HIT_ARRAY_IDENTITY[4] = this._$tx / this._$scale / Util.$devicePixelRatio;
        Util.$MATRIX_HIT_ARRAY_IDENTITY[5] = this._$ty / this._$scale / Util.$devicePixelRatio;
        this._$stage._$mouseHit(
            Util.$hitContext, Util.$MATRIX_HIT_ARRAY_IDENTITY,
            this._$hitObject, true
        );

        // stop event
        if (this._$hitObject.hit) {
            event.preventDefault();
        }

        // change state
        let canPointerText = false;
        let staticPointer  = false;
        let canPointer     = false;
        switch (Util.$eventType) {

            case Util.$TOUCH_MOVE:
            case Util.$MOUSE_MOVE:

                if (Util.$dropTarget) {

                    const point = Util.$dropTarget._$dragMousePoint();

                    let dragX = point.x;
                    let dragY = point.y;

                    if (!Util.$dragRules.lock) {
                        dragX += Util.$dragRules.position.x;
                        dragY += Util.$dragRules.position.y;
                    }

                    const bounds = Util.$dragRules.bounds;
                    if (bounds) {

                        dragX = Util.$clamp(dragX, bounds.left, bounds.right);
                        dragY = Util.$clamp(dragY, bounds.top,  bounds.bottom);

                    }

                    // set move xy
                    Util.$dropTarget.x = dragX;
                    Util.$dropTarget.y = dragY;

                }

                break;

            case Util.$TOUCH_START:
            case Util.$MOUSE_DOWN:
                this._$state  = "down";
                canPointer    = this._$canvas.style.cursor === "pointer";
                staticPointer = true;
                break;

            case Util.$TOUCH_END:
            case Util.$MOUSE_UP:
            case Util.$DOUBLE_CLICK:
                this._$state = "up";
                break;

        }

        // execute
        switch (true) {

            case this._$hitObject.hit === null:
            case Util.$eventType === Util.$MOUSE_LEAVE:

                // (1) mouseOut
                if (this._$mouseOverTarget) {

                    instance = this._$mouseOverTarget;
                    if (instance.willTrigger(MouseEvent.MOUSE_OUT)) {
                        instance.dispatchEvent(new MouseEvent(
                            MouseEvent.MOUSE_OUT, true, false,
                            instance.mouseX, instance.mouseY
                        ));
                    }

                }

                // (2) rollOut
                if (this._$rollOverObject) {

                    target = this._$rollOverObject;

                    // parent target
                    while (target && target.root !== target) {

                        if (target.willTrigger(MouseEvent.ROLL_OUT)) {
                            target.dispatchEvent(new MouseEvent(
                                MouseEvent.ROLL_OUT, false, false,
                                target.mouseX, target.mouseY
                            ));
                        }

                        target = target._$parent;

                    }

                }

                // reset
                this._$rollOverObject  = null;
                this._$mouseOverTarget = null;

                // stage event
                switch (Util.$eventType) {

                    case Util.$MOUSE_WHEEL:
                        if (this._$stage.hasEventListener(MouseEvent.MOUSE_WHEEL)) {

                            this._$stage.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_WHEEL, true, false,
                                this._$stage.mouseX, this._$stage.mouseY
                            ));

                        }
                        break;

                    case Util.$TOUCH_START:
                    case Util.$MOUSE_DOWN:
                        if (this._$stage.hasEventListener(MouseEvent.MOUSE_DOWN)) {
                            this._$stage.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_DOWN, true, false,
                                this._$stage.mouseX, this._$stage.mouseY
                            ));
                        }

                        // TextField focus out
                        if (this._$textField
                            && this._$textField instanceof TextField
                        ) {
                            this._$textField.focus = false;
                            this._$textField = null;
                        }
                        break;

                    case Util.$TOUCH_END:
                    case Util.$MOUSE_UP:

                        // TextField focus out
                        if (this._$textField
                            && this._$textField instanceof TextField
                        ) {
                            this._$textField.focus = false;
                            this._$textField = null;
                        }

                        if (this._$stage.hasEventListener(MouseEvent.CLICK)) {
                            this._$stage.dispatchEvent(new MouseEvent(
                                MouseEvent.CLICK, true, false,
                                this._$stage.mouseX, this._$stage.mouseY
                            ));
                        }

                        if (this._$stage.hasEventListener(MouseEvent.MOUSE_UP)) {
                            this._$stage.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_UP, true, false,
                                this._$stage.mouseX, this._$stage.mouseY
                            ));
                        }

                        break;

                    case Util.$TOUCH_MOVE:
                    case Util.$MOUSE_MOVE:
                        if (this._$stage.hasEventListener(MouseEvent.MOUSE_MOVE)) {
                            this._$stage.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_MOVE, true, false,
                                this._$stage.mouseX, this._$stage.mouseY
                            ));
                        }
                        break;

                    case Util.$DOUBLE_CLICK:
                        if (this._$stage.hasEventListener(MouseEvent.DOUBLE_CLICK)) {
                            this._$stage.dispatchEvent(new MouseEvent(
                                MouseEvent.DOUBLE_CLICK, true, false,
                                this._$stage.mouseX, this._$stage.mouseY
                            ));
                        }
                        break;

                }

                break;

            default:

                instance = this._$hitObject.hit;

                switch (Util.$eventType) {

                    // move event
                    case Util.$TOUCH_MOVE:
                    case Util.$MOUSE_MOVE:

                        // (1) mouseMove
                        if (instance.willTrigger(MouseEvent.MOUSE_MOVE)) {
                            instance.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_MOVE, true, false,
                                instance.mouseX, instance.mouseY
                            ));
                        }

                        // (2) mouseOut
                        if (this._$mouseOverTarget
                            && this._$mouseOverTarget !== instance
                        ) {

                            const outInstance = this._$mouseOverTarget;

                            if (outInstance.willTrigger(MouseEvent.MOUSE_OUT)) {
                                outInstance.dispatchEvent(new MouseEvent(
                                    MouseEvent.MOUSE_OUT, true, false,
                                    outInstance.mouseX, outInstance.mouseY
                                ));
                            }

                        }

                        // rollOut and rollOver
                        if (this._$rollOverObject !== instance) {

                            let hitParent = null;
                            if (this._$rollOverObject) {

                                // (3) prev object rollOut
                                target = this._$rollOverObject;

                                if (target.willTrigger(MouseEvent.ROLL_OUT)) {
                                    target.dispatchEvent(new MouseEvent(
                                        MouseEvent.ROLL_OUT, false, false,
                                        target.mouseX, target.mouseY
                                    ));
                                }

                                // rollOver flag instance
                                hitParent = target._$parent;
                                while (hitParent && hitParent._$root !== hitParent) {

                                    if (hitParent === instance) {
                                        break;
                                    }

                                    if (hitParent._$mouseEnabled
                                        && hitParent._$outCheck(stageX, stageY)
                                    ) {

                                        let isUpperLayer = false;
                                        let check = instance;
                                        while (check && check._$root !== check) {

                                            if (check !== hitParent) {
                                                check = check._$parent;
                                                continue;
                                            }

                                            isUpperLayer = true;

                                            break;
                                        }

                                        if (!isUpperLayer && hitParent._$parent === instance._$parent
                                            && hitParent._$index > instance._$index
                                        ) {
                                            isUpperLayer = true;
                                        }

                                        if (isUpperLayer) {
                                            break;
                                        }

                                    }

                                    if (hitParent.willTrigger(MouseEvent.ROLL_OUT)) {
                                        hitParent.dispatchEvent(new MouseEvent(
                                            MouseEvent.ROLL_OUT, false, false,
                                            hitParent.mouseX, hitParent.mouseY
                                        ));
                                    }

                                    hitParent = hitParent._$parent;

                                }
                            }

                            // (4) current object rollOver
                            target = instance;
                            for (;;) {

                                if (target.willTrigger(MouseEvent.ROLL_OVER)) {
                                    target.dispatchEvent(new MouseEvent(
                                        MouseEvent.ROLL_OVER, false, false,
                                        target.mouseX, target.mouseY
                                    ));
                                }

                                target = target._$parent;
                                if (!target || target === hitParent
                                    || target.stage === target
                                ) {
                                    break;
                                }

                            }

                        }

                        this._$rollOverObject = instance;

                        // (5) mouseOver
                        switch (true) {

                            case this._$mouseOverTarget === null:
                            case this._$mouseOverTarget !== instance:

                                if (instance.willTrigger(MouseEvent.MOUSE_OVER)) {
                                    instance.dispatchEvent(new MouseEvent(
                                        MouseEvent.MOUSE_OVER, true, false,
                                        instance.mouseX, instance.mouseY
                                    ));
                                }

                                // set target
                                this._$mouseOverTarget = instance;
                                break;

                        }

                        // click reset
                        if (this._$state === "up") {
                            this._$clickTarget = null;
                        }

                        break;

                    // down event
                    case Util.$TOUCH_START:
                    case Util.$MOUSE_DOWN:

                        // TextField focus out
                        if (instance !== this._$textField
                            && this._$textField instanceof TextField
                        ) {
                            this._$textField.focus = false;
                            this._$textField       = null;
                        }

                        // TextField focus out
                        if (instance instanceof TextField) {
                            instance.focus   = true;
                            this._$textField = instance;
                        }

                        // (3) mouseDown
                        if (instance.willTrigger(MouseEvent.MOUSE_DOWN)) {
                            instance.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_DOWN, true, false,
                                instance.mouseX, instance.mouseY
                            ));
                        }

                        // (4) click
                        this._$clickTarget = instance;

                        break;

                    // up event
                    case Util.$TOUCH_END:
                    case Util.$MOUSE_UP:

                        // TextField focus out
                        if (instance !== this._$textField
                            && this._$textField instanceof TextField
                        ) {
                            this._$textField.focus = false;
                            this._$textField       = null;
                        }

                        // (1) mouseUp
                        if (instance.willTrigger(MouseEvent.MOUSE_UP)) {
                            instance.dispatchEvent(new MouseEvent(
                                MouseEvent.MOUSE_UP, true, false,
                                instance.mouseX, instance.mouseY
                            ));
                        }

                        // (2) click
                        if (this._$clickTarget === instance) {

                            if (instance.willTrigger(MouseEvent.CLICK)) {
                                instance.dispatchEvent(new MouseEvent(
                                    MouseEvent.CLICK, true, false,
                                    instance.mouseX, instance.mouseY
                                ));
                            }

                        }

                        // reset
                        this._$clickTarget = null;

                        break;

                    case Util.$MOUSE_WHEEL:
                        if (instance.willTrigger(MouseEvent.MOUSE_WHEEL)) {
                            instance.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_WHEEL));
                        }

                        if (instance instanceof TextField && instance._$scrollEnabled) {
                            instance.scrollV += event.deltaY;
                        }
                        break;

                    case Util.$DOUBLE_CLICK:
                        if (instance.willTrigger(MouseEvent.DOUBLE_CLICK)) {
                            instance.dispatchEvent(new MouseEvent(MouseEvent.DOUBLE_CLICK));
                        }
                        break;

                    default:
                        break;

                }

                // PC
                if (!staticPointer) {

                    if (!Util.$isTouch && this._$state === "up") {

                        target = instance;
                        while (target && target.root !== target) {

                            if (target instanceof TextField) {

                                if (target._$type === TextFieldType.INPUT) {
                                    canPointerText = true;
                                    break;
                                }

                            } else {

                                if (target._$buttonMode) {
                                    canPointer = true;
                                    break;
                                }

                            }

                            target = target._$parent;

                        }
                    }
                }
                break;

        }

        // change cursor
        switch (true) {

            case canPointerText:
                this._$canvas.style.cursor = "text";
                break;

            case canPointer:
                this._$canvas.style.cursor = "pointer";
                break;

            case !Util.$isTouch && this._$state === "up":
                this._$canvas.style.cursor = "auto";
                break;

        }

        // execute action
        if (!Util.$actionProcess && this._$actions.length > 1) {
            this._$doAction();
        }

        if (Util.$isUpdated) {

            // action script
            this._$stage._$prepareActions();
            if (!Util.$actionProcess) {
                this._$doAction();
            }

        }

        this._$hitTestStart = false;
    }
}
/**
 * @description TODO
 * @class
 */
class Next2D
{
    /**
     * @constructor
     * @public
     */
    constructor ()
    {
        /**
         * @type {Player}
         * @private
         */
        this._$player = new Player();
    }

    /**
     * @description TODO
     *
     * @param  {string} url JSONファイルのURL
     *                      URL of the JSON file
     *
     * @param  {object} [options=null] {number} width = Stageの幅 | Stage width
     *                                 {number} height = Stageの高さ | Stage height
     *                                 {string} [tagId=null] canvasを追加対象のDOMのID | ID of the DOM to which the canvas is added
     *                                 {string} [base="/"] Loaderが読み込む際の絶対パス | Absolute path for Loader to load.
     *                                 {number|string|boolean} [bgColor=null] 背景色 | background color
     * @return {void}
     * @method
     * @public
     */
    load (url, options = null)
    {
        if (url === "develop") {
            const path = Util.$location.search.substr(1).split("&")[0];
            if (!path) {
                return ;
            }
            url = `${Util.$location.origin}/${path}`;
        }

        if (!url) {
            return ;
        }

        if (url.charAt(1) === "/") {
            url = url.slice(1);
        }

        // base set
        if ((!options || !("base" in options)) && url.indexOf("//") > -1) {
            this._$player.base = url;
        }

        this._$player.setOptions(options);

        const loader     = new Loader();
        const loaderInfo = loader.contentLoaderInfo;

        loaderInfo.addEventListener(IOErrorEvent.IO_ERROR, (event) =>
        {
            event.target.removeEventListener(IOErrorEvent.IO_ERROR, event.listener);
            alert("Error: " + event.message);
        });

        loaderInfo.addEventListener(Event.COMPLETE, (event) =>
        {
            const loaderInfo = event.target;
            loaderInfo.removeEventListener(Event.COMPLETE, event.listener);

            const player = Util.$currentPlayer();
            const stage  = player.stage;
            const data   = loaderInfo._$data.stage;

            player.width  = data.width;
            player.height = data.height;
            player.stage.frameRate = data.fps;

            if (player._$bgColor === null) {

                const color = Util.$intToRGBA(
                    `0x${data.bgColor.substr(1)}` | 0
                );

                player._$context._$setColor(
                    color.R / 255,
                    color.G / 255,
                    color.B / 255,
                    1
                );

                player._$backgroundColor = [
                    color.R / 255,
                    color.G / 255,
                    color.B / 255,
                    1
                ];

            }

            stage.addChild(loaderInfo.content);

            player._$resize();
        });

        loader.load(new URLRequest(url));
    }

    /**
     * @description TODO
     *
     * @param  {number} [width=240]
     * @param  {number} [height=240]
     * @param  {number} [fps=24]
     * @param  {object} [options=null]
     * @return {Sprite}
     * @method
     * @public
     */
    createRootMovieClip (width = 240, height = 240, fps = 24, options = null)
    {
        const player = this._$player;

        player._$loadStatus = Player.LOAD_END;
        player._$mode = "create";
        player._$stage.frameRate = fps | 0;

        // setup
        player.width  = width | 0;
        player.height = height | 0;
        player.setOptions(options);

        return player._$stage.addChild(new Sprite());
    }
}

Util.$window.next2d = new Next2D();
Util.$packages(Util.$window.next2d);

        // output build version
        console.log("%c Next2D Player %c 1.12.1 %c https://next2d.app",
        "color: #fff; background: #5f5f5f",
        "color: #fff; background: #4bc729",
        "");

    })(window);
}