const zlibes=function(e){"use strict";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),n=131072,r=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],o=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],f=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function a(e){const t=Object.keys(e);let n=0,r=0,i=Number.MAX_SAFE_INTEGER;t.forEach(e=>{n=Number(e),r<n&&(r=n),i>n&&(i=n)});let o,s=0;const f={};for(let t=i;t<=r;t++){void 0===(o=e[t])&&(o=[]),o.sort((e,t)=>e<t?-1:e>t?1:0);const n={};o.forEach(e=>{n[s]=e,s++}),f[t]=n,s<<=1}return f}function h(e,t=15){const n={};for(const t of e)n[t]?n[t]++:n[t]=1;const r=Object.keys(n);let i=[],o=0,s=[];if(1===r.length)s.push({count:n[0],simbles:[Number(r[0])]});else for(let e=0;e<t;e++){for(s=[],r.forEach(e=>{const t={count:n[Number(e)],simbles:[Number(e)]};s.push(t)}),o=0;o+2<=i.length;){const e={count:i[o].count+i[o+1].count,simbles:i[o].simbles.concat(i[o+1].simbles)};s.push(e),o+=2}(s=s.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&s.pop(),i=s}const f={};let a;s.forEach(e=>{e.simbles.forEach(e=>{f[e]?f[e]++:f[e]=1})});const h=Object.keys(f),d={};let u=0,c=3,w=Number.MAX_SAFE_INTEGER,l=0;h.forEach(e=>{c=f[Number(e)],d[c]||(d[c]=[],w>c&&(w=c),l<c&&(l=c)),d[c].push(Number(e))}),u=0;const g=new Map;for(let e=w;e<=l;e++)(a=d[e])&&(a=a.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{g.set(t,{code:u,bitlen:e}),u++}),u<<=1;return g}const d=3,u=128,c=16,w=8;function l(e,t,n){let r=t;const s=t+n-d;let f=0,a=0,h=0,l=0,g=0,b=0,R=0;const E=[],p={},B={},I=function(e,t,n){const r=t+n-d,i={};for(let n=t;n<=r;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===i[t]&&(i[t]=[]),i[t].push(n)}return i}(e,t,n);for(;r<=s;){const t=e[r]<<16|e[r+1]<<8|e[r+2],n=I[t];if(void 0===n||n.length<=1){E.push([e[r]]),r++;continue}f=r>32768?r-32768:0,h=0,l=0;let d=p[t]||0;for(;n[d]<f;)d=d+1|0;for(p[t]=d,d=B[t]||0;n[d]<r;)d=d+1|0;B[t]=d;let N=0;e:for(let i=B[t]-1,o=p[t];o<=i&&!(N>=u||h>=w&&N>=c);i--){N++;const t=n[i];for(let n=h-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;a=258;for(let n=h;n<=258;n++)if(e[t+n]!==e[r+n]){a=n;break}if(h<a&&(h=a,l=t,258<=a))break}if(h>=3&&r+h<=s){g=r-l;for(let e=0;e<i.length&&!(i[e]>h);e++)b=e;for(let e=0;e<o.length&&!(o[e]>g);e++)R=e;E.push([b,R,h,g]),r+=h}else E.push([e[r]]),r++}return E.push([e[r]]),E.push([e[r+1]]),E}class g{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n>>>=1}}function b(e,t,n,a){const d=l(t,n,a),u=[256],c=[];let w=256,g=0;for(let e=0,t=d.length;e<t;e++){const t=d[e];let n=t[0];const r=t[1];void 0!==r&&(n+=257,c.push(r),g<r&&(g=r)),u.push(n),w<n&&(w=n)}const b=h(u),R=h(c),E=[];for(let e=0;e<=w;e++)b.has(e)?E.push(b.get(e).bitlen):E.push(0);const p=E.length;for(let e=0;e<=g;e++)R.has(e)?E.push(R.get(e).bitlen):E.push(0);const B=E.length-p,I=[],N=[];let x=0,m=0;for(let e=0;e<E.length;e++){for(x=E[e],m=1;x===E[e+1];)if(m++,e++,0===x){if(138<=m)break}else if(6<=m)break;if(4<=m)0===x?11<=m?I.push(18):I.push(17):(I.push(x),N.push(1),m--,I.push(16)),N.push(m);else for(let e=0;e<m;e++)I.push(x),N.push(1)}const A=h(I,7);let v,D=0;f.forEach((e,t)=>{A.has(e)&&(D=t+1)}),e.writeRange(p-257,5),e.writeRange(B-1,5),e.writeRange(D-4,4);for(let t=0;t<D;t++)void 0!==(v=A.get(f[t]))?e.writeRange(v.bitlen,3):e.writeRange(0,3);I.forEach((t,n)=>{if(void 0===(v=A.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen),18===t?e.writeRange(N[n]-11,7):17===t?e.writeRange(N[n]-3,3):16===t&&e.writeRange(N[n]-3,2)});for(let t=0,n=d.length;t<n;t++){const n=d[t],f=n[0],a=n[1];if(void 0!==a){if(void 0===(v=b.get(f+257)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen),0<r[f]&&(m=n[2],e.writeRange(m-i[f],r[f]));const t=R.get(a);if(void 0===t)throw new Error("Data is corrupted");if(e.writeRangeCoded(t.code,t.bitlen),0<s[a]){const t=n[3];e.writeRange(t-o[a],s[a])}}else{if(void 0===(v=b.get(f)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen)}}if(void 0===(v=b.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(v.code,v.bitlen)}class R{constructor(e,t=0){this.nowBitsLength=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsLength=8}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsLength>1?(this.nowBitsLength--,this.nowBits>>=1):(this.bufferIndex++,this.bufferIndex<this.buffer.length?(this.nowBits=this.buffer[this.bufferIndex],this.nowBitsLength=8):(this.nowBitsLength=0,this.isEnd=!0)),e}readRange(e){for(;this.nowBitsLength<=e;)this.nowBits|=this.buffer[++this.bufferIndex]<<this.nowBitsLength,this.nowBitsLength+=8;const t=this.nowBits&(1<<e)-1;return this.nowBits>>>=e,this.nowBitsLength-=e,t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}class E{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let n=0;n<t;n++)e[n]=this.buffer[n];this.buffer=e}this.buffer[this.index]=e,this.index++}}const p=a(function(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}());function B(e,t){e.nowBitsLength<8&&e.readRange(e.nowBitsLength);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let r=0;r<n;r++)t.write(e.readRange(8))}function I(e,t){const n=p,f=Object.keys(n);let a=0,h=0,d=Number.MAX_SAFE_INTEGER;f.forEach(e=>{a=Number(e),h<a&&(h=a),d>a&&(d=a)});let u,c,w,l,g,b,R,E,B=0;for(;!e.isEnd;){for(u=void 0,a=d,B=e.readRangeCoded(d);void 0===(u=n[a][B]);){if(h<=a)throw new Error("Data is corrupted");a++,B<<=1,B|=e.read()}if(u<256)t.write(u);else{if(256===u)break;w=i[c=u-257],0<(l=r[c])&&(w+=e.readRange(l)),g=e.readRangeCoded(5),b=o[g],0<(R=s[g])&&(b+=e.readRange(R)),E=t.index-b;for(let e=0;e<w;e++)t.write(t.buffer[E+e])}}}function N(e,t){const n=e.readRange(5)+257,h=e.readRange(5)+1,d=e.readRange(4)+4;let u=0;const c={};for(let t=0;t<d;t++)0!==(u=e.readRange(3))&&(c[u]||(c[u]=[]),c[u].push(f[t]));const w=a(c),l=Object.keys(w);let g=0,b=Number.MAX_SAFE_INTEGER;l.forEach(e=>{u=Number(e),g<u&&(g=u),b>u&&(b=u)});const R={},E={};let p,B=0,I=0,N=0;const x=n+h;for(let t=0;t<x;){for(p=void 0,u=b,B=e.readRangeCoded(b);void 0===(p=w[u][B]);){if(g<=u)throw new Error("Data is corrupted");u++,B<<=1,B|=e.read()}if(16===p?I=3+e.readRange(2):17===p?(I=3+e.readRange(3),N=0):18===p?(I=11+e.readRange(7),N=0):(I=1,N=p),N<=0)t+=I;else for(;I;)t<n?(R[N]||(R[N]=[]),R[N].push(t++)):(E[N]||(E[N]=[]),E[N].push(t++-n)),I--}const m=a(R),A=a(E),v=Object.keys(m);let D=0,y=0,C=Number.MAX_SAFE_INTEGER;v.forEach(e=>{D=Number(e),y<D&&(y=D),C>D&&(C=D)});const k=Object.keys(A);let L=0,_=0,M=Number.MAX_SAFE_INTEGER;k.forEach(e=>{L=Number(e),_<L&&(_=L),M>L&&(M=L)});let S,O,U,j,F,X,T,G,z,Y,P=0;for(;!e.isEnd;){for(S=void 0,D=C,P=e.readRangeCoded(C);void 0===(S=m[D][P]);){if(y<=D)throw new Error("Data is corrupted");D++,P<<=1,P|=e.read()}if(S<256)t.write(S);else{if(256===S)break;for(U=i[O=S-257],0<(j=r[O])&&(U+=e.readRange(j)),F=void 0,G=M,z=e.readRangeCoded(M);void 0===(F=A[G][z]);){if(_<=G)throw new Error("Data is corrupted");G++,z<<=1,z|=e.read()}X=o[F],0<(T=s[F])&&(X+=e.readRange(T)),Y=t.index-X;for(let e=0;e<U;e++)t.write(t.buffer[Y+e])}}}
    /**
     * @license Copyright (c) 2018 zprodev
     */return e.inflate=function(e){const n=new R(e);if(8!==n.readRange(4))throw new Error("Not compressed by deflate");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){const r=new E(10*e.length),i=new R(e,n);let o=0,s=0;for(;1!==o;){if(o=i.readRange(1),(s=i.readRange(2))===t.UNCOMPRESSED)B(i,r);else if(s===t.FIXED)I(i,r);else{if(s!==t.DYNAMIC)throw new Error("Not supported BTYPE : "+s);N(i,r)}if(0===o&&i.isEnd)throw new Error("Data length is insufficient")}return r.buffer.subarray(0,r.index)}(e,2)},e.deflate=function(e){const r=function(e){const r=e.length,i=new g(new Uint8Array(r<n/2?n:2*r));let o=0,s=0;for(;o+n>=r?(s=r-o,i.writeRange(1,1)):(s=n,i.writeRange(0,1)),i.writeRange(t.DYNAMIC,2),b(i,e,o,s),!((o+=n)>=r););return 0!==i.nowBitsIndex&&i.writeRange(0,8-i.nowBitsIndex),i.buffer.subarray(0,i.bufferIndex)}(e),i=new g(new Uint8Array(1));i.writeRange(8,4),i.writeRange(7,4);const o=new g(new Uint8Array(1));o.writeRange(28,5),o.writeRange(0,1),o.writeRange(2,2);const s=new g(new Uint8Array(4)),f=function(e){let t=1,n=0;const r=e.length;for(let i=0;i<r;i++)n=((t=(t+e[i])%65521)+n)%65521;return(n<<16)+t}(e);s.writeRange(f>>>24,8),s.writeRange(f>>>16&255,8),s.writeRange(f>>>8&255,8),s.writeRange(255&f,8);const a=new Uint8Array(r.length+6);return a.set(i.buffer),a.set(o.buffer,1),a.set(r,2),a.set(s.buffer,a.length-4),a},e}({});

/**
 * @public
 */
this.addEventListener("message", function (event)
{
    const buffer = zlibes.inflate(event.data);

    let json = "";
    for (let idx = 0; idx < buffer.length; ++idx) {
        json += String.fromCharCode(buffer[idx])
    }

    this.postMessage(JSON.parse(decodeURIComponent(json)));
});